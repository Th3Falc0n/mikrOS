In archive lib-mikrOS.a:

syscall.o:     file format elf32-i386
rw-rw-rw- 0/0   3464 Aug 10 18:30 2014 syscall.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000077  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ac  2**2
                  ALLOC
  3 .stab         00000348  00000000  00000000  000000ac  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000006ac  00000000  00000000  000003f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000012  00000000  00000000  00000aa0  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 syscall.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000 g     F .text	00000077 syscall



Disassembly of section .text:

00000000 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	83 ec 0c             	sub    $0xc,%esp
			"=c" (state->ecx),
			"=d" (state->edx),
			"=S" (state->esi),
			"=D" (state->edi)

			: "a" (state->eax),
   9:	8b 45 08             	mov    0x8(%ebp),%eax
   c:	8b 00                	mov    (%eax),%eax
   e:	89 45 ec             	mov    %eax,-0x14(%ebp)
			"b" (state->ebx),
  11:	8b 55 08             	mov    0x8(%ebp),%edx
  14:	8b 5a 04             	mov    0x4(%edx),%ebx
			"c" (state->ecx),
  17:	8b 55 08             	mov    0x8(%ebp),%edx
  1a:	8b 4a 08             	mov    0x8(%edx),%ecx
			"d" (state->edx),
  1d:	8b 55 08             	mov    0x8(%ebp),%edx
  20:	8b 52 0c             	mov    0xc(%edx),%edx
  23:	89 55 e8             	mov    %edx,-0x18(%ebp)
			"S" (state->esi),
  26:	8b 75 08             	mov    0x8(%ebp),%esi
  29:	8b 76 10             	mov    0x10(%esi),%esi
			"D" (state->edi));
  2c:	8b 7d 08             	mov    0x8(%ebp),%edi
  2f:	8b 7f 14             	mov    0x14(%edi),%edi
#include "syscall.h"

void syscall(struct regstate* state) {
	asm("int $0x30"
  32:	8b 45 ec             	mov    -0x14(%ebp),%eax
  35:	8b 55 e8             	mov    -0x18(%ebp),%edx
  38:	cd 30                	int    $0x30
  3a:	89 55 e8             	mov    %edx,-0x18(%ebp)
  3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  40:	8b 45 08             	mov    0x8(%ebp),%eax
  43:	89 45 ec             	mov    %eax,-0x14(%ebp)
  46:	8b 45 f0             	mov    -0x10(%ebp),%eax
  49:	8b 55 ec             	mov    -0x14(%ebp),%edx
  4c:	89 02                	mov    %eax,(%edx)
  4e:	8b 45 08             	mov    0x8(%ebp),%eax
  51:	89 58 04             	mov    %ebx,0x4(%eax)
  54:	8b 45 08             	mov    0x8(%ebp),%eax
  57:	89 48 08             	mov    %ecx,0x8(%eax)
  5a:	8b 45 08             	mov    0x8(%ebp),%eax
  5d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  60:	89 50 0c             	mov    %edx,0xc(%eax)
  63:	8b 45 08             	mov    0x8(%ebp),%eax
  66:	89 70 10             	mov    %esi,0x10(%eax)
  69:	8b 45 08             	mov    0x8(%ebp),%eax
  6c:	89 78 14             	mov    %edi,0x14(%eax)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
  6f:	83 c4 0c             	add    $0xc,%esp
  72:	5b                   	pop    %ebx
  73:	5e                   	pop    %esi
  74:	5f                   	pop    %edi
  75:	5d                   	pop    %ebp
  76:	c3                   	ret    

process.o:     file format elf32-i386
rw-rw-rw- 0/0  10928 Aug 10 18:30 2014 process.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000527  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000055c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000200  00000000  00000000  00000560  2**5
                  ALLOC
  3 .stab         00000f48  00000000  00000000  00000560  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000b7b  00000000  00000000  000014a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .rodata       00000114  00000000  00000000  00002024  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  6 .comment      00000012  00000000  00000000  00002138  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 process.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l     F .text	00000040 return_rpc
000000c0 l     F .text	00000043 register_irq_rpc_syscall
00000000 l     O .bss	00000200 irq_handlers
00000000 l    d  .rodata	00000000 .rodata
00000136 l     F .text	00000088 _handle_rpc
000000fc l     O .rodata	00000018 C.8.1010
0000020d l     F .text	00000044 getargs
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000         *UND*	00000000 syscall
00000040 g     F .text	00000040 call_rpc
00000080 g     F .text	00000040 fetch_rpc_data
00000103 g     F .text	00000033 register_irq_handler
00000000         *UND*	00000000 malloc
00000000         *UND*	00000000 printf
00000000         *UND*	00000000 free
000001be g     F .text	0000004f set_rpc_handler
00000000         *UND*	00000000 memset
00000251 g     F .text	00000058 _start
00000000         *UND*	00000000 main
000002ea g     F .text	00000050 exit
000002a9 g     F .text	00000041 yield
0000033a g     F .text	00000040 getExecPath
0000037a g     F .text	00000043 changeExecPath
000003bd g     F .text	0000002e cd
00000000         *UND*	00000000 getLastVFSErr
00000466 g     F .text	000000c1 printFilesystemError
000003eb g     F .text	00000042 exec
0000042d g     F .text	00000039 texec



Disassembly of section .text:

00000000 <return_rpc>:
#include "process.h"
#include "stdio.h"
#include "stdlib.h"

static void return_rpc(int code) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 30,
      .ebx = (uint32_t)code,
   6:	8b 45 08             	mov    0x8(%ebp),%eax
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
   9:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
  10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  13:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  2f:	83 ec 0c             	sub    $0xc,%esp
  32:	8d 45 e0             	lea    -0x20(%ebp),%eax
  35:	50                   	push   %eax
  36:	e8 fc ff ff ff       	call   37 <return_rpc+0x37>
			37: R_386_PC32	syscall
  3b:	83 c4 10             	add    $0x10,%esp

    while(1);
  3e:	eb fe                	jmp    3e <return_rpc+0x3e>

00000040 <call_rpc>:
}

uint32_t call_rpc(int pid, uint32_t funcID, uint32_t datasize, void* data) {
  40:	55                   	push   %ebp
  41:	89 e5                	mov    %esp,%ebp
  43:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 31,
      .ebx = (uint32_t)pid,
  46:	8b 55 08             	mov    0x8(%ebp),%edx
      .ecx = funcID,
      .edx = datasize,
      .esi = (uint32_t)data,
  49:	8b 45 14             	mov    0x14(%ebp),%eax
      .edi = 0
    };
  4c:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%ebp)
  53:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  56:	8b 55 0c             	mov    0xc(%ebp),%edx
  59:	89 55 e8             	mov    %edx,-0x18(%ebp)
  5c:	8b 55 10             	mov    0x10(%ebp),%edx
  5f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  62:	89 45 f0             	mov    %eax,-0x10(%ebp)
  65:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  6c:	83 ec 0c             	sub    $0xc,%esp
  6f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  72:	50                   	push   %eax
  73:	e8 fc ff ff ff       	call   74 <call_rpc+0x34>
			74: R_386_PC32	syscall
  78:	83 c4 10             	add    $0x10,%esp

    return state.eax;
  7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  7e:	c9                   	leave  
  7f:	c3                   	ret    

00000080 <fetch_rpc_data>:

void fetch_rpc_data(void* dest) {
  80:	55                   	push   %ebp
  81:	89 e5                	mov    %esp,%ebp
  83:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 33,
      .ebx = (uint32_t)dest,
  86:	8b 45 08             	mov    0x8(%ebp),%eax
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
  89:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
  90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  93:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  af:	83 ec 0c             	sub    $0xc,%esp
  b2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  b5:	50                   	push   %eax
  b6:	e8 fc ff ff ff       	call   b7 <fetch_rpc_data+0x37>
			b7: R_386_PC32	syscall
  bb:	83 c4 10             	add    $0x10,%esp
}
  be:	c9                   	leave  
  bf:	c3                   	ret    

000000c0 <register_irq_rpc_syscall>:

static uint32_t register_irq_rpc_syscall(uint32_t irq) {
  c0:	55                   	push   %ebp
  c1:	89 e5                	mov    %esp,%ebp
  c3:	83 ec 28             	sub    $0x28,%esp
      .ebx = irq,
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
  c6:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
  cd:	8b 45 08             	mov    0x8(%ebp),%eax
  d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  ef:	83 ec 0c             	sub    $0xc,%esp
  f2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  f5:	50                   	push   %eax
  f6:	e8 fc ff ff ff       	call   f7 <register_irq_rpc_syscall+0x37>
			f7: R_386_PC32	syscall
  fb:	83 c4 10             	add    $0x10,%esp

    return state.eax;
  fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 101:	c9                   	leave  
 102:	c3                   	ret    

00000103 <register_irq_handler>:

static void (*irq_handlers[128])(uint32_t);

uint32_t register_irq_handler(uint32_t irq, void(*handler)(uint32_t)) {
 103:	55                   	push   %ebp
 104:	89 e5                	mov    %esp,%ebp
 106:	83 ec 08             	sub    $0x8,%esp
    if(register_irq_rpc_syscall(irq)) {
 109:	83 ec 0c             	sub    $0xc,%esp
 10c:	ff 75 08             	pushl  0x8(%ebp)
 10f:	e8 ac ff ff ff       	call   c0 <register_irq_rpc_syscall>
 114:	83 c4 10             	add    $0x10,%esp
 117:	85 c0                	test   %eax,%eax
 119:	74 14                	je     12f <register_irq_handler+0x2c>
        irq_handlers[irq] = handler;
 11b:	8b 45 08             	mov    0x8(%ebp),%eax
 11e:	8b 55 0c             	mov    0xc(%ebp),%edx
 121:	89 14 85 00 00 00 00 	mov    %edx,0x0(,%eax,4)
			124: R_386_32	.bss
        return 1;
 128:	b8 01 00 00 00       	mov    $0x1,%eax
 12d:	eb 05                	jmp    134 <register_irq_handler+0x31>
    }
    return 0;
 12f:	b8 00 00 00 00       	mov    $0x0,%eax
}
 134:	c9                   	leave  
 135:	c3                   	ret    

00000136 <_handle_rpc>:

static void _handle_rpc(uint32_t type, uint32_t funcID, uint32_t datasize) {
 136:	55                   	push   %ebp
 137:	89 e5                	mov    %esp,%ebp
 139:	83 ec 18             	sub    $0x18,%esp
    void* localData = malloc(datasize);
 13c:	83 ec 0c             	sub    $0xc,%esp
 13f:	ff 75 10             	pushl  0x10(%ebp)
 142:	e8 fc ff ff ff       	call   143 <_handle_rpc+0xd>
			143: R_386_PC32	malloc
 147:	83 c4 10             	add    $0x10,%esp
 14a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fetch_rpc_data(localData);
 14d:	83 ec 0c             	sub    $0xc,%esp
 150:	ff 75 f4             	pushl  -0xc(%ebp)
 153:	e8 fc ff ff ff       	call   154 <_handle_rpc+0x1e>
			154: R_386_PC32	fetch_rpc_data
 158:	83 c4 10             	add    $0x10,%esp

    if(type == RPCT_IRQ) {
 15b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 15f:	75 30                	jne    191 <_handle_rpc+0x5b>
        if(irq_handlers[funcID]) {
 161:	8b 45 0c             	mov    0xc(%ebp),%eax
 164:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
			167: R_386_32	.bss
 16b:	85 c0                	test   %eax,%eax
 16d:	74 22                	je     191 <_handle_rpc+0x5b>
            irq_handlers[funcID](funcID);
 16f:	8b 45 0c             	mov    0xc(%ebp),%eax
 172:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
			175: R_386_32	.bss
 179:	83 ec 0c             	sub    $0xc,%esp
 17c:	ff 75 0c             	pushl  0xc(%ebp)
 17f:	ff d0                	call   *%eax
 181:	83 c4 10             	add    $0x10,%esp
            return_rpc(0);
 184:	83 ec 0c             	sub    $0xc,%esp
 187:	6a 00                	push   $0x0
 189:	e8 72 fe ff ff       	call   0 <return_rpc>
 18e:	83 c4 10             	add    $0x10,%esp
        }
    }

    printf("Unhandled RPC!\n");
 191:	83 ec 0c             	sub    $0xc,%esp
 194:	68 00 00 00 00       	push   $0x0
			195: R_386_32	.rodata
 199:	e8 fc ff ff ff       	call   19a <_handle_rpc+0x64>
			19a: R_386_PC32	printf
 19e:	83 c4 10             	add    $0x10,%esp

    free(localData);
 1a1:	83 ec 0c             	sub    $0xc,%esp
 1a4:	ff 75 f4             	pushl  -0xc(%ebp)
 1a7:	e8 fc ff ff ff       	call   1a8 <_handle_rpc+0x72>
			1a8: R_386_PC32	free
 1ac:	83 c4 10             	add    $0x10,%esp
    return_rpc(0);
 1af:	83 ec 0c             	sub    $0xc,%esp
 1b2:	6a 00                	push   $0x0
 1b4:	e8 47 fe ff ff       	call   0 <return_rpc>
 1b9:	83 c4 10             	add    $0x10,%esp
}
 1bc:	c9                   	leave  
 1bd:	c3                   	ret    

000001be <set_rpc_handler>:

void set_rpc_handler() {
 1be:	55                   	push   %ebp
 1bf:	89 e5                	mov    %esp,%ebp
 1c1:	57                   	push   %edi
 1c2:	56                   	push   %esi
 1c3:	53                   	push   %ebx
 1c4:	83 ec 2c             	sub    $0x2c,%esp
    memset(irq_handlers, 0, sizeof(irq_handlers));
 1c7:	83 ec 04             	sub    $0x4,%esp
 1ca:	68 00 02 00 00       	push   $0x200
 1cf:	6a 00                	push   $0x0
 1d1:	68 00 00 00 00       	push   $0x0
			1d2: R_386_32	.bss
 1d6:	e8 fc ff ff ff       	call   1d7 <set_rpc_handler+0x19>
			1d7: R_386_PC32	memset
 1db:	83 c4 10             	add    $0x10,%esp
      .ebx = (uint32_t)_handle_rpc,
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
 1de:	8d 55 d0             	lea    -0x30(%ebp),%edx
 1e1:	bb fc 00 00 00       	mov    $0xfc,%ebx
			1e2: R_386_32	.rodata
 1e6:	b8 06 00 00 00       	mov    $0x6,%eax
 1eb:	89 d7                	mov    %edx,%edi
 1ed:	89 de                	mov    %ebx,%esi
 1ef:	89 c1                	mov    %eax,%ecx
 1f1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    syscall(&state);
 1f3:	83 ec 0c             	sub    $0xc,%esp
 1f6:	8d 45 d0             	lea    -0x30(%ebp),%eax
 1f9:	50                   	push   %eax
 1fa:	e8 fc ff ff ff       	call   1fb <set_rpc_handler+0x3d>
			1fb: R_386_PC32	syscall
 1ff:	83 c4 10             	add    $0x10,%esp
}
 202:	8d 65 f4             	lea    -0xc(%ebp),%esp
 205:	83 c4 00             	add    $0x0,%esp
 208:	5b                   	pop    %ebx
 209:	5e                   	pop    %esi
 20a:	5f                   	pop    %edi
 20b:	5d                   	pop    %ebp
 20c:	c3                   	ret    

0000020d <getargs>:
#include "stdio.h"
#include "stdlib.h"

static void return_rpc(int code) {
    struct regstate state = {
      .eax = 30,
 20d:	55                   	push   %ebp
 20e:	89 e5                	mov    %esp,%ebp
 210:	83 ec 28             	sub    $0x28,%esp
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
 213:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
 21a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 221:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 228:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 22f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 236:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    while(1);
 23d:	83 ec 0c             	sub    $0xc,%esp
 240:	8d 45 e0             	lea    -0x20(%ebp),%eax
 243:	50                   	push   %eax
 244:	e8 fc ff ff ff       	call   245 <getargs+0x38>
			245: R_386_PC32	syscall
 249:	83 c4 10             	add    $0x10,%esp
}

 24c:	8b 45 e0             	mov    -0x20(%ebp),%eax
uint32_t call_rpc(int pid, uint32_t funcID, uint32_t datasize, void* data) {
 24f:	c9                   	leave  
 250:	c3                   	ret    

00000251 <_start>:
    struct regstate state = {
      .eax = 31,
 251:	55                   	push   %ebp
 252:	89 e5                	mov    %esp,%ebp
 254:	83 ec 18             	sub    $0x18,%esp
      .ebx = (uint32_t)pid,
 257:	e8 b1 ff ff ff       	call   20d <getargs>
 25c:	89 45 ec             	mov    %eax,-0x14(%ebp)
      .ecx = funcID,
      .edx = datasize,
 25f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
      .esi = (uint32_t)data,
      .edi = 0
 266:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 26a:	74 14                	je     280 <_start+0x2f>
    };
 26c:	eb 03                	jmp    271 <_start+0x20>

 26e:	ff 45 f0             	incl   -0x10(%ebp)
      .ebx = (uint32_t)pid,
      .ecx = funcID,
      .edx = datasize,
      .esi = (uint32_t)data,
      .edi = 0
    };
 271:	8b 45 f0             	mov    -0x10(%ebp),%eax
 274:	c1 e0 02             	shl    $0x2,%eax
 277:	03 45 ec             	add    -0x14(%ebp),%eax
 27a:	8b 00                	mov    (%eax),%eax
 27c:	85 c0                	test   %eax,%eax
 27e:	75 ee                	jne    26e <_start+0x1d>

    syscall(&state);

    return state.eax;
}
 280:	e8 fc ff ff ff       	call   281 <_start+0x30>
			281: R_386_PC32	set_rpc_handler

void fetch_rpc_data(void* dest) {
 285:	83 ec 08             	sub    $0x8,%esp
 288:	ff 75 ec             	pushl  -0x14(%ebp)
 28b:	ff 75 f0             	pushl  -0x10(%ebp)
 28e:	e8 fc ff ff ff       	call   28f <_start+0x3e>
			28f: R_386_PC32	main
 293:	83 c4 10             	add    $0x10,%esp
 296:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct regstate state = {
      .eax = 33,
 299:	83 ec 0c             	sub    $0xc,%esp
 29c:	ff 75 f4             	pushl  -0xc(%ebp)
 29f:	e8 fc ff ff ff       	call   2a0 <_start+0x4f>
			2a0: R_386_PC32	exit
 2a4:	83 c4 10             	add    $0x10,%esp
      .ebx = (uint32_t)dest,
 2a7:	c9                   	leave  
 2a8:	c3                   	ret    

000002a9 <yield>:
      .ecx = 0,
      .edx = 0,
 2a9:	55                   	push   %ebp
 2aa:	89 e5                	mov    %esp,%ebp
 2ac:	83 ec 28             	sub    $0x28,%esp
    };

    syscall(&state);
}

static uint32_t register_irq_rpc_syscall(uint32_t irq) {
 2af:	c7 45 e0 05 00 00 00 	movl   $0x5,-0x20(%ebp)
 2b6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 2bd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 2c4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 2cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 2d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct regstate state = {
      .eax = 40,
 2d9:	83 ec 0c             	sub    $0xc,%esp
 2dc:	8d 45 e0             	lea    -0x20(%ebp),%eax
 2df:	50                   	push   %eax
 2e0:	e8 fc ff ff ff       	call   2e1 <yield+0x38>
			2e1: R_386_PC32	syscall
 2e5:	83 c4 10             	add    $0x10,%esp
      .ebx = irq,
      .ecx = 0,
      .edx = 0,
 2e8:	c9                   	leave  
 2e9:	c3                   	ret    

000002ea <exit>:
      .esi = 0,
      .edi = 0
 2ea:	55                   	push   %ebp
 2eb:	89 e5                	mov    %esp,%ebp
 2ed:	83 ec 28             	sub    $0x28,%esp
    syscall(&state);

    return state.eax;
}

static void (*irq_handlers[128])(uint32_t);
 2f0:	8b 45 08             	mov    0x8(%ebp),%eax
 2f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
 2fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 2fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 304:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 30b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 312:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

uint32_t register_irq_handler(uint32_t irq, void(*handler)(uint32_t)) {
 319:	83 ec 0c             	sub    $0xc,%esp
 31c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 31f:	50                   	push   %eax
 320:	e8 fc ff ff ff       	call   321 <exit+0x37>
			321: R_386_PC32	syscall
 325:	83 c4 10             	add    $0x10,%esp
    if(register_irq_rpc_syscall(irq)) {
        irq_handlers[irq] = handler;
        return 1;
 328:	83 ec 0c             	sub    $0xc,%esp
 32b:	68 10 00 00 00       	push   $0x10
			32c: R_386_32	.rodata
 330:	e8 fc ff ff ff       	call   331 <exit+0x47>
			331: R_386_PC32	printf
 335:	83 c4 10             	add    $0x10,%esp
    }
 338:	eb ee                	jmp    328 <exit+0x3e>

0000033a <getExecPath>:
    return 0;
}

 33a:	55                   	push   %ebp
 33b:	89 e5                	mov    %esp,%ebp
 33d:	83 ec 28             	sub    $0x28,%esp
static void _handle_rpc(uint32_t type, uint32_t funcID, uint32_t datasize) {
    void* localData = malloc(datasize);
    fetch_rpc_data(localData);
 340:	8b 45 08             	mov    0x8(%ebp),%eax

    if(type == RPCT_IRQ) {
        if(irq_handlers[funcID]) {
            irq_handlers[funcID](funcID);
            return_rpc(0);
 343:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
 34a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 34d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 354:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 35b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 362:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        }
    }
 369:	83 ec 0c             	sub    $0xc,%esp
 36c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 36f:	50                   	push   %eax
 370:	e8 fc ff ff ff       	call   371 <getExecPath+0x37>
			371: R_386_PC32	syscall
 375:	83 c4 10             	add    $0x10,%esp

 378:	c9                   	leave  
 379:	c3                   	ret    

0000037a <changeExecPath>:
    printf("Unhandled RPC!\n");

 37a:	55                   	push   %ebp
 37b:	89 e5                	mov    %esp,%ebp
 37d:	83 ec 28             	sub    $0x28,%esp
    free(localData);
    return_rpc(0);
}
 380:	8b 45 08             	mov    0x8(%ebp),%eax

void set_rpc_handler() {
    memset(irq_handlers, 0, sizeof(irq_handlers));

    struct regstate state = {
 383:	c7 45 e0 07 00 00 00 	movl   $0x7,-0x20(%ebp)
 38a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 38d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 394:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 39b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 3a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .eax = 32,
      .ebx = (uint32_t)_handle_rpc,
 3a9:	83 ec 0c             	sub    $0xc,%esp
 3ac:	8d 45 e0             	lea    -0x20(%ebp),%eax
 3af:	50                   	push   %eax
 3b0:	e8 fc ff ff ff       	call   3b1 <changeExecPath+0x37>
			3b1: R_386_PC32	syscall
 3b5:	83 c4 10             	add    $0x10,%esp
      .ecx = 0,
      .edx = 0,
 3b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
      .esi = 0,
 3bb:	c9                   	leave  
 3bc:	c3                   	ret    

000003bd <cd>:
      .edi = 0
    };
 3bd:	55                   	push   %ebp
 3be:	89 e5                	mov    %esp,%ebp
 3c0:	83 ec 08             	sub    $0x8,%esp

 3c3:	83 ec 0c             	sub    $0xc,%esp
 3c6:	ff 75 08             	pushl  0x8(%ebp)
 3c9:	e8 fc ff ff ff       	call   3ca <cd+0xd>
			3ca: R_386_PC32	changeExecPath
 3ce:	83 c4 10             	add    $0x10,%esp
 3d1:	85 c0                	test   %eax,%eax
 3d3:	75 14                	jne    3e9 <cd+0x2c>
 3d5:	e8 fc ff ff ff       	call   3d6 <cd+0x19>
			3d6: R_386_PC32	getLastVFSErr
 3da:	83 ec 08             	sub    $0x8,%esp
 3dd:	50                   	push   %eax
 3de:	ff 75 08             	pushl  0x8(%ebp)
 3e1:	e8 fc ff ff ff       	call   3e2 <cd+0x25>
			3e2: R_386_PC32	printFilesystemError
 3e6:	83 c4 10             	add    $0x10,%esp
    syscall(&state);
 3e9:	c9                   	leave  
 3ea:	c3                   	ret    

000003eb <exec>:
}
 3eb:	55                   	push   %ebp
 3ec:	89 e5                	mov    %esp,%ebp
 3ee:	83 ec 28             	sub    $0x28,%esp
 3f1:	8b 55 08             	mov    0x8(%ebp),%edx
 3f4:	8b 45 0c             	mov    0xc(%ebp),%eax
 3f7:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%ebp)
 3fe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 401:	89 45 e8             	mov    %eax,-0x18(%ebp)
 404:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 40b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 412:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 419:	83 ec 0c             	sub    $0xc,%esp
 41c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 41f:	50                   	push   %eax
 420:	e8 fc ff ff ff       	call   421 <exec+0x36>
			421: R_386_PC32	syscall
 425:	83 c4 10             	add    $0x10,%esp
 428:	8b 45 e0             	mov    -0x20(%ebp),%eax
 42b:	c9                   	leave  
 42c:	c3                   	ret    

0000042d <texec>:
 42d:	55                   	push   %ebp
 42e:	89 e5                	mov    %esp,%ebp
 430:	83 ec 18             	sub    $0x18,%esp
 433:	83 ec 08             	sub    $0x8,%esp
 436:	ff 75 0c             	pushl  0xc(%ebp)
 439:	ff 75 08             	pushl  0x8(%ebp)
 43c:	e8 fc ff ff ff       	call   43d <texec+0x10>
			43d: R_386_PC32	exec
 441:	83 c4 10             	add    $0x10,%esp
 444:	89 45 f4             	mov    %eax,-0xc(%ebp)
 447:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 44b:	75 14                	jne    461 <texec+0x34>
 44d:	e8 fc ff ff ff       	call   44e <texec+0x21>
			44e: R_386_PC32	getLastVFSErr
 452:	83 ec 08             	sub    $0x8,%esp
 455:	50                   	push   %eax
 456:	ff 75 08             	pushl  0x8(%ebp)
 459:	e8 fc ff ff ff       	call   45a <texec+0x2d>
			45a: R_386_PC32	printFilesystemError
 45e:	83 c4 10             	add    $0x10,%esp
 461:	8b 45 f4             	mov    -0xc(%ebp),%eax
 464:	c9                   	leave  
 465:	c3                   	ret    

00000466 <printFilesystemError>:
 466:	55                   	push   %ebp
 467:	89 e5                	mov    %esp,%ebp
 469:	83 ec 08             	sub    $0x8,%esp
 46c:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
 470:	0f 87 8c 00 00 00    	ja     502 <printFilesystemError+0x9c>
 476:	8b 45 0c             	mov    0xc(%ebp),%eax
 479:	c1 e0 02             	shl    $0x2,%eax
 47c:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
			47e: R_386_32	.rodata
 482:	ff e0                	jmp    *%eax
 484:	83 ec 08             	sub    $0x8,%esp
 487:	ff 75 08             	pushl  0x8(%ebp)
 48a:	68 17 00 00 00       	push   $0x17
			48b: R_386_32	.rodata
 48f:	e8 fc ff ff ff       	call   490 <printFilesystemError+0x2a>
			490: R_386_PC32	printf
 494:	83 c4 10             	add    $0x10,%esp
 497:	eb 7c                	jmp    515 <printFilesystemError+0xaf>
 499:	83 ec 08             	sub    $0x8,%esp
 49c:	ff 75 08             	pushl  0x8(%ebp)
 49f:	68 2c 00 00 00       	push   $0x2c
			4a0: R_386_32	.rodata
 4a4:	e8 fc ff ff ff       	call   4a5 <printFilesystemError+0x3f>
			4a5: R_386_PC32	printf
 4a9:	83 c4 10             	add    $0x10,%esp
 4ac:	eb 67                	jmp    515 <printFilesystemError+0xaf>
 4ae:	83 ec 08             	sub    $0x8,%esp
 4b1:	ff 75 08             	pushl  0x8(%ebp)
 4b4:	68 4c 00 00 00       	push   $0x4c
			4b5: R_386_32	.rodata
 4b9:	e8 fc ff ff ff       	call   4ba <printFilesystemError+0x54>
			4ba: R_386_PC32	printf
 4be:	83 c4 10             	add    $0x10,%esp
 4c1:	eb 52                	jmp    515 <printFilesystemError+0xaf>
 4c3:	83 ec 08             	sub    $0x8,%esp
 4c6:	ff 75 08             	pushl  0x8(%ebp)
 4c9:	68 76 00 00 00       	push   $0x76
			4ca: R_386_32	.rodata
 4ce:	e8 fc ff ff ff       	call   4cf <printFilesystemError+0x69>
			4cf: R_386_PC32	printf
 4d3:	83 c4 10             	add    $0x10,%esp
 4d6:	eb 3d                	jmp    515 <printFilesystemError+0xaf>
 4d8:	83 ec 08             	sub    $0x8,%esp
 4db:	ff 75 08             	pushl  0x8(%ebp)
 4de:	68 8c 00 00 00       	push   $0x8c
			4df: R_386_32	.rodata
 4e3:	e8 fc ff ff ff       	call   4e4 <printFilesystemError+0x7e>
			4e4: R_386_PC32	printf
 4e8:	83 c4 10             	add    $0x10,%esp
 4eb:	eb 28                	jmp    515 <printFilesystemError+0xaf>
 4ed:	83 ec 08             	sub    $0x8,%esp
 4f0:	ff 75 08             	pushl  0x8(%ebp)
 4f3:	68 c7 00 00 00       	push   $0xc7
			4f4: R_386_32	.rodata
 4f8:	e8 fc ff ff ff       	call   4f9 <printFilesystemError+0x93>
			4f9: R_386_PC32	printf
 4fd:	83 c4 10             	add    $0x10,%esp
 500:	eb 13                	jmp    515 <printFilesystemError+0xaf>
 502:	83 ec 08             	sub    $0x8,%esp
 505:	ff 75 08             	pushl  0x8(%ebp)
 508:	68 da 00 00 00       	push   $0xda
			509: R_386_32	.rodata
 50d:	e8 fc ff ff ff       	call   50e <printFilesystemError+0xa8>
			50e: R_386_PC32	printf
 512:	83 c4 10             	add    $0x10,%esp
 515:	83 ec 0c             	sub    $0xc,%esp
 518:	68 e2 00 00 00       	push   $0xe2
			519: R_386_32	.rodata
 51d:	e8 fc ff ff ff       	call   51e <printFilesystemError+0xb8>
			51e: R_386_PC32	printf
 522:	83 c4 10             	add    $0x10,%esp
 525:	c9                   	leave  
 526:	c3                   	ret    

stdio.o:     file format elf32-i386
rw-rw-rw- 0/0  14628 Aug 10 18:30 2014 stdio.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008b1  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000008e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000008e8  2**2
                  ALLOC
  3 .stab         00001800  00000000  00000000  000008e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000cb5  00000000  00000000  000020e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .rodata       000000b1  00000000  00000000  00002da0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .comment      00000012  00000000  00000000  00002e51  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000044 l     F .text	00000043 getpmhandle
00000087 l     F .text	00000015 getstdout
0000009c l     F .text	00000015 getstdin
000000b1 l     F .text	00000015 getstderr
00000000 l    d  .rodata	00000000 .rodata
000001d5 l     F .text	0000006c printrwerror
00000241 l     F .text	00000041 frwrite
000002d9 l     F .text	00000041 frread
000003b4 l     F .text	00000025 resolveHandle
00000539 l     F .text	0000004a kputc
00000611 l     F .text	00000043 kputs
000006bb l     F .text	0000007c putn
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000 g     F .text	00000044 getLastVFSErr
00000000         *UND*	00000000 syscall
000000c6 g     F .text	00000042 fopenpmhandle
00000108 g     F .text	00000018 setstdout
00000120 g     F .text	00000018 setstdin
00000138 g     F .text	00000018 setstderr
00000150 g     F .text	00000042 fopen
00000192 g     F .text	00000043 fclose
00000737 g     F .text	0000017a printf
00000282 g     F .text	00000057 fwrite
00000000         *UND*	00000000 yield
0000031a g     F .text	00000057 fread
00000371 g     F .text	00000043 fmkfifo
000003d9 g     F .text	0000003a fgetc
00000413 g     F .text	00000062 fgets
00000475 g     F .text	00000016 getc
0000048b g     F .text	00000015 getchar
000004a0 g     F .text	00000099 getln
00000583 g     F .text	00000020 putchar
000005c4 g     F .text	0000004d fputc
000005a3 g     F .text	00000021 putc
00000654 g     F .text	00000018 puts
0000066c g     F .text	0000004f fputs
00000000         *UND*	00000000 strlen



Disassembly of section .text:

00000000 <getLastVFSErr>:
#include "stdio.h"
#include "string.h"
#include "process.h"

uint32_t getLastVFSErr() {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
        .ebx = 0,
        .ecx = 0,
        .edx = 0,
        .esi = 0,
        .edi = 0
    };
   6:	c7 45 e0 0f 00 00 00 	movl   $0xf,-0x20(%ebp)
   d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  14:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  30:	83 ec 0c             	sub    $0xc,%esp
  33:	8d 45 e0             	lea    -0x20(%ebp),%eax
  36:	50                   	push   %eax
  37:	e8 fc ff ff ff       	call   38 <getLastVFSErr+0x38>
			38: R_386_PC32	syscall
  3c:	83 c4 10             	add    $0x10,%esp

    return state.eax;
  3f:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  42:	c9                   	leave  
  43:	c3                   	ret    

00000044 <getpmhandle>:

static HANDLE getpmhandle   (uint32_t pmid) {
  44:	55                   	push   %ebp
  45:	89 e5                	mov    %esp,%ebp
  47:	83 ec 28             	sub    $0x28,%esp
      .ebx = pmid,
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
  4a:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
  51:	8b 45 08             	mov    0x8(%ebp),%eax
  54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  57:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  5e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  6c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  73:	83 ec 0c             	sub    $0xc,%esp
  76:	8d 45 e0             	lea    -0x20(%ebp),%eax
  79:	50                   	push   %eax
  7a:	e8 fc ff ff ff       	call   7b <getpmhandle+0x37>
			7b: R_386_PC32	syscall
  7f:	83 c4 10             	add    $0x10,%esp

    return (HANDLE)state.eax;
  82:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  85:	c9                   	leave  
  86:	c3                   	ret    

00000087 <getstdout>:

static HANDLE getstdout() { return getpmhandle(PMID_STDOUT); };
  87:	55                   	push   %ebp
  88:	89 e5                	mov    %esp,%ebp
  8a:	83 ec 08             	sub    $0x8,%esp
  8d:	83 ec 0c             	sub    $0xc,%esp
  90:	6a 00                	push   $0x0
  92:	e8 ad ff ff ff       	call   44 <getpmhandle>
  97:	83 c4 10             	add    $0x10,%esp
  9a:	c9                   	leave  
  9b:	c3                   	ret    

0000009c <getstdin>:
static HANDLE getstdin() { return getpmhandle(PMID_STDIN); };
  9c:	55                   	push   %ebp
  9d:	89 e5                	mov    %esp,%ebp
  9f:	83 ec 08             	sub    $0x8,%esp
  a2:	83 ec 0c             	sub    $0xc,%esp
  a5:	6a 01                	push   $0x1
  a7:	e8 98 ff ff ff       	call   44 <getpmhandle>
  ac:	83 c4 10             	add    $0x10,%esp
  af:	c9                   	leave  
  b0:	c3                   	ret    

000000b1 <getstderr>:
static HANDLE getstderr() { return getpmhandle(PMID_STDERR); };
  b1:	55                   	push   %ebp
  b2:	89 e5                	mov    %esp,%ebp
  b4:	83 ec 08             	sub    $0x8,%esp
  b7:	83 ec 0c             	sub    $0xc,%esp
  ba:	6a 02                	push   $0x2
  bc:	e8 83 ff ff ff       	call   44 <getpmhandle>
  c1:	83 c4 10             	add    $0x10,%esp
  c4:	c9                   	leave  
  c5:	c3                   	ret    

000000c6 <fopenpmhandle>:

int fopenpmhandle (uint32_t pmid, char* path) {
  c6:	55                   	push   %ebp
  c7:	89 e5                	mov    %esp,%ebp
  c9:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 21,
      .ebx = pmid,
      .ecx = (uint32_t)path,
  cc:	8b 45 0c             	mov    0xc(%ebp),%eax
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
  cf:	c7 45 e0 15 00 00 00 	movl   $0x15,-0x20(%ebp)
  d6:	8b 55 08             	mov    0x8(%ebp),%edx
  d9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
  df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  f4:	83 ec 0c             	sub    $0xc,%esp
  f7:	8d 45 e0             	lea    -0x20(%ebp),%eax
  fa:	50                   	push   %eax
  fb:	e8 fc ff ff ff       	call   fc <fopenpmhandle+0x36>
			fc: R_386_PC32	syscall
 100:	83 c4 10             	add    $0x10,%esp

    return (HANDLE)state.eax;
 103:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 106:	c9                   	leave  
 107:	c3                   	ret    

00000108 <setstdout>:

int setstdout(char* path) { return fopenpmhandle(PMID_STDOUT, path); };
 108:	55                   	push   %ebp
 109:	89 e5                	mov    %esp,%ebp
 10b:	83 ec 08             	sub    $0x8,%esp
 10e:	83 ec 08             	sub    $0x8,%esp
 111:	ff 75 08             	pushl  0x8(%ebp)
 114:	6a 00                	push   $0x0
 116:	e8 fc ff ff ff       	call   117 <setstdout+0xf>
			117: R_386_PC32	fopenpmhandle
 11b:	83 c4 10             	add    $0x10,%esp
 11e:	c9                   	leave  
 11f:	c3                   	ret    

00000120 <setstdin>:
int setstdin (char* path) { return fopenpmhandle(PMID_STDIN , path); };
 120:	55                   	push   %ebp
 121:	89 e5                	mov    %esp,%ebp
 123:	83 ec 08             	sub    $0x8,%esp
 126:	83 ec 08             	sub    $0x8,%esp
 129:	ff 75 08             	pushl  0x8(%ebp)
 12c:	6a 01                	push   $0x1
 12e:	e8 fc ff ff ff       	call   12f <setstdin+0xf>
			12f: R_386_PC32	fopenpmhandle
 133:	83 c4 10             	add    $0x10,%esp
 136:	c9                   	leave  
 137:	c3                   	ret    

00000138 <setstderr>:
int setstderr(char* path) { return fopenpmhandle(PMID_STDERR, path); };
 138:	55                   	push   %ebp
 139:	89 e5                	mov    %esp,%ebp
 13b:	83 ec 08             	sub    $0x8,%esp
 13e:	83 ec 08             	sub    $0x8,%esp
 141:	ff 75 08             	pushl  0x8(%ebp)
 144:	6a 02                	push   $0x2
 146:	e8 fc ff ff ff       	call   147 <setstderr+0xf>
			147: R_386_PC32	fopenpmhandle
 14b:	83 c4 10             	add    $0x10,%esp
 14e:	c9                   	leave  
 14f:	c3                   	ret    

00000150 <fopen>:

HANDLE fopen(char* path, uint32_t mode) {
 150:	55                   	push   %ebp
 151:	89 e5                	mov    %esp,%ebp
 153:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 10,
      .ebx = (uint32_t)path,
 156:	8b 45 08             	mov    0x8(%ebp),%eax
      .ecx = mode,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
 159:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
 160:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 163:	8b 45 0c             	mov    0xc(%ebp),%eax
 166:	89 45 e8             	mov    %eax,-0x18(%ebp)
 169:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 170:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 177:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
 17e:	83 ec 0c             	sub    $0xc,%esp
 181:	8d 45 e0             	lea    -0x20(%ebp),%eax
 184:	50                   	push   %eax
 185:	e8 fc ff ff ff       	call   186 <fopen+0x36>
			186: R_386_PC32	syscall
 18a:	83 c4 10             	add    $0x10,%esp

    return (HANDLE)state.eax;
 18d:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 190:	c9                   	leave  
 191:	c3                   	ret    

00000192 <fclose>:

int fclose(uint32_t handle) {
 192:	55                   	push   %ebp
 193:	89 e5                	mov    %esp,%ebp
 195:	83 ec 28             	sub    $0x28,%esp
      .ebx = (uint32_t)handle,
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
 198:	c7 45 e0 0b 00 00 00 	movl   $0xb,-0x20(%ebp)
 19f:	8b 45 08             	mov    0x8(%ebp),%eax
 1a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 1a5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 1ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 1b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 1ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
 1c1:	83 ec 0c             	sub    $0xc,%esp
 1c4:	8d 45 e0             	lea    -0x20(%ebp),%eax
 1c7:	50                   	push   %eax
 1c8:	e8 fc ff ff ff       	call   1c9 <fclose+0x37>
			1c9: R_386_PC32	syscall
 1cd:	83 c4 10             	add    $0x10,%esp

    return (int)state.eax;
 1d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 1d3:	c9                   	leave  
 1d4:	c3                   	ret    

000001d5 <printrwerror>:

static void printrwerror(HANDLE handle, uint32_t res) {
 1d5:	55                   	push   %ebp
 1d6:	89 e5                	mov    %esp,%ebp
 1d8:	83 ec 08             	sub    $0x8,%esp
    if(res == RW_ERR_VFS) {
 1db:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
 1df:	75 13                	jne    1f4 <printrwerror+0x1f>
        printf("HANDLE[0x%x] VFS_ERROR\n", handle);
 1e1:	83 ec 08             	sub    $0x8,%esp
 1e4:	ff 75 08             	pushl  0x8(%ebp)
 1e7:	68 00 00 00 00       	push   $0x0
			1e8: R_386_32	.rodata
 1ec:	e8 fc ff ff ff       	call   1ed <printrwerror+0x18>
			1ed: R_386_PC32	printf
 1f1:	83 c4 10             	add    $0x10,%esp
    }

    if(res == RW_ERR_DRIVER) {
 1f4:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
 1f8:	75 13                	jne    20d <printrwerror+0x38>
        printf("HANDLE[0x%x] DRIVER_ERROR\n", handle);
 1fa:	83 ec 08             	sub    $0x8,%esp
 1fd:	ff 75 08             	pushl  0x8(%ebp)
 200:	68 18 00 00 00       	push   $0x18
			201: R_386_32	.rodata
 205:	e8 fc ff ff ff       	call   206 <printrwerror+0x31>
			206: R_386_PC32	printf
 20a:	83 c4 10             	add    $0x10,%esp
    }

    if(res == RW_NOFM_READ) {
 20d:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
 211:	75 13                	jne    226 <printrwerror+0x51>
        printf("HANDLE[0x%x] FILEMODE doesn't allow read\n", handle);
 213:	83 ec 08             	sub    $0x8,%esp
 216:	ff 75 08             	pushl  0x8(%ebp)
 219:	68 34 00 00 00       	push   $0x34
			21a: R_386_32	.rodata
 21e:	e8 fc ff ff ff       	call   21f <printrwerror+0x4a>
			21f: R_386_PC32	printf
 223:	83 c4 10             	add    $0x10,%esp
    }

    if(res == RW_NOFM_WRITE) {
 226:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
 22a:	75 13                	jne    23f <printrwerror+0x6a>
        printf("HANDLE[0x%x] FILEMODE doesn't allow write\n", handle);
 22c:	83 ec 08             	sub    $0x8,%esp
 22f:	ff 75 08             	pushl  0x8(%ebp)
 232:	68 60 00 00 00       	push   $0x60
			233: R_386_32	.rodata
 237:	e8 fc ff ff ff       	call   238 <printrwerror+0x63>
			238: R_386_PC32	printf
 23c:	83 c4 10             	add    $0x10,%esp
    }
}
 23f:	c9                   	leave  
 240:	c3                   	ret    

00000241 <frwrite>:

static uint32_t frwrite(uint32_t handle, const void* src, uint32_t length) {
 241:	55                   	push   %ebp
 242:	89 e5                	mov    %esp,%ebp
 244:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 12,
      .ebx = (uint32_t)handle,
      .ecx = (uint32_t)src,
 247:	8b 45 0c             	mov    0xc(%ebp),%eax
      .edx = length,
      .esi = 0,
      .edi = 0
    };
 24a:	c7 45 e0 0c 00 00 00 	movl   $0xc,-0x20(%ebp)
 251:	8b 55 08             	mov    0x8(%ebp),%edx
 254:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 257:	89 45 e8             	mov    %eax,-0x18(%ebp)
 25a:	8b 45 10             	mov    0x10(%ebp),%eax
 25d:	89 45 ec             	mov    %eax,-0x14(%ebp)
 260:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 267:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
 26e:	83 ec 0c             	sub    $0xc,%esp
 271:	8d 45 e0             	lea    -0x20(%ebp),%eax
 274:	50                   	push   %eax
 275:	e8 fc ff ff ff       	call   276 <frwrite+0x35>
			276: R_386_PC32	syscall
 27a:	83 c4 10             	add    $0x10,%esp

    return (int)state.eax;
 27d:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 280:	c9                   	leave  
 281:	c3                   	ret    

00000282 <fwrite>:

uint32_t fwrite(uint32_t handle, const void* src, uint32_t length) {
 282:	55                   	push   %ebp
 283:	89 e5                	mov    %esp,%ebp
 285:	83 ec 18             	sub    $0x18,%esp
    uint32_t res = frwrite(handle, src, length);
 288:	83 ec 04             	sub    $0x4,%esp
 28b:	ff 75 10             	pushl  0x10(%ebp)
 28e:	ff 75 0c             	pushl  0xc(%ebp)
 291:	ff 75 08             	pushl  0x8(%ebp)
 294:	e8 a8 ff ff ff       	call   241 <frwrite>
 299:	83 c4 10             	add    $0x10,%esp
 29c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(res == RW_BLOCK) {
 29f:	eb 1c                	jmp    2bd <fwrite+0x3b>
        yield();
 2a1:	e8 fc ff ff ff       	call   2a2 <fwrite+0x20>
			2a2: R_386_PC32	yield
        res = frwrite(handle, src, length);
 2a6:	83 ec 04             	sub    $0x4,%esp
 2a9:	ff 75 10             	pushl  0x10(%ebp)
 2ac:	ff 75 0c             	pushl  0xc(%ebp)
 2af:	ff 75 08             	pushl  0x8(%ebp)
 2b2:	e8 8a ff ff ff       	call   241 <frwrite>
 2b7:	83 c4 10             	add    $0x10,%esp
 2ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

uint32_t fwrite(uint32_t handle, const void* src, uint32_t length) {
    uint32_t res = frwrite(handle, src, length);

    while(res == RW_BLOCK) {
 2bd:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
 2c1:	74 de                	je     2a1 <fwrite+0x1f>
        yield();
        res = frwrite(handle, src, length);
    }

    printrwerror(handle, res);
 2c3:	83 ec 08             	sub    $0x8,%esp
 2c6:	ff 75 f4             	pushl  -0xc(%ebp)
 2c9:	ff 75 08             	pushl  0x8(%ebp)
 2cc:	e8 04 ff ff ff       	call   1d5 <printrwerror>
 2d1:	83 c4 10             	add    $0x10,%esp

    return res;
 2d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 2d7:	c9                   	leave  
 2d8:	c3                   	ret    

000002d9 <frread>:

static uint32_t frread(uint32_t handle, void* dest, uint32_t length) {
 2d9:	55                   	push   %ebp
 2da:	89 e5                	mov    %esp,%ebp
 2dc:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 13,
      .ebx = (uint32_t)handle,
      .ecx = (uint32_t)dest,
 2df:	8b 45 0c             	mov    0xc(%ebp),%eax
      .edx = length,
      .esi = 0,
      .edi = 0
    };
 2e2:	c7 45 e0 0d 00 00 00 	movl   $0xd,-0x20(%ebp)
 2e9:	8b 55 08             	mov    0x8(%ebp),%edx
 2ec:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 2ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
 2f2:	8b 45 10             	mov    0x10(%ebp),%eax
 2f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
 2f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 2ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
 306:	83 ec 0c             	sub    $0xc,%esp
 309:	8d 45 e0             	lea    -0x20(%ebp),%eax
 30c:	50                   	push   %eax
 30d:	e8 fc ff ff ff       	call   30e <frread+0x35>
			30e: R_386_PC32	syscall
 312:	83 c4 10             	add    $0x10,%esp

    return (int)state.eax;
 315:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 318:	c9                   	leave  
 319:	c3                   	ret    

0000031a <fread>:

uint32_t fread(uint32_t handle, void* dest, uint32_t length) {
 31a:	55                   	push   %ebp
 31b:	89 e5                	mov    %esp,%ebp
 31d:	83 ec 18             	sub    $0x18,%esp
    uint32_t res = frread(handle, dest, length);
 320:	83 ec 04             	sub    $0x4,%esp
 323:	ff 75 10             	pushl  0x10(%ebp)
 326:	ff 75 0c             	pushl  0xc(%ebp)
 329:	ff 75 08             	pushl  0x8(%ebp)
 32c:	e8 a8 ff ff ff       	call   2d9 <frread>
 331:	83 c4 10             	add    $0x10,%esp
 334:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(res == RW_BLOCK) {
 337:	eb 1c                	jmp    355 <fread+0x3b>
        yield();
 339:	e8 fc ff ff ff       	call   33a <fread+0x20>
			33a: R_386_PC32	yield
        res = frread(handle, dest, length);
 33e:	83 ec 04             	sub    $0x4,%esp
 341:	ff 75 10             	pushl  0x10(%ebp)
 344:	ff 75 0c             	pushl  0xc(%ebp)
 347:	ff 75 08             	pushl  0x8(%ebp)
 34a:	e8 8a ff ff ff       	call   2d9 <frread>
 34f:	83 c4 10             	add    $0x10,%esp
 352:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

uint32_t fread(uint32_t handle, void* dest, uint32_t length) {
    uint32_t res = frread(handle, dest, length);

    while(res == RW_BLOCK) {
 355:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
 359:	74 de                	je     339 <fread+0x1f>
        yield();
        res = frread(handle, dest, length);
    }

    printrwerror(handle, res);
 35b:	83 ec 08             	sub    $0x8,%esp
 35e:	ff 75 f4             	pushl  -0xc(%ebp)
 361:	ff 75 08             	pushl  0x8(%ebp)
 364:	e8 6c fe ff ff       	call   1d5 <printrwerror>
 369:	83 c4 10             	add    $0x10,%esp

    return res;
 36c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 36f:	c9                   	leave  
 370:	c3                   	ret    

00000371 <fmkfifo>:

HANDLE fmkfifo(char* path) {
 371:	55                   	push   %ebp
 372:	89 e5                	mov    %esp,%ebp
 374:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 14,
      .ebx = (uint32_t)path,
 377:	8b 45 08             	mov    0x8(%ebp),%eax
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
 37a:	c7 45 e0 0e 00 00 00 	movl   $0xe,-0x20(%ebp)
 381:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 384:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 38b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 392:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 399:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
 3a0:	83 ec 0c             	sub    $0xc,%esp
 3a3:	8d 45 e0             	lea    -0x20(%ebp),%eax
 3a6:	50                   	push   %eax
 3a7:	e8 fc ff ff ff       	call   3a8 <fmkfifo+0x37>
			3a8: R_386_PC32	syscall
 3ac:	83 c4 10             	add    $0x10,%esp

    return (HANDLE)state.eax;
 3af:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 3b2:	c9                   	leave  
 3b3:	c3                   	ret    

000003b4 <resolveHandle>:

static HANDLE resolveHandle(HANDLE hdl) {
 3b4:	55                   	push   %ebp
 3b5:	89 e5                	mov    %esp,%ebp
 3b7:	83 ec 08             	sub    $0x8,%esp
    if(hdl < 0xFFF) {
 3ba:	81 7d 08 fe 0f 00 00 	cmpl   $0xffe,0x8(%ebp)
 3c1:	77 11                	ja     3d4 <resolveHandle+0x20>
        hdl = getpmhandle(hdl);
 3c3:	83 ec 0c             	sub    $0xc,%esp
 3c6:	ff 75 08             	pushl  0x8(%ebp)
 3c9:	e8 76 fc ff ff       	call   44 <getpmhandle>
 3ce:	83 c4 10             	add    $0x10,%esp
 3d1:	89 45 08             	mov    %eax,0x8(%ebp)
    }
    return hdl;
 3d4:	8b 45 08             	mov    0x8(%ebp),%eax
}
 3d7:	c9                   	leave  
 3d8:	c3                   	ret    

000003d9 <fgetc>:

char fgetc(HANDLE hdl) {
 3d9:	55                   	push   %ebp
 3da:	89 e5                	mov    %esp,%ebp
 3dc:	83 ec 18             	sub    $0x18,%esp
    hdl = resolveHandle(hdl);
 3df:	83 ec 0c             	sub    $0xc,%esp
 3e2:	ff 75 08             	pushl  0x8(%ebp)
 3e5:	e8 ca ff ff ff       	call   3b4 <resolveHandle>
 3ea:	83 c4 10             	add    $0x10,%esp
 3ed:	89 45 08             	mov    %eax,0x8(%ebp)
    char in = 0;
 3f0:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
    if(hdl != 0) {
 3f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 3f8:	74 14                	je     40e <fgetc+0x35>
        fread(hdl, &in, sizeof(char));
 3fa:	83 ec 04             	sub    $0x4,%esp
 3fd:	6a 01                	push   $0x1
 3ff:	8d 45 f7             	lea    -0x9(%ebp),%eax
 402:	50                   	push   %eax
 403:	ff 75 08             	pushl  0x8(%ebp)
 406:	e8 fc ff ff ff       	call   407 <fgetc+0x2e>
			407: R_386_PC32	fread
 40b:	83 c4 10             	add    $0x10,%esp
    }
    return in;
 40e:	8a 45 f7             	mov    -0x9(%ebp),%al
}
 411:	c9                   	leave  
 412:	c3                   	ret    

00000413 <fgets>:

char* fgets(char* str, int num, HANDLE hdl) {
 413:	55                   	push   %ebp
 414:	89 e5                	mov    %esp,%ebp
 416:	53                   	push   %ebx
 417:	83 ec 14             	sub    $0x14,%esp
    for(int n = 0; n < (num - 1); n++) {
 41a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 421:	eb 38                	jmp    45b <fgets+0x48>
        str[n] = fgetc(hdl);
 423:	8b 45 f4             	mov    -0xc(%ebp),%eax
 426:	89 c3                	mov    %eax,%ebx
 428:	03 5d 08             	add    0x8(%ebp),%ebx
 42b:	83 ec 0c             	sub    $0xc,%esp
 42e:	ff 75 10             	pushl  0x10(%ebp)
 431:	e8 fc ff ff ff       	call   432 <fgets+0x1f>
			432: R_386_PC32	fgetc
 436:	83 c4 10             	add    $0x10,%esp
 439:	88 03                	mov    %al,(%ebx)
        if(str[n] == 0 || str[n] == '\0') {
 43b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 43e:	03 45 08             	add    0x8(%ebp),%eax
 441:	8a 00                	mov    (%eax),%al
 443:	84 c0                	test   %al,%al
 445:	74 0c                	je     453 <fgets+0x40>
 447:	8b 45 f4             	mov    -0xc(%ebp),%eax
 44a:	03 45 08             	add    0x8(%ebp),%eax
 44d:	8a 00                	mov    (%eax),%al
 44f:	84 c0                	test   %al,%al
 451:	75 05                	jne    458 <fgets+0x45>
            return str;
 453:	8b 45 08             	mov    0x8(%ebp),%eax
 456:	eb 18                	jmp    470 <fgets+0x5d>
    }
    return in;
}

char* fgets(char* str, int num, HANDLE hdl) {
    for(int n = 0; n < (num - 1); n++) {
 458:	ff 45 f4             	incl   -0xc(%ebp)
 45b:	8b 45 0c             	mov    0xc(%ebp),%eax
 45e:	48                   	dec    %eax
 45f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 462:	7f bf                	jg     423 <fgets+0x10>
        if(str[n] == 0 || str[n] == '\0') {
            return str;
        }
    }

    str[num] = '\0';
 464:	8b 45 0c             	mov    0xc(%ebp),%eax
 467:	03 45 08             	add    0x8(%ebp),%eax
 46a:	c6 00 00             	movb   $0x0,(%eax)
    return str;
 46d:	8b 45 08             	mov    0x8(%ebp),%eax
}
 470:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 473:	c9                   	leave  
 474:	c3                   	ret    

00000475 <getc>:

char getc(HANDLE hdl) {
 475:	55                   	push   %ebp
 476:	89 e5                	mov    %esp,%ebp
 478:	83 ec 08             	sub    $0x8,%esp
    return fgetc(hdl);
 47b:	83 ec 0c             	sub    $0xc,%esp
 47e:	ff 75 08             	pushl  0x8(%ebp)
 481:	e8 fc ff ff ff       	call   482 <getc+0xd>
			482: R_386_PC32	fgetc
 486:	83 c4 10             	add    $0x10,%esp
}
 489:	c9                   	leave  
 48a:	c3                   	ret    

0000048b <getchar>:

char getchar() {
 48b:	55                   	push   %ebp
 48c:	89 e5                	mov    %esp,%ebp
 48e:	83 ec 08             	sub    $0x8,%esp
    return fgetc(PMID_STDIN);
 491:	83 ec 0c             	sub    $0xc,%esp
 494:	6a 01                	push   $0x1
 496:	e8 fc ff ff ff       	call   497 <getchar+0xc>
			497: R_386_PC32	fgetc
 49b:	83 c4 10             	add    $0x10,%esp
}
 49e:	c9                   	leave  
 49f:	c3                   	ret    

000004a0 <getln>:

char* getln(char* str) {
 4a0:	55                   	push   %ebp
 4a1:	89 e5                	mov    %esp,%ebp
 4a3:	83 ec 18             	sub    $0x18,%esp
    uint32_t index = 0;
 4a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    char lastChar = 0;
 4ad:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    while((lastChar = fgetc(PMID_STDIN))) {
 4b1:	eb 5f                	jmp    512 <getln+0x72>
        if(lastChar == '\n') {
 4b3:	80 7d f7 0a          	cmpb   $0xa,-0x9(%ebp)
 4b7:	75 0f                	jne    4c8 <getln+0x28>
            putchar('\n');
 4b9:	83 ec 0c             	sub    $0xc,%esp
 4bc:	6a 0a                	push   $0xa
 4be:	e8 fc ff ff ff       	call   4bf <getln+0x1f>
			4bf: R_386_PC32	putchar
 4c3:	83 c4 10             	add    $0x10,%esp
            break;
 4c6:	eb 60                	jmp    528 <getln+0x88>
        }

        if(lastChar == 8) {
 4c8:	80 7d f7 08          	cmpb   $0x8,-0x9(%ebp)
 4cc:	75 24                	jne    4f2 <getln+0x52>
            if(index != 0) {
 4ce:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 4d2:	74 10                	je     4e4 <getln+0x44>
                index--;
 4d4:	ff 4d f0             	decl   -0x10(%ebp)
                putchar(8);
 4d7:	83 ec 0c             	sub    $0xc,%esp
 4da:	6a 08                	push   $0x8
 4dc:	e8 fc ff ff ff       	call   4dd <getln+0x3d>
			4dd: R_386_PC32	putchar
 4e1:	83 c4 10             	add    $0x10,%esp
            }
            str[index] = 0;
 4e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 4e7:	8b 55 08             	mov    0x8(%ebp),%edx
 4ea:	8d 04 02             	lea    (%edx,%eax,1),%eax
 4ed:	c6 00 00             	movb   $0x0,(%eax)
            continue;
 4f0:	eb 20                	jmp    512 <getln+0x72>
        }

        str[index] = lastChar;
 4f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 4f5:	8b 55 08             	mov    0x8(%ebp),%edx
 4f8:	01 c2                	add    %eax,%edx
 4fa:	8a 45 f7             	mov    -0x9(%ebp),%al
 4fd:	88 02                	mov    %al,(%edx)
        putchar(lastChar);
 4ff:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
 503:	83 ec 0c             	sub    $0xc,%esp
 506:	50                   	push   %eax
 507:	e8 fc ff ff ff       	call   508 <getln+0x68>
			508: R_386_PC32	putchar
 50c:	83 c4 10             	add    $0x10,%esp

        index++;
 50f:	ff 45 f0             	incl   -0x10(%ebp)

char* getln(char* str) {
    uint32_t index = 0;
    char lastChar = 0;

    while((lastChar = fgetc(PMID_STDIN))) {
 512:	83 ec 0c             	sub    $0xc,%esp
 515:	6a 01                	push   $0x1
 517:	e8 fc ff ff ff       	call   518 <getln+0x78>
			518: R_386_PC32	fgetc
 51c:	83 c4 10             	add    $0x10,%esp
 51f:	88 45 f7             	mov    %al,-0x9(%ebp)
 522:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 526:	75 8b                	jne    4b3 <getln+0x13>
        putchar(lastChar);

        index++;
    }

    str[index] = 0;
 528:	8b 45 f0             	mov    -0x10(%ebp),%eax
 52b:	8b 55 08             	mov    0x8(%ebp),%edx
 52e:	8d 04 02             	lea    (%edx,%eax,1),%eax
 531:	c6 00 00             	movb   $0x0,(%eax)

    return str;
 534:	8b 45 08             	mov    0x8(%ebp),%eax
}
 537:	c9                   	leave  
 538:	c3                   	ret    

00000539 <kputc>:

static int kputc(char c) {
 539:	55                   	push   %ebp
 53a:	89 e5                	mov    %esp,%ebp
 53c:	83 ec 38             	sub    $0x38,%esp
 53f:	8b 45 08             	mov    0x8(%ebp),%eax
 542:	88 45 d4             	mov    %al,-0x2c(%ebp)
  struct regstate state = {
    .eax = 201,
    .ebx = (uint32_t)c,
 545:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
    .ecx = 0,
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
 549:	c7 45 e0 c9 00 00 00 	movl   $0xc9,-0x20(%ebp)
 550:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 553:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 55a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 561:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 568:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  
  syscall(&state);
 56f:	83 ec 0c             	sub    $0xc,%esp
 572:	8d 45 e0             	lea    -0x20(%ebp),%eax
 575:	50                   	push   %eax
 576:	e8 fc ff ff ff       	call   577 <kputc+0x3e>
			577: R_386_PC32	syscall
 57b:	83 c4 10             	add    $0x10,%esp
  
  return state.eax;
 57e:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 581:	c9                   	leave  
 582:	c3                   	ret    

00000583 <putchar>:

int putchar(char c) {
 583:	55                   	push   %ebp
 584:	89 e5                	mov    %esp,%ebp
 586:	83 ec 18             	sub    $0x18,%esp
 589:	8b 45 08             	mov    0x8(%ebp),%eax
 58c:	88 45 f4             	mov    %al,-0xc(%ebp)
    return fputc(c, PMID_STDOUT);
 58f:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
 593:	83 ec 08             	sub    $0x8,%esp
 596:	6a 00                	push   $0x0
 598:	50                   	push   %eax
 599:	e8 fc ff ff ff       	call   59a <putchar+0x17>
			59a: R_386_PC32	fputc
 59e:	83 c4 10             	add    $0x10,%esp
}
 5a1:	c9                   	leave  
 5a2:	c3                   	ret    

000005a3 <putc>:

int putc(char c, HANDLE hdl) {
 5a3:	55                   	push   %ebp
 5a4:	89 e5                	mov    %esp,%ebp
 5a6:	83 ec 18             	sub    $0x18,%esp
 5a9:	8b 45 08             	mov    0x8(%ebp),%eax
 5ac:	88 45 f4             	mov    %al,-0xc(%ebp)
    return fputc(c, hdl);
 5af:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
 5b3:	83 ec 08             	sub    $0x8,%esp
 5b6:	ff 75 0c             	pushl  0xc(%ebp)
 5b9:	50                   	push   %eax
 5ba:	e8 fc ff ff ff       	call   5bb <putc+0x18>
			5bb: R_386_PC32	fputc
 5bf:	83 c4 10             	add    $0x10,%esp
}
 5c2:	c9                   	leave  
 5c3:	c3                   	ret    

000005c4 <fputc>:

int fputc(char c, HANDLE hdl) {
 5c4:	55                   	push   %ebp
 5c5:	89 e5                	mov    %esp,%ebp
 5c7:	83 ec 18             	sub    $0x18,%esp
 5ca:	8b 45 08             	mov    0x8(%ebp),%eax
 5cd:	88 45 f4             	mov    %al,-0xc(%ebp)
    hdl = resolveHandle(hdl);
 5d0:	83 ec 0c             	sub    $0xc,%esp
 5d3:	ff 75 0c             	pushl  0xc(%ebp)
 5d6:	e8 d9 fd ff ff       	call   3b4 <resolveHandle>
 5db:	83 c4 10             	add    $0x10,%esp
 5de:	89 45 0c             	mov    %eax,0xc(%ebp)
    if(hdl != 0) {
 5e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 5e5:	74 16                	je     5fd <fputc+0x39>
        return fwrite(hdl, &c, sizeof(char));
 5e7:	83 ec 04             	sub    $0x4,%esp
 5ea:	6a 01                	push   $0x1
 5ec:	8d 45 f4             	lea    -0xc(%ebp),%eax
 5ef:	50                   	push   %eax
 5f0:	ff 75 0c             	pushl  0xc(%ebp)
 5f3:	e8 fc ff ff ff       	call   5f4 <fputc+0x30>
			5f4: R_386_PC32	fwrite
 5f8:	83 c4 10             	add    $0x10,%esp
 5fb:	eb 12                	jmp    60f <fputc+0x4b>
    }
    return kputc(c);
 5fd:	8a 45 f4             	mov    -0xc(%ebp),%al
 600:	0f be c0             	movsbl %al,%eax
 603:	83 ec 0c             	sub    $0xc,%esp
 606:	50                   	push   %eax
 607:	e8 2d ff ff ff       	call   539 <kputc>
 60c:	83 c4 10             	add    $0x10,%esp
}
 60f:	c9                   	leave  
 610:	c3                   	ret    

00000611 <kputs>:

static int kputs(const char* cp) {
 611:	55                   	push   %ebp
 612:	89 e5                	mov    %esp,%ebp
 614:	83 ec 28             	sub    $0x28,%esp
  struct regstate state = {
    .eax = 202,
    .ebx = (uint32_t)cp,
 617:	8b 45 08             	mov    0x8(%ebp),%eax
    .ecx = 0,
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
 61a:	c7 45 e0 ca 00 00 00 	movl   $0xca,-0x20(%ebp)
 621:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 624:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 62b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 632:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 639:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  
  syscall(&state);
 640:	83 ec 0c             	sub    $0xc,%esp
 643:	8d 45 e0             	lea    -0x20(%ebp),%eax
 646:	50                   	push   %eax
 647:	e8 fc ff ff ff       	call   648 <kputs+0x37>
			648: R_386_PC32	syscall
 64c:	83 c4 10             	add    $0x10,%esp
  
  return state.eax;
 64f:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 652:	c9                   	leave  
 653:	c3                   	ret    

00000654 <puts>:

int puts(const char* c) {
 654:	55                   	push   %ebp
 655:	89 e5                	mov    %esp,%ebp
 657:	83 ec 08             	sub    $0x8,%esp
    return fputs(c, PMID_STDOUT);
 65a:	83 ec 08             	sub    $0x8,%esp
 65d:	6a 00                	push   $0x0
 65f:	ff 75 08             	pushl  0x8(%ebp)
 662:	e8 fc ff ff ff       	call   663 <puts+0xf>
			663: R_386_PC32	fputs
 667:	83 c4 10             	add    $0x10,%esp
}
 66a:	c9                   	leave  
 66b:	c3                   	ret    

0000066c <fputs>:

int fputs(const char* c, HANDLE hdl) {
 66c:	55                   	push   %ebp
 66d:	89 e5                	mov    %esp,%ebp
 66f:	83 ec 08             	sub    $0x8,%esp
    hdl = resolveHandle(hdl);
 672:	83 ec 0c             	sub    $0xc,%esp
 675:	ff 75 0c             	pushl  0xc(%ebp)
 678:	e8 37 fd ff ff       	call   3b4 <resolveHandle>
 67d:	83 c4 10             	add    $0x10,%esp
 680:	89 45 0c             	mov    %eax,0xc(%ebp)
    if(hdl != 0) {
 683:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 687:	74 22                	je     6ab <fputs+0x3f>
        return fwrite(hdl, c, strlen(c));
 689:	83 ec 0c             	sub    $0xc,%esp
 68c:	ff 75 08             	pushl  0x8(%ebp)
 68f:	e8 fc ff ff ff       	call   690 <fputs+0x24>
			690: R_386_PC32	strlen
 694:	83 c4 10             	add    $0x10,%esp
 697:	83 ec 04             	sub    $0x4,%esp
 69a:	50                   	push   %eax
 69b:	ff 75 08             	pushl  0x8(%ebp)
 69e:	ff 75 0c             	pushl  0xc(%ebp)
 6a1:	e8 fc ff ff ff       	call   6a2 <fputs+0x36>
			6a2: R_386_PC32	fwrite
 6a6:	83 c4 10             	add    $0x10,%esp
 6a9:	eb 0e                	jmp    6b9 <fputs+0x4d>
    }
    return kputs(c);
 6ab:	83 ec 0c             	sub    $0xc,%esp
 6ae:	ff 75 08             	pushl  0x8(%ebp)
 6b1:	e8 5b ff ff ff       	call   611 <kputs>
 6b6:	83 c4 10             	add    $0x10,%esp
}
 6b9:	c9                   	leave  
 6ba:	c3                   	ret    

000006bb <putn>:

static int putn(unsigned long x, int base)
{
 6bb:	55                   	push   %ebp
 6bc:	89 e5                	mov    %esp,%ebp
 6be:	83 ec 58             	sub    $0x58,%esp
  char buf[65];
  const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
 6c1:	c7 45 ec 8c 00 00 00 	movl   $0x8c,-0x14(%ebp)
			6c4: R_386_32	.rodata
  char* p;
  int wrt = 0;
 6c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (base > 36) {
 6cf:	83 7d 0c 24          	cmpl   $0x24,0xc(%ebp)
 6d3:	7e 07                	jle    6dc <putn+0x21>
    return 0;
 6d5:	b8 00 00 00 00       	mov    $0x0,%eax
 6da:	eb 59                	jmp    735 <putn+0x7a>
  }

  p = buf + 64;
 6dc:	8d 45 ab             	lea    -0x55(%ebp),%eax
 6df:	83 c0 40             	add    $0x40,%eax
 6e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  *p = '\0';
 6e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 6e8:	c6 00 00             	movb   $0x0,(%eax)
  do {
    wrt++;
 6eb:	ff 45 f4             	incl   -0xc(%ebp)
    *--p = digits[x % base];
 6ee:	ff 4d f0             	decl   -0x10(%ebp)
 6f1:	8b 55 0c             	mov    0xc(%ebp),%edx
 6f4:	8b 45 08             	mov    0x8(%ebp),%eax
 6f7:	89 d1                	mov    %edx,%ecx
 6f9:	ba 00 00 00 00       	mov    $0x0,%edx
 6fe:	f7 f1                	div    %ecx
 700:	89 d0                	mov    %edx,%eax
 702:	03 45 ec             	add    -0x14(%ebp),%eax
 705:	8a 10                	mov    (%eax),%dl
 707:	8b 45 f0             	mov    -0x10(%ebp),%eax
 70a:	88 10                	mov    %dl,(%eax)
    x /= base;
 70c:	8b 55 0c             	mov    0xc(%ebp),%edx
 70f:	8b 45 08             	mov    0x8(%ebp),%eax
 712:	89 d1                	mov    %edx,%ecx
 714:	ba 00 00 00 00       	mov    $0x0,%edx
 719:	f7 f1                	div    %ecx
 71b:	89 45 08             	mov    %eax,0x8(%ebp)
  } while (x);
 71e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 722:	75 c7                	jne    6eb <putn+0x30>
  puts(p);
 724:	83 ec 0c             	sub    $0xc,%esp
 727:	ff 75 f0             	pushl  -0x10(%ebp)
 72a:	e8 fc ff ff ff       	call   72b <putn+0x70>
			72b: R_386_PC32	puts
 72f:	83 c4 10             	add    $0x10,%esp
  
  return wrt;
 732:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 735:	c9                   	leave  
 736:	c3                   	ret    

00000737 <printf>:

int printf(const char* fmt, ...)
{
 737:	55                   	push   %ebp
 738:	89 e5                	mov    %esp,%ebp
 73a:	83 ec 28             	sub    $0x28,%esp
  va_list ap;
  const char* s;
  unsigned long n;
	char c;
	int wrt = 0;
 73d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  va_start(ap, fmt);
 744:	8d 45 0c             	lea    0xc(%ebp),%eax
 747:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  while (*fmt) {
 74a:	e9 4d 01 00 00       	jmp    89c <printf+0x165>
    if (*fmt == '%') {
 74f:	8b 45 08             	mov    0x8(%ebp),%eax
 752:	8a 00                	mov    (%eax),%al
 754:	3c 25                	cmp    $0x25,%al
 756:	0f 85 26 01 00 00    	jne    882 <printf+0x14b>
      fmt++;
 75c:	ff 45 08             	incl   0x8(%ebp)
      switch (*fmt) {
 75f:	8b 45 08             	mov    0x8(%ebp),%eax
 762:	8a 00                	mov    (%eax),%al
 764:	0f be c0             	movsbl %al,%eax
 767:	83 f8 70             	cmp    $0x70,%eax
 76a:	0f 84 90 00 00 00    	je     800 <printf+0xc9>
 770:	83 f8 70             	cmp    $0x70,%eax
 773:	7f 2e                	jg     7a3 <printf+0x6c>
 775:	83 f8 63             	cmp    $0x63,%eax
 778:	0f 84 a5 00 00 00    	je     823 <printf+0xec>
 77e:	83 f8 63             	cmp    $0x63,%eax
 781:	7f 16                	jg     799 <printf+0x62>
 783:	85 c0                	test   %eax,%eax
 785:	0f 84 20 01 00 00    	je     8ab <printf+0x174>
 78b:	83 f8 25             	cmp    $0x25,%eax
 78e:	0f 84 b2 00 00 00    	je     846 <printf+0x10f>
 794:	e9 c0 00 00 00       	jmp    859 <printf+0x122>
 799:	83 f8 64             	cmp    $0x64,%eax
 79c:	74 3c                	je     7da <printf+0xa3>
 79e:	e9 b6 00 00 00       	jmp    859 <printf+0x122>
 7a3:	83 f8 75             	cmp    $0x75,%eax
 7a6:	74 32                	je     7da <printf+0xa3>
 7a8:	83 f8 78             	cmp    $0x78,%eax
 7ab:	74 53                	je     800 <printf+0xc9>
 7ad:	83 f8 73             	cmp    $0x73,%eax
 7b0:	0f 85 a3 00 00 00    	jne    859 <printf+0x122>
        case 's':
          s = va_arg(ap, char*);
 7b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 7b9:	8d 50 04             	lea    0x4(%eax),%edx
 7bc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 7bf:	8b 00                	mov    (%eax),%eax
 7c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
          wrt += puts(s);
 7c4:	83 ec 0c             	sub    $0xc,%esp
 7c7:	ff 75 e8             	pushl  -0x18(%ebp)
 7ca:	e8 fc ff ff ff       	call   7cb <printf+0x94>
			7cb: R_386_PC32	puts
 7cf:	83 c4 10             	add    $0x10,%esp
 7d2:	01 45 f4             	add    %eax,-0xc(%ebp)
          break;
 7d5:	e9 bf 00 00 00       	jmp    899 <printf+0x162>
        case 'd':
        case 'u':
          n = va_arg(ap, unsigned long int);
 7da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 7dd:	8d 50 04             	lea    0x4(%eax),%edx
 7e0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 7e3:	8b 00                	mov    (%eax),%eax
 7e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
          wrt += putn(n, 10);
 7e8:	83 ec 08             	sub    $0x8,%esp
 7eb:	6a 0a                	push   $0xa
 7ed:	ff 75 ec             	pushl  -0x14(%ebp)
 7f0:	e8 c6 fe ff ff       	call   6bb <putn>
 7f5:	83 c4 10             	add    $0x10,%esp
 7f8:	01 45 f4             	add    %eax,-0xc(%ebp)
          break;
 7fb:	e9 99 00 00 00       	jmp    899 <printf+0x162>
        case 'x':
        case 'p':
          n = va_arg(ap, unsigned long int);
 800:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 803:	8d 50 04             	lea    0x4(%eax),%edx
 806:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 809:	8b 00                	mov    (%eax),%eax
 80b:	89 45 ec             	mov    %eax,-0x14(%ebp)
          wrt += putn(n, 16);
 80e:	83 ec 08             	sub    $0x8,%esp
 811:	6a 10                	push   $0x10
 813:	ff 75 ec             	pushl  -0x14(%ebp)
 816:	e8 a0 fe ff ff       	call   6bb <putn>
 81b:	83 c4 10             	add    $0x10,%esp
 81e:	01 45 f4             	add    %eax,-0xc(%ebp)
          break;
 821:	eb 76                	jmp    899 <printf+0x162>
        case 'c':
          c = va_arg(ap, int);
 823:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 826:	8d 50 04             	lea    0x4(%eax),%edx
 829:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 82c:	8b 00                	mov    (%eax),%eax
 82e:	88 45 f3             	mov    %al,-0xd(%ebp)
          wrt += putchar(c);
 831:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
 835:	83 ec 0c             	sub    $0xc,%esp
 838:	50                   	push   %eax
 839:	e8 fc ff ff ff       	call   83a <printf+0x103>
			83a: R_386_PC32	putchar
 83e:	83 c4 10             	add    $0x10,%esp
 841:	01 45 f4             	add    %eax,-0xc(%ebp)
          break;
 844:	eb 53                	jmp    899 <printf+0x162>
        case '%':
          wrt += putchar('%');
 846:	83 ec 0c             	sub    $0xc,%esp
 849:	6a 25                	push   $0x25
 84b:	e8 fc ff ff ff       	call   84c <printf+0x115>
			84c: R_386_PC32	putchar
 850:	83 c4 10             	add    $0x10,%esp
 853:	01 45 f4             	add    %eax,-0xc(%ebp)
          break;
 856:	90                   	nop    
 857:	eb 40                	jmp    899 <printf+0x162>
        case '\0':
          goto out;
        default:
          wrt += putchar('%');
 859:	83 ec 0c             	sub    $0xc,%esp
 85c:	6a 25                	push   $0x25
 85e:	e8 fc ff ff ff       	call   85f <printf+0x128>
			85f: R_386_PC32	putchar
 863:	83 c4 10             	add    $0x10,%esp
 866:	01 45 f4             	add    %eax,-0xc(%ebp)
          wrt += putchar(*fmt);
 869:	8b 45 08             	mov    0x8(%ebp),%eax
 86c:	8a 00                	mov    (%eax),%al
 86e:	0f be c0             	movsbl %al,%eax
 871:	83 ec 0c             	sub    $0xc,%esp
 874:	50                   	push   %eax
 875:	e8 fc ff ff ff       	call   876 <printf+0x13f>
			876: R_386_PC32	putchar
 87a:	83 c4 10             	add    $0x10,%esp
 87d:	01 45 f4             	add    %eax,-0xc(%ebp)
 880:	eb 17                	jmp    899 <printf+0x162>
          break;
      }
    } else {
      wrt += putchar(*fmt);
 882:	8b 45 08             	mov    0x8(%ebp),%eax
 885:	8a 00                	mov    (%eax),%al
 887:	0f be c0             	movsbl %al,%eax
 88a:	83 ec 0c             	sub    $0xc,%esp
 88d:	50                   	push   %eax
 88e:	e8 fc ff ff ff       	call   88f <printf+0x158>
			88f: R_386_PC32	putchar
 893:	83 c4 10             	add    $0x10,%esp
 896:	01 45 f4             	add    %eax,-0xc(%ebp)
    }

    fmt++;
 899:	ff 45 08             	incl   0x8(%ebp)
  unsigned long n;
	char c;
	int wrt = 0;

  va_start(ap, fmt);
  while (*fmt) {
 89c:	8b 45 08             	mov    0x8(%ebp),%eax
 89f:	8a 00                	mov    (%eax),%al
 8a1:	84 c0                	test   %al,%al
 8a3:	0f 85 a6 fe ff ff    	jne    74f <printf+0x18>
 8a9:	eb 01                	jmp    8ac <printf+0x175>
          break;
        case '%':
          wrt += putchar('%');
          break;
        case '\0':
          goto out;
 8ab:	90                   	nop    
  }

out:
  va_end(ap);

  return wrt;
 8ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8af:	c9                   	leave  
 8b0:	c3                   	ret    

string.o:     file format elf32-i386
rw-rw-rw- 0/0   7820 Aug 10 18:30 2014 string.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000355  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000038c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00000000  00000000  0000038c  2**2
                  ALLOC
  3 .stab         00000b7c  00000000  00000000  0000038c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000009bc  00000000  00000000  00000f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000012  00000000  00000000  000018c4  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 string.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000 g     F .text	0000002e memset
0000002e g     F .text	00000045 memcpy
00000073 g     F .text	0000009b memcmp
0000010e g     F .text	0000004f strcmp
0000015d g     F .text	00000030 strlen
0000018d g     F .text	00000023 strcpy
000001b0 g     F .text	00000037 strclone
00000000         *UND*	00000000 malloc
00000000 g     O .bss	00000004 sp
00000004 g     O .bss	00000004 fr
000001e7 g     F .text	00000061 strtok
00000000         *UND*	00000000 free
00000248 g     F .text	0000010d strtoknc



Disassembly of section .text:

00000000 <memset>:
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
    unsigned char* p = buf;
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (n--) {
   c:	eb 0d                	jmp    1b <memset+0x1b>
        *p++ = c;
   e:	8b 45 0c             	mov    0xc(%ebp),%eax
  11:	88 c2                	mov    %al,%dl
  13:	8b 45 fc             	mov    -0x4(%ebp),%eax
  16:	88 10                	mov    %dl,(%eax)
  18:	ff 45 fc             	incl   -0x4(%ebp)
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
    unsigned char* p = buf;

    while (n--) {
  1b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1f:	0f 95 c0             	setne  %al
  22:	ff 4d 10             	decl   0x10(%ebp)
  25:	84 c0                	test   %al,%al
  27:	75 e5                	jne    e <memset+0xe>
        *p++ = c;
    }

    return buf;
  29:	8b 45 08             	mov    0x8(%ebp),%eax
}
  2c:	c9                   	leave  
  2d:	c3                   	ret    

0000002e <memcpy>:

void* memcpy(void* dest, const void* src, size_t n) {
  2e:	55                   	push   %ebp
  2f:	89 e5                	mov    %esp,%ebp
  31:	83 ec 10             	sub    $0x10,%esp
    unsigned char* d = dest;
  34:	8b 45 08             	mov    0x8(%ebp),%eax
  37:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const unsigned char* s = src;
  3a:	8b 45 0c             	mov    0xc(%ebp),%eax
  3d:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(n == 0) return 0;
  40:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  44:	75 19                	jne    5f <memcpy+0x31>
  46:	b8 00 00 00 00       	mov    $0x0,%eax
  4b:	eb 24                	jmp    71 <memcpy+0x43>

    while (n--) {
        *(d++) = *(s++);
  4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  50:	8a 10                	mov    (%eax),%dl
  52:	8b 45 f8             	mov    -0x8(%ebp),%eax
  55:	88 10                	mov    %dl,(%eax)
  57:	ff 45 f8             	incl   -0x8(%ebp)
  5a:	ff 45 fc             	incl   -0x4(%ebp)
  5d:	eb 01                	jmp    60 <memcpy+0x32>
    unsigned char* d = dest;
    const unsigned char* s = src;

    if(n == 0) return 0;

    while (n--) {
  5f:	90                   	nop    
  60:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  64:	0f 95 c0             	setne  %al
  67:	ff 4d 10             	decl   0x10(%ebp)
  6a:	84 c0                	test   %al,%al
  6c:	75 df                	jne    4d <memcpy+0x1f>
        *(d++) = *(s++);
    }

    return dest;
  6e:	8b 45 08             	mov    0x8(%ebp),%eax
}
  71:	c9                   	leave  
  72:	c3                   	ret    

00000073 <memcmp>:

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  73:	55                   	push   %ebp
  74:	89 e5                	mov    %esp,%ebp
  76:	83 ec 10             	sub    $0x10,%esp
    if (ptr1 == 0)
  79:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  7d:	75 0a                	jne    89 <memcmp+0x16>
        return -1;
  7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  84:	e9 83 00 00 00       	jmp    10c <memcmp+0x99>
    if (ptr2 == 0)
  89:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8d:	75 07                	jne    96 <memcmp+0x23>
        return 1;
  8f:	b8 01 00 00 00       	mov    $0x1,%eax
  94:	eb 76                	jmp    10c <memcmp+0x99>
    if (num == 0)
  96:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  9a:	75 07                	jne    a3 <memcmp+0x30>
        return 0;
  9c:	b8 00 00 00 00       	mov    $0x0,%eax
  a1:	eb 69                	jmp    10c <memcmp+0x99>

    const uint8_t* pa = ptr1;
  a3:	8b 45 08             	mov    0x8(%ebp),%eax
  a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    const uint8_t* pb = ptr2;
  a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  ac:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for (uint32_t i = 0; i < num; i++) {
  af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  b6:	eb 47                	jmp    ff <memcmp+0x8c>
        if (pa[i] != pb[i]) {
  b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  be:	8d 04 02             	lea    (%edx,%eax,1),%eax
  c1:	8a 10                	mov    (%eax),%dl
  c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  c6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  c9:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  cc:	8a 00                	mov    (%eax),%al
  ce:	38 c2                	cmp    %al,%dl
  d0:	74 2a                	je     fc <memcmp+0x89>
            return pa[i] - pb[i];
  d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  d8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  db:	8a 00                	mov    (%eax),%al
  dd:	ba 00 00 00 00       	mov    $0x0,%edx
  e2:	88 c2                	mov    %al,%dl
  e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  e7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  ea:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  ed:	8a 00                	mov    (%eax),%al
  ef:	25 ff 00 00 00       	and    $0xff,%eax
  f4:	89 d1                	mov    %edx,%ecx
  f6:	29 c1                	sub    %eax,%ecx
  f8:	89 c8                	mov    %ecx,%eax
  fa:	eb 10                	jmp    10c <memcmp+0x99>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
  fc:	ff 45 fc             	incl   -0x4(%ebp)
  ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
 102:	3b 45 10             	cmp    0x10(%ebp),%eax
 105:	72 b1                	jb     b8 <memcmp+0x45>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
 107:	b8 00 00 00 00       	mov    $0x0,%eax
}
 10c:	c9                   	leave  
 10d:	c3                   	ret    

0000010e <strcmp>:

int strcmp(const char* str1, const char* str2) {
 10e:	55                   	push   %ebp
 10f:	89 e5                	mov    %esp,%ebp
 111:	83 ec 18             	sub    $0x18,%esp
    int l1 = strlen(str1);
 114:	83 ec 0c             	sub    $0xc,%esp
 117:	ff 75 08             	pushl  0x8(%ebp)
 11a:	e8 fc ff ff ff       	call   11b <strcmp+0xd>
			11b: R_386_PC32	strlen
 11f:	83 c4 10             	add    $0x10,%esp
 122:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
 125:	83 ec 0c             	sub    $0xc,%esp
 128:	ff 75 0c             	pushl  0xc(%ebp)
 12b:	e8 fc ff ff ff       	call   12c <strcmp+0x1e>
			12c: R_386_PC32	strlen
 130:	83 c4 10             	add    $0x10,%esp
 133:	89 45 f4             	mov    %eax,-0xc(%ebp)
    l1 = l1 < l2 ? l1 : l2;
 136:	8b 55 f0             	mov    -0x10(%ebp),%edx
 139:	8b 45 f4             	mov    -0xc(%ebp),%eax
 13c:	39 d0                	cmp    %edx,%eax
 13e:	7e 02                	jle    142 <strcmp+0x34>
 140:	89 d0                	mov    %edx,%eax
 142:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
 145:	8b 45 f0             	mov    -0x10(%ebp),%eax
 148:	40                   	inc    %eax
 149:	83 ec 04             	sub    $0x4,%esp
 14c:	50                   	push   %eax
 14d:	ff 75 0c             	pushl  0xc(%ebp)
 150:	ff 75 08             	pushl  0x8(%ebp)
 153:	e8 fc ff ff ff       	call   154 <strcmp+0x46>
			154: R_386_PC32	memcmp
 158:	83 c4 10             	add    $0x10,%esp
}
 15b:	c9                   	leave  
 15c:	c3                   	ret    

0000015d <strlen>:

unsigned int strlen(const char* str) {
 15d:	55                   	push   %ebp
 15e:	89 e5                	mov    %esp,%ebp
 160:	83 ec 10             	sub    $0x10,%esp
    if (str == 0)
 163:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 167:	75 07                	jne    170 <strlen+0x13>
        return 0;
 169:	b8 00 00 00 00       	mov    $0x0,%eax
 16e:	eb 1b                	jmp    18b <strlen+0x2e>
    int i;
    for (i = 0; str[i] != '\0'; i++)
 170:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 177:	eb 03                	jmp    17c <strlen+0x1f>
 179:	ff 45 fc             	incl   -0x4(%ebp)
 17c:	8b 45 fc             	mov    -0x4(%ebp),%eax
 17f:	03 45 08             	add    0x8(%ebp),%eax
 182:	8a 00                	mov    (%eax),%al
 184:	84 c0                	test   %al,%al
 186:	75 f1                	jne    179 <strlen+0x1c>
        ;
    return i;
 188:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 18b:	c9                   	leave  
 18c:	c3                   	ret    

0000018d <strcpy>:

char* strcpy(char* dest, const char* src) {
 18d:	55                   	push   %ebp
 18e:	89 e5                	mov    %esp,%ebp
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
 190:	ff 75 0c             	pushl  0xc(%ebp)
 193:	e8 fc ff ff ff       	call   194 <strcpy+0x7>
			194: R_386_PC32	strlen
 198:	83 c4 04             	add    $0x4,%esp
 19b:	40                   	inc    %eax
 19c:	50                   	push   %eax
 19d:	ff 75 0c             	pushl  0xc(%ebp)
 1a0:	ff 75 08             	pushl  0x8(%ebp)
 1a3:	e8 fc ff ff ff       	call   1a4 <strcpy+0x17>
			1a4: R_386_PC32	memcpy
 1a8:	83 c4 0c             	add    $0xc,%esp
    return dest;
 1ab:	8b 45 08             	mov    0x8(%ebp),%eax
}
 1ae:	c9                   	leave  
 1af:	c3                   	ret    

000001b0 <strclone>:

char* strclone(char* str) {
 1b0:	55                   	push   %ebp
 1b1:	89 e5                	mov    %esp,%ebp
 1b3:	83 ec 18             	sub    $0x18,%esp
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
 1b6:	ff 75 08             	pushl  0x8(%ebp)
 1b9:	e8 fc ff ff ff       	call   1ba <strclone+0xa>
			1ba: R_386_PC32	strlen
 1be:	83 c4 04             	add    $0x4,%esp
 1c1:	40                   	inc    %eax
 1c2:	83 ec 0c             	sub    $0xc,%esp
 1c5:	50                   	push   %eax
 1c6:	e8 fc ff ff ff       	call   1c7 <strclone+0x17>
			1c7: R_386_PC32	malloc
 1cb:	83 c4 10             	add    $0x10,%esp
 1ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    strcpy(ret, str);
 1d1:	83 ec 08             	sub    $0x8,%esp
 1d4:	ff 75 08             	pushl  0x8(%ebp)
 1d7:	ff 75 f4             	pushl  -0xc(%ebp)
 1da:	e8 fc ff ff ff       	call   1db <strclone+0x2b>
			1db: R_386_PC32	strcpy
 1df:	83 c4 10             	add    $0x10,%esp

    return ret;
 1e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 1e5:	c9                   	leave  
 1e6:	c3                   	ret    

000001e7 <strtok>:

char* sp = NULL; /* the start position of the string */
void* fr = NULL;

char* strtok(char* str, const char* delimiters) {
 1e7:	55                   	push   %ebp
 1e8:	89 e5                	mov    %esp,%ebp
 1ea:	83 ec 08             	sub    $0x8,%esp
    if(str != 0) { //TODO better but if you call strtok and after that strtoknc will still be a memory leak. -> Don't use strtoknc
 1ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 1f1:	74 43                	je     236 <strtok+0x4f>
        if(fr != 0) {
 1f3:	a1 00 00 00 00       	mov    0x0,%eax
			1f4: R_386_32	fr
 1f8:	85 c0                	test   %eax,%eax
 1fa:	74 11                	je     20d <strtok+0x26>
            free(fr);
 1fc:	a1 00 00 00 00       	mov    0x0,%eax
			1fd: R_386_32	fr
 201:	83 ec 0c             	sub    $0xc,%esp
 204:	50                   	push   %eax
 205:	e8 fc ff ff ff       	call   206 <strtok+0x1f>
			206: R_386_PC32	free
 20a:	83 c4 10             	add    $0x10,%esp
        }
        fr = strclone(str);
 20d:	83 ec 0c             	sub    $0xc,%esp
 210:	ff 75 08             	pushl  0x8(%ebp)
 213:	e8 fc ff ff ff       	call   214 <strtok+0x2d>
			214: R_386_PC32	strclone
 218:	83 c4 10             	add    $0x10,%esp
 21b:	a3 00 00 00 00       	mov    %eax,0x0
			21c: R_386_32	fr
        return strtoknc(fr, delimiters);
 220:	a1 00 00 00 00       	mov    0x0,%eax
			221: R_386_32	fr
 225:	83 ec 08             	sub    $0x8,%esp
 228:	ff 75 0c             	pushl  0xc(%ebp)
 22b:	50                   	push   %eax
 22c:	e8 fc ff ff ff       	call   22d <strtok+0x46>
			22d: R_386_PC32	strtoknc
 231:	83 c4 10             	add    $0x10,%esp
 234:	eb 10                	jmp    246 <strtok+0x5f>
    }
    return strtoknc(0, delimiters);
 236:	83 ec 08             	sub    $0x8,%esp
 239:	ff 75 0c             	pushl  0xc(%ebp)
 23c:	6a 00                	push   $0x0
 23e:	e8 fc ff ff ff       	call   23f <strtok+0x58>
			23f: R_386_PC32	strtoknc
 243:	83 c4 10             	add    $0x10,%esp
}
 246:	c9                   	leave  
 247:	c3                   	ret    

00000248 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
 248:	55                   	push   %ebp
 249:	89 e5                	mov    %esp,%ebp
 24b:	83 ec 10             	sub    $0x10,%esp
    int i = 0;
 24e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int len = strlen(delimiters);
 255:	ff 75 0c             	pushl  0xc(%ebp)
 258:	e8 fc ff ff ff       	call   259 <strtoknc+0x11>
			259: R_386_PC32	strlen
 25d:	83 c4 04             	add    $0x4,%esp
 260:	89 45 f8             	mov    %eax,-0x8(%ebp)

    /* check in the delimiters */
    if (len == 0)
 263:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 267:	75 0a                	jne    273 <strtoknc+0x2b>
        return 0;
 269:	b8 00 00 00 00       	mov    $0x0,%eax
 26e:	e9 e0 00 00 00       	jmp    353 <strtoknc+0x10b>

    /* if the original string has nothing left */
    if (!str && !sp)
 273:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 277:	75 13                	jne    28c <strtoknc+0x44>
 279:	a1 00 00 00 00       	mov    0x0,%eax
			27a: R_386_32	sp
 27e:	85 c0                	test   %eax,%eax
 280:	75 0a                	jne    28c <strtoknc+0x44>
        return 0;
 282:	b8 00 00 00 00       	mov    $0x0,%eax
 287:	e9 c7 00 00 00       	jmp    353 <strtoknc+0x10b>

    /* initialize the sp during the first call */
    if (str) {
 28c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 290:	74 08                	je     29a <strtoknc+0x52>
        sp = str;
 292:	8b 45 08             	mov    0x8(%ebp),%eax
 295:	a3 00 00 00 00       	mov    %eax,0x0
			296: R_386_32	sp
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
 29a:	a1 00 00 00 00       	mov    0x0,%eax
			29b: R_386_32	sp
 29f:	89 45 fc             	mov    %eax,-0x4(%ebp)
 2a2:	eb 01                	jmp    2a5 <strtoknc+0x5d>

        if (i == len) {
            sp = p_start;
            break;
        }
    }
 2a4:	90                   	nop    
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
 2a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 2ac:	eb 19                	jmp    2c7 <strtoknc+0x7f>
            if (*p_start == delimiters[i]) {
 2ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2b1:	8a 10                	mov    (%eax),%dl
 2b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2b6:	03 45 0c             	add    0xc(%ebp),%eax
 2b9:	8a 00                	mov    (%eax),%al
 2bb:	38 c2                	cmp    %al,%dl
 2bd:	75 05                	jne    2c4 <strtoknc+0x7c>
                p_start++;
 2bf:	ff 45 fc             	incl   -0x4(%ebp)
                break;
 2c2:	eb 0b                	jmp    2cf <strtoknc+0x87>
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
 2c4:	ff 45 f4             	incl   -0xc(%ebp)
 2c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2ca:	3b 45 f8             	cmp    -0x8(%ebp),%eax
 2cd:	7c df                	jl     2ae <strtoknc+0x66>
                p_start++;
                break;
            }
        }

        if (i == len) {
 2cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2d2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
 2d5:	75 cd                	jne    2a4 <strtoknc+0x5c>
            sp = p_start;
 2d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2da:	a3 00 00 00 00       	mov    %eax,0x0
			2db: R_386_32	sp
            break;
        }
    }

    /* return NULL if nothing left */
    if (*sp == '\0') {
 2df:	a1 00 00 00 00       	mov    0x0,%eax
			2e0: R_386_32	sp
 2e4:	8a 00                	mov    (%eax),%al
 2e6:	84 c0                	test   %al,%al
 2e8:	75 57                	jne    341 <strtoknc+0xf9>
        sp = NULL;
 2ea:	c7 05 00 00 00 00 00 	movl   $0x0,0x0
 2f1:	00 00 00 
			2ec: R_386_32	sp
        return sp;
 2f4:	a1 00 00 00 00       	mov    0x0,%eax
			2f5: R_386_32	sp
 2f9:	eb 58                	jmp    353 <strtoknc+0x10b>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
 2fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 302:	eb 20                	jmp    324 <strtoknc+0xdc>
            if (*sp == delimiters[i]) {
 304:	a1 00 00 00 00       	mov    0x0,%eax
			305: R_386_32	sp
 309:	8a 10                	mov    (%eax),%dl
 30b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 30e:	03 45 0c             	add    0xc(%ebp),%eax
 311:	8a 00                	mov    (%eax),%al
 313:	38 c2                	cmp    %al,%dl
 315:	75 0a                	jne    321 <strtoknc+0xd9>
                *sp = '\0';
 317:	a1 00 00 00 00       	mov    0x0,%eax
			318: R_386_32	sp
 31c:	c6 00 00             	movb   $0x0,(%eax)
                break;
 31f:	eb 0b                	jmp    32c <strtoknc+0xe4>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
 321:	ff 45 f4             	incl   -0xc(%ebp)
 324:	8b 45 f4             	mov    -0xc(%ebp),%eax
 327:	3b 45 f8             	cmp    -0x8(%ebp),%eax
 32a:	7c d8                	jl     304 <strtoknc+0xbc>
                *sp = '\0';
                break;
            }
        }

        sp++;
 32c:	a1 00 00 00 00       	mov    0x0,%eax
			32d: R_386_32	sp
 331:	40                   	inc    %eax
 332:	a3 00 00 00 00       	mov    %eax,0x0
			333: R_386_32	sp
        if (i < len)
 337:	8b 45 f4             	mov    -0xc(%ebp),%eax
 33a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
 33d:	7c 10                	jl     34f <strtoknc+0x107>
 33f:	eb 01                	jmp    342 <strtoknc+0xfa>
        sp = NULL;
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
 341:	90                   	nop    
 342:	a1 00 00 00 00       	mov    0x0,%eax
			343: R_386_32	sp
 347:	8a 00                	mov    (%eax),%al
 349:	84 c0                	test   %al,%al
 34b:	75 ae                	jne    2fb <strtoknc+0xb3>
 34d:	eb 01                	jmp    350 <strtoknc+0x108>
            }
        }

        sp++;
        if (i < len)
            break;
 34f:	90                   	nop    
    }

    return p_start;
 350:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 353:	c9                   	leave  
 354:	c3                   	ret    

stdlib.o:     file format elf32-i386
rw-rw-rw- 0/0   9060 Aug 10 18:30 2014 stdlib.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000490  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000004c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000c  00000000  00000000  000004c4  2**2
                  ALLOC
  3 .stab         00000e40  00000000  00000000  000004c4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000a04  00000000  00000000  00001304  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000012  00000000  00000000  00001d08  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 stdlib.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l     F .text	00000057 remove_from_list
00000057 l     F .text	00000018 append_to_list
0000006f l     F .text	00000031 pop_from_list
000000a0 l     F .text	00000062 allocate_unused_nodes
00000102 l     F .text	0000003b pop_unused_node
0000013d l     F .text	000000c8 merge_into_frees
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000 g     O .bss	00000004 first_unused
00000004 g     O .bss	00000004 first_used
00000008 g     O .bss	00000004 first_free
00000000         *UND*	00000000 vmm_alloc_cont
00000000         *UND*	00000000 memset
00000205 g     F .text	00000166 malloc
0000036b g     F .text	0000003f calloc
000003aa g     F .text	0000009e realloc
00000448 g     F .text	00000048 free
00000000         *UND*	00000000 memcpy



Disassembly of section .text:

00000000 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
    struct memory_node* last = 0;
   6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = *root;
   d:	8b 45 08             	mov    0x8(%ebp),%eax
  10:	8b 00                	mov    (%eax),%eax
  12:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (cur != 0) {
  15:	eb 38                	jmp    4f <remove_from_list+0x4f>
        if (cur == element) {
  17:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1a:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1d:	75 21                	jne    40 <remove_from_list+0x40>
            if (last == 0) {
  1f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  23:	75 0d                	jne    32 <remove_from_list+0x32>
                *root = cur->next;
  25:	8b 45 fc             	mov    -0x4(%ebp),%eax
  28:	8b 50 08             	mov    0x8(%eax),%edx
  2b:	8b 45 08             	mov    0x8(%ebp),%eax
  2e:	89 10                	mov    %edx,(%eax)
                return;
  30:	eb 23                	jmp    55 <remove_from_list+0x55>
            } else {
                last->next = cur->next;
  32:	8b 45 fc             	mov    -0x4(%ebp),%eax
  35:	8b 50 08             	mov    0x8(%eax),%edx
  38:	8b 45 f8             	mov    -0x8(%ebp),%eax
  3b:	89 50 08             	mov    %edx,0x8(%eax)
                return;
  3e:	eb 15                	jmp    55 <remove_from_list+0x55>
            }
        }
        last = cur;
  40:	8b 45 fc             	mov    -0x4(%ebp),%eax
  43:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
  46:	8b 45 fc             	mov    -0x4(%ebp),%eax
  49:	8b 40 08             	mov    0x8(%eax),%eax
  4c:	89 45 fc             	mov    %eax,-0x4(%ebp)
static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
    struct memory_node* last = 0;
    struct memory_node* cur = *root;

    while (cur != 0) {
  4f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  53:	75 c2                	jne    17 <remove_from_list+0x17>
            }
        }
        last = cur;
        cur = cur->next;
    }
}
  55:	c9                   	leave  
  56:	c3                   	ret    

00000057 <append_to_list>:

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
  57:	55                   	push   %ebp
  58:	89 e5                	mov    %esp,%ebp
    element->next = *root;
  5a:	8b 45 08             	mov    0x8(%ebp),%eax
  5d:	8b 10                	mov    (%eax),%edx
  5f:	8b 45 0c             	mov    0xc(%ebp),%eax
  62:	89 50 08             	mov    %edx,0x8(%eax)
    *root = element;
  65:	8b 45 08             	mov    0x8(%ebp),%eax
  68:	8b 55 0c             	mov    0xc(%ebp),%edx
  6b:	89 10                	mov    %edx,(%eax)
}
  6d:	5d                   	pop    %ebp
  6e:	c3                   	ret    

0000006f <pop_from_list>:

static struct memory_node* pop_from_list(struct memory_node** root) {
  6f:	55                   	push   %ebp
  70:	89 e5                	mov    %esp,%ebp
  72:	83 ec 10             	sub    $0x10,%esp
    if (*root == 0)
  75:	8b 45 08             	mov    0x8(%ebp),%eax
  78:	8b 00                	mov    (%eax),%eax
  7a:	85 c0                	test   %eax,%eax
  7c:	75 07                	jne    85 <pop_from_list+0x16>
        return 0;
  7e:	b8 00 00 00 00       	mov    $0x0,%eax
  83:	eb 19                	jmp    9e <pop_from_list+0x2f>
    struct memory_node* pop = *root;
  85:	8b 45 08             	mov    0x8(%ebp),%eax
  88:	8b 00                	mov    (%eax),%eax
  8a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    remove_from_list(root, pop);
  8d:	ff 75 fc             	pushl  -0x4(%ebp)
  90:	ff 75 08             	pushl  0x8(%ebp)
  93:	e8 68 ff ff ff       	call   0 <remove_from_list>
  98:	83 c4 08             	add    $0x8,%esp
    return pop;
  9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  9e:	c9                   	leave  
  9f:	c3                   	ret    

000000a0 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
  a0:	55                   	push   %ebp
  a1:	89 e5                	mov    %esp,%ebp
  a3:	83 ec 18             	sub    $0x18,%esp
    struct memory_node* new_nodes = vmm_alloc_cont(1);
  a6:	83 ec 0c             	sub    $0xc,%esp
  a9:	6a 01                	push   $0x1
  ab:	e8 fc ff ff ff       	call   ac <allocate_unused_nodes+0xc>
			ac: R_386_PC32	vmm_alloc_cont
  b0:	83 c4 10             	add    $0x10,%esp
  b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(new_nodes, 0, PAGESIZE);
  b6:	83 ec 04             	sub    $0x4,%esp
  b9:	68 00 10 00 00       	push   $0x1000
  be:	6a 00                	push   $0x0
  c0:	ff 75 f0             	pushl  -0x10(%ebp)
  c3:	e8 fc ff ff ff       	call   c4 <allocate_unused_nodes+0x24>
			c4: R_386_PC32	memset
  c8:	83 c4 10             	add    $0x10,%esp

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  cb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  d2:	eb 23                	jmp    f7 <allocate_unused_nodes+0x57>
        append_to_list(&first_unused, &(new_nodes[i]));
  d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  d7:	89 d0                	mov    %edx,%eax
  d9:	01 c0                	add    %eax,%eax
  db:	01 d0                	add    %edx,%eax
  dd:	c1 e0 02             	shl    $0x2,%eax
  e0:	03 45 f0             	add    -0x10(%ebp),%eax
  e3:	83 ec 08             	sub    $0x8,%esp
  e6:	50                   	push   %eax
  e7:	68 00 00 00 00       	push   $0x0
			e8: R_386_32	first_unused
  ec:	e8 66 ff ff ff       	call   57 <append_to_list>
  f1:	83 c4 10             	add    $0x10,%esp

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  f4:	ff 45 f4             	incl   -0xc(%ebp)
  f7:	81 7d f4 54 01 00 00 	cmpl   $0x154,-0xc(%ebp)
  fe:	76 d4                	jbe    d4 <allocate_unused_nodes+0x34>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
 100:	c9                   	leave  
 101:	c3                   	ret    

00000102 <pop_unused_node>:

static struct memory_node* pop_unused_node() {
 102:	55                   	push   %ebp
 103:	89 e5                	mov    %esp,%ebp
 105:	83 ec 18             	sub    $0x18,%esp
    struct memory_node* ret = pop_from_list(&first_unused);
 108:	68 00 00 00 00       	push   $0x0
			109: R_386_32	first_unused
 10d:	e8 5d ff ff ff       	call   6f <pop_from_list>
 112:	83 c4 04             	add    $0x4,%esp
 115:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (ret == 0) {
 118:	eb 18                	jmp    132 <pop_unused_node+0x30>
        allocate_unused_nodes();
 11a:	e8 81 ff ff ff       	call   a0 <allocate_unused_nodes>
        ret = pop_from_list(&first_unused);
 11f:	83 ec 0c             	sub    $0xc,%esp
 122:	68 00 00 00 00       	push   $0x0
			123: R_386_32	first_unused
 127:	e8 43 ff ff ff       	call   6f <pop_from_list>
 12c:	83 c4 10             	add    $0x10,%esp
 12f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static struct memory_node* pop_unused_node() {
    struct memory_node* ret = pop_from_list(&first_unused);

    while (ret == 0) {
 132:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 136:	74 e2                	je     11a <pop_unused_node+0x18>
        allocate_unused_nodes();
        ret = pop_from_list(&first_unused);
    }

    return ret;
 138:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 13b:	c9                   	leave  
 13c:	c3                   	ret    

0000013d <merge_into_frees>:

static void merge_into_frees(struct memory_node* tf) {
 13d:	55                   	push   %ebp
 13e:	89 e5                	mov    %esp,%ebp
 140:	83 ec 10             	sub    $0x10,%esp
    remove_from_list(&first_used, tf);
 143:	ff 75 08             	pushl  0x8(%ebp)
 146:	68 00 00 00 00       	push   $0x0
			147: R_386_32	first_used
 14b:	e8 b0 fe ff ff       	call   0 <remove_from_list>
 150:	83 c4 08             	add    $0x8,%esp

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
 153:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    cur = first_free;
 15a:	a1 00 00 00 00       	mov    0x0,%eax
			15b: R_386_32	first_free
 15f:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (cur != 0) {
 162:	e9 82 00 00 00       	jmp    1e9 <merge_into_frees+0xac>
        if (cur->address + cur->size == tf->address) {
 167:	8b 45 fc             	mov    -0x4(%ebp),%eax
 16a:	8b 50 04             	mov    0x4(%eax),%edx
 16d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 170:	8b 00                	mov    (%eax),%eax
 172:	01 c2                	add    %eax,%edx
 174:	8b 45 08             	mov    0x8(%ebp),%eax
 177:	8b 40 04             	mov    0x4(%eax),%eax
 17a:	39 c2                	cmp    %eax,%edx
 17c:	75 1e                	jne    19c <merge_into_frees+0x5f>
            tf->address = cur->address;
 17e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 181:	8b 50 04             	mov    0x4(%eax),%edx
 184:	8b 45 08             	mov    0x8(%ebp),%eax
 187:	89 50 04             	mov    %edx,0x4(%eax)
            remove_from_list(&first_free, cur);
 18a:	ff 75 fc             	pushl  -0x4(%ebp)
 18d:	68 00 00 00 00       	push   $0x0
			18e: R_386_32	first_free
 192:	e8 69 fe ff ff       	call   0 <remove_from_list>
 197:	83 c4 08             	add    $0x8,%esp
            goto editedList;
 19a:	eb b7                	jmp    153 <merge_into_frees+0x16>
        }

        if (cur->address == tf->address + tf->size) {
 19c:	8b 45 fc             	mov    -0x4(%ebp),%eax
 19f:	8b 50 04             	mov    0x4(%eax),%edx
 1a2:	8b 45 08             	mov    0x8(%ebp),%eax
 1a5:	8b 48 04             	mov    0x4(%eax),%ecx
 1a8:	8b 45 08             	mov    0x8(%ebp),%eax
 1ab:	8b 00                	mov    (%eax),%eax
 1ad:	8d 04 01             	lea    (%ecx,%eax,1),%eax
 1b0:	39 c2                	cmp    %eax,%edx
 1b2:	75 26                	jne    1da <merge_into_frees+0x9d>
            tf->size += cur->size;
 1b4:	8b 45 08             	mov    0x8(%ebp),%eax
 1b7:	8b 10                	mov    (%eax),%edx
 1b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
 1bc:	8b 00                	mov    (%eax),%eax
 1be:	01 c2                	add    %eax,%edx
 1c0:	8b 45 08             	mov    0x8(%ebp),%eax
 1c3:	89 10                	mov    %edx,(%eax)
            remove_from_list(&first_free, cur);
 1c5:	ff 75 fc             	pushl  -0x4(%ebp)
 1c8:	68 00 00 00 00       	push   $0x0
			1c9: R_386_32	first_free
 1cd:	e8 2e fe ff ff       	call   0 <remove_from_list>
 1d2:	83 c4 08             	add    $0x8,%esp
            goto editedList;
 1d5:	e9 79 ff ff ff       	jmp    153 <merge_into_frees+0x16>
        }

        last = cur;
 1da:	8b 45 fc             	mov    -0x4(%ebp),%eax
 1dd:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
 1e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 1e3:	8b 40 08             	mov    0x8(%eax),%eax
 1e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* cur;

    editedList: last = 0;
    cur = first_free;

    while (cur != 0) {
 1e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
 1ed:	0f 85 74 ff ff ff    	jne    167 <merge_into_frees+0x2a>

        last = cur;
        cur = cur->next;
    }

    append_to_list(&first_free, tf);
 1f3:	ff 75 08             	pushl  0x8(%ebp)
 1f6:	68 00 00 00 00       	push   $0x0
			1f7: R_386_32	first_free
 1fb:	e8 57 fe ff ff       	call   57 <append_to_list>
 200:	83 c4 08             	add    $0x8,%esp
}
 203:	c9                   	leave  
 204:	c3                   	ret    

00000205 <malloc>:

void* malloc(size_t size) {
 205:	55                   	push   %ebp
 206:	89 e5                	mov    %esp,%ebp
 208:	83 ec 28             	sub    $0x28,%esp
    struct memory_node* last = 0;
 20b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    struct memory_node* cur = first_free;
 212:	a1 00 00 00 00       	mov    0x0,%eax
			213: R_386_32	first_free
 217:	89 45 dc             	mov    %eax,-0x24(%ebp)

    while (cur != 0) {
 21a:	eb 19                	jmp    235 <malloc+0x30>
        if (cur->size >= size) {
 21c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 21f:	8b 00                	mov    (%eax),%eax
 221:	3b 45 08             	cmp    0x8(%ebp),%eax
 224:	73 17                	jae    23d <malloc+0x38>
            break;
        }
        last = cur;
 226:	8b 45 dc             	mov    -0x24(%ebp),%eax
 229:	89 45 d8             	mov    %eax,-0x28(%ebp)
        cur = cur->next;
 22c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 22f:	8b 40 08             	mov    0x8(%eax),%eax
 232:	89 45 dc             	mov    %eax,-0x24(%ebp)

void* malloc(size_t size) {
    struct memory_node* last = 0;
    struct memory_node* cur = first_free;

    while (cur != 0) {
 235:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 239:	75 e1                	jne    21c <malloc+0x17>
 23b:	eb 01                	jmp    23e <malloc+0x39>
        if (cur->size >= size) {
            break;
 23d:	90                   	nop    
        }
        last = cur;
        cur = cur->next;
    }

    if (cur == 0) {
 23e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 242:	0f 85 a6 00 00 00    	jne    2ee <malloc+0xe9>
        uint32_t pgs = size / PAGESIZE;
 248:	8b 45 08             	mov    0x8(%ebp),%eax
 24b:	c1 e8 0c             	shr    $0xc,%eax
 24e:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if ((size % PAGESIZE) != 0)
 251:	8b 45 08             	mov    0x8(%ebp),%eax
 254:	25 ff 0f 00 00       	and    $0xfff,%eax
 259:	85 c0                	test   %eax,%eax
 25b:	74 03                	je     260 <malloc+0x5b>
            pgs++;
 25d:	ff 45 e0             	incl   -0x20(%ebp)

        void* addr = vmm_alloc_cont(pgs);
 260:	83 ec 0c             	sub    $0xc,%esp
 263:	ff 75 e0             	pushl  -0x20(%ebp)
 266:	e8 fc ff ff ff       	call   267 <malloc+0x62>
			267: R_386_PC32	vmm_alloc_cont
 26b:	83 c4 10             	add    $0x10,%esp
 26e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        struct memory_node* fill = pop_unused_node();
 271:	e8 8c fe ff ff       	call   102 <pop_unused_node>
 276:	89 45 e8             	mov    %eax,-0x18(%ebp)

        fill->address = (uint32_t) addr;
 279:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 27c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 27f:	89 50 04             	mov    %edx,0x4(%eax)
        fill->size = (uint32_t) size;
 282:	8b 45 e8             	mov    -0x18(%ebp),%eax
 285:	8b 55 08             	mov    0x8(%ebp),%edx
 288:	89 10                	mov    %edx,(%eax)

        if (pgs * PAGESIZE > size) {
 28a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 28d:	c1 e0 0c             	shl    $0xc,%eax
 290:	3b 45 08             	cmp    0x8(%ebp),%eax
 293:	76 3e                	jbe    2d3 <malloc+0xce>
            struct memory_node* free = pop_unused_node();
 295:	e8 68 fe ff ff       	call   102 <pop_unused_node>
 29a:	89 45 ec             	mov    %eax,-0x14(%ebp)

            free->address = fill->address + fill->size;
 29d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 2a0:	8b 50 04             	mov    0x4(%eax),%edx
 2a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 2a6:	8b 00                	mov    (%eax),%eax
 2a8:	01 c2                	add    %eax,%edx
 2aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
 2ad:	89 50 04             	mov    %edx,0x4(%eax)
            free->size = pgs * PAGESIZE - size;
 2b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 2b3:	c1 e0 0c             	shl    $0xc,%eax
 2b6:	89 c2                	mov    %eax,%edx
 2b8:	2b 55 08             	sub    0x8(%ebp),%edx
 2bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
 2be:	89 10                	mov    %edx,(%eax)

            append_to_list(&first_free, free);
 2c0:	83 ec 08             	sub    $0x8,%esp
 2c3:	ff 75 ec             	pushl  -0x14(%ebp)
 2c6:	68 00 00 00 00       	push   $0x0
			2c7: R_386_32	first_free
 2cb:	e8 87 fd ff ff       	call   57 <append_to_list>
 2d0:	83 c4 10             	add    $0x10,%esp
        }

        append_to_list(&first_used, fill);
 2d3:	83 ec 08             	sub    $0x8,%esp
 2d6:	ff 75 e8             	pushl  -0x18(%ebp)
 2d9:	68 00 00 00 00       	push   $0x0
			2da: R_386_32	first_used
 2de:	e8 74 fd ff ff       	call   57 <append_to_list>
 2e3:	83 c4 10             	add    $0x10,%esp

        return (void*) fill->address;
 2e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 2e9:	8b 40 04             	mov    0x4(%eax),%eax
 2ec:	eb 7b                	jmp    369 <malloc+0x164>
    } else {
        uint32_t freesize = cur->size - size;
 2ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
 2f1:	8b 00                	mov    (%eax),%eax
 2f3:	2b 45 08             	sub    0x8(%ebp),%eax
 2f6:	89 45 f0             	mov    %eax,-0x10(%ebp)

        cur->size = size;
 2f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
 2fc:	8b 55 08             	mov    0x8(%ebp),%edx
 2ff:	89 10                	mov    %edx,(%eax)

        remove_from_list(&first_free, cur);
 301:	83 ec 08             	sub    $0x8,%esp
 304:	ff 75 dc             	pushl  -0x24(%ebp)
 307:	68 00 00 00 00       	push   $0x0
			308: R_386_32	first_free
 30c:	e8 ef fc ff ff       	call   0 <remove_from_list>
 311:	83 c4 10             	add    $0x10,%esp
        append_to_list(&first_used, cur);
 314:	83 ec 08             	sub    $0x8,%esp
 317:	ff 75 dc             	pushl  -0x24(%ebp)
 31a:	68 00 00 00 00       	push   $0x0
			31b: R_386_32	first_used
 31f:	e8 33 fd ff ff       	call   57 <append_to_list>
 324:	83 c4 10             	add    $0x10,%esp

        if (freesize > 0) {
 327:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 32b:	74 36                	je     363 <malloc+0x15e>
            struct memory_node* free = pop_unused_node();
 32d:	e8 d0 fd ff ff       	call   102 <pop_unused_node>
 332:	89 45 f4             	mov    %eax,-0xc(%ebp)

            free->address = cur->address + cur->size;
 335:	8b 45 dc             	mov    -0x24(%ebp),%eax
 338:	8b 50 04             	mov    0x4(%eax),%edx
 33b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 33e:	8b 00                	mov    (%eax),%eax
 340:	01 c2                	add    %eax,%edx
 342:	8b 45 f4             	mov    -0xc(%ebp),%eax
 345:	89 50 04             	mov    %edx,0x4(%eax)
            free->size = freesize;
 348:	8b 45 f4             	mov    -0xc(%ebp),%eax
 34b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 34e:	89 10                	mov    %edx,(%eax)

            append_to_list(&first_free, free);
 350:	83 ec 08             	sub    $0x8,%esp
 353:	ff 75 f4             	pushl  -0xc(%ebp)
 356:	68 00 00 00 00       	push   $0x0
			357: R_386_32	first_free
 35b:	e8 f7 fc ff ff       	call   57 <append_to_list>
 360:	83 c4 10             	add    $0x10,%esp
        }

        return (void*) cur->address;
 363:	8b 45 dc             	mov    -0x24(%ebp),%eax
 366:	8b 40 04             	mov    0x4(%eax),%eax
    }
}
 369:	c9                   	leave  
 36a:	c3                   	ret    

0000036b <calloc>:

void* calloc(size_t num, size_t size) {
 36b:	55                   	push   %ebp
 36c:	89 e5                	mov    %esp,%ebp
 36e:	83 ec 18             	sub    $0x18,%esp
    size_t gsize = num * size;
 371:	8b 45 08             	mov    0x8(%ebp),%eax
 374:	0f af 45 0c          	imul   0xc(%ebp),%eax
 378:	89 45 f0             	mov    %eax,-0x10(%ebp)
    void* p = malloc(gsize);
 37b:	83 ec 0c             	sub    $0xc,%esp
 37e:	ff 75 f0             	pushl  -0x10(%ebp)
 381:	e8 fc ff ff ff       	call   382 <calloc+0x17>
			382: R_386_PC32	malloc
 386:	83 c4 10             	add    $0x10,%esp
 389:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (p != 0) {
 38c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 390:	74 13                	je     3a5 <calloc+0x3a>
        memset(p, 0, gsize);
 392:	83 ec 04             	sub    $0x4,%esp
 395:	ff 75 f0             	pushl  -0x10(%ebp)
 398:	6a 00                	push   $0x0
 39a:	ff 75 f4             	pushl  -0xc(%ebp)
 39d:	e8 fc ff ff ff       	call   39e <calloc+0x33>
			39e: R_386_PC32	memset
 3a2:	83 c4 10             	add    $0x10,%esp
    }

    return p;
 3a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 3a8:	c9                   	leave  
 3a9:	c3                   	ret    

000003aa <realloc>:

void* realloc(void* ptr, size_t size) {
 3aa:	55                   	push   %ebp
 3ab:	89 e5                	mov    %esp,%ebp
 3ad:	83 ec 18             	sub    $0x18,%esp
    struct memory_node* last = 0;
 3b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    struct memory_node* cur = first_used;
 3b7:	a1 00 00 00 00       	mov    0x0,%eax
			3b8: R_386_32	first_used
 3bc:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
 3bf:	eb 7a                	jmp    43b <realloc+0x91>
        if (cur->address == (uint32_t) ptr) {
 3c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 3c4:	8b 50 04             	mov    0x4(%eax),%edx
 3c7:	8b 45 08             	mov    0x8(%ebp),%eax
 3ca:	39 c2                	cmp    %eax,%edx
 3cc:	75 5e                	jne    42c <realloc+0x82>
            if (size == 0) {
 3ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 3d2:	75 15                	jne    3e9 <realloc+0x3f>
                free(ptr);
 3d4:	83 ec 0c             	sub    $0xc,%esp
 3d7:	ff 75 08             	pushl  0x8(%ebp)
 3da:	e8 fc ff ff ff       	call   3db <realloc+0x31>
			3db: R_386_PC32	free
 3df:	83 c4 10             	add    $0x10,%esp
                return 0;
 3e2:	b8 00 00 00 00       	mov    $0x0,%eax
 3e7:	eb 5d                	jmp    446 <realloc+0x9c>
            } else {
                void* new = malloc(size);
 3e9:	83 ec 0c             	sub    $0xc,%esp
 3ec:	ff 75 0c             	pushl  0xc(%ebp)
 3ef:	e8 fc ff ff ff       	call   3f0 <realloc+0x46>
			3f0: R_386_PC32	malloc
 3f4:	83 c4 10             	add    $0x10,%esp
 3f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
 3fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
 3fd:	8b 10                	mov    (%eax),%edx
 3ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
 402:	8b 40 04             	mov    0x4(%eax),%eax
 405:	83 ec 04             	sub    $0x4,%esp
 408:	52                   	push   %edx
 409:	50                   	push   %eax
 40a:	ff 75 f4             	pushl  -0xc(%ebp)
 40d:	e8 fc ff ff ff       	call   40e <realloc+0x64>
			40e: R_386_PC32	memcpy
 412:	83 c4 10             	add    $0x10,%esp
                free((void*) cur->address);
 415:	8b 45 f0             	mov    -0x10(%ebp),%eax
 418:	8b 40 04             	mov    0x4(%eax),%eax
 41b:	83 ec 0c             	sub    $0xc,%esp
 41e:	50                   	push   %eax
 41f:	e8 fc ff ff ff       	call   420 <realloc+0x76>
			420: R_386_PC32	free
 424:	83 c4 10             	add    $0x10,%esp

                return new;
 427:	8b 45 f4             	mov    -0xc(%ebp),%eax
 42a:	eb 1a                	jmp    446 <realloc+0x9c>
            }
        }
        last = cur;
 42c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 42f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        cur = cur->next;
 432:	8b 45 f0             	mov    -0x10(%ebp),%eax
 435:	8b 40 08             	mov    0x8(%eax),%eax
 438:	89 45 f0             	mov    %eax,-0x10(%ebp)

void* realloc(void* ptr, size_t size) {
    struct memory_node* last = 0;
    struct memory_node* cur = first_used;

    while (cur != 0) {
 43b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 43f:	75 80                	jne    3c1 <realloc+0x17>
            }
        }
        last = cur;
        cur = cur->next;
    }
    return 0;
 441:	b8 00 00 00 00       	mov    $0x0,%eax
}
 446:	c9                   	leave  
 447:	c3                   	ret    

00000448 <free>:

void free(void* ptr) {
 448:	55                   	push   %ebp
 449:	89 e5                	mov    %esp,%ebp
 44b:	83 ec 10             	sub    $0x10,%esp
    struct memory_node* last = 0;
 44e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
 455:	a1 00 00 00 00       	mov    0x0,%eax
			456: R_386_32	first_used
 45a:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (cur != 0) {
 45d:	eb 29                	jmp    488 <free+0x40>
        if (cur->address == (uint32_t) ptr) {
 45f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 462:	8b 50 04             	mov    0x4(%eax),%edx
 465:	8b 45 08             	mov    0x8(%ebp),%eax
 468:	39 c2                	cmp    %eax,%edx
 46a:	75 0d                	jne    479 <free+0x31>
            merge_into_frees(cur);
 46c:	ff 75 fc             	pushl  -0x4(%ebp)
 46f:	e8 c9 fc ff ff       	call   13d <merge_into_frees>
 474:	83 c4 04             	add    $0x4,%esp
            break;
 477:	eb 15                	jmp    48e <free+0x46>
        }
        last = cur;
 479:	8b 45 fc             	mov    -0x4(%ebp),%eax
 47c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
 47f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 482:	8b 40 08             	mov    0x8(%eax),%eax
 485:	89 45 fc             	mov    %eax,-0x4(%ebp)

void free(void* ptr) {
    struct memory_node* last = 0;
    struct memory_node* cur = first_used;

    while (cur != 0) {
 488:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
 48c:	75 d1                	jne    45f <free+0x17>
            break;
        }
        last = cur;
        cur = cur->next;
    }
}
 48e:	c9                   	leave  
 48f:	c3                   	ret    

vmmcall.o:     file format elf32-i386
rw-rw-rw- 0/0   4156 Aug 10 18:30 2014 vmmcall.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000c4  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000f8  2**2
                  ALLOC
  3 .stab         00000474  00000000  00000000  000000f8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000071d  00000000  00000000  0000056c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000012  00000000  00000000  00000c89  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 vmmcall.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000 g     F .text	00000043 vmm_alloc_cont
00000000         *UND*	00000000 syscall
00000043 g     F .text	00000040 vmm_free
00000083 g     F .text	00000041 print_memstat



Disassembly of section .text:

00000000 <vmm_alloc_cont>:
#include "vmmcall.h"

void* vmm_alloc_cont (uint32_t cont) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
    .ebx = cont,
    .ecx = 0,
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
   6:	c7 45 e0 cb 00 00 00 	movl   $0xcb,-0x20(%ebp)
   d:	8b 45 08             	mov    0x8(%ebp),%eax
  10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  13:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  
  syscall(&state);  
  2f:	83 ec 0c             	sub    $0xc,%esp
  32:	8d 45 e0             	lea    -0x20(%ebp),%eax
  35:	50                   	push   %eax
  36:	e8 fc ff ff ff       	call   37 <vmm_alloc_cont+0x37>
			37: R_386_PC32	syscall
  3b:	83 c4 10             	add    $0x10,%esp
  
  return (void*)state.eax;
  3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  41:	c9                   	leave  
  42:	c3                   	ret    

00000043 <vmm_free>:

void vmm_free (void* vaddr) {
  43:	55                   	push   %ebp
  44:	89 e5                	mov    %esp,%ebp
  46:	83 ec 28             	sub    $0x28,%esp
  struct regstate state = {
    .eax = 204,
    .ebx = (uint32_t)vaddr,
  49:	8b 45 08             	mov    0x8(%ebp),%eax
    .ecx = 0,
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  4c:	c7 45 e0 cc 00 00 00 	movl   $0xcc,-0x20(%ebp)
  53:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  
  syscall(&state);  
  72:	83 ec 0c             	sub    $0xc,%esp
  75:	8d 45 e0             	lea    -0x20(%ebp),%eax
  78:	50                   	push   %eax
  79:	e8 fc ff ff ff       	call   7a <vmm_free+0x37>
			7a: R_386_PC32	syscall
  7e:	83 c4 10             	add    $0x10,%esp
}
  81:	c9                   	leave  
  82:	c3                   	ret    

00000083 <print_memstat>:

void print_memstat() {
  83:	55                   	push   %ebp
  84:	89 e5                	mov    %esp,%ebp
  86:	83 ec 28             	sub    $0x28,%esp
    .ebx = 0,
    .ecx = 0,
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  89:	c7 45 e0 cd 00 00 00 	movl   $0xcd,-0x20(%ebp)
  90:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  97:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  9e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  a5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  
  syscall(&state);  
  b3:	83 ec 0c             	sub    $0xc,%esp
  b6:	8d 45 e0             	lea    -0x20(%ebp),%eax
  b9:	50                   	push   %eax
  ba:	e8 fc ff ff ff       	call   bb <print_memstat+0x38>
			bb: R_386_PC32	syscall
  bf:	83 c4 10             	add    $0x10,%esp
}
  c2:	c9                   	leave  
  c3:	c3                   	ret    

process_rpc.o:     file format elf32-i386
rw-rw-rw- 0/0   6792 Aug 10 18:30 2014 process_rpc.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000020d  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000244  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000200  00000000  00000000  00000260  2**5
                  ALLOC
  3 .stab         0000084c  00000000  00000000  00000260  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000009a2  00000000  00000000  00000aac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .rodata       00000028  00000000  00000000  00001450  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  6 .comment      00000012  00000000  00000000  00001478  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 process_rpc.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l     F .text	00000040 return_rpc
000000c0 l     F .text	00000043 register_irq_rpc_syscall
00000000 l     O .bss	00000200 irq_handlers
00000000 l    d  .rodata	00000000 .rodata
00000136 l     F .text	00000088 _handle_rpc
00000010 l     O .rodata	00000018 C.8.1010
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .comment	00000000 .comment
00000000         *UND*	00000000 syscall
00000040 g     F .text	00000040 call_rpc
00000080 g     F .text	00000040 fetch_rpc_data
00000103 g     F .text	00000033 register_irq_handler
00000000         *UND*	00000000 malloc
00000000         *UND*	00000000 printf
00000000         *UND*	00000000 free
000001be g     F .text	0000004f set_rpc_handler
00000000         *UND*	00000000 memset



Disassembly of section .text:

00000000 <return_rpc>:
#include "process.h"
#include "stdio.h"
#include "stdlib.h"

static void return_rpc(int code) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 30,
      .ebx = (uint32_t)code,
   6:	8b 45 08             	mov    0x8(%ebp),%eax
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
   9:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
  10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  13:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  2f:	83 ec 0c             	sub    $0xc,%esp
  32:	8d 45 e0             	lea    -0x20(%ebp),%eax
  35:	50                   	push   %eax
  36:	e8 fc ff ff ff       	call   37 <return_rpc+0x37>
			37: R_386_PC32	syscall
  3b:	83 c4 10             	add    $0x10,%esp

    while(1);
  3e:	eb fe                	jmp    3e <return_rpc+0x3e>

00000040 <call_rpc>:
}

uint32_t call_rpc(int pid, uint32_t funcID, uint32_t datasize, void* data) {
  40:	55                   	push   %ebp
  41:	89 e5                	mov    %esp,%ebp
  43:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 31,
      .ebx = (uint32_t)pid,
  46:	8b 55 08             	mov    0x8(%ebp),%edx
      .ecx = funcID,
      .edx = datasize,
      .esi = (uint32_t)data,
  49:	8b 45 14             	mov    0x14(%ebp),%eax
      .edi = 0
    };
  4c:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%ebp)
  53:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  56:	8b 55 0c             	mov    0xc(%ebp),%edx
  59:	89 55 e8             	mov    %edx,-0x18(%ebp)
  5c:	8b 55 10             	mov    0x10(%ebp),%edx
  5f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  62:	89 45 f0             	mov    %eax,-0x10(%ebp)
  65:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  6c:	83 ec 0c             	sub    $0xc,%esp
  6f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  72:	50                   	push   %eax
  73:	e8 fc ff ff ff       	call   74 <call_rpc+0x34>
			74: R_386_PC32	syscall
  78:	83 c4 10             	add    $0x10,%esp

    return state.eax;
  7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  7e:	c9                   	leave  
  7f:	c3                   	ret    

00000080 <fetch_rpc_data>:

void fetch_rpc_data(void* dest) {
  80:	55                   	push   %ebp
  81:	89 e5                	mov    %esp,%ebp
  83:	83 ec 28             	sub    $0x28,%esp
    struct regstate state = {
      .eax = 33,
      .ebx = (uint32_t)dest,
  86:	8b 45 08             	mov    0x8(%ebp),%eax
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
  89:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
  90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  93:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  9a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  af:	83 ec 0c             	sub    $0xc,%esp
  b2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  b5:	50                   	push   %eax
  b6:	e8 fc ff ff ff       	call   b7 <fetch_rpc_data+0x37>
			b7: R_386_PC32	syscall
  bb:	83 c4 10             	add    $0x10,%esp
}
  be:	c9                   	leave  
  bf:	c3                   	ret    

000000c0 <register_irq_rpc_syscall>:

static uint32_t register_irq_rpc_syscall(uint32_t irq) {
  c0:	55                   	push   %ebp
  c1:	89 e5                	mov    %esp,%ebp
  c3:	83 ec 28             	sub    $0x28,%esp
      .ebx = irq,
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
  c6:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
  cd:	8b 45 08             	mov    0x8(%ebp),%eax
  d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    syscall(&state);
  ef:	83 ec 0c             	sub    $0xc,%esp
  f2:	8d 45 e0             	lea    -0x20(%ebp),%eax
  f5:	50                   	push   %eax
  f6:	e8 fc ff ff ff       	call   f7 <register_irq_rpc_syscall+0x37>
			f7: R_386_PC32	syscall
  fb:	83 c4 10             	add    $0x10,%esp

    return state.eax;
  fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
 101:	c9                   	leave  
 102:	c3                   	ret    

00000103 <register_irq_handler>:

static void (*irq_handlers[128])(uint32_t);

uint32_t register_irq_handler(uint32_t irq, void(*handler)(uint32_t)) {
 103:	55                   	push   %ebp
 104:	89 e5                	mov    %esp,%ebp
 106:	83 ec 08             	sub    $0x8,%esp
    if(register_irq_rpc_syscall(irq)) {
 109:	83 ec 0c             	sub    $0xc,%esp
 10c:	ff 75 08             	pushl  0x8(%ebp)
 10f:	e8 ac ff ff ff       	call   c0 <register_irq_rpc_syscall>
 114:	83 c4 10             	add    $0x10,%esp
 117:	85 c0                	test   %eax,%eax
 119:	74 14                	je     12f <register_irq_handler+0x2c>
        irq_handlers[irq] = handler;
 11b:	8b 45 08             	mov    0x8(%ebp),%eax
 11e:	8b 55 0c             	mov    0xc(%ebp),%edx
 121:	89 14 85 00 00 00 00 	mov    %edx,0x0(,%eax,4)
			124: R_386_32	.bss
        return 1;
 128:	b8 01 00 00 00       	mov    $0x1,%eax
 12d:	eb 05                	jmp    134 <register_irq_handler+0x31>
    }
    return 0;
 12f:	b8 00 00 00 00       	mov    $0x0,%eax
}
 134:	c9                   	leave  
 135:	c3                   	ret    

00000136 <_handle_rpc>:

static void _handle_rpc(uint32_t type, uint32_t funcID, uint32_t datasize) {
 136:	55                   	push   %ebp
 137:	89 e5                	mov    %esp,%ebp
 139:	83 ec 18             	sub    $0x18,%esp
    void* localData = malloc(datasize);
 13c:	83 ec 0c             	sub    $0xc,%esp
 13f:	ff 75 10             	pushl  0x10(%ebp)
 142:	e8 fc ff ff ff       	call   143 <_handle_rpc+0xd>
			143: R_386_PC32	malloc
 147:	83 c4 10             	add    $0x10,%esp
 14a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fetch_rpc_data(localData);
 14d:	83 ec 0c             	sub    $0xc,%esp
 150:	ff 75 f4             	pushl  -0xc(%ebp)
 153:	e8 fc ff ff ff       	call   154 <_handle_rpc+0x1e>
			154: R_386_PC32	fetch_rpc_data
 158:	83 c4 10             	add    $0x10,%esp

    if(type == RPCT_IRQ) {
 15b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 15f:	75 30                	jne    191 <_handle_rpc+0x5b>
        if(irq_handlers[funcID]) {
 161:	8b 45 0c             	mov    0xc(%ebp),%eax
 164:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
			167: R_386_32	.bss
 16b:	85 c0                	test   %eax,%eax
 16d:	74 22                	je     191 <_handle_rpc+0x5b>
            irq_handlers[funcID](funcID);
 16f:	8b 45 0c             	mov    0xc(%ebp),%eax
 172:	8b 04 85 00 00 00 00 	mov    0x0(,%eax,4),%eax
			175: R_386_32	.bss
 179:	83 ec 0c             	sub    $0xc,%esp
 17c:	ff 75 0c             	pushl  0xc(%ebp)
 17f:	ff d0                	call   *%eax
 181:	83 c4 10             	add    $0x10,%esp
            return_rpc(0);
 184:	83 ec 0c             	sub    $0xc,%esp
 187:	6a 00                	push   $0x0
 189:	e8 72 fe ff ff       	call   0 <return_rpc>
 18e:	83 c4 10             	add    $0x10,%esp
        }
    }

    printf("Unhandled RPC!\n");
 191:	83 ec 0c             	sub    $0xc,%esp
 194:	68 00 00 00 00       	push   $0x0
			195: R_386_32	.rodata
 199:	e8 fc ff ff ff       	call   19a <_handle_rpc+0x64>
			19a: R_386_PC32	printf
 19e:	83 c4 10             	add    $0x10,%esp

    free(localData);
 1a1:	83 ec 0c             	sub    $0xc,%esp
 1a4:	ff 75 f4             	pushl  -0xc(%ebp)
 1a7:	e8 fc ff ff ff       	call   1a8 <_handle_rpc+0x72>
			1a8: R_386_PC32	free
 1ac:	83 c4 10             	add    $0x10,%esp
    return_rpc(0);
 1af:	83 ec 0c             	sub    $0xc,%esp
 1b2:	6a 00                	push   $0x0
 1b4:	e8 47 fe ff ff       	call   0 <return_rpc>
 1b9:	83 c4 10             	add    $0x10,%esp
}
 1bc:	c9                   	leave  
 1bd:	c3                   	ret    

000001be <set_rpc_handler>:

void set_rpc_handler() {
 1be:	55                   	push   %ebp
 1bf:	89 e5                	mov    %esp,%ebp
 1c1:	57                   	push   %edi
 1c2:	56                   	push   %esi
 1c3:	53                   	push   %ebx
 1c4:	83 ec 2c             	sub    $0x2c,%esp
    memset(irq_handlers, 0, sizeof(irq_handlers));
 1c7:	83 ec 04             	sub    $0x4,%esp
 1ca:	68 00 02 00 00       	push   $0x200
 1cf:	6a 00                	push   $0x0
 1d1:	68 00 00 00 00       	push   $0x0
			1d2: R_386_32	.bss
 1d6:	e8 fc ff ff ff       	call   1d7 <set_rpc_handler+0x19>
			1d7: R_386_PC32	memset
 1db:	83 c4 10             	add    $0x10,%esp
      .ebx = (uint32_t)_handle_rpc,
      .ecx = 0,
      .edx = 0,
      .esi = 0,
      .edi = 0
    };
 1de:	8d 55 d0             	lea    -0x30(%ebp),%edx
 1e1:	bb 10 00 00 00       	mov    $0x10,%ebx
			1e2: R_386_32	.rodata
 1e6:	b8 06 00 00 00       	mov    $0x6,%eax
 1eb:	89 d7                	mov    %edx,%edi
 1ed:	89 de                	mov    %ebx,%esi
 1ef:	89 c1                	mov    %eax,%ecx
 1f1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    syscall(&state);
 1f3:	83 ec 0c             	sub    $0xc,%esp
 1f6:	8d 45 d0             	lea    -0x30(%ebp),%eax
 1f9:	50                   	push   %eax
 1fa:	e8 fc ff ff ff       	call   1fb <set_rpc_handler+0x3d>
			1fb: R_386_PC32	syscall
 1ff:	83 c4 10             	add    $0x10,%esp
}
 202:	8d 65 f4             	lea    -0xc(%ebp),%esp
 205:	83 c4 00             	add    $0x0,%esp
 208:	5b                   	pop    %ebx
 209:	5e                   	pop    %esi
 20a:	5f                   	pop    %edi
 20b:	5d                   	pop    %ebp
 20c:	c3                   	ret    
