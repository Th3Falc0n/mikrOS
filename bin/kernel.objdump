
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <intr_stub_0-0xc>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 6a                	in     $0x6a,%al

0010000c <intr_stub_0>:
  10000c:	6a 00                	push   $0x0
  10000e:	6a 00                	push   $0x0
  100010:	e9 eb 00 00 00       	jmp    100100 <intr_common_handler>

00100015 <intr_stub_1>:
  100015:	6a 00                	push   $0x0
  100017:	6a 01                	push   $0x1
  100019:	e9 e2 00 00 00       	jmp    100100 <intr_common_handler>

0010001e <intr_stub_2>:
  10001e:	6a 00                	push   $0x0
  100020:	6a 02                	push   $0x2
  100022:	e9 d9 00 00 00       	jmp    100100 <intr_common_handler>

00100027 <intr_stub_3>:
  100027:	6a 00                	push   $0x0
  100029:	6a 03                	push   $0x3
  10002b:	e9 d0 00 00 00       	jmp    100100 <intr_common_handler>

00100030 <intr_stub_4>:
  100030:	6a 00                	push   $0x0
  100032:	6a 04                	push   $0x4
  100034:	e9 c7 00 00 00       	jmp    100100 <intr_common_handler>

00100039 <intr_stub_5>:
  100039:	6a 00                	push   $0x0
  10003b:	6a 05                	push   $0x5
  10003d:	e9 be 00 00 00       	jmp    100100 <intr_common_handler>

00100042 <intr_stub_6>:
  100042:	6a 00                	push   $0x0
  100044:	6a 06                	push   $0x6
  100046:	e9 b5 00 00 00       	jmp    100100 <intr_common_handler>

0010004b <intr_stub_7>:
  10004b:	6a 00                	push   $0x0
  10004d:	6a 07                	push   $0x7
  10004f:	e9 ac 00 00 00       	jmp    100100 <intr_common_handler>

00100054 <intr_stub_8>:
  100054:	6a 08                	push   $0x8
  100056:	e9 a5 00 00 00       	jmp    100100 <intr_common_handler>

0010005b <intr_stub_9>:
  10005b:	6a 00                	push   $0x0
  10005d:	6a 09                	push   $0x9
  10005f:	e9 9c 00 00 00       	jmp    100100 <intr_common_handler>

00100064 <intr_stub_10>:
  100064:	6a 0a                	push   $0xa
  100066:	e9 95 00 00 00       	jmp    100100 <intr_common_handler>

0010006b <intr_stub_11>:
  10006b:	6a 0b                	push   $0xb
  10006d:	e9 8e 00 00 00       	jmp    100100 <intr_common_handler>

00100072 <intr_stub_12>:
  100072:	6a 0c                	push   $0xc
  100074:	e9 87 00 00 00       	jmp    100100 <intr_common_handler>

00100079 <intr_stub_13>:
  100079:	6a 0d                	push   $0xd
  10007b:	e9 80 00 00 00       	jmp    100100 <intr_common_handler>

00100080 <intr_stub_14>:
  100080:	6a 0e                	push   $0xe
  100082:	eb 7c                	jmp    100100 <intr_common_handler>

00100084 <intr_stub_15>:
  100084:	6a 00                	push   $0x0
  100086:	6a 0f                	push   $0xf
  100088:	eb 76                	jmp    100100 <intr_common_handler>

0010008a <intr_stub_16>:
  10008a:	6a 00                	push   $0x0
  10008c:	6a 10                	push   $0x10
  10008e:	eb 70                	jmp    100100 <intr_common_handler>

00100090 <intr_stub_17>:
  100090:	6a 11                	push   $0x11
  100092:	eb 6c                	jmp    100100 <intr_common_handler>

00100094 <intr_stub_18>:
  100094:	6a 00                	push   $0x0
  100096:	6a 12                	push   $0x12
  100098:	eb 66                	jmp    100100 <intr_common_handler>

0010009a <intr_stub_32>:
  10009a:	6a 00                	push   $0x0
  10009c:	6a 20                	push   $0x20
  10009e:	eb 60                	jmp    100100 <intr_common_handler>

001000a0 <intr_stub_33>:
  1000a0:	6a 00                	push   $0x0
  1000a2:	6a 21                	push   $0x21
  1000a4:	eb 5a                	jmp    100100 <intr_common_handler>

001000a6 <intr_stub_34>:
  1000a6:	6a 00                	push   $0x0
  1000a8:	6a 22                	push   $0x22
  1000aa:	eb 54                	jmp    100100 <intr_common_handler>

001000ac <intr_stub_35>:
  1000ac:	6a 00                	push   $0x0
  1000ae:	6a 23                	push   $0x23
  1000b0:	eb 4e                	jmp    100100 <intr_common_handler>

001000b2 <intr_stub_36>:
  1000b2:	6a 00                	push   $0x0
  1000b4:	6a 24                	push   $0x24
  1000b6:	eb 48                	jmp    100100 <intr_common_handler>

001000b8 <intr_stub_37>:
  1000b8:	6a 00                	push   $0x0
  1000ba:	6a 25                	push   $0x25
  1000bc:	eb 42                	jmp    100100 <intr_common_handler>

001000be <intr_stub_38>:
  1000be:	6a 00                	push   $0x0
  1000c0:	6a 26                	push   $0x26
  1000c2:	eb 3c                	jmp    100100 <intr_common_handler>

001000c4 <intr_stub_39>:
  1000c4:	6a 00                	push   $0x0
  1000c6:	6a 27                	push   $0x27
  1000c8:	eb 36                	jmp    100100 <intr_common_handler>

001000ca <intr_stub_40>:
  1000ca:	6a 00                	push   $0x0
  1000cc:	6a 28                	push   $0x28
  1000ce:	eb 30                	jmp    100100 <intr_common_handler>

001000d0 <intr_stub_41>:
  1000d0:	6a 00                	push   $0x0
  1000d2:	6a 29                	push   $0x29
  1000d4:	eb 2a                	jmp    100100 <intr_common_handler>

001000d6 <intr_stub_42>:
  1000d6:	6a 00                	push   $0x0
  1000d8:	6a 2a                	push   $0x2a
  1000da:	eb 24                	jmp    100100 <intr_common_handler>

001000dc <intr_stub_43>:
  1000dc:	6a 00                	push   $0x0
  1000de:	6a 2b                	push   $0x2b
  1000e0:	eb 1e                	jmp    100100 <intr_common_handler>

001000e2 <intr_stub_44>:
  1000e2:	6a 00                	push   $0x0
  1000e4:	6a 2c                	push   $0x2c
  1000e6:	eb 18                	jmp    100100 <intr_common_handler>

001000e8 <intr_stub_45>:
  1000e8:	6a 00                	push   $0x0
  1000ea:	6a 2d                	push   $0x2d
  1000ec:	eb 12                	jmp    100100 <intr_common_handler>

001000ee <intr_stub_46>:
  1000ee:	6a 00                	push   $0x0
  1000f0:	6a 2e                	push   $0x2e
  1000f2:	eb 0c                	jmp    100100 <intr_common_handler>

001000f4 <intr_stub_47>:
  1000f4:	6a 00                	push   $0x0
  1000f6:	6a 2f                	push   $0x2f
  1000f8:	eb 06                	jmp    100100 <intr_common_handler>

001000fa <intr_stub_48>:
  1000fa:	6a 00                	push   $0x0
  1000fc:	6a 30                	push   $0x30
  1000fe:	eb 00                	jmp    100100 <intr_common_handler>

00100100 <intr_common_handler>:
  100100:	55                   	push   %ebp
  100101:	57                   	push   %edi
  100102:	56                   	push   %esi
  100103:	52                   	push   %edx
  100104:	51                   	push   %ecx
  100105:	53                   	push   %ebx
  100106:	50                   	push   %eax
  100107:	54                   	push   %esp
  100108:	66 b8 10 00          	mov    $0x10,%ax
  10010c:	8e d8                	mov    %eax,%ds
  10010e:	8e c0                	mov    %eax,%es
  100110:	e8 8c 0e 00 00       	call   100fa1 <handle_interrupt>
  100115:	89 c4                	mov    %eax,%esp
  100117:	66 b8 23 00          	mov    $0x23,%ax
  10011b:	8e d8                	mov    %eax,%ds
  10011d:	8e c0                	mov    %eax,%es
  10011f:	58                   	pop    %eax
  100120:	5b                   	pop    %ebx
  100121:	59                   	pop    %ecx
  100122:	5a                   	pop    %edx
  100123:	5e                   	pop    %esi
  100124:	5f                   	pop    %edi
  100125:	5d                   	pop    %ebp
  100126:	83 c4 08             	add    $0x8,%esp
  100129:	cf                   	iret   
	...

0010012c <_start>:
  10012c:	bc 00 80 11 00       	mov    $0x118000,%esp
  100131:	53                   	push   %ebx
  100132:	e8 05 00 00 00       	call   10013c <init>

00100137 <_stop>:
  100137:	fa                   	cli    
  100138:	f4                   	hlt    
  100139:	eb fc                	jmp    100137 <_stop>
	...

0010013c <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
  10013c:	55                   	push   %ebp
  10013d:	89 e5                	mov    %esp,%ebp
  10013f:	83 ec 08             	sub    $0x8,%esp
	clrscr();
  100142:	e8 c9 03 00 00       	call   100510 <clrscr>
	pmm_init(mb_info);
  100147:	83 ec 0c             	sub    $0xc,%esp
  10014a:	ff 75 08             	pushl  0x8(%ebp)
  10014d:	e8 f2 1a 00 00       	call   101c44 <pmm_init>
  100152:	83 c4 10             	add    $0x10,%esp

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100155:	83 ec 08             	sub    $0x8,%esp
  100158:	68 00 70 10 00       	push   $0x107000
  10015d:	68 14 70 10 00       	push   $0x107014
  100162:	e8 06 04 00 00       	call   10056d <kprintf>
  100167:	83 c4 10             	add    $0x10,%esp
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10016a:	83 ec 0c             	sub    $0xc,%esp
  10016d:	68 38 70 10 00       	push   $0x107038
  100172:	e8 f6 03 00 00       	call   10056d <kprintf>
  100177:	83 c4 10             	add    $0x10,%esp

	kprintf("Initializing GDT...\n");
  10017a:	83 ec 0c             	sub    $0xc,%esp
  10017d:	68 77 70 10 00       	push   $0x107077
  100182:	e8 e6 03 00 00       	call   10056d <kprintf>
  100187:	83 c4 10             	add    $0x10,%esp

	init_gdt();
  10018a:	e8 67 07 00 00       	call   1008f6 <init_gdt>

	kprintf("Initializing IDT...\n");
  10018f:	83 ec 0c             	sub    $0xc,%esp
  100192:	68 8c 70 10 00       	push   $0x10708c
  100197:	e8 d1 03 00 00       	call   10056d <kprintf>
  10019c:	83 c4 10             	add    $0x10,%esp

	init_idt();
  10019f:	e8 eb 08 00 00       	call   100a8f <init_idt>

	kprintf("Initializing Kernel...\n");
  1001a4:	83 ec 0c             	sub    $0xc,%esp
  1001a7:	68 a1 70 10 00       	push   $0x1070a1
  1001ac:	e8 bc 03 00 00       	call   10056d <kprintf>
  1001b1:	83 c4 10             	add    $0x10,%esp

	pmm_print_stats();
  1001b4:	e8 18 19 00 00       	call   101ad1 <pmm_print_stats>

	kernel_main(mb_info);
  1001b9:	83 ec 0c             	sub    $0xc,%esp
  1001bc:	ff 75 08             	pushl  0x8(%ebp)
  1001bf:	e8 a1 16 00 00       	call   101865 <kernel_main>
  1001c4:	83 c4 10             	add    $0x10,%esp

	return;
}
  1001c7:	c9                   	leave  
  1001c8:	c3                   	ret    
  1001c9:	00 00                	add    %al,(%eax)
	...

001001cc <in_cod>:
#include "console.h"
#include "gdt.h"
#include "idt.h"
#include "kernel.h"
#include "multiboot.h"
  1001cc:	55                   	push   %ebp
  1001cd:	89 e5                	mov    %esp,%ebp
#include "pmm.h"
  1001cf:	a1 00 80 12 00       	mov    0x128000,%eax
#include "vfs.h"
  1001d4:	5d                   	pop    %ebp
  1001d5:	c3                   	ret    

001001d6 <show_cod>:

#define _VERSION "alphaUSpaceDev 1.02"
  1001d6:	55                   	push   %ebp
  1001d7:	89 e5                	mov    %esp,%ebp
  1001d9:	83 ec 08             	sub    $0x8,%esp

  1001dc:	c7 05 00 80 12 00 01 	movl   $0x1,0x128000
  1001e3:	00 00 00 
	kprintf("Initializing Kernel...\n");

	pmm_print_stats();

	kernel_main(mb_info);

  1001e6:	83 ec 0c             	sub    $0xc,%esp
  1001e9:	6a 04                	push   $0x4
  1001eb:	e8 67 03 00 00       	call   100557 <setclr>
  1001f0:	83 c4 10             	add    $0x10,%esp
	return;
  1001f3:	83 ec 0c             	sub    $0xc,%esp
  1001f6:	ff 75 0c             	pushl  0xc(%ebp)
  1001f9:	e8 6f 03 00 00       	call   10056d <kprintf>
  1001fe:	83 c4 10             	add    $0x10,%esp
}
  100201:	8b 45 08             	mov    0x8(%ebp),%eax
  100204:	8b 50 20             	mov    0x20(%eax),%edx
  100207:	8b 45 08             	mov    0x8(%ebp),%eax
  10020a:	8b 40 1c             	mov    0x1c(%eax),%eax
  10020d:	83 ec 04             	sub    $0x4,%esp
  100210:	52                   	push   %edx
  100211:	50                   	push   %eax
  100212:	68 bc 70 10 00       	push   $0x1070bc
  100217:	e8 51 03 00 00       	call   10056d <kprintf>
  10021c:	83 c4 10             	add    $0x10,%esp
  10021f:	83 ec 0c             	sub    $0xc,%esp
  100222:	ff 75 08             	pushl  0x8(%ebp)
  100225:	e8 07 00 00 00       	call   100231 <show_dump>
  10022a:	83 c4 10             	add    $0x10,%esp
  10022d:	fa                   	cli    
  10022e:	f4                   	hlt    
  10022f:	eb fc                	jmp    10022d <show_cod+0x57>

00100231 <show_dump>:
  100231:	55                   	push   %ebp
  100232:	89 e5                	mov    %esp,%ebp
  100234:	53                   	push   %ebx
  100235:	83 ec 14             	sub    $0x14,%esp
  100238:	8b 45 08             	mov    0x8(%ebp),%eax
  10023b:	8b 58 0c             	mov    0xc(%eax),%ebx
  10023e:	8b 45 08             	mov    0x8(%ebp),%eax
  100241:	8b 48 08             	mov    0x8(%eax),%ecx
  100244:	8b 45 08             	mov    0x8(%ebp),%eax
  100247:	8b 50 04             	mov    0x4(%eax),%edx
  10024a:	8b 45 08             	mov    0x8(%ebp),%eax
  10024d:	8b 00                	mov    (%eax),%eax
  10024f:	83 ec 0c             	sub    $0xc,%esp
  100252:	53                   	push   %ebx
  100253:	51                   	push   %ecx
  100254:	52                   	push   %edx
  100255:	50                   	push   %eax
  100256:	68 e4 70 10 00       	push   $0x1070e4
  10025b:	e8 0d 03 00 00       	call   10056d <kprintf>
  100260:	83 c4 20             	add    $0x20,%esp
  100263:	8b 45 08             	mov    0x8(%ebp),%eax
  100266:	8b 58 24             	mov    0x24(%eax),%ebx
  100269:	8b 45 08             	mov    0x8(%ebp),%eax
  10026c:	8b 48 18             	mov    0x18(%eax),%ecx
  10026f:	8b 45 08             	mov    0x8(%ebp),%eax
  100272:	8b 50 14             	mov    0x14(%eax),%edx
  100275:	8b 45 08             	mov    0x8(%ebp),%eax
  100278:	8b 40 10             	mov    0x10(%eax),%eax
  10027b:	83 ec 0c             	sub    $0xc,%esp
  10027e:	53                   	push   %ebx
  10027f:	51                   	push   %ecx
  100280:	52                   	push   %edx
  100281:	50                   	push   %eax
  100282:	68 08 71 10 00       	push   $0x107108
  100287:	e8 e1 02 00 00       	call   10056d <kprintf>
  10028c:	83 c4 20             	add    $0x20,%esp
  10028f:	8b 45 08             	mov    0x8(%ebp),%eax
  100292:	8b 58 34             	mov    0x34(%eax),%ebx
  100295:	8b 45 08             	mov    0x8(%ebp),%eax
  100298:	8b 48 30             	mov    0x30(%eax),%ecx
  10029b:	8b 45 08             	mov    0x8(%ebp),%eax
  10029e:	8b 50 2c             	mov    0x2c(%eax),%edx
  1002a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002a4:	8b 40 28             	mov    0x28(%eax),%eax
  1002a7:	83 ec 0c             	sub    $0xc,%esp
  1002aa:	53                   	push   %ebx
  1002ab:	51                   	push   %ecx
  1002ac:	52                   	push   %edx
  1002ad:	50                   	push   %eax
  1002ae:	68 2c 71 10 00       	push   $0x10712c
  1002b3:	e8 b5 02 00 00       	call   10056d <kprintf>
  1002b8:	83 c4 20             	add    $0x20,%esp
  1002bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1002c2:	0f 20 d0             	mov    %cr2,%eax
  1002c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1002c8:	83 ec 08             	sub    $0x8,%esp
  1002cb:	ff 75 f4             	pushl  -0xc(%ebp)
  1002ce:	68 4e 71 10 00       	push   $0x10714e
  1002d3:	e8 95 02 00 00       	call   10056d <kprintf>
  1002d8:	83 c4 10             	add    $0x10,%esp
  1002db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1002de:	c9                   	leave  
  1002df:	c3                   	ret    

001002e0 <kputc>:
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
	clrscr();
  1002e0:	55                   	push   %ebp
  1002e1:	89 e5                	mov    %esp,%ebp
  1002e3:	83 ec 28             	sub    $0x28,%esp
  1002e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002e9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	pmm_init(mb_info);
  1002ec:	e8 db fe ff ff       	call   1001cc <in_cod>
  1002f1:	85 c0                	test   %eax,%eax
  1002f3:	75 79                	jne    10036e <kputc+0x8e>

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");

  1002f5:	e8 33 28 00 00       	call   102b2d <get_current_task>
  1002fa:	85 c0                	test   %eax,%eax
  1002fc:	74 61                	je     10035f <kputc+0x7f>
	kprintf("Initializing GDT...\n");
  1002fe:	e8 2a 28 00 00       	call   102b2d <get_current_task>
  100303:	8b 40 30             	mov    0x30(%eax),%eax
  100306:	85 c0                	test   %eax,%eax
  100308:	74 55                	je     10035f <kputc+0x7f>

  10030a:	c6 45 f3 11          	movb   $0x11,-0xd(%ebp)
  10030e:	e8 1a 28 00 00       	call   102b2d <get_current_task>
  100313:	8b 40 30             	mov    0x30(%eax),%eax
  100316:	6a 01                	push   $0x1
  100318:	6a 01                	push   $0x1
  10031a:	8d 55 f3             	lea    -0xd(%ebp),%edx
  10031d:	52                   	push   %edx
  10031e:	50                   	push   %eax
  10031f:	e8 65 40 00 00       	call   104389 <vfs_write>
  100324:	83 c4 10             	add    $0x10,%esp
	init_gdt();
  100327:	e8 01 28 00 00       	call   102b2d <get_current_task>
  10032c:	8b 40 30             	mov    0x30(%eax),%eax
  10032f:	6a 01                	push   $0x1
  100331:	6a 01                	push   $0x1
  100333:	68 00 60 10 00       	push   $0x106000
  100338:	50                   	push   %eax
  100339:	e8 4b 40 00 00       	call   104389 <vfs_write>
  10033e:	83 c4 10             	add    $0x10,%esp

  100341:	e8 e7 27 00 00       	call   102b2d <get_current_task>
  100346:	8b 40 30             	mov    0x30(%eax),%eax
  100349:	6a 01                	push   $0x1
  10034b:	6a 01                	push   $0x1
  10034d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  100350:	52                   	push   %edx
  100351:	50                   	push   %eax
  100352:	e8 32 40 00 00       	call   104389 <vfs_write>
  100357:	83 c4 10             	add    $0x10,%esp
	kprintf("Initializing IDT...\n");

  10035a:	e9 1a 01 00 00       	jmp    100479 <kputc+0x199>
	init_idt();

	kprintf("Initializing Kernel...\n");

  10035f:	e8 ca 25 00 00       	call   10292e <ramfs_vga_writers>
  100364:	85 c0                	test   %eax,%eax
  100366:	0f 85 09 01 00 00    	jne    100475 <kputc+0x195>
  10036c:	eb 01                	jmp    10036f <kputc+0x8f>
#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
	clrscr();
	pmm_init(mb_info);

  10036e:	90                   	nop    
	pmm_print_stats();

	kernel_main(mb_info);

	return;
}
  10036f:	8a 45 e4             	mov    -0x1c(%ebp),%al
  100372:	3c 0a                	cmp    $0xa,%al
  100374:	74 0a                	je     100380 <kputc+0xa0>
  100376:	a1 04 80 12 00       	mov    0x128004,%eax
  10037b:	83 f8 4f             	cmp    $0x4f,%eax
  10037e:	7e 15                	jle    100395 <kputc+0xb5>
  100380:	c7 05 04 80 12 00 00 	movl   $0x0,0x128004
  100387:	00 00 00 
  10038a:	a1 08 80 12 00       	mov    0x128008,%eax
  10038f:	40                   	inc    %eax
  100390:	a3 08 80 12 00       	mov    %eax,0x128008
  100395:	8a 45 e4             	mov    -0x1c(%ebp),%al
  100398:	3c 0a                	cmp    $0xa,%al
  10039a:	0f 84 d8 00 00 00    	je     100478 <kputc+0x198>
  1003a0:	a1 08 80 12 00       	mov    0x128008,%eax
  1003a5:	83 f8 18             	cmp    $0x18,%eax
  1003a8:	7e 5c                	jle    100406 <kputc+0x126>
  1003aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1003b1:	eb 22                	jmp    1003d5 <kputc+0xf5>
  1003b3:	8b 15 04 60 10 00    	mov    0x106004,%edx
  1003b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003bc:	01 c2                	add    %eax,%edx
  1003be:	a1 04 60 10 00       	mov    0x106004,%eax
  1003c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1003c6:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
  1003cc:	01 c8                	add    %ecx,%eax
  1003ce:	8a 00                	mov    (%eax),%al
  1003d0:	88 02                	mov    %al,(%edx)
  1003d2:	ff 45 f4             	incl   -0xc(%ebp)
  1003d5:	81 7d f4 ff 0e 00 00 	cmpl   $0xeff,-0xc(%ebp)
  1003dc:	7e d5                	jle    1003b3 <kputc+0xd3>
  1003de:	eb 12                	jmp    1003f2 <kputc+0x112>
  1003e0:	8b 15 04 60 10 00    	mov    0x106004,%edx
  1003e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003e9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1003ec:	c6 00 00             	movb   $0x0,(%eax)
  1003ef:	ff 45 f4             	incl   -0xc(%ebp)
  1003f2:	81 7d f4 9f 0f 00 00 	cmpl   $0xf9f,-0xc(%ebp)
  1003f9:	7e e5                	jle    1003e0 <kputc+0x100>
  1003fb:	a1 08 80 12 00       	mov    0x128008,%eax
  100400:	48                   	dec    %eax
  100401:	a3 08 80 12 00       	mov    %eax,0x128008
  100406:	8b 0d 04 60 10 00    	mov    0x106004,%ecx
  10040c:	8b 15 08 80 12 00    	mov    0x128008,%edx
  100412:	89 d0                	mov    %edx,%eax
  100414:	c1 e0 02             	shl    $0x2,%eax
  100417:	01 d0                	add    %edx,%eax
  100419:	c1 e0 04             	shl    $0x4,%eax
  10041c:	89 c2                	mov    %eax,%edx
  10041e:	a1 04 80 12 00       	mov    0x128004,%eax
  100423:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100426:	01 c0                	add    %eax,%eax
  100428:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  10042b:	8a 45 e4             	mov    -0x1c(%ebp),%al
  10042e:	88 02                	mov    %al,(%edx)
  100430:	8b 0d 04 60 10 00    	mov    0x106004,%ecx
  100436:	8b 15 08 80 12 00    	mov    0x128008,%edx
  10043c:	89 d0                	mov    %edx,%eax
  10043e:	c1 e0 02             	shl    $0x2,%eax
  100441:	01 d0                	add    %edx,%eax
  100443:	c1 e0 04             	shl    $0x4,%eax
  100446:	89 c2                	mov    %eax,%edx
  100448:	a1 04 80 12 00       	mov    0x128004,%eax
  10044d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100450:	01 c0                	add    %eax,%eax
  100452:	40                   	inc    %eax
  100453:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  100456:	a0 00 60 10 00       	mov    0x106000,%al
  10045b:	88 02                	mov    %al,(%edx)
  10045d:	a1 04 80 12 00       	mov    0x128004,%eax
  100462:	40                   	inc    %eax
  100463:	a3 04 80 12 00       	mov    %eax,0x128004
  100468:	a1 0c 80 12 00       	mov    0x12800c,%eax
  10046d:	40                   	inc    %eax
  10046e:	a3 0c 80 12 00       	mov    %eax,0x12800c
  100473:	eb 04                	jmp    100479 <kputc+0x199>

	init_idt();

	kprintf("Initializing Kernel...\n");

	pmm_print_stats();
  100475:	90                   	nop    
  100476:	eb 01                	jmp    100479 <kputc+0x199>
  100478:	90                   	nop    
  100479:	c9                   	leave  
  10047a:	c3                   	ret    

0010047b <kputs>:
  10047b:	55                   	push   %ebp
  10047c:	89 e5                	mov    %esp,%ebp
  10047e:	83 ec 08             	sub    $0x8,%esp
  100481:	eb 17                	jmp    10049a <kputs+0x1f>
  100483:	8b 45 08             	mov    0x8(%ebp),%eax
  100486:	8a 00                	mov    (%eax),%al
  100488:	0f be c0             	movsbl %al,%eax
  10048b:	ff 45 08             	incl   0x8(%ebp)
  10048e:	83 ec 0c             	sub    $0xc,%esp
  100491:	50                   	push   %eax
  100492:	e8 49 fe ff ff       	call   1002e0 <kputc>
  100497:	83 c4 10             	add    $0x10,%esp
  10049a:	8b 45 08             	mov    0x8(%ebp),%eax
  10049d:	8a 00                	mov    (%eax),%al
  10049f:	84 c0                	test   %al,%al
  1004a1:	75 e0                	jne    100483 <kputs+0x8>
  1004a3:	c9                   	leave  
  1004a4:	c3                   	ret    

001004a5 <kputn>:
  1004a5:	55                   	push   %ebp
  1004a6:	89 e5                	mov    %esp,%ebp
  1004a8:	83 ec 58             	sub    $0x58,%esp
  1004ab:	c7 45 f0 58 71 10 00 	movl   $0x107158,-0x10(%ebp)
  1004b2:	83 7d 0c 24          	cmpl   $0x24,0xc(%ebp)
  1004b6:	7f 55                	jg     10050d <kputn+0x68>
  1004b8:	8d 45 af             	lea    -0x51(%ebp),%eax
  1004bb:	83 c0 40             	add    $0x40,%eax
  1004be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1004c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1004c4:	c6 00 00             	movb   $0x0,(%eax)
  1004c7:	ff 4d f4             	decl   -0xc(%ebp)
  1004ca:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1004d0:	89 d1                	mov    %edx,%ecx
  1004d2:	ba 00 00 00 00       	mov    $0x0,%edx
  1004d7:	f7 f1                	div    %ecx
  1004d9:	89 d0                	mov    %edx,%eax
  1004db:	03 45 f0             	add    -0x10(%ebp),%eax
  1004de:	8a 10                	mov    (%eax),%dl
  1004e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1004e3:	88 10                	mov    %dl,(%eax)
  1004e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1004eb:	89 d1                	mov    %edx,%ecx
  1004ed:	ba 00 00 00 00       	mov    $0x0,%edx
  1004f2:	f7 f1                	div    %ecx
  1004f4:	89 45 08             	mov    %eax,0x8(%ebp)
  1004f7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1004fb:	75 ca                	jne    1004c7 <kputn+0x22>
  1004fd:	83 ec 0c             	sub    $0xc,%esp
  100500:	ff 75 f4             	pushl  -0xc(%ebp)
  100503:	e8 73 ff ff ff       	call   10047b <kputs>
  100508:	83 c4 10             	add    $0x10,%esp
  10050b:	eb 01                	jmp    10050e <kputn+0x69>
  10050d:	90                   	nop    
  10050e:	c9                   	leave  
  10050f:	c3                   	ret    

00100510 <clrscr>:
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	83 ec 10             	sub    $0x10,%esp
  100516:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10051d:	eb 12                	jmp    100531 <clrscr+0x21>
  10051f:	8b 15 04 60 10 00    	mov    0x106004,%edx
  100525:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100528:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10052b:	c6 00 00             	movb   $0x0,(%eax)
  10052e:	ff 45 fc             	incl   -0x4(%ebp)
  100531:	81 7d fc 9f 0f 00 00 	cmpl   $0xf9f,-0x4(%ebp)
  100538:	7e e5                	jle    10051f <clrscr+0xf>
  10053a:	c6 05 00 60 10 00 07 	movb   $0x7,0x106000
  100541:	c7 05 08 80 12 00 00 	movl   $0x0,0x128008
  100548:	00 00 00 
  10054b:	a1 08 80 12 00       	mov    0x128008,%eax
  100550:	a3 04 80 12 00       	mov    %eax,0x128004
  100555:	c9                   	leave  
  100556:	c3                   	ret    

00100557 <setclr>:
  100557:	55                   	push   %ebp
  100558:	89 e5                	mov    %esp,%ebp
  10055a:	83 ec 04             	sub    $0x4,%esp
  10055d:	8b 45 08             	mov    0x8(%ebp),%eax
  100560:	88 45 fc             	mov    %al,-0x4(%ebp)
  100563:	8a 45 fc             	mov    -0x4(%ebp),%al
  100566:	a2 00 60 10 00       	mov    %al,0x106000
  10056b:	c9                   	leave  
  10056c:	c3                   	ret    

0010056d <kprintf>:
  10056d:	55                   	push   %ebp
  10056e:	89 e5                	mov    %esp,%ebp
  100570:	83 ec 18             	sub    $0x18,%esp
  100573:	8d 45 0c             	lea    0xc(%ebp),%eax
  100576:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100579:	c7 05 0c 80 12 00 00 	movl   $0x0,0x12800c
  100580:	00 00 00 
  100583:	e9 35 01 00 00       	jmp    1006bd <kprintf+0x150>
  100588:	8b 45 08             	mov    0x8(%ebp),%eax
  10058b:	8a 00                	mov    (%eax),%al
  10058d:	3c 25                	cmp    $0x25,%al
  10058f:	0f 85 11 01 00 00    	jne    1006a6 <kprintf+0x139>
  100595:	ff 45 08             	incl   0x8(%ebp)
  100598:	8b 45 08             	mov    0x8(%ebp),%eax
  10059b:	8a 00                	mov    (%eax),%al
  10059d:	0f be c0             	movsbl %al,%eax
  1005a0:	83 f8 70             	cmp    $0x70,%eax
  1005a3:	0f 84 8a 00 00 00    	je     100633 <kprintf+0xc6>
  1005a9:	83 f8 70             	cmp    $0x70,%eax
  1005ac:	7f 2e                	jg     1005dc <kprintf+0x6f>
  1005ae:	83 f8 63             	cmp    $0x63,%eax
  1005b1:	0f 84 9c 00 00 00    	je     100653 <kprintf+0xe6>
  1005b7:	83 f8 63             	cmp    $0x63,%eax
  1005ba:	7f 16                	jg     1005d2 <kprintf+0x65>
  1005bc:	85 c0                	test   %eax,%eax
  1005be:	0f 84 08 01 00 00    	je     1006cc <kprintf+0x15f>
  1005c4:	83 f8 25             	cmp    $0x25,%eax
  1005c7:	0f 84 a6 00 00 00    	je     100673 <kprintf+0x106>
  1005cd:	e9 b1 00 00 00       	jmp    100683 <kprintf+0x116>
  1005d2:	83 f8 64             	cmp    $0x64,%eax
  1005d5:	74 39                	je     100610 <kprintf+0xa3>
  1005d7:	e9 a7 00 00 00       	jmp    100683 <kprintf+0x116>
  1005dc:	83 f8 75             	cmp    $0x75,%eax
  1005df:	74 2f                	je     100610 <kprintf+0xa3>
  1005e1:	83 f8 78             	cmp    $0x78,%eax
  1005e4:	74 4d                	je     100633 <kprintf+0xc6>
  1005e6:	83 f8 73             	cmp    $0x73,%eax
  1005e9:	0f 85 94 00 00 00    	jne    100683 <kprintf+0x116>
  1005ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005f2:	8d 50 04             	lea    0x4(%eax),%edx
  1005f5:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1005f8:	8b 00                	mov    (%eax),%eax
  1005fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1005fd:	83 ec 0c             	sub    $0xc,%esp
  100600:	ff 75 ec             	pushl  -0x14(%ebp)
  100603:	e8 73 fe ff ff       	call   10047b <kputs>
  100608:	83 c4 10             	add    $0x10,%esp
  10060b:	e9 aa 00 00 00       	jmp    1006ba <kprintf+0x14d>
  100610:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100613:	8d 50 04             	lea    0x4(%eax),%edx
  100616:	89 55 e8             	mov    %edx,-0x18(%ebp)
  100619:	8b 00                	mov    (%eax),%eax
  10061b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10061e:	83 ec 08             	sub    $0x8,%esp
  100621:	6a 0a                	push   $0xa
  100623:	ff 75 f0             	pushl  -0x10(%ebp)
  100626:	e8 7a fe ff ff       	call   1004a5 <kputn>
  10062b:	83 c4 10             	add    $0x10,%esp
  10062e:	e9 87 00 00 00       	jmp    1006ba <kprintf+0x14d>
  100633:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100636:	8d 50 04             	lea    0x4(%eax),%edx
  100639:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10063c:	8b 00                	mov    (%eax),%eax
  10063e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100641:	83 ec 08             	sub    $0x8,%esp
  100644:	6a 10                	push   $0x10
  100646:	ff 75 f0             	pushl  -0x10(%ebp)
  100649:	e8 57 fe ff ff       	call   1004a5 <kputn>
  10064e:	83 c4 10             	add    $0x10,%esp
  100651:	eb 67                	jmp    1006ba <kprintf+0x14d>
  100653:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100656:	8d 50 04             	lea    0x4(%eax),%edx
  100659:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10065c:	8b 00                	mov    (%eax),%eax
  10065e:	88 45 f7             	mov    %al,-0x9(%ebp)
  100661:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
  100665:	83 ec 0c             	sub    $0xc,%esp
  100668:	50                   	push   %eax
  100669:	e8 72 fc ff ff       	call   1002e0 <kputc>
  10066e:	83 c4 10             	add    $0x10,%esp
  100671:	eb 47                	jmp    1006ba <kprintf+0x14d>
  100673:	83 ec 0c             	sub    $0xc,%esp
  100676:	6a 25                	push   $0x25
  100678:	e8 63 fc ff ff       	call   1002e0 <kputc>
  10067d:	83 c4 10             	add    $0x10,%esp
  100680:	90                   	nop    
  100681:	eb 37                	jmp    1006ba <kprintf+0x14d>
  100683:	83 ec 0c             	sub    $0xc,%esp
  100686:	6a 25                	push   $0x25
  100688:	e8 53 fc ff ff       	call   1002e0 <kputc>
  10068d:	83 c4 10             	add    $0x10,%esp
  100690:	8b 45 08             	mov    0x8(%ebp),%eax
  100693:	8a 00                	mov    (%eax),%al
  100695:	0f be c0             	movsbl %al,%eax
  100698:	83 ec 0c             	sub    $0xc,%esp
  10069b:	50                   	push   %eax
  10069c:	e8 3f fc ff ff       	call   1002e0 <kputc>
  1006a1:	83 c4 10             	add    $0x10,%esp
  1006a4:	eb 14                	jmp    1006ba <kprintf+0x14d>
  1006a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1006a9:	8a 00                	mov    (%eax),%al
  1006ab:	0f be c0             	movsbl %al,%eax
  1006ae:	83 ec 0c             	sub    $0xc,%esp
  1006b1:	50                   	push   %eax
  1006b2:	e8 29 fc ff ff       	call   1002e0 <kputc>
  1006b7:	83 c4 10             	add    $0x10,%esp
  1006ba:	ff 45 08             	incl   0x8(%ebp)
  1006bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1006c0:	8a 00                	mov    (%eax),%al
  1006c2:	84 c0                	test   %al,%al
  1006c4:	0f 85 be fe ff ff    	jne    100588 <kprintf+0x1b>
  1006ca:	eb 01                	jmp    1006cd <kprintf+0x160>
  1006cc:	90                   	nop    
  1006cd:	a1 0c 80 12 00       	mov    0x12800c,%eax
  1006d2:	c9                   	leave  
  1006d3:	c3                   	ret    

001006d4 <load_gdt>:
#include "idt.h"
#include "kernel.h"
#include "multiboot.h"
#include "pmm.h"
#include "vfs.h"

  1006d4:	55                   	push   %ebp
  1006d5:	89 e5                	mov    %esp,%ebp
  1006d7:	83 ec 10             	sub    $0x10,%esp
#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
	clrscr();
	pmm_init(mb_info);
  1006da:	66 c7 45 fa 2f 00    	movw   $0x2f,-0x6(%ebp)
  1006e0:	c7 45 fc 80 85 16 00 	movl   $0x168580,-0x4(%ebp)

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  1006e7:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");

  1006eb:	66 b8 10 00          	mov    $0x10,%ax
	kprintf("Initializing GDT...\n");
  1006ef:	8e d8                	mov    %eax,%ds

  1006f1:	8e c0                	mov    %eax,%es
	init_gdt();
  1006f3:	8e e0                	mov    %eax,%fs

  1006f5:	8e e8                	mov    %eax,%gs
	kprintf("Initializing IDT...\n");
  1006f7:	8e d0                	mov    %eax,%ss

	init_idt();

  1006f9:	c9                   	leave  
  1006fa:	c3                   	ret    

001006fb <set_gdt_entry>:
	kprintf("Initializing Kernel...\n");

  1006fb:	55                   	push   %ebp
  1006fc:	89 e5                	mov    %esp,%ebp
  1006fe:	57                   	push   %edi
  1006ff:	56                   	push   %esi
  100700:	53                   	push   %ebx
  100701:	83 ec 4c             	sub    $0x4c,%esp
	pmm_print_stats();
  100704:	8b 45 08             	mov    0x8(%ebp),%eax
  100707:	89 45 a8             	mov    %eax,-0x58(%ebp)
  10070a:	8b 45 10             	mov    0x10(%ebp),%eax
  10070d:	ba 00 00 00 00       	mov    $0x0,%edx
  100712:	0f b7 c8             	movzwl %ax,%ecx
  100715:	89 d3                	mov    %edx,%ebx
  100717:	83 e3 00             	and    $0x0,%ebx
  10071a:	8b 55 a8             	mov    -0x58(%ebp),%edx
  10071d:	89 0c d5 80 85 16 00 	mov    %ecx,0x168580(,%edx,8)
  100724:	89 1c d5 84 85 16 00 	mov    %ebx,0x168584(,%edx,8)

  10072b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10072e:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  100731:	8b 45 08             	mov    0x8(%ebp),%eax
  100734:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  10073b:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  100742:	8b 45 0c             	mov    0xc(%ebp),%eax
  100745:	ba 00 00 00 00       	mov    $0x0,%edx
  10074a:	89 c6                	mov    %eax,%esi
  10074c:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
  100752:	89 d7                	mov    %edx,%edi
  100754:	83 e7 00             	and    $0x0,%edi
  100757:	89 f0                	mov    %esi,%eax
  100759:	89 fa                	mov    %edi,%edx
  10075b:	0f a4 c2 10          	shld   $0x10,%eax,%edx
  10075f:	c1 e0 10             	shl    $0x10,%eax
  100762:	89 ce                	mov    %ecx,%esi
  100764:	09 c6                	or     %eax,%esi
  100766:	89 75 b0             	mov    %esi,-0x50(%ebp)
  100769:	89 df                	mov    %ebx,%edi
  10076b:	09 d7                	or     %edx,%edi
  10076d:	89 7d b4             	mov    %edi,-0x4c(%ebp)
  100770:	8b 45 b0             	mov    -0x50(%ebp),%eax
  100773:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  100776:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  100779:	89 04 cd 80 85 16 00 	mov    %eax,0x168580(,%ecx,8)
  100780:	89 14 cd 84 85 16 00 	mov    %edx,0x168584(,%ecx,8)
	kernel_main(mb_info);
  100787:	8b 75 08             	mov    0x8(%ebp),%esi
  10078a:	8b 45 08             	mov    0x8(%ebp),%eax
  10078d:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  100794:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  10079b:	8b 45 14             	mov    0x14(%ebp),%eax
  10079e:	89 c2                	mov    %eax,%edx
  1007a0:	c1 fa 1f             	sar    $0x1f,%edx
  1007a3:	0f b6 f8             	movzbl %al,%edi
  1007a6:	89 7d b8             	mov    %edi,-0x48(%ebp)
  1007a9:	89 d7                	mov    %edx,%edi
  1007ab:	83 e7 00             	and    $0x0,%edi
  1007ae:	89 7d bc             	mov    %edi,-0x44(%ebp)
  1007b1:	8b 45 b8             	mov    -0x48(%ebp),%eax
  1007b4:	8b 55 bc             	mov    -0x44(%ebp),%edx
  1007b7:	89 c2                	mov    %eax,%edx
  1007b9:	b8 00 00 00 00       	mov    $0x0,%eax
  1007be:	c1 e2 08             	shl    $0x8,%edx
  1007c1:	89 cf                	mov    %ecx,%edi
  1007c3:	09 c7                	or     %eax,%edi
  1007c5:	89 7d c0             	mov    %edi,-0x40(%ebp)
  1007c8:	89 df                	mov    %ebx,%edi
  1007ca:	09 d7                	or     %edx,%edi
  1007cc:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  1007cf:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1007d2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1007d5:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  1007dc:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)

  1007e3:	8b 75 08             	mov    0x8(%ebp),%esi
  1007e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1007e9:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  1007f0:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  1007f7:	8b 45 10             	mov    0x10(%ebp),%eax
  1007fa:	c1 e8 10             	shr    $0x10,%eax
  1007fd:	ba 00 00 00 00       	mov    $0x0,%edx
  100802:	89 c7                	mov    %eax,%edi
  100804:	83 e7 0f             	and    $0xf,%edi
  100807:	89 7d c8             	mov    %edi,-0x38(%ebp)
  10080a:	89 d7                	mov    %edx,%edi
  10080c:	83 e7 00             	and    $0x0,%edi
  10080f:	89 7d cc             	mov    %edi,-0x34(%ebp)
  100812:	8b 45 c8             	mov    -0x38(%ebp),%eax
  100815:	8b 55 cc             	mov    -0x34(%ebp),%edx
  100818:	89 c2                	mov    %eax,%edx
  10081a:	b8 00 00 00 00       	mov    $0x0,%eax
  10081f:	c1 e2 10             	shl    $0x10,%edx
  100822:	89 cf                	mov    %ecx,%edi
  100824:	09 c7                	or     %eax,%edi
  100826:	89 7d d0             	mov    %edi,-0x30(%ebp)
  100829:	89 df                	mov    %ebx,%edi
  10082b:	09 d7                	or     %edx,%edi
  10082d:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  100830:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100833:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100836:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  10083d:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)
	return;
  100844:	8b 75 08             	mov    0x8(%ebp),%esi
  100847:	8b 45 08             	mov    0x8(%ebp),%eax
  10084a:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  100851:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  100858:	8b 45 14             	mov    0x14(%ebp),%eax
  10085b:	c1 f8 08             	sar    $0x8,%eax
  10085e:	89 c2                	mov    %eax,%edx
  100860:	c1 fa 1f             	sar    $0x1f,%edx
  100863:	0f b6 f8             	movzbl %al,%edi
  100866:	89 7d d8             	mov    %edi,-0x28(%ebp)
  100869:	89 d7                	mov    %edx,%edi
  10086b:	83 e7 00             	and    $0x0,%edi
  10086e:	89 7d dc             	mov    %edi,-0x24(%ebp)
  100871:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100874:	8b 55 dc             	mov    -0x24(%ebp),%edx
  100877:	89 c2                	mov    %eax,%edx
  100879:	b8 00 00 00 00       	mov    $0x0,%eax
  10087e:	c1 e2 14             	shl    $0x14,%edx
  100881:	89 cf                	mov    %ecx,%edi
  100883:	09 c7                	or     %eax,%edi
  100885:	89 7d e0             	mov    %edi,-0x20(%ebp)
  100888:	89 df                	mov    %ebx,%edi
  10088a:	09 d7                	or     %edx,%edi
  10088c:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  10088f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100892:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  100895:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  10089c:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)
}
  1008a3:	8b 75 08             	mov    0x8(%ebp),%esi
  1008a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1008a9:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  1008b0:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  1008b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1008ba:	c1 e8 18             	shr    $0x18,%eax
  1008bd:	ba 00 00 00 00       	mov    $0x0,%edx
  1008c2:	89 c2                	mov    %eax,%edx
  1008c4:	b8 00 00 00 00       	mov    $0x0,%eax
  1008c9:	c1 e2 18             	shl    $0x18,%edx
  1008cc:	89 cf                	mov    %ecx,%edi
  1008ce:	09 c7                	or     %eax,%edi
  1008d0:	89 7d e8             	mov    %edi,-0x18(%ebp)
  1008d3:	89 df                	mov    %ebx,%edi
  1008d5:	09 d7                	or     %edx,%edi
  1008d7:	89 7d ec             	mov    %edi,-0x14(%ebp)
  1008da:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1008dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1008e0:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  1008e7:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)
  1008ee:	83 c4 4c             	add    $0x4c,%esp
  1008f1:	5b                   	pop    %ebx
  1008f2:	5e                   	pop    %esi
  1008f3:	5f                   	pop    %edi
  1008f4:	5d                   	pop    %ebp
  1008f5:	c3                   	ret    

001008f6 <init_gdt>:
  1008f6:	55                   	push   %ebp
  1008f7:	89 e5                	mov    %esp,%ebp
  1008f9:	6a 00                	push   $0x0
  1008fb:	6a 00                	push   $0x0
  1008fd:	6a 00                	push   $0x0
  1008ff:	6a 00                	push   $0x0
  100901:	e8 f5 fd ff ff       	call   1006fb <set_gdt_entry>
  100906:	83 c4 10             	add    $0x10,%esp
  100909:	68 9a 0c 00 00       	push   $0xc9a
  10090e:	68 ff ff 0f 00       	push   $0xfffff
  100913:	6a 00                	push   $0x0
  100915:	6a 01                	push   $0x1
  100917:	e8 df fd ff ff       	call   1006fb <set_gdt_entry>
  10091c:	83 c4 10             	add    $0x10,%esp
  10091f:	68 92 0c 00 00       	push   $0xc92
  100924:	68 ff ff 0f 00       	push   $0xfffff
  100929:	6a 00                	push   $0x0
  10092b:	6a 02                	push   $0x2
  10092d:	e8 c9 fd ff ff       	call   1006fb <set_gdt_entry>
  100932:	83 c4 10             	add    $0x10,%esp
  100935:	68 fa 0c 00 00       	push   $0xcfa
  10093a:	68 ff ff 0f 00       	push   $0xfffff
  10093f:	6a 00                	push   $0x0
  100941:	6a 03                	push   $0x3
  100943:	e8 b3 fd ff ff       	call   1006fb <set_gdt_entry>
  100948:	83 c4 10             	add    $0x10,%esp
  10094b:	68 f2 0c 00 00       	push   $0xcf2
  100950:	68 ff ff 0f 00       	push   $0xfffff
  100955:	6a 00                	push   $0x0
  100957:	6a 04                	push   $0x4
  100959:	e8 9d fd ff ff       	call   1006fb <set_gdt_entry>
  10095e:	83 c4 10             	add    $0x10,%esp
  100961:	e8 6e fd ff ff       	call   1006d4 <load_gdt>
  100966:	c9                   	leave  
  100967:	c3                   	ret    

00100968 <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  100968:	55                   	push   %ebp
  100969:	89 e5                	mov    %esp,%ebp
  10096b:	57                   	push   %edi
  10096c:	56                   	push   %esi
  10096d:	53                   	push   %ebx
  10096e:	83 ec 34             	sub    $0x34,%esp
  100971:	8b 45 10             	mov    0x10(%ebp),%eax
  100974:	8b 55 14             	mov    0x14(%ebp),%edx
  100977:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  10097b:	88 55 d8             	mov    %dl,-0x28(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  10097e:	8b 45 0c             	mov    0xc(%ebp),%eax
  100981:	89 45 ec             	mov    %eax,-0x14(%ebp)
	idt[i] = handler & 0xffffLL;
  100984:	8b 75 08             	mov    0x8(%ebp),%esi
  100987:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10098a:	ba 00 00 00 00       	mov    $0x0,%edx
  10098f:	0f b7 c8             	movzwl %ax,%ecx
  100992:	89 d3                	mov    %edx,%ebx
  100994:	83 e3 00             	and    $0x0,%ebx
  100997:	89 0c f5 20 80 12 00 	mov    %ecx,0x128020(,%esi,8)
  10099e:	89 1c f5 24 80 12 00 	mov    %ebx,0x128024(,%esi,8)
	idt[i] |= (selector & 0xffffLL) << 16;
  1009a5:	8b 75 08             	mov    0x8(%ebp),%esi
  1009a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1009ab:	8b 0c c5 20 80 12 00 	mov    0x128020(,%eax,8),%ecx
  1009b2:	8b 1c c5 24 80 12 00 	mov    0x128024(,%eax,8),%ebx
  1009b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1009bc:	25 ff ff 00 00       	and    $0xffff,%eax
  1009c1:	ba 00 00 00 00       	mov    $0x0,%edx
  1009c6:	0f a4 c2 10          	shld   $0x10,%eax,%edx
  1009ca:	c1 e0 10             	shl    $0x10,%eax
  1009cd:	89 cf                	mov    %ecx,%edi
  1009cf:	09 c7                	or     %eax,%edi
  1009d1:	89 7d c0             	mov    %edi,-0x40(%ebp)
  1009d4:	89 df                	mov    %ebx,%edi
  1009d6:	09 d7                	or     %edx,%edi
  1009d8:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  1009db:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1009de:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1009e1:	89 04 f5 20 80 12 00 	mov    %eax,0x128020(,%esi,8)
  1009e8:	89 14 f5 24 80 12 00 	mov    %edx,0x128024(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  1009ef:	8b 75 08             	mov    0x8(%ebp),%esi
  1009f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1009f5:	8b 0c c5 20 80 12 00 	mov    0x128020(,%eax,8),%ecx
  1009fc:	8b 1c c5 24 80 12 00 	mov    0x128024(,%eax,8),%ebx
  100a03:	b8 00 00 00 00       	mov    $0x0,%eax
  100a08:	8a 45 d8             	mov    -0x28(%ebp),%al
  100a0b:	ba 00 00 00 00       	mov    $0x0,%edx
  100a10:	89 c2                	mov    %eax,%edx
  100a12:	b8 00 00 00 00       	mov    $0x0,%eax
  100a17:	c1 e2 08             	shl    $0x8,%edx
  100a1a:	89 cf                	mov    %ecx,%edi
  100a1c:	09 c7                	or     %eax,%edi
  100a1e:	89 7d c8             	mov    %edi,-0x38(%ebp)
  100a21:	89 df                	mov    %ebx,%edi
  100a23:	09 d7                	or     %edx,%edi
  100a25:	89 7d cc             	mov    %edi,-0x34(%ebp)
  100a28:	8b 45 c8             	mov    -0x38(%ebp),%eax
  100a2b:	8b 55 cc             	mov    -0x34(%ebp),%edx
  100a2e:	89 04 f5 20 80 12 00 	mov    %eax,0x128020(,%esi,8)
  100a35:	89 14 f5 24 80 12 00 	mov    %edx,0x128024(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  100a3c:	8b 75 08             	mov    0x8(%ebp),%esi
  100a3f:	8b 45 08             	mov    0x8(%ebp),%eax
  100a42:	8b 0c c5 20 80 12 00 	mov    0x128020(,%eax,8),%ecx
  100a49:	8b 1c c5 24 80 12 00 	mov    0x128024(,%eax,8),%ebx
  100a50:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100a53:	c1 e8 10             	shr    $0x10,%eax
  100a56:	ba 00 00 00 00       	mov    $0x0,%edx
  100a5b:	89 c2                	mov    %eax,%edx
  100a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  100a62:	c1 e2 10             	shl    $0x10,%edx
  100a65:	89 cf                	mov    %ecx,%edi
  100a67:	09 c7                	or     %eax,%edi
  100a69:	89 7d d0             	mov    %edi,-0x30(%ebp)
  100a6c:	89 df                	mov    %ebx,%edi
  100a6e:	09 d7                	or     %edx,%edi
  100a70:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  100a73:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100a76:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100a79:	89 04 f5 20 80 12 00 	mov    %eax,0x128020(,%esi,8)
  100a80:	89 14 f5 24 80 12 00 	mov    %edx,0x128024(,%esi,8)
}
  100a87:	83 c4 34             	add    $0x34,%esp
  100a8a:	5b                   	pop    %ebx
  100a8b:	5e                   	pop    %esi
  100a8c:	5f                   	pop    %edi
  100a8d:	5d                   	pop    %ebp
  100a8e:	c3                   	ret    

00100a8f <init_idt>:

void init_idt() {
  100a8f:	55                   	push   %ebp
  100a90:	89 e5                	mov    %esp,%ebp
  100a92:	83 ec 18             	sub    $0x18,%esp
	struct {
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };
  100a95:	66 c7 45 ee ff 01    	movw   $0x1ff,-0x12(%ebp)
  100a9b:	c7 45 f0 20 80 12 00 	movl   $0x128020,-0x10(%ebp)

	int i = 0;
  100aa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  100aa9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  100ab0:	eb 1f                	jmp    100ad1 <init_idt+0x42>
		handler_set[i] = 0;
  100ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ab5:	c7 04 85 20 83 12 00 	movl   $0x0,0x128320(,%eax,4)
  100abc:	00 00 00 00 
		irq_rpcs[i] = 0;
  100ac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ac3:	c7 04 85 20 84 12 00 	movl   $0x0,0x128420(,%eax,4)
  100aca:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  100ace:	ff 45 f4             	incl   -0xc(%ebp)
  100ad1:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
  100ad5:	7e db                	jle    100ab2 <init_idt+0x23>
		handler_set[i] = 0;
		irq_rpcs[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  100ad7:	83 ec 08             	sub    $0x8,%esp
  100ada:	6a 11                	push   $0x11
  100adc:	6a 20                	push   $0x20
  100ade:	e8 28 15 00 00       	call   10200b <outb>
  100ae3:	83 c4 10             	add    $0x10,%esp
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  100ae6:	83 ec 08             	sub    $0x8,%esp
  100ae9:	6a 20                	push   $0x20
  100aeb:	6a 21                	push   $0x21
  100aed:	e8 19 15 00 00       	call   10200b <outb>
  100af2:	83 c4 10             	add    $0x10,%esp
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  100af5:	83 ec 08             	sub    $0x8,%esp
  100af8:	6a 04                	push   $0x4
  100afa:	6a 21                	push   $0x21
  100afc:	e8 0a 15 00 00       	call   10200b <outb>
  100b01:	83 c4 10             	add    $0x10,%esp
	outb(0x21, 0x01); // ICW 4
  100b04:	83 ec 08             	sub    $0x8,%esp
  100b07:	6a 01                	push   $0x1
  100b09:	6a 21                	push   $0x21
  100b0b:	e8 fb 14 00 00       	call   10200b <outb>
  100b10:	83 c4 10             	add    $0x10,%esp

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  100b13:	83 ec 08             	sub    $0x8,%esp
  100b16:	6a 11                	push   $0x11
  100b18:	68 a0 00 00 00       	push   $0xa0
  100b1d:	e8 e9 14 00 00       	call   10200b <outb>
  100b22:	83 c4 10             	add    $0x10,%esp
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  100b25:	83 ec 08             	sub    $0x8,%esp
  100b28:	6a 28                	push   $0x28
  100b2a:	68 a1 00 00 00       	push   $0xa1
  100b2f:	e8 d7 14 00 00       	call   10200b <outb>
  100b34:	83 c4 10             	add    $0x10,%esp
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  100b37:	83 ec 08             	sub    $0x8,%esp
  100b3a:	6a 02                	push   $0x2
  100b3c:	68 a1 00 00 00       	push   $0xa1
  100b41:	e8 c5 14 00 00       	call   10200b <outb>
  100b46:	83 c4 10             	add    $0x10,%esp
	outb(0xa1, 0x01); // ICW 4
  100b49:	83 ec 08             	sub    $0x8,%esp
  100b4c:	6a 01                	push   $0x1
  100b4e:	68 a1 00 00 00       	push   $0xa1
  100b53:	e8 b3 14 00 00       	call   10200b <outb>
  100b58:	83 c4 10             	add    $0x10,%esp

	outb(0x20, 0x0);
  100b5b:	83 ec 08             	sub    $0x8,%esp
  100b5e:	6a 00                	push   $0x0
  100b60:	6a 20                	push   $0x20
  100b62:	e8 a4 14 00 00       	call   10200b <outb>
  100b67:	83 c4 10             	add    $0x10,%esp
	outb(0xa0, 0x0);
  100b6a:	83 ec 08             	sub    $0x8,%esp
  100b6d:	6a 00                	push   $0x0
  100b6f:	68 a0 00 00 00       	push   $0xa0
  100b74:	e8 92 14 00 00       	call   10200b <outb>
  100b79:	83 c4 10             	add    $0x10,%esp

	idt_set_entry(0, intr_stub_0, 0x8,
  100b7c:	b8 0c 00 10 00       	mov    $0x10000c,%eax
  100b81:	68 8e 00 00 00       	push   $0x8e
  100b86:	6a 08                	push   $0x8
  100b88:	50                   	push   %eax
  100b89:	6a 00                	push   $0x0
  100b8b:	e8 d8 fd ff ff       	call   100968 <idt_set_entry>
  100b90:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  100b93:	b8 15 00 10 00       	mov    $0x100015,%eax
  100b98:	68 8e 00 00 00       	push   $0x8e
  100b9d:	6a 08                	push   $0x8
  100b9f:	50                   	push   %eax
  100ba0:	6a 01                	push   $0x1
  100ba2:	e8 c1 fd ff ff       	call   100968 <idt_set_entry>
  100ba7:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  100baa:	b8 1e 00 10 00       	mov    $0x10001e,%eax
  100baf:	68 8e 00 00 00       	push   $0x8e
  100bb4:	6a 08                	push   $0x8
  100bb6:	50                   	push   %eax
  100bb7:	6a 02                	push   $0x2
  100bb9:	e8 aa fd ff ff       	call   100968 <idt_set_entry>
  100bbe:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  100bc1:	b8 27 00 10 00       	mov    $0x100027,%eax
  100bc6:	68 8e 00 00 00       	push   $0x8e
  100bcb:	6a 08                	push   $0x8
  100bcd:	50                   	push   %eax
  100bce:	6a 03                	push   $0x3
  100bd0:	e8 93 fd ff ff       	call   100968 <idt_set_entry>
  100bd5:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  100bd8:	b8 30 00 10 00       	mov    $0x100030,%eax
  100bdd:	68 8e 00 00 00       	push   $0x8e
  100be2:	6a 08                	push   $0x8
  100be4:	50                   	push   %eax
  100be5:	6a 04                	push   $0x4
  100be7:	e8 7c fd ff ff       	call   100968 <idt_set_entry>
  100bec:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  100bef:	b8 39 00 10 00       	mov    $0x100039,%eax
  100bf4:	68 8e 00 00 00       	push   $0x8e
  100bf9:	6a 08                	push   $0x8
  100bfb:	50                   	push   %eax
  100bfc:	6a 05                	push   $0x5
  100bfe:	e8 65 fd ff ff       	call   100968 <idt_set_entry>
  100c03:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  100c06:	b8 42 00 10 00       	mov    $0x100042,%eax
  100c0b:	68 8e 00 00 00       	push   $0x8e
  100c10:	6a 08                	push   $0x8
  100c12:	50                   	push   %eax
  100c13:	6a 06                	push   $0x6
  100c15:	e8 4e fd ff ff       	call   100968 <idt_set_entry>
  100c1a:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  100c1d:	b8 4b 00 10 00       	mov    $0x10004b,%eax
  100c22:	68 8e 00 00 00       	push   $0x8e
  100c27:	6a 08                	push   $0x8
  100c29:	50                   	push   %eax
  100c2a:	6a 07                	push   $0x7
  100c2c:	e8 37 fd ff ff       	call   100968 <idt_set_entry>
  100c31:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  100c34:	b8 54 00 10 00       	mov    $0x100054,%eax
  100c39:	68 8e 00 00 00       	push   $0x8e
  100c3e:	6a 08                	push   $0x8
  100c40:	50                   	push   %eax
  100c41:	6a 08                	push   $0x8
  100c43:	e8 20 fd ff ff       	call   100968 <idt_set_entry>
  100c48:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  100c4b:	b8 5b 00 10 00       	mov    $0x10005b,%eax
  100c50:	68 8e 00 00 00       	push   $0x8e
  100c55:	6a 08                	push   $0x8
  100c57:	50                   	push   %eax
  100c58:	6a 09                	push   $0x9
  100c5a:	e8 09 fd ff ff       	call   100968 <idt_set_entry>
  100c5f:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  100c62:	b8 64 00 10 00       	mov    $0x100064,%eax
  100c67:	68 8e 00 00 00       	push   $0x8e
  100c6c:	6a 08                	push   $0x8
  100c6e:	50                   	push   %eax
  100c6f:	6a 0a                	push   $0xa
  100c71:	e8 f2 fc ff ff       	call   100968 <idt_set_entry>
  100c76:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  100c79:	b8 6b 00 10 00       	mov    $0x10006b,%eax
  100c7e:	68 8e 00 00 00       	push   $0x8e
  100c83:	6a 08                	push   $0x8
  100c85:	50                   	push   %eax
  100c86:	6a 0b                	push   $0xb
  100c88:	e8 db fc ff ff       	call   100968 <idt_set_entry>
  100c8d:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  100c90:	b8 72 00 10 00       	mov    $0x100072,%eax
  100c95:	68 8e 00 00 00       	push   $0x8e
  100c9a:	6a 08                	push   $0x8
  100c9c:	50                   	push   %eax
  100c9d:	6a 0c                	push   $0xc
  100c9f:	e8 c4 fc ff ff       	call   100968 <idt_set_entry>
  100ca4:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  100ca7:	b8 79 00 10 00       	mov    $0x100079,%eax
  100cac:	68 8e 00 00 00       	push   $0x8e
  100cb1:	6a 08                	push   $0x8
  100cb3:	50                   	push   %eax
  100cb4:	6a 0d                	push   $0xd
  100cb6:	e8 ad fc ff ff       	call   100968 <idt_set_entry>
  100cbb:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  100cbe:	b8 80 00 10 00       	mov    $0x100080,%eax
  100cc3:	68 8e 00 00 00       	push   $0x8e
  100cc8:	6a 08                	push   $0x8
  100cca:	50                   	push   %eax
  100ccb:	6a 0e                	push   $0xe
  100ccd:	e8 96 fc ff ff       	call   100968 <idt_set_entry>
  100cd2:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  100cd5:	b8 84 00 10 00       	mov    $0x100084,%eax
  100cda:	68 8e 00 00 00       	push   $0x8e
  100cdf:	6a 08                	push   $0x8
  100ce1:	50                   	push   %eax
  100ce2:	6a 0f                	push   $0xf
  100ce4:	e8 7f fc ff ff       	call   100968 <idt_set_entry>
  100ce9:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  100cec:	b8 8a 00 10 00       	mov    $0x10008a,%eax
  100cf1:	68 8e 00 00 00       	push   $0x8e
  100cf6:	6a 08                	push   $0x8
  100cf8:	50                   	push   %eax
  100cf9:	6a 10                	push   $0x10
  100cfb:	e8 68 fc ff ff       	call   100968 <idt_set_entry>
  100d00:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  100d03:	b8 90 00 10 00       	mov    $0x100090,%eax
  100d08:	68 8e 00 00 00       	push   $0x8e
  100d0d:	6a 08                	push   $0x8
  100d0f:	50                   	push   %eax
  100d10:	6a 11                	push   $0x11
  100d12:	e8 51 fc ff ff       	call   100968 <idt_set_entry>
  100d17:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  100d1a:	b8 94 00 10 00       	mov    $0x100094,%eax
  100d1f:	68 8e 00 00 00       	push   $0x8e
  100d24:	6a 08                	push   $0x8
  100d26:	50                   	push   %eax
  100d27:	6a 12                	push   $0x12
  100d29:	e8 3a fc ff ff       	call   100968 <idt_set_entry>
  100d2e:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  100d31:	b8 9a 00 10 00       	mov    $0x10009a,%eax
  100d36:	68 8e 00 00 00       	push   $0x8e
  100d3b:	6a 08                	push   $0x8
  100d3d:	50                   	push   %eax
  100d3e:	6a 20                	push   $0x20
  100d40:	e8 23 fc ff ff       	call   100968 <idt_set_entry>
  100d45:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  100d48:	b8 a0 00 10 00       	mov    $0x1000a0,%eax
  100d4d:	68 8e 00 00 00       	push   $0x8e
  100d52:	6a 08                	push   $0x8
  100d54:	50                   	push   %eax
  100d55:	6a 21                	push   $0x21
  100d57:	e8 0c fc ff ff       	call   100968 <idt_set_entry>
  100d5c:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  100d5f:	b8 a6 00 10 00       	mov    $0x1000a6,%eax
  100d64:	68 8e 00 00 00       	push   $0x8e
  100d69:	6a 08                	push   $0x8
  100d6b:	50                   	push   %eax
  100d6c:	6a 22                	push   $0x22
  100d6e:	e8 f5 fb ff ff       	call   100968 <idt_set_entry>
  100d73:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  100d76:	b8 ac 00 10 00       	mov    $0x1000ac,%eax
  100d7b:	68 8e 00 00 00       	push   $0x8e
  100d80:	6a 08                	push   $0x8
  100d82:	50                   	push   %eax
  100d83:	6a 23                	push   $0x23
  100d85:	e8 de fb ff ff       	call   100968 <idt_set_entry>
  100d8a:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  100d8d:	b8 b2 00 10 00       	mov    $0x1000b2,%eax
  100d92:	68 8e 00 00 00       	push   $0x8e
  100d97:	6a 08                	push   $0x8
  100d99:	50                   	push   %eax
  100d9a:	6a 24                	push   $0x24
  100d9c:	e8 c7 fb ff ff       	call   100968 <idt_set_entry>
  100da1:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  100da4:	b8 b8 00 10 00       	mov    $0x1000b8,%eax
  100da9:	68 8e 00 00 00       	push   $0x8e
  100dae:	6a 08                	push   $0x8
  100db0:	50                   	push   %eax
  100db1:	6a 25                	push   $0x25
  100db3:	e8 b0 fb ff ff       	call   100968 <idt_set_entry>
  100db8:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  100dbb:	b8 be 00 10 00       	mov    $0x1000be,%eax
  100dc0:	68 8e 00 00 00       	push   $0x8e
  100dc5:	6a 08                	push   $0x8
  100dc7:	50                   	push   %eax
  100dc8:	6a 26                	push   $0x26
  100dca:	e8 99 fb ff ff       	call   100968 <idt_set_entry>
  100dcf:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  100dd2:	b8 c4 00 10 00       	mov    $0x1000c4,%eax
  100dd7:	68 8e 00 00 00       	push   $0x8e
  100ddc:	6a 08                	push   $0x8
  100dde:	50                   	push   %eax
  100ddf:	6a 27                	push   $0x27
  100de1:	e8 82 fb ff ff       	call   100968 <idt_set_entry>
  100de6:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  100de9:	b8 ca 00 10 00       	mov    $0x1000ca,%eax
  100dee:	68 8e 00 00 00       	push   $0x8e
  100df3:	6a 08                	push   $0x8
  100df5:	50                   	push   %eax
  100df6:	6a 28                	push   $0x28
  100df8:	e8 6b fb ff ff       	call   100968 <idt_set_entry>
  100dfd:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  100e00:	b8 d0 00 10 00       	mov    $0x1000d0,%eax
  100e05:	68 8e 00 00 00       	push   $0x8e
  100e0a:	6a 08                	push   $0x8
  100e0c:	50                   	push   %eax
  100e0d:	6a 29                	push   $0x29
  100e0f:	e8 54 fb ff ff       	call   100968 <idt_set_entry>
  100e14:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  100e17:	b8 d6 00 10 00       	mov    $0x1000d6,%eax
  100e1c:	68 8e 00 00 00       	push   $0x8e
  100e21:	6a 08                	push   $0x8
  100e23:	50                   	push   %eax
  100e24:	6a 2a                	push   $0x2a
  100e26:	e8 3d fb ff ff       	call   100968 <idt_set_entry>
  100e2b:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  100e2e:	b8 dc 00 10 00       	mov    $0x1000dc,%eax
  100e33:	68 8e 00 00 00       	push   $0x8e
  100e38:	6a 08                	push   $0x8
  100e3a:	50                   	push   %eax
  100e3b:	6a 2b                	push   $0x2b
  100e3d:	e8 26 fb ff ff       	call   100968 <idt_set_entry>
  100e42:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  100e45:	b8 e2 00 10 00       	mov    $0x1000e2,%eax
  100e4a:	68 8e 00 00 00       	push   $0x8e
  100e4f:	6a 08                	push   $0x8
  100e51:	50                   	push   %eax
  100e52:	6a 2c                	push   $0x2c
  100e54:	e8 0f fb ff ff       	call   100968 <idt_set_entry>
  100e59:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  100e5c:	b8 e8 00 10 00       	mov    $0x1000e8,%eax
  100e61:	68 8e 00 00 00       	push   $0x8e
  100e66:	6a 08                	push   $0x8
  100e68:	50                   	push   %eax
  100e69:	6a 2d                	push   $0x2d
  100e6b:	e8 f8 fa ff ff       	call   100968 <idt_set_entry>
  100e70:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  100e73:	b8 ee 00 10 00       	mov    $0x1000ee,%eax
  100e78:	68 8e 00 00 00       	push   $0x8e
  100e7d:	6a 08                	push   $0x8
  100e7f:	50                   	push   %eax
  100e80:	6a 2e                	push   $0x2e
  100e82:	e8 e1 fa ff ff       	call   100968 <idt_set_entry>
  100e87:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  100e8a:	b8 f4 00 10 00       	mov    $0x1000f4,%eax
  100e8f:	68 8e 00 00 00       	push   $0x8e
  100e94:	6a 08                	push   $0x8
  100e96:	50                   	push   %eax
  100e97:	6a 2f                	push   $0x2f
  100e99:	e8 ca fa ff ff       	call   100968 <idt_set_entry>
  100e9e:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  100ea1:	b8 fa 00 10 00       	mov    $0x1000fa,%eax
  100ea6:	68 ee 00 00 00       	push   $0xee
  100eab:	6a 08                	push   $0x8
  100ead:	50                   	push   %eax
  100eae:	6a 30                	push   $0x30
  100eb0:	e8 b3 fa ff ff       	call   100968 <idt_set_entry>
  100eb5:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  100eb8:	b8 20 60 10 00       	mov    $0x106020,%eax
  100ebd:	68 e9 00 00 00       	push   $0xe9
  100ec2:	68 80 00 00 00       	push   $0x80
  100ec7:	50                   	push   %eax
  100ec8:	6a 05                	push   $0x5
  100eca:	e8 2c f8 ff ff       	call   1006fb <set_gdt_entry>
  100ecf:	83 c4 10             	add    $0x10,%esp
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  100ed2:	b8 28 00 00 00       	mov    $0x28,%eax
  100ed7:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  100eda:	0f 01 5d ee          	lidtl  -0x12(%ebp)
	asm volatile("sti");
  100ede:	fb                   	sti    
}
  100edf:	c9                   	leave  
  100ee0:	c3                   	ret    

00100ee1 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  100ee1:	55                   	push   %ebp
  100ee2:	89 e5                	mov    %esp,%ebp
	handlers[i] = fn;
  100ee4:	8b 45 08             	mov    0x8(%ebp),%eax
  100ee7:	8b 55 0c             	mov    0xc(%ebp),%edx
  100eea:	89 14 85 20 82 12 00 	mov    %edx,0x128220(,%eax,4)
	handler_set[i] = 1;
  100ef1:	8b 45 08             	mov    0x8(%ebp),%eax
  100ef4:	c7 04 85 20 83 12 00 	movl   $0x1,0x128320(,%eax,4)
  100efb:	01 00 00 00 
}
  100eff:	5d                   	pop    %ebp
  100f00:	c3                   	ret    

00100f01 <register_irq_rpc>:

uint32_t register_irq_rpc(uint32_t irq) {
  100f01:	55                   	push   %ebp
  100f02:	89 e5                	mov    %esp,%ebp
  100f04:	53                   	push   %ebx
  100f05:	83 ec 04             	sub    $0x4,%esp
    if (irq >= 0x20 && irq <= 0x2f) {
  100f08:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100f0c:	76 1e                	jbe    100f2c <register_irq_rpc+0x2b>
  100f0e:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100f12:	77 18                	ja     100f2c <register_irq_rpc+0x2b>
        irq_rpcs[irq] = get_current_task()->PID;
  100f14:	8b 5d 08             	mov    0x8(%ebp),%ebx
  100f17:	e8 11 1c 00 00       	call   102b2d <get_current_task>
  100f1c:	8b 00                	mov    (%eax),%eax
  100f1e:	89 04 9d 20 84 12 00 	mov    %eax,0x128420(,%ebx,4)
        return 1;
  100f25:	b8 01 00 00 00       	mov    $0x1,%eax
  100f2a:	eb 05                	jmp    100f31 <register_irq_rpc+0x30>
    }
    return 0;
  100f2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  100f31:	83 c4 04             	add    $0x4,%esp
  100f34:	5b                   	pop    %ebx
  100f35:	5d                   	pop    %ebp
  100f36:	c3                   	ret    

00100f37 <disable_irq_rpc>:

void disable_irq_rpc(uint32_t irq) {
  100f37:	55                   	push   %ebp
  100f38:	89 e5                	mov    %esp,%ebp
    if (irq >= 0x20 && irq <= 0x2f) {
  100f3a:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100f3e:	76 2a                	jbe    100f6a <disable_irq_rpc+0x33>
  100f40:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100f44:	77 24                	ja     100f6a <disable_irq_rpc+0x33>
        if(irq_rpcs[irq] > 0) {
  100f46:	8b 45 08             	mov    0x8(%ebp),%eax
  100f49:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  100f50:	85 c0                	test   %eax,%eax
  100f52:	7e 16                	jle    100f6a <disable_irq_rpc+0x33>
            irq_rpcs[irq] = -irq_rpcs[irq];
  100f54:	8b 45 08             	mov    0x8(%ebp),%eax
  100f57:	8b 55 08             	mov    0x8(%ebp),%edx
  100f5a:	8b 14 95 20 84 12 00 	mov    0x128420(,%edx,4),%edx
  100f61:	f7 da                	neg    %edx
  100f63:	89 14 85 20 84 12 00 	mov    %edx,0x128420(,%eax,4)
        }
    }
}
  100f6a:	5d                   	pop    %ebp
  100f6b:	c3                   	ret    

00100f6c <enable_irq_rpc>:

void enable_irq_rpc(uint32_t irq) {
  100f6c:	55                   	push   %ebp
  100f6d:	89 e5                	mov    %esp,%ebp
    if (irq >= 0x20 && irq <= 0x2f) {
  100f6f:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100f73:	76 2a                	jbe    100f9f <enable_irq_rpc+0x33>
  100f75:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100f79:	77 24                	ja     100f9f <enable_irq_rpc+0x33>
        if(irq_rpcs[irq] < 0) {
  100f7b:	8b 45 08             	mov    0x8(%ebp),%eax
  100f7e:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  100f85:	85 c0                	test   %eax,%eax
  100f87:	79 16                	jns    100f9f <enable_irq_rpc+0x33>
            irq_rpcs[irq] = -irq_rpcs[irq];
  100f89:	8b 45 08             	mov    0x8(%ebp),%eax
  100f8c:	8b 55 08             	mov    0x8(%ebp),%edx
  100f8f:	8b 14 95 20 84 12 00 	mov    0x128420(,%edx,4),%edx
  100f96:	f7 da                	neg    %edx
  100f98:	89 14 85 20 84 12 00 	mov    %edx,0x128420(,%eax,4)
        }
    }
}
  100f9f:	5d                   	pop    %ebp
  100fa0:	c3                   	ret    

00100fa1 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  100fa1:	55                   	push   %ebp
  100fa2:	89 e5                	mov    %esp,%ebp
  100fa4:	83 ec 18             	sub    $0x18,%esp
	struct cpu_state* new_cpu = cpu;
  100fa7:	8b 45 08             	mov    0x8(%ebp),%eax
  100faa:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (cpu->intr <= 0x1f) {
  100fad:	8b 45 08             	mov    0x8(%ebp),%eax
  100fb0:	8b 40 1c             	mov    0x1c(%eax),%eax
  100fb3:	83 f8 1f             	cmp    $0x1f,%eax
  100fb6:	77 37                	ja     100fef <handle_interrupt+0x4e>
		if (!isSchedulingEnabled()) {
  100fb8:	e8 66 1b 00 00       	call   102b23 <isSchedulingEnabled>
  100fbd:	85 c0                	test   %eax,%eax
  100fbf:	75 18                	jne    100fd9 <handle_interrupt+0x38>
			show_cod(cpu, "Kernel PANIC!");
  100fc1:	83 ec 08             	sub    $0x8,%esp
  100fc4:	68 7d 71 10 00       	push   $0x10717d
  100fc9:	ff 75 08             	pushl  0x8(%ebp)
  100fcc:	e8 05 f2 ff ff       	call   1001d6 <show_cod>
  100fd1:	83 c4 10             	add    $0x10,%esp
		} else {
			new_cpu = schedule_exception(cpu);
  100fd4:	e9 08 01 00 00       	jmp    1010e1 <handle_interrupt+0x140>
  100fd9:	83 ec 0c             	sub    $0xc,%esp
  100fdc:	ff 75 08             	pushl  0x8(%ebp)
  100fdf:	e8 80 1c 00 00       	call   102c64 <schedule_exception>
  100fe4:	83 c4 10             	add    $0x10,%esp
  100fe7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100fea:	e9 f2 00 00 00       	jmp    1010e1 <handle_interrupt+0x140>
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  100fef:	8b 45 08             	mov    0x8(%ebp),%eax
  100ff2:	8b 40 1c             	mov    0x1c(%eax),%eax
  100ff5:	83 f8 1f             	cmp    $0x1f,%eax
  100ff8:	0f 86 b2 00 00 00    	jbe    1010b0 <handle_interrupt+0x10f>
  100ffe:	8b 45 08             	mov    0x8(%ebp),%eax
  101001:	8b 40 1c             	mov    0x1c(%eax),%eax
  101004:	83 f8 2f             	cmp    $0x2f,%eax
  101007:	0f 87 a3 00 00 00    	ja     1010b0 <handle_interrupt+0x10f>
		if (cpu->intr >= 0x28) {
  10100d:	8b 45 08             	mov    0x8(%ebp),%eax
  101010:	8b 40 1c             	mov    0x1c(%eax),%eax
  101013:	83 f8 27             	cmp    $0x27,%eax
  101016:	76 12                	jbe    10102a <handle_interrupt+0x89>
			outb(0xa0, 0x20);
  101018:	83 ec 08             	sub    $0x8,%esp
  10101b:	6a 20                	push   $0x20
  10101d:	68 a0 00 00 00       	push   $0xa0
  101022:	e8 e4 0f 00 00       	call   10200b <outb>
  101027:	83 c4 10             	add    $0x10,%esp
		}

		if (cpu->intr == 0x20) {
  10102a:	8b 45 08             	mov    0x8(%ebp),%eax
  10102d:	8b 40 1c             	mov    0x1c(%eax),%eax
  101030:	83 f8 20             	cmp    $0x20,%eax
  101033:	75 13                	jne    101048 <handle_interrupt+0xa7>
			new_cpu = schedule(cpu);
  101035:	83 ec 0c             	sub    $0xc,%esp
  101038:	ff 75 08             	pushl  0x8(%ebp)
  10103b:	e8 65 20 00 00       	call   1030a5 <schedule>
  101040:	83 c4 10             	add    $0x10,%esp
  101043:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101046:	eb 57                	jmp    10109f <handle_interrupt+0xfe>
		}
		else
		{
            if (handler_set[cpu->intr]) {
  101048:	8b 45 08             	mov    0x8(%ebp),%eax
  10104b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10104e:	8b 04 85 20 83 12 00 	mov    0x128320(,%eax,4),%eax
  101055:	85 c0                	test   %eax,%eax
  101057:	74 0f                	je     101068 <handle_interrupt+0xc7>
                handlers[cpu->intr]();
  101059:	8b 45 08             	mov    0x8(%ebp),%eax
  10105c:	8b 40 1c             	mov    0x1c(%eax),%eax
  10105f:	8b 04 85 20 82 12 00 	mov    0x128220(,%eax,4),%eax
  101066:	ff d0                	call   *%eax
            }
            if(irq_rpcs[cpu->intr] > 0) {
  101068:	8b 45 08             	mov    0x8(%ebp),%eax
  10106b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10106e:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  101075:	85 c0                	test   %eax,%eax
  101077:	7e 26                	jle    10109f <handle_interrupt+0xfe>
                create_rpc_call(irq_rpcs[cpu->intr], RPCT_IRQ, cpu->intr, 0, 0);
  101079:	8b 45 08             	mov    0x8(%ebp),%eax
  10107c:	8b 50 1c             	mov    0x1c(%eax),%edx
  10107f:	8b 45 08             	mov    0x8(%ebp),%eax
  101082:	8b 40 1c             	mov    0x1c(%eax),%eax
  101085:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  10108c:	83 ec 0c             	sub    $0xc,%esp
  10108f:	6a 00                	push   $0x0
  101091:	6a 00                	push   $0x0
  101093:	52                   	push   %edx
  101094:	6a 00                	push   $0x0
  101096:	50                   	push   %eax
  101097:	e8 77 21 00 00       	call   103213 <create_rpc_call>
  10109c:	83 c4 20             	add    $0x20,%esp
                //disable_irq_rpc(cpu->intr); TODO find out if we need to block
            }
		}

        outb(0x20, 0x20);
  10109f:	83 ec 08             	sub    $0x8,%esp
  1010a2:	6a 20                	push   $0x20
  1010a4:	6a 20                	push   $0x20
  1010a6:	e8 60 0f 00 00       	call   10200b <outb>
  1010ab:	83 c4 10             	add    $0x10,%esp
		if (!isSchedulingEnabled()) {
			show_cod(cpu, "Kernel PANIC!");
		} else {
			new_cpu = schedule_exception(cpu);
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  1010ae:	eb 31                	jmp    1010e1 <handle_interrupt+0x140>
                //disable_irq_rpc(cpu->intr); TODO find out if we need to block
            }
		}

        outb(0x20, 0x20);
	} else if (cpu->intr == 0x30) {
  1010b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1010b3:	8b 40 1c             	mov    0x1c(%eax),%eax
  1010b6:	83 f8 30             	cmp    $0x30,%eax
  1010b9:	75 13                	jne    1010ce <handle_interrupt+0x12d>
		new_cpu = syscall(new_cpu);
  1010bb:	83 ec 0c             	sub    $0xc,%esp
  1010be:	ff 75 f4             	pushl  -0xc(%ebp)
  1010c1:	e8 22 00 00 00       	call   1010e8 <syscall>
  1010c6:	83 c4 10             	add    $0x10,%esp
  1010c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1010cc:	eb 13                	jmp    1010e1 <handle_interrupt+0x140>
	} else {
		show_cod(cpu, "Unknown Interrupt!");
  1010ce:	83 ec 08             	sub    $0x8,%esp
  1010d1:	68 8b 71 10 00       	push   $0x10718b
  1010d6:	ff 75 08             	pushl  0x8(%ebp)
  1010d9:	e8 f8 f0 ff ff       	call   1001d6 <show_cod>
  1010de:	83 c4 10             	add    $0x10,%esp
	}

	return new_cpu;
  1010e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  1010e4:	c9                   	leave  
  1010e5:	c3                   	ret    
	...

001010e8 <syscall>:

extern uint8_t* interrupt_stack;

static uint32_t tss[32] = { 0, (uint32_t) &interrupt_stack, 0x10 };

static uint64_t idt[IDT_ENTRIES];
  1010e8:	55                   	push   %ebp
  1010e9:	89 e5                	mov    %esp,%ebp
  1010eb:	53                   	push   %ebx
  1010ec:	83 ec 64             	sub    $0x64,%esp
static void (*handlers[IDT_ENTRIES])();
  1010ef:	83 ec 0c             	sub    $0xc,%esp
  1010f2:	ff 75 08             	pushl  0x8(%ebp)
  1010f5:	e8 e6 1e 00 00       	call   102fe0 <save_cpu_state>
  1010fa:	83 c4 10             	add    $0x10,%esp
  1010fd:	89 45 08             	mov    %eax,0x8(%ebp)
static int handler_set[IDT_ENTRIES];

  101100:	8b 45 08             	mov    0x8(%ebp),%eax
  101103:	8b 00                	mov    (%eax),%eax
  101105:	3d cd 00 00 00       	cmp    $0xcd,%eax
  10110a:	0f 87 28 07 00 00    	ja     101838 <syscall+0x750>
  101110:	8b 04 85 bc 71 10 00 	mov    0x1071bc(,%eax,4),%eax
  101117:	ff e0                	jmp    *%eax
static int irq_rpcs[IDT_ENTRIES];

  101119:	83 ec 0c             	sub    $0xc,%esp
  10111c:	ff 75 08             	pushl  0x8(%ebp)
  10111f:	e8 32 1c 00 00       	call   102d56 <terminate_current>
  101124:	83 c4 10             	add    $0x10,%esp
  101127:	e9 34 07 00 00       	jmp    101860 <syscall+0x778>
extern void intr_stub_0(void);
extern void intr_stub_1(void);
extern void intr_stub_2(void);
extern void intr_stub_3(void);
  10112c:	8b 45 08             	mov    0x8(%ebp),%eax
  10112f:	8b 40 04             	mov    0x4(%eax),%eax
  101132:	83 ec 0c             	sub    $0xc,%esp
  101135:	50                   	push   %eax
  101136:	e8 fc 19 00 00       	call   102b37 <get_task_by_pid>
  10113b:	83 c4 10             	add    $0x10,%esp
  10113e:	89 c2                	mov    %eax,%edx
  101140:	8b 45 08             	mov    0x8(%ebp),%eax
  101143:	89 10                	mov    %edx,(%eax)
extern void intr_stub_4(void);
extern void intr_stub_5(void);
  101145:	e9 13 07 00 00       	jmp    10185d <syscall+0x775>
extern void intr_stub_6(void);
extern void intr_stub_7(void);
extern void intr_stub_8(void);
extern void intr_stub_9(void);
  10114a:	8b 45 08             	mov    0x8(%ebp),%eax
  10114d:	8b 40 04             	mov    0x4(%eax),%eax
  101150:	83 ec 0c             	sub    $0xc,%esp
  101153:	50                   	push   %eax
  101154:	e8 97 29 00 00       	call   103af0 <strclone>
  101159:	83 c4 10             	add    $0x10,%esp
  10115c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
extern void intr_stub_10(void);
extern void intr_stub_11(void);
  10115f:	8b 45 08             	mov    0x8(%ebp),%eax
  101162:	8b 40 0c             	mov    0xc(%eax),%eax
  101165:	89 c2                	mov    %eax,%edx
  101167:	8b 45 08             	mov    0x8(%ebp),%eax
  10116a:	8b 40 08             	mov    0x8(%eax),%eax
  10116d:	83 ec 04             	sub    $0x4,%esp
  101170:	52                   	push   %edx
  101171:	6a 00                	push   $0x0
  101173:	6a 00                	push   $0x0
  101175:	6a 00                	push   $0x0
  101177:	6a 00                	push   $0x0
  101179:	50                   	push   %eax
  10117a:	ff 75 a4             	pushl  -0x5c(%ebp)
  10117d:	e8 25 33 00 00       	call   1044a7 <vfs_exec>
  101182:	83 c4 20             	add    $0x20,%esp
  101185:	8b 55 08             	mov    0x8(%ebp),%edx
  101188:	89 02                	mov    %eax,(%edx)
extern void intr_stub_12(void);
extern void intr_stub_13(void);
  10118a:	83 ec 0c             	sub    $0xc,%esp
  10118d:	ff 75 a4             	pushl  -0x5c(%ebp)
  101190:	e8 57 27 00 00       	call   1038ec <free>
  101195:	83 c4 10             	add    $0x10,%esp
extern void intr_stub_14(void);
extern void intr_stub_15(void);
  101198:	8b 45 08             	mov    0x8(%ebp),%eax
  10119b:	8b 40 0c             	mov    0xc(%eax),%eax
  10119e:	85 c0                	test   %eax,%eax
  1011a0:	0f 84 aa 06 00 00    	je     101850 <syscall+0x768>
extern void intr_stub_16(void);
  1011a6:	83 ec 0c             	sub    $0xc,%esp
  1011a9:	ff 75 08             	pushl  0x8(%ebp)
  1011ac:	e8 f4 1e 00 00       	call   1030a5 <schedule>
  1011b1:	83 c4 10             	add    $0x10,%esp
  1011b4:	89 45 08             	mov    %eax,0x8(%ebp)
extern void intr_stub_17(void);
extern void intr_stub_18(void);

  1011b7:	e9 a1 06 00 00       	jmp    10185d <syscall+0x775>
extern void intr_stub_32(void);
extern void intr_stub_33(void);
extern void intr_stub_34(void);
extern void intr_stub_35(void);
  1011bc:	e8 6c 19 00 00       	call   102b2d <get_current_task>
  1011c1:	8b 40 20             	mov    0x20(%eax),%eax
  1011c4:	89 c2                	mov    %eax,%edx
  1011c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1011c9:	89 10                	mov    %edx,(%eax)
extern void intr_stub_36(void);
extern void intr_stub_37(void);
  1011cb:	e9 8d 06 00 00       	jmp    10185d <syscall+0x775>
extern void intr_stub_38(void);
extern void intr_stub_39(void);
extern void intr_stub_40(void);
extern void intr_stub_41(void);
  1011d0:	83 ec 0c             	sub    $0xc,%esp
  1011d3:	ff 75 08             	pushl  0x8(%ebp)
  1011d6:	e8 ca 1e 00 00       	call   1030a5 <schedule>
  1011db:	83 c4 10             	add    $0x10,%esp
  1011de:	89 45 08             	mov    %eax,0x8(%ebp)
extern void intr_stub_42(void);
extern void intr_stub_43(void);
  1011e1:	e9 77 06 00 00       	jmp    10185d <syscall+0x775>
extern void intr_stub_44(void);
extern void intr_stub_45(void);
extern void intr_stub_46(void);
extern void intr_stub_47(void);
  1011e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1011e9:	8b 40 04             	mov    0x4(%eax),%eax
  1011ec:	89 45 a8             	mov    %eax,-0x58(%ebp)

  1011ef:	e8 39 19 00 00       	call   102b2d <get_current_task>
  1011f4:	8b 40 28             	mov    0x28(%eax),%eax
  1011f7:	85 c0                	test   %eax,%eax
  1011f9:	0f 84 54 06 00 00    	je     101853 <syscall+0x76b>
  1011ff:	e8 29 19 00 00       	call   102b2d <get_current_task>
  101204:	8b 40 28             	mov    0x28(%eax),%eax
  101207:	83 ec 08             	sub    $0x8,%esp
  10120a:	50                   	push   %eax
  10120b:	ff 75 a8             	pushl  -0x58(%ebp)
  10120e:	e8 ba 28 00 00       	call   103acd <strcpy>
  101213:	83 c4 10             	add    $0x10,%esp
extern void intr_stub_48(void);

  101216:	e9 42 06 00 00       	jmp    10185d <syscall+0x775>
void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
	unsigned long int handler = (unsigned long int) fn;
	idt[i] = handler & 0xffffLL;
	idt[i] |= (selector & 0xffffLL) << 16;
  10121b:	e8 a0 2a 00 00       	call   103cc0 <vfs_reset_error>
	idt[i] |= (flags & 0xffLL) << 40;
  101220:	8b 45 08             	mov    0x8(%ebp),%eax
  101223:	8b 40 04             	mov    0x4(%eax),%eax
  101226:	83 ec 0c             	sub    $0xc,%esp
  101229:	50                   	push   %eax
  10122a:	e8 c1 28 00 00       	call   103af0 <strclone>
  10122f:	83 c4 10             	add    $0x10,%esp
  101232:	89 45 ac             	mov    %eax,-0x54(%ebp)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
}
  101235:	e8 f3 18 00 00       	call   102b2d <get_current_task>
  10123a:	8b 40 28             	mov    0x28(%eax),%eax
  10123d:	85 c0                	test   %eax,%eax
  10123f:	74 14                	je     101255 <syscall+0x16d>
  101241:	e8 e7 18 00 00       	call   102b2d <get_current_task>
  101246:	8b 40 28             	mov    0x28(%eax),%eax
  101249:	83 ec 0c             	sub    $0xc,%esp
  10124c:	50                   	push   %eax
  10124d:	e8 9a 26 00 00       	call   1038ec <free>
  101252:	83 c4 10             	add    $0x10,%esp

void init_idt() {
  101255:	83 ec 0c             	sub    $0xc,%esp
  101258:	ff 75 ac             	pushl  -0x54(%ebp)
  10125b:	e8 55 37 00 00       	call   1049b5 <vfs_resolve_path>
  101260:	83 c4 10             	add    $0x10,%esp
  101263:	89 45 b0             	mov    %eax,-0x50(%ebp)
	struct {
		unsigned short int limit;
  101266:	8b 45 08             	mov    0x8(%ebp),%eax
  101269:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		void* pointer;
  10126f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  101273:	74 14                	je     101289 <syscall+0x1a1>
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
  101275:	e8 b3 18 00 00       	call   102b2d <get_current_task>
  10127a:	8b 55 b0             	mov    -0x50(%ebp),%edx
  10127d:	89 50 28             	mov    %edx,0x28(%eax)
			idt, };
  101280:	8b 45 08             	mov    0x8(%ebp),%eax
  101283:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	int i = 0;

  101289:	83 ec 0c             	sub    $0xc,%esp
  10128c:	ff 75 ac             	pushl  -0x54(%ebp)
  10128f:	e8 58 26 00 00       	call   1038ec <free>
  101294:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < IDT_ENTRIES; i++) {
		handler_set[i] = 0;
  101297:	e9 c1 05 00 00       	jmp    10185d <syscall+0x775>
		irq_rpcs[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  10129c:	e8 1f 2a 00 00       	call   103cc0 <vfs_reset_error>
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  1012a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1012a4:	8b 40 04             	mov    0x4(%eax),%eax
  1012a7:	83 ec 0c             	sub    $0xc,%esp
  1012aa:	50                   	push   %eax
  1012ab:	e8 40 28 00 00       	call   103af0 <strclone>
  1012b0:	83 c4 10             	add    $0x10,%esp
  1012b3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  1012b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1012b9:	8b 40 08             	mov    0x8(%eax),%eax
  1012bc:	89 45 b8             	mov    %eax,-0x48(%ebp)
	outb(0x21, 0x01); // ICW 4

  1012bf:	83 ec 08             	sub    $0x8,%esp
  1012c2:	ff 75 b8             	pushl  -0x48(%ebp)
  1012c5:	ff 75 b4             	pushl  -0x4c(%ebp)
  1012c8:	e8 a0 2f 00 00       	call   10426d <vfs_open>
  1012cd:	83 c4 10             	add    $0x10,%esp
  1012d0:	89 45 bc             	mov    %eax,-0x44(%ebp)
	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  1012d3:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  1012d7:	74 18                	je     1012f1 <syscall+0x209>
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  1012d9:	83 ec 0c             	sub    $0xc,%esp
  1012dc:	ff 75 bc             	pushl  -0x44(%ebp)
  1012df:	e8 88 18 00 00       	call   102b6c <register_handle>
  1012e4:	83 c4 10             	add    $0x10,%esp
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  1012e7:	8b 55 bc             	mov    -0x44(%ebp),%edx
  1012ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1012ed:	89 10                	mov    %edx,(%eax)
  1012ef:	eb 09                	jmp    1012fa <syscall+0x212>
	outb(0xa1, 0x01); // ICW 4

	outb(0x20, 0x0);
	outb(0xa0, 0x0);
  1012f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1012f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	idt_set_entry(0, intr_stub_0, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  1012fa:	83 ec 0c             	sub    $0xc,%esp
  1012fd:	ff 75 b4             	pushl  -0x4c(%ebp)
  101300:	e8 e7 25 00 00       	call   1038ec <free>
  101305:	83 c4 10             	add    $0x10,%esp
	idt_set_entry(1, intr_stub_1, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101308:	e9 50 05 00 00       	jmp    10185d <syscall+0x775>
	idt_set_entry(2, intr_stub_2, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  10130d:	e8 ae 29 00 00       	call   103cc0 <vfs_reset_error>
	idt_set_entry(4, intr_stub_4, 0x8,
  101312:	8b 45 08             	mov    0x8(%ebp),%eax
  101315:	8b 40 04             	mov    0x4(%eax),%eax
  101318:	89 45 c0             	mov    %eax,-0x40(%ebp)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  10131b:	83 ec 0c             	sub    $0xc,%esp
  10131e:	ff 75 c0             	pushl  -0x40(%ebp)
  101321:	e8 93 18 00 00       	call   102bb9 <unregister_handle>
  101326:	83 c4 10             	add    $0x10,%esp
  101329:	85 c0                	test   %eax,%eax
  10132b:	75 1c                	jne    101349 <syscall+0x261>
	idt_set_entry(5, intr_stub_5, 0x8,
  10132d:	83 ec 0c             	sub    $0xc,%esp
  101330:	ff 75 c0             	pushl  -0x40(%ebp)
  101333:	e8 92 2f 00 00       	call   1042ca <vfs_close>
  101338:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  10133b:	8b 45 08             	mov    0x8(%ebp),%eax
  10133e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	idt_set_entry(7, intr_stub_7, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101344:	e9 14 05 00 00       	jmp    10185d <syscall+0x775>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  101349:	8b 45 08             	mov    0x8(%ebp),%eax
  10134c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101352:	e9 06 05 00 00       	jmp    10185d <syscall+0x775>
	idt_set_entry(10, intr_stub_10, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101357:	e8 64 29 00 00       	call   103cc0 <vfs_reset_error>
	idt_set_entry(12, intr_stub_12, 0x8,
  10135c:	8b 45 08             	mov    0x8(%ebp),%eax
  10135f:	8b 40 04             	mov    0x4(%eax),%eax
  101362:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101365:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  101369:	74 25                	je     101390 <syscall+0x2a8>
	idt_set_entry(13, intr_stub_13, 0x8,
  10136b:	8b 45 08             	mov    0x8(%ebp),%eax
  10136e:	8b 50 0c             	mov    0xc(%eax),%edx
  101371:	8b 45 08             	mov    0x8(%ebp),%eax
  101374:	8b 40 08             	mov    0x8(%eax),%eax
  101377:	6a 01                	push   $0x1
  101379:	52                   	push   %edx
  10137a:	50                   	push   %eax
  10137b:	ff 75 c4             	pushl  -0x3c(%ebp)
  10137e:	e8 06 30 00 00       	call   104389 <vfs_write>
  101383:	83 c4 10             	add    $0x10,%esp
  101386:	8b 55 08             	mov    0x8(%ebp),%edx
  101389:	89 02                	mov    %eax,(%edx)
	idt_set_entry(14, intr_stub_14, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  10138b:	e9 cd 04 00 00       	jmp    10185d <syscall+0x775>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  101390:	8b 45 08             	mov    0x8(%ebp),%eax
  101393:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101399:	e9 bf 04 00 00       	jmp    10185d <syscall+0x775>
	idt_set_entry(17, intr_stub_17, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  10139e:	e8 1d 29 00 00       	call   103cc0 <vfs_reset_error>

  1013a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1013a6:	8b 40 04             	mov    0x4(%eax),%eax
  1013a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
	idt_set_entry(32, intr_stub_32, 0x8,
  1013ac:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  1013b0:	74 25                	je     1013d7 <syscall+0x2ef>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  1013b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1013b5:	8b 50 0c             	mov    0xc(%eax),%edx
  1013b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1013bb:	8b 40 08             	mov    0x8(%eax),%eax
  1013be:	6a 01                	push   $0x1
  1013c0:	52                   	push   %edx
  1013c1:	50                   	push   %eax
  1013c2:	ff 75 c8             	pushl  -0x38(%ebp)
  1013c5:	e8 36 2f 00 00       	call   104300 <vfs_read>
  1013ca:	83 c4 10             	add    $0x10,%esp
  1013cd:	8b 55 08             	mov    0x8(%ebp),%edx
  1013d0:	89 02                	mov    %eax,(%edx)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  1013d2:	e9 86 04 00 00       	jmp    10185d <syscall+0x775>
	idt_set_entry(32, intr_stub_32, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  1013d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1013da:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	idt_set_entry(35, intr_stub_35, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  1013e0:	e9 78 04 00 00       	jmp    10185d <syscall+0x775>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  1013e5:	e8 d6 28 00 00       	call   103cc0 <vfs_reset_error>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  1013ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1013ed:	8b 40 04             	mov    0x4(%eax),%eax
  1013f0:	83 ec 0c             	sub    $0xc,%esp
  1013f3:	50                   	push   %eax
  1013f4:	e8 f7 26 00 00       	call   103af0 <strclone>
  1013f9:	83 c4 10             	add    $0x10,%esp
  1013fc:	89 45 cc             	mov    %eax,-0x34(%ebp)
	idt_set_entry(39, intr_stub_39, 0x8,
  1013ff:	c7 45 a0 00 10 00 00 	movl   $0x1000,-0x60(%ebp)
  101406:	e8 9c 0f 00 00       	call   1023a7 <ramfs_fifo_driver_struct>
  10140b:	83 ec 04             	sub    $0x4,%esp
  10140e:	8d 55 a0             	lea    -0x60(%ebp),%edx
  101411:	52                   	push   %edx
  101412:	50                   	push   %eax
  101413:	ff 75 cc             	pushl  -0x34(%ebp)
  101416:	e8 b3 2d 00 00       	call   1041ce <vfs_create_kfile>
  10141b:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  10141e:	83 ec 08             	sub    $0x8,%esp
  101421:	6a 03                	push   $0x3
  101423:	ff 75 cc             	pushl  -0x34(%ebp)
  101426:	e8 42 2e 00 00       	call   10426d <vfs_open>
  10142b:	83 c4 10             	add    $0x10,%esp
  10142e:	89 45 d0             	mov    %eax,-0x30(%ebp)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101431:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  101435:	74 18                	je     10144f <syscall+0x367>
	idt_set_entry(41, intr_stub_41, 0x8,
  101437:	83 ec 0c             	sub    $0xc,%esp
  10143a:	ff 75 d0             	pushl  -0x30(%ebp)
  10143d:	e8 2a 17 00 00       	call   102b6c <register_handle>
  101442:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101445:	8b 55 d0             	mov    -0x30(%ebp),%edx
  101448:	8b 45 08             	mov    0x8(%ebp),%eax
  10144b:	89 10                	mov    %edx,(%eax)
  10144d:	eb 09                	jmp    101458 <syscall+0x370>
	idt_set_entry(42, intr_stub_42, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  10144f:	8b 45 08             	mov    0x8(%ebp),%eax
  101452:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	idt_set_entry(44, intr_stub_44, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  101458:	83 ec 0c             	sub    $0xc,%esp
  10145b:	ff 75 cc             	pushl  -0x34(%ebp)
  10145e:	e8 89 24 00 00       	call   1038ec <free>
  101463:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  101466:	e9 f2 03 00 00       	jmp    10185d <syscall+0x775>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

  10146b:	e8 bd 16 00 00       	call   102b2d <get_current_task>
  101470:	8b 50 2c             	mov    0x2c(%eax),%edx
  101473:	8b 45 08             	mov    0x8(%ebp),%eax
  101476:	89 10                	mov    %edx,(%eax)
	idt_set_entry(48, intr_stub_48, 0x8,
  101478:	e8 43 28 00 00       	call   103cc0 <vfs_reset_error>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

  10147d:	e9 db 03 00 00       	jmp    10185d <syscall+0x775>
	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101482:	8b 45 08             	mov    0x8(%ebp),%eax
  101485:	8b 40 04             	mov    0x4(%eax),%eax
  101488:	83 ec 0c             	sub    $0xc,%esp
  10148b:	50                   	push   %eax
  10148c:	e8 82 2f 00 00       	call   104413 <vfs_available>
  101491:	83 c4 10             	add    $0x10,%esp
  101494:	8b 55 08             	mov    0x8(%ebp),%edx
  101497:	89 02                	mov    %eax,(%edx)

	asm volatile("lidt %0" : : "m" (idtp));
  101499:	e9 bf 03 00 00       	jmp    10185d <syscall+0x775>
	asm volatile("sti");
}

void register_intr_handler(int i, void (*fn)()) {
  10149e:	8b 45 08             	mov    0x8(%ebp),%eax
  1014a1:	8b 40 04             	mov    0x4(%eax),%eax
  1014a4:	83 ec 0c             	sub    $0xc,%esp
  1014a7:	50                   	push   %eax
  1014a8:	e8 88 2c 00 00       	call   104135 <vfs_get_child_of_exec_path>
  1014ad:	83 c4 10             	add    $0x10,%esp
  1014b0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	handlers[i] = fn;
	handler_set[i] = 1;
  1014b3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  1014b7:	74 3e                	je     1014f7 <syscall+0x40f>
  1014b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1014bc:	8b 40 08             	mov    0x8(%eax),%eax
  1014bf:	85 c0                	test   %eax,%eax
  1014c1:	74 34                	je     1014f7 <syscall+0x40f>
}
  1014c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1014c6:	8b 40 08             	mov    0x8(%eax),%eax
  1014c9:	83 ec 08             	sub    $0x8,%esp
  1014cc:	ff 75 d4             	pushl  -0x2c(%ebp)
  1014cf:	50                   	push   %eax
  1014d0:	e8 f8 25 00 00       	call   103acd <strcpy>
  1014d5:	83 c4 10             	add    $0x10,%esp

  1014d8:	83 ec 0c             	sub    $0xc,%esp
  1014db:	ff 75 d4             	pushl  -0x2c(%ebp)
  1014de:	e8 09 24 00 00       	call   1038ec <free>
  1014e3:	83 c4 10             	add    $0x10,%esp
uint32_t register_irq_rpc(uint32_t irq) {
    if (irq >= 0x20 && irq <= 0x2f) {
  1014e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1014e9:	8b 50 08             	mov    0x8(%eax),%edx
  1014ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1014ef:	89 10                	mov    %edx,(%eax)
	asm volatile("sti");
}

void register_intr_handler(int i, void (*fn)()) {
	handlers[i] = fn;
	handler_set[i] = 1;
  1014f1:	90                   	nop    
        return 1;
    }
    return 0;
}

void disable_irq_rpc(uint32_t irq) {
  1014f2:	e9 66 03 00 00       	jmp    10185d <syscall+0x775>
uint32_t register_irq_rpc(uint32_t irq) {
    if (irq >= 0x20 && irq <= 0x2f) {
        irq_rpcs[irq] = get_current_task()->PID;
        return 1;
    }
    return 0;
  1014f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1014fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}

void disable_irq_rpc(uint32_t irq) {
  101500:	e9 58 03 00 00       	jmp    10185d <syscall+0x775>
    if (irq >= 0x20 && irq <= 0x2f) {
        if(irq_rpcs[irq] > 0) {
            irq_rpcs[irq] = -irq_rpcs[irq];
        }
  101505:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    }
}
  10150c:	8b 45 08             	mov    0x8(%ebp),%eax
  10150f:	8b 40 04             	mov    0x4(%eax),%eax
  101512:	83 f8 02             	cmp    $0x2,%eax
  101515:	74 17                	je     10152e <syscall+0x446>
  101517:	83 f8 03             	cmp    $0x3,%eax
  10151a:	74 1f                	je     10153b <syscall+0x453>
  10151c:	83 f8 01             	cmp    $0x1,%eax
  10151f:	75 27                	jne    101548 <syscall+0x460>

void enable_irq_rpc(uint32_t irq) {
  101521:	e8 07 16 00 00       	call   102b2d <get_current_task>
  101526:	8b 40 30             	mov    0x30(%eax),%eax
  101529:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (irq >= 0x20 && irq <= 0x2f) {
  10152c:	eb 25                	jmp    101553 <syscall+0x46b>
        if(irq_rpcs[irq] < 0) {
            irq_rpcs[irq] = -irq_rpcs[irq];
  10152e:	e8 fa 15 00 00       	call   102b2d <get_current_task>
  101533:	8b 40 38             	mov    0x38(%eax),%eax
  101536:	89 45 d8             	mov    %eax,-0x28(%ebp)
        }
  101539:	eb 18                	jmp    101553 <syscall+0x46b>
    }
}
  10153b:	e8 ed 15 00 00       	call   102b2d <get_current_task>
  101540:	8b 40 34             	mov    0x34(%eax),%eax
  101543:	89 45 d8             	mov    %eax,-0x28(%ebp)

  101546:	eb 0b                	jmp    101553 <syscall+0x46b>
struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
	struct cpu_state* new_cpu = cpu;
  101548:	e8 e0 15 00 00       	call   102b2d <get_current_task>
  10154d:	8b 40 30             	mov    0x30(%eax),%eax
  101550:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (cpu->intr <= 0x1f) {
		if (!isSchedulingEnabled()) {
			show_cod(cpu, "Kernel PANIC!");
  101553:	8b 55 d8             	mov    -0x28(%ebp),%edx
  101556:	8b 45 08             	mov    0x8(%ebp),%eax
  101559:	89 10                	mov    %edx,(%eax)
		} else {
			new_cpu = schedule_exception(cpu);
  10155b:	e9 fd 02 00 00       	jmp    10185d <syscall+0x775>
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
		if (cpu->intr >= 0x28) {
			outb(0xa0, 0x20);
  101560:	e8 5b 27 00 00       	call   103cc0 <vfs_reset_error>
		}
  101565:	8b 45 08             	mov    0x8(%ebp),%eax
  101568:	8b 40 08             	mov    0x8(%eax),%eax
  10156b:	83 ec 0c             	sub    $0xc,%esp
  10156e:	50                   	push   %eax
  10156f:	e8 7c 25 00 00       	call   103af0 <strclone>
  101574:	83 c4 10             	add    $0x10,%esp
  101577:	89 45 dc             	mov    %eax,-0x24(%ebp)

		if (cpu->intr == 0x20) {
			new_cpu = schedule(cpu);
  10157a:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
		}
		else
  101581:	8b 45 08             	mov    0x8(%ebp),%eax
  101584:	8b 40 04             	mov    0x4(%eax),%eax
  101587:	83 f8 02             	cmp    $0x2,%eax
  10158a:	75 07                	jne    101593 <syscall+0x4ab>
		{
  10158c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
            if (handler_set[cpu->intr]) {
                handlers[cpu->intr]();
            }
  101593:	83 ec 08             	sub    $0x8,%esp
  101596:	ff 75 e4             	pushl  -0x1c(%ebp)
  101599:	ff 75 dc             	pushl  -0x24(%ebp)
  10159c:	e8 cc 2c 00 00       	call   10426d <vfs_open>
  1015a1:	83 c4 10             	add    $0x10,%esp
  1015a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(irq_rpcs[cpu->intr] > 0) {
                create_rpc_call(irq_rpcs[cpu->intr], RPCT_IRQ, cpu->intr, 0, 0);
  1015a7:	83 ec 0c             	sub    $0xc,%esp
  1015aa:	ff 75 dc             	pushl  -0x24(%ebp)
  1015ad:	e8 3a 23 00 00       	call   1038ec <free>
  1015b2:	83 c4 10             	add    $0x10,%esp
                //disable_irq_rpc(cpu->intr); TODO find out if we need to block
            }
  1015b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  1015b9:	75 0e                	jne    1015c9 <syscall+0x4e1>
		}
  1015bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1015be:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)

  1015c4:	e9 94 02 00 00       	jmp    10185d <syscall+0x775>
        outb(0x20, 0x20);
	} else if (cpu->intr == 0x30) {
		new_cpu = syscall(new_cpu);
  1015c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	} else {
		show_cod(cpu, "Unknown Interrupt!");
  1015d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1015d3:	8b 40 04             	mov    0x4(%eax),%eax
  1015d6:	83 f8 02             	cmp    $0x2,%eax
  1015d9:	74 22                	je     1015fd <syscall+0x515>
  1015db:	83 f8 03             	cmp    $0x3,%eax
  1015de:	74 35                	je     101615 <syscall+0x52d>
  1015e0:	83 f8 01             	cmp    $0x1,%eax
  1015e3:	75 48                	jne    10162d <syscall+0x545>
	}

  1015e5:	e8 43 15 00 00       	call   102b2d <get_current_task>
  1015ea:	8b 40 30             	mov    0x30(%eax),%eax
  1015ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return new_cpu;
  1015f0:	e8 38 15 00 00       	call   102b2d <get_current_task>
  1015f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1015f8:	89 50 30             	mov    %edx,0x30(%eax)
}
  1015fb:	eb 46                	jmp    101643 <syscall+0x55b>
  1015fd:	e8 2b 15 00 00       	call   102b2d <get_current_task>
  101602:	8b 40 38             	mov    0x38(%eax),%eax
  101605:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101608:	e8 20 15 00 00       	call   102b2d <get_current_task>
  10160d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101610:	89 50 38             	mov    %edx,0x38(%eax)
  101613:	eb 2e                	jmp    101643 <syscall+0x55b>
  101615:	e8 13 15 00 00       	call   102b2d <get_current_task>
  10161a:	8b 40 34             	mov    0x34(%eax),%eax
  10161d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101620:	e8 08 15 00 00       	call   102b2d <get_current_task>
  101625:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101628:	89 50 34             	mov    %edx,0x34(%eax)
  10162b:	eb 16                	jmp    101643 <syscall+0x55b>
  10162d:	e8 fb 14 00 00       	call   102b2d <get_current_task>
  101632:	8b 40 30             	mov    0x30(%eax),%eax
  101635:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101638:	e8 f0 14 00 00       	call   102b2d <get_current_task>
  10163d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101640:	89 50 30             	mov    %edx,0x30(%eax)
  101643:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101647:	74 0e                	je     101657 <syscall+0x56f>
  101649:	83 ec 0c             	sub    $0xc,%esp
  10164c:	ff 75 e8             	pushl  -0x18(%ebp)
  10164f:	e8 76 2c 00 00       	call   1042ca <vfs_close>
  101654:	83 c4 10             	add    $0x10,%esp
  101657:	8b 45 08             	mov    0x8(%ebp),%eax
  10165a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  101660:	e9 f8 01 00 00       	jmp    10185d <syscall+0x775>
  101665:	83 ec 0c             	sub    $0xc,%esp
  101668:	ff 75 08             	pushl  0x8(%ebp)
  10166b:	e8 0e 1d 00 00       	call   10337e <return_rpc_call>
  101670:	83 c4 10             	add    $0x10,%esp
  101673:	89 45 08             	mov    %eax,0x8(%ebp)
  101676:	e9 e2 01 00 00       	jmp    10185d <syscall+0x775>
  10167b:	8b 45 08             	mov    0x8(%ebp),%eax
  10167e:	8b 40 04             	mov    0x4(%eax),%eax
  101681:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101684:	e9 d4 01 00 00       	jmp    10185d <syscall+0x775>
  101689:	8b 45 08             	mov    0x8(%ebp),%eax
  10168c:	8b 40 04             	mov    0x4(%eax),%eax
  10168f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101692:	e8 96 14 00 00       	call   102b2d <get_current_task>
  101697:	8b 40 1c             	mov    0x1c(%eax),%eax
  10169a:	85 c0                	test   %eax,%eax
  10169c:	0f 85 b4 01 00 00    	jne    101856 <syscall+0x76e>
  1016a2:	e8 86 14 00 00       	call   102b2d <get_current_task>
  1016a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1016aa:	89 50 1c             	mov    %edx,0x1c(%eax)
  1016ad:	e9 ab 01 00 00       	jmp    10185d <syscall+0x775>
  1016b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1016b5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  1016bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1016be:	8b 40 04             	mov    0x4(%eax),%eax
  1016c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1016c4:	e8 64 14 00 00       	call   102b2d <get_current_task>
  1016c9:	8b 40 18             	mov    0x18(%eax),%eax
  1016cc:	85 c0                	test   %eax,%eax
  1016ce:	0f 84 85 01 00 00    	je     101859 <syscall+0x771>
  1016d4:	e8 54 14 00 00       	call   102b2d <get_current_task>
  1016d9:	8b 40 18             	mov    0x18(%eax),%eax
  1016dc:	8b 58 10             	mov    0x10(%eax),%ebx
  1016df:	e8 49 14 00 00       	call   102b2d <get_current_task>
  1016e4:	8b 40 18             	mov    0x18(%eax),%eax
  1016e7:	8b 40 0c             	mov    0xc(%eax),%eax
  1016ea:	83 ec 04             	sub    $0x4,%esp
  1016ed:	53                   	push   %ebx
  1016ee:	50                   	push   %eax
  1016ef:	ff 75 f4             	pushl  -0xc(%ebp)
  1016f2:	e8 77 22 00 00       	call   10396e <memcpy>
  1016f7:	83 c4 10             	add    $0x10,%esp
  1016fa:	e8 2e 14 00 00       	call   102b2d <get_current_task>
  1016ff:	8b 40 18             	mov    0x18(%eax),%eax
  101702:	8b 50 10             	mov    0x10(%eax),%edx
  101705:	8b 45 08             	mov    0x8(%ebp),%eax
  101708:	89 10                	mov    %edx,(%eax)
  10170a:	e9 4e 01 00 00       	jmp    10185d <syscall+0x775>
  10170f:	8b 45 08             	mov    0x8(%ebp),%eax
  101712:	8b 40 04             	mov    0x4(%eax),%eax
  101715:	83 ec 0c             	sub    $0xc,%esp
  101718:	50                   	push   %eax
  101719:	e8 e3 f7 ff ff       	call   100f01 <register_irq_rpc>
  10171e:	83 c4 10             	add    $0x10,%esp
  101721:	8b 55 08             	mov    0x8(%ebp),%edx
  101724:	89 02                	mov    %eax,(%edx)
  101726:	e9 32 01 00 00       	jmp    10185d <syscall+0x775>
  10172b:	8b 45 08             	mov    0x8(%ebp),%eax
  10172e:	8b 40 04             	mov    0x4(%eax),%eax
  101731:	25 ff ff 00 00       	and    $0xffff,%eax
  101736:	83 ec 0c             	sub    $0xc,%esp
  101739:	50                   	push   %eax
  10173a:	e8 9b 06 00 00       	call   101dda <require_port>
  10173f:	83 c4 10             	add    $0x10,%esp
  101742:	8b 55 08             	mov    0x8(%ebp),%edx
  101745:	89 02                	mov    %eax,(%edx)
  101747:	e9 11 01 00 00       	jmp    10185d <syscall+0x775>
  10174c:	8b 45 08             	mov    0x8(%ebp),%eax
  10174f:	8b 48 0c             	mov    0xc(%eax),%ecx
  101752:	8b 45 08             	mov    0x8(%ebp),%eax
  101755:	8b 40 08             	mov    0x8(%eax),%eax
  101758:	89 c2                	mov    %eax,%edx
  10175a:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  101760:	8b 45 08             	mov    0x8(%ebp),%eax
  101763:	8b 40 04             	mov    0x4(%eax),%eax
  101766:	83 ec 04             	sub    $0x4,%esp
  101769:	51                   	push   %ecx
  10176a:	52                   	push   %edx
  10176b:	50                   	push   %eax
  10176c:	e8 6d 07 00 00       	call   101ede <port_out>
  101771:	83 c4 10             	add    $0x10,%esp
  101774:	8b 55 08             	mov    0x8(%ebp),%edx
  101777:	89 02                	mov    %eax,(%edx)
  101779:	e9 df 00 00 00       	jmp    10185d <syscall+0x775>
  10177e:	8b 45 08             	mov    0x8(%ebp),%eax
  101781:	8b 40 08             	mov    0x8(%eax),%eax
  101784:	89 c2                	mov    %eax,%edx
  101786:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  10178c:	8b 45 08             	mov    0x8(%ebp),%eax
  10178f:	8b 40 04             	mov    0x4(%eax),%eax
  101792:	83 ec 08             	sub    $0x8,%esp
  101795:	52                   	push   %edx
  101796:	50                   	push   %eax
  101797:	e8 8a 06 00 00       	call   101e26 <port_in>
  10179c:	83 c4 10             	add    $0x10,%esp
  10179f:	8b 55 08             	mov    0x8(%ebp),%edx
  1017a2:	89 02                	mov    %eax,(%edx)
  1017a4:	e9 b4 00 00 00       	jmp    10185d <syscall+0x775>
  1017a9:	8b 45 08             	mov    0x8(%ebp),%eax
  1017ac:	8b 40 04             	mov    0x4(%eax),%eax
  1017af:	83 ec 08             	sub    $0x8,%esp
  1017b2:	50                   	push   %eax
  1017b3:	68 a0 71 10 00       	push   $0x1071a0
  1017b8:	e8 b0 ed ff ff       	call   10056d <kprintf>
  1017bd:	83 c4 10             	add    $0x10,%esp
  1017c0:	89 c2                	mov    %eax,%edx
  1017c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1017c5:	89 10                	mov    %edx,(%eax)
  1017c7:	e9 91 00 00 00       	jmp    10185d <syscall+0x775>
  1017cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1017cf:	8b 40 04             	mov    0x4(%eax),%eax
  1017d2:	83 ec 08             	sub    $0x8,%esp
  1017d5:	50                   	push   %eax
  1017d6:	68 a3 71 10 00       	push   $0x1071a3
  1017db:	e8 8d ed ff ff       	call   10056d <kprintf>
  1017e0:	83 c4 10             	add    $0x10,%esp
  1017e3:	89 c2                	mov    %eax,%edx
  1017e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1017e8:	89 10                	mov    %edx,(%eax)
  1017ea:	eb 71                	jmp    10185d <syscall+0x775>
  1017ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1017ef:	8b 40 04             	mov    0x4(%eax),%eax
  1017f2:	83 ec 0c             	sub    $0xc,%esp
  1017f5:	50                   	push   %eax
  1017f6:	e8 58 3a 00 00       	call   105253 <vmm_alloc_ucont>
  1017fb:	83 c4 10             	add    $0x10,%esp
  1017fe:	89 c2                	mov    %eax,%edx
  101800:	8b 45 08             	mov    0x8(%ebp),%eax
  101803:	89 10                	mov    %edx,(%eax)
  101805:	eb 56                	jmp    10185d <syscall+0x775>
  101807:	8b 45 08             	mov    0x8(%ebp),%eax
  10180a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  101810:	8b 45 08             	mov    0x8(%ebp),%eax
  101813:	8b 40 04             	mov    0x4(%eax),%eax
  101816:	3d ff 0f 40 01       	cmp    $0x1400fff,%eax
  10181b:	76 3f                	jbe    10185c <syscall+0x774>
  10181d:	8b 45 08             	mov    0x8(%ebp),%eax
  101820:	8b 40 04             	mov    0x4(%eax),%eax
  101823:	83 ec 0c             	sub    $0xc,%esp
  101826:	50                   	push   %eax
  101827:	e8 8d 38 00 00       	call   1050b9 <vmm_free>
  10182c:	83 c4 10             	add    $0x10,%esp
  10182f:	eb 2c                	jmp    10185d <syscall+0x775>
  101831:	e8 9b 02 00 00       	call   101ad1 <pmm_print_stats>
  101836:	eb 25                	jmp    10185d <syscall+0x775>
  101838:	8b 45 08             	mov    0x8(%ebp),%eax
  10183b:	8b 00                	mov    (%eax),%eax
  10183d:	83 ec 08             	sub    $0x8,%esp
  101840:	50                   	push   %eax
  101841:	68 a6 71 10 00       	push   $0x1071a6
  101846:	e8 22 ed ff ff       	call   10056d <kprintf>
  10184b:	83 c4 10             	add    $0x10,%esp
  10184e:	eb 0d                	jmp    10185d <syscall+0x775>
extern void intr_stub_14(void);
extern void intr_stub_15(void);
extern void intr_stub_16(void);
extern void intr_stub_17(void);
extern void intr_stub_18(void);

  101850:	90                   	nop    
  101851:	eb 0a                	jmp    10185d <syscall+0x775>
extern void intr_stub_45(void);
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

  101853:	90                   	nop    
  101854:	eb 07                	jmp    10185d <syscall+0x775>
  101856:	90                   	nop    
  101857:	eb 04                	jmp    10185d <syscall+0x775>
  101859:	90                   	nop    
  10185a:	eb 01                	jmp    10185d <syscall+0x775>
  10185c:	90                   	nop    
  10185d:	8b 45 08             	mov    0x8(%ebp),%eax
  101860:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101863:	c9                   	leave  
  101864:	c3                   	ret    

00101865 <kernel_main>:
  101865:	55                   	push   %ebp
  101866:	89 e5                	mov    %esp,%ebp
  101868:	83 ec 18             	sub    $0x18,%esp
  10186b:	e8 17 3b 00 00       	call   105387 <vmm_init>
  101870:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101873:	83 ec 0c             	sub    $0xc,%esp
  101876:	68 f4 74 10 00       	push   $0x1074f4
  10187b:	e8 ed ec ff ff       	call   10056d <kprintf>
  101880:	83 c4 10             	add    $0x10,%esp
  101883:	83 ec 08             	sub    $0x8,%esp
  101886:	6a 34                	push   $0x34
  101888:	6a 43                	push   $0x43
  10188a:	e8 7c 07 00 00       	call   10200b <outb>
  10188f:	83 c4 10             	add    $0x10,%esp
  101892:	83 ec 08             	sub    $0x8,%esp
  101895:	6a 00                	push   $0x0
  101897:	6a 40                	push   $0x40
  101899:	e8 6d 07 00 00       	call   10200b <outb>
  10189e:	83 c4 10             	add    $0x10,%esp
  1018a1:	83 ec 08             	sub    $0x8,%esp
  1018a4:	6a 08                	push   $0x8
  1018a6:	6a 40                	push   $0x40
  1018a8:	e8 5e 07 00 00       	call   10200b <outb>
  1018ad:	83 c4 10             	add    $0x10,%esp
  1018b0:	83 ec 0c             	sub    $0xc,%esp
  1018b3:	68 0d 75 10 00       	push   $0x10750d
  1018b8:	e8 b0 ec ff ff       	call   10056d <kprintf>
  1018bd:	83 c4 10             	add    $0x10,%esp
  1018c0:	e8 24 31 00 00       	call   1049e9 <vfs_init_root>
  1018c5:	e8 be 0a 00 00       	call   102388 <ramfs_fifo_init>
  1018ca:	e8 91 07 00 00       	call   102060 <ramfs_block_init>
  1018cf:	8b 55 08             	mov    0x8(%ebp),%edx
  1018d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1018d5:	83 ec 04             	sub    $0x4,%esp
  1018d8:	6a 00                	push   $0x0
  1018da:	52                   	push   %edx
  1018db:	50                   	push   %eax
  1018dc:	e8 83 37 00 00       	call   105064 <map_address_active>
  1018e1:	83 c4 10             	add    $0x10,%esp
  1018e4:	8b 45 08             	mov    0x8(%ebp),%eax
  1018e7:	8b 40 18             	mov    0x18(%eax),%eax
  1018ea:	89 c2                	mov    %eax,%edx
  1018ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1018ef:	8b 40 18             	mov    0x18(%eax),%eax
  1018f2:	83 ec 04             	sub    $0x4,%esp
  1018f5:	6a 00                	push   $0x0
  1018f7:	52                   	push   %edx
  1018f8:	50                   	push   %eax
  1018f9:	e8 66 37 00 00       	call   105064 <map_address_active>
  1018fe:	83 c4 10             	add    $0x10,%esp
  101901:	8b 45 08             	mov    0x8(%ebp),%eax
  101904:	8b 00                	mov    (%eax),%eax
  101906:	83 e0 08             	and    $0x8,%eax
  101909:	85 c0                	test   %eax,%eax
  10190b:	0f 84 9b 00 00 00    	je     1019ac <kernel_main+0x147>
  101911:	8b 45 08             	mov    0x8(%ebp),%eax
  101914:	8b 40 18             	mov    0x18(%eax),%eax
  101917:	8b 40 04             	mov    0x4(%eax),%eax
  10191a:	89 c2                	mov    %eax,%edx
  10191c:	8b 45 08             	mov    0x8(%ebp),%eax
  10191f:	8b 40 18             	mov    0x18(%eax),%eax
  101922:	8b 00                	mov    (%eax),%eax
  101924:	89 d1                	mov    %edx,%ecx
  101926:	29 c1                	sub    %eax,%ecx
  101928:	89 c8                	mov    %ecx,%eax
  10192a:	89 c1                	mov    %eax,%ecx
  10192c:	8b 45 08             	mov    0x8(%ebp),%eax
  10192f:	8b 40 18             	mov    0x18(%eax),%eax
  101932:	8b 10                	mov    (%eax),%edx
  101934:	8b 45 08             	mov    0x8(%ebp),%eax
  101937:	8b 40 18             	mov    0x18(%eax),%eax
  10193a:	8b 00                	mov    (%eax),%eax
  10193c:	6a 00                	push   $0x0
  10193e:	51                   	push   %ecx
  10193f:	52                   	push   %edx
  101940:	50                   	push   %eax
  101941:	e8 3e 36 00 00       	call   104f84 <vmm_map_range>
  101946:	83 c4 10             	add    $0x10,%esp
  101949:	8b 45 08             	mov    0x8(%ebp),%eax
  10194c:	8b 40 18             	mov    0x18(%eax),%eax
  10194f:	8b 40 04             	mov    0x4(%eax),%eax
  101952:	89 c2                	mov    %eax,%edx
  101954:	8b 45 08             	mov    0x8(%ebp),%eax
  101957:	8b 40 18             	mov    0x18(%eax),%eax
  10195a:	8b 00                	mov    (%eax),%eax
  10195c:	89 d1                	mov    %edx,%ecx
  10195e:	29 c1                	sub    %eax,%ecx
  101960:	89 c8                	mov    %ecx,%eax
  101962:	83 ec 08             	sub    $0x8,%esp
  101965:	50                   	push   %eax
  101966:	68 24 75 10 00       	push   $0x107524
  10196b:	e8 fd eb ff ff       	call   10056d <kprintf>
  101970:	83 c4 10             	add    $0x10,%esp
  101973:	8b 45 08             	mov    0x8(%ebp),%eax
  101976:	8b 40 18             	mov    0x18(%eax),%eax
  101979:	8b 50 04             	mov    0x4(%eax),%edx
  10197c:	8b 45 08             	mov    0x8(%ebp),%eax
  10197f:	8b 40 18             	mov    0x18(%eax),%eax
  101982:	8b 00                	mov    (%eax),%eax
  101984:	83 ec 04             	sub    $0x4,%esp
  101987:	52                   	push   %edx
  101988:	50                   	push   %eax
  101989:	68 64 75 10 00       	push   $0x107564
  10198e:	e8 da eb ff ff       	call   10056d <kprintf>
  101993:	83 c4 10             	add    $0x10,%esp
  101996:	8b 45 08             	mov    0x8(%ebp),%eax
  101999:	8b 40 18             	mov    0x18(%eax),%eax
  10199c:	8b 00                	mov    (%eax),%eax
  10199e:	83 ec 0c             	sub    $0xc,%esp
  1019a1:	50                   	push   %eax
  1019a2:	e8 3a 0e 00 00       	call   1027e1 <tar_load_ramfs>
  1019a7:	83 c4 10             	add    $0x10,%esp
  1019aa:	eb 10                	jmp    1019bc <kernel_main+0x157>
  1019ac:	83 ec 0c             	sub    $0xc,%esp
  1019af:	68 80 75 10 00       	push   $0x107580
  1019b4:	e8 b4 eb ff ff       	call   10056d <kprintf>
  1019b9:	83 c4 10             	add    $0x10,%esp
  1019bc:	83 ec 0c             	sub    $0xc,%esp
  1019bf:	68 b4 75 10 00       	push   $0x1075b4
  1019c4:	e8 a4 eb ff ff       	call   10056d <kprintf>
  1019c9:	83 c4 10             	add    $0x10,%esp
  1019cc:	e8 53 0f 00 00       	call   102924 <ramfs_vga_driver_struct>
  1019d1:	83 ec 04             	sub    $0x4,%esp
  1019d4:	6a 00                	push   $0x0
  1019d6:	50                   	push   %eax
  1019d7:	68 d4 75 10 00       	push   $0x1075d4
  1019dc:	e8 ed 27 00 00       	call   1041ce <vfs_create_kfile>
  1019e1:	83 c4 10             	add    $0x10,%esp
  1019e4:	83 ec 0c             	sub    $0xc,%esp
  1019e7:	68 dd 75 10 00       	push   $0x1075dd
  1019ec:	e8 65 2a 00 00       	call   104456 <vfs_exists>
  1019f1:	83 c4 10             	add    $0x10,%esp
  1019f4:	85 c0                	test   %eax,%eax
  1019f6:	74 31                	je     101a29 <kernel_main+0x1c4>
  1019f8:	83 ec 0c             	sub    $0xc,%esp
  1019fb:	68 e8 75 10 00       	push   $0x1075e8
  101a00:	e8 68 eb ff ff       	call   10056d <kprintf>
  101a05:	83 c4 10             	add    $0x10,%esp
  101a08:	83 ec 04             	sub    $0x4,%esp
  101a0b:	6a 00                	push   $0x0
  101a0d:	6a 00                	push   $0x0
  101a0f:	6a 00                	push   $0x0
  101a11:	6a 00                	push   $0x0
  101a13:	6a 00                	push   $0x0
  101a15:	6a 00                	push   $0x0
  101a17:	68 dd 75 10 00       	push   $0x1075dd
  101a1c:	e8 86 2a 00 00       	call   1044a7 <vfs_exec>
  101a21:	83 c4 20             	add    $0x20,%esp
  101a24:	e8 eb 10 00 00       	call   102b14 <enableScheduling>
  101a29:	eb fe                	jmp    101a29 <kernel_main+0x1c4>
	...

00101a2c <pmm_alloc>:
#include "ports.h"
#include "kernel.h"
#include "scheduler.h"
#include "gdt.h"
#include "catofdeath.h"

  101a2c:	55                   	push   %ebp
  101a2d:	89 e5                	mov    %esp,%ebp
  101a2f:	57                   	push   %edi
  101a30:	56                   	push   %esi
  101a31:	53                   	push   %ebx
  101a32:	83 ec 10             	sub    $0x10,%esp
#define IDT_ENTRIES 64

  101a35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101a3c:	eb 79                	jmp    101ab7 <pmm_alloc+0x8b>
extern uint8_t* interrupt_stack;
  101a3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101a41:	8b 04 85 c0 85 16 00 	mov    0x1685c0(,%eax,4),%eax
  101a48:	85 c0                	test   %eax,%eax
  101a4a:	74 68                	je     101ab4 <pmm_alloc+0x88>

static uint32_t tss[32] = { 0, (uint32_t) &interrupt_stack, 0x10 };
  101a4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101a53:	eb 59                	jmp    101aae <pmm_alloc+0x82>

  101a55:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101a58:	8b 14 85 c0 85 16 00 	mov    0x1685c0(,%eax,4),%edx
  101a5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101a62:	bb 01 00 00 00       	mov    $0x1,%ebx
  101a67:	89 de                	mov    %ebx,%esi
  101a69:	88 c1                	mov    %al,%cl
  101a6b:	d3 e6                	shl    %cl,%esi
  101a6d:	89 f0                	mov    %esi,%eax
  101a6f:	21 d0                	and    %edx,%eax
  101a71:	85 c0                	test   %eax,%eax
  101a73:	74 36                	je     101aab <pmm_alloc+0x7f>
static uint64_t idt[IDT_ENTRIES];
  101a75:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101a78:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101a7b:	8b 1c 95 c0 85 16 00 	mov    0x1685c0(,%edx,4),%ebx
  101a82:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101a85:	be 01 00 00 00       	mov    $0x1,%esi
  101a8a:	89 f7                	mov    %esi,%edi
  101a8c:	88 d1                	mov    %dl,%cl
  101a8e:	d3 e7                	shl    %cl,%edi
  101a90:	89 fa                	mov    %edi,%edx
  101a92:	f7 d2                	not    %edx
  101a94:	21 da                	and    %ebx,%edx
  101a96:	89 14 85 c0 85 16 00 	mov    %edx,0x1685c0(,%eax,4)
static void (*handlers[IDT_ENTRIES])();
  101a9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101aa0:	c1 e0 05             	shl    $0x5,%eax
  101aa3:	03 45 f0             	add    -0x10(%ebp),%eax
  101aa6:	c1 e0 0c             	shl    $0xc,%eax
  101aa9:	eb 1e                	jmp    101ac9 <pmm_alloc+0x9d>

#define IDT_ENTRIES 64

extern uint8_t* interrupt_stack;

static uint32_t tss[32] = { 0, (uint32_t) &interrupt_stack, 0x10 };
  101aab:	ff 45 f0             	incl   -0x10(%ebp)
  101aae:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
  101ab2:	7e a1                	jle    101a55 <pmm_alloc+0x29>
#include "scheduler.h"
#include "gdt.h"
#include "catofdeath.h"

#define IDT_ENTRIES 64

  101ab4:	ff 45 ec             	incl   -0x14(%ebp)
  101ab7:	81 7d ec ff 7f 00 00 	cmpl   $0x7fff,-0x14(%ebp)
  101abe:	0f 8e 7a ff ff ff    	jle    101a3e <pmm_alloc+0x12>
static void (*handlers[IDT_ENTRIES])();
static int handler_set[IDT_ENTRIES];

static int irq_rpcs[IDT_ENTRIES];

extern void intr_stub_0(void);
  101ac4:	b8 00 00 00 00       	mov    $0x0,%eax
extern void intr_stub_1(void);
  101ac9:	83 c4 10             	add    $0x10,%esp
  101acc:	5b                   	pop    %ebx
  101acd:	5e                   	pop    %esi
  101ace:	5f                   	pop    %edi
  101acf:	5d                   	pop    %ebp
  101ad0:	c3                   	ret    

00101ad1 <pmm_print_stats>:
extern void intr_stub_2(void);
extern void intr_stub_3(void);
  101ad1:	55                   	push   %ebp
  101ad2:	89 e5                	mov    %esp,%ebp
  101ad4:	57                   	push   %edi
  101ad5:	56                   	push   %esi
  101ad6:	53                   	push   %ebx
  101ad7:	83 ec 0c             	sub    $0xc,%esp
extern void intr_stub_4(void);
  101ada:	a1 20 85 12 00       	mov    0x128520,%eax
  101adf:	89 c7                	mov    %eax,%edi
  101ae1:	c1 ef 0a             	shr    $0xa,%edi
  101ae4:	83 ec 0c             	sub    $0xc,%esp
  101ae7:	68 00 04 00 00       	push   $0x400
  101aec:	e8 3e 00 00 00       	call   101b2f <pmm_get_free_space>
  101af1:	83 c4 10             	add    $0x10,%esp
  101af4:	89 c3                	mov    %eax,%ebx
  101af6:	a1 20 85 12 00       	mov    0x128520,%eax
  101afb:	89 c6                	mov    %eax,%esi
  101afd:	c1 ee 14             	shr    $0x14,%esi
  101b00:	83 ec 0c             	sub    $0xc,%esp
  101b03:	68 00 00 10 00       	push   $0x100000
  101b08:	e8 22 00 00 00       	call   101b2f <pmm_get_free_space>
  101b0d:	83 c4 10             	add    $0x10,%esp
  101b10:	83 ec 0c             	sub    $0xc,%esp
  101b13:	57                   	push   %edi
  101b14:	53                   	push   %ebx
  101b15:	56                   	push   %esi
  101b16:	50                   	push   %eax
  101b17:	68 10 76 10 00       	push   $0x107610
  101b1c:	e8 4c ea ff ff       	call   10056d <kprintf>
  101b21:	83 c4 20             	add    $0x20,%esp
extern void intr_stub_5(void);
extern void intr_stub_6(void);
extern void intr_stub_7(void);
  101b24:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101b27:	83 c4 00             	add    $0x0,%esp
  101b2a:	5b                   	pop    %ebx
  101b2b:	5e                   	pop    %esi
  101b2c:	5f                   	pop    %edi
  101b2d:	5d                   	pop    %ebp
  101b2e:	c3                   	ret    

00101b2f <pmm_get_free_space>:
extern void intr_stub_8(void);
extern void intr_stub_9(void);
  101b2f:	55                   	push   %ebp
  101b30:	89 e5                	mov    %esp,%ebp
  101b32:	56                   	push   %esi
  101b33:	53                   	push   %ebx
  101b34:	83 ec 10             	sub    $0x10,%esp
extern void intr_stub_10(void);
  101b37:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
extern void intr_stub_11(void);
extern void intr_stub_12(void);
  101b3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101b45:	eb 3c                	jmp    101b83 <pmm_get_free_space+0x54>
extern void intr_stub_13(void);
  101b47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  101b4e:	eb 2a                	jmp    101b7a <pmm_get_free_space+0x4b>
extern void intr_stub_14(void);
  101b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b53:	8b 14 85 c0 85 16 00 	mov    0x1685c0(,%eax,4),%edx
  101b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101b5d:	bb 01 00 00 00       	mov    $0x1,%ebx
  101b62:	89 de                	mov    %ebx,%esi
  101b64:	88 c1                	mov    %al,%cl
  101b66:	d3 e6                	shl    %cl,%esi
  101b68:	89 f0                	mov    %esi,%eax
  101b6a:	21 d0                	and    %edx,%eax
  101b6c:	85 c0                	test   %eax,%eax
  101b6e:	74 07                	je     101b77 <pmm_get_free_space+0x48>
extern void intr_stub_15(void);
  101b70:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
extern void intr_stub_8(void);
extern void intr_stub_9(void);
extern void intr_stub_10(void);
extern void intr_stub_11(void);
extern void intr_stub_12(void);
extern void intr_stub_13(void);
  101b77:	ff 45 f4             	incl   -0xc(%ebp)
  101b7a:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
  101b7e:	76 d0                	jbe    101b50 <pmm_get_free_space+0x21>
extern void intr_stub_7(void);
extern void intr_stub_8(void);
extern void intr_stub_9(void);
extern void intr_stub_10(void);
extern void intr_stub_11(void);
extern void intr_stub_12(void);
  101b80:	ff 45 f0             	incl   -0x10(%ebp)
  101b83:	81 7d f0 ff 7f 00 00 	cmpl   $0x7fff,-0x10(%ebp)
  101b8a:	76 bb                	jbe    101b47 <pmm_get_free_space+0x18>
extern void intr_stub_14(void);
extern void intr_stub_15(void);
extern void intr_stub_16(void);
extern void intr_stub_17(void);
extern void intr_stub_18(void);

  101b8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101b8f:	ba 00 00 00 00       	mov    $0x0,%edx
  101b94:	f7 75 08             	divl   0x8(%ebp)
extern void intr_stub_32(void);
  101b97:	83 c4 10             	add    $0x10,%esp
  101b9a:	5b                   	pop    %ebx
  101b9b:	5e                   	pop    %esi
  101b9c:	5d                   	pop    %ebp
  101b9d:	c3                   	ret    

00101b9e <pmm_free>:
extern void intr_stub_33(void);
extern void intr_stub_34(void);
  101b9e:	55                   	push   %ebp
  101b9f:	89 e5                	mov    %esp,%ebp
  101ba1:	57                   	push   %edi
  101ba2:	56                   	push   %esi
  101ba3:	53                   	push   %ebx
  101ba4:	83 ec 10             	sub    $0x10,%esp
extern void intr_stub_35(void);
  101ba7:	8b 45 08             	mov    0x8(%ebp),%eax
  101baa:	c1 e8 0c             	shr    $0xc,%eax
  101bad:	89 45 e8             	mov    %eax,-0x18(%ebp)
extern void intr_stub_36(void);
extern void intr_stub_37(void);
  101bb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101bb3:	83 e0 1f             	and    $0x1f,%eax
  101bb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
extern void intr_stub_38(void);
  101bb9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101bbc:	c1 e8 05             	shr    $0x5,%eax
  101bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
extern void intr_stub_39(void);
extern void intr_stub_40(void);
  101bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101bc5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101bc8:	8b 1c 95 c0 85 16 00 	mov    0x1685c0(,%edx,4),%ebx
  101bcf:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101bd2:	be 01 00 00 00       	mov    $0x1,%esi
  101bd7:	89 f7                	mov    %esi,%edi
  101bd9:	88 d1                	mov    %dl,%cl
  101bdb:	d3 e7                	shl    %cl,%edi
  101bdd:	89 fa                	mov    %edi,%edx
  101bdf:	09 da                	or     %ebx,%edx
  101be1:	89 14 85 c0 85 16 00 	mov    %edx,0x1685c0(,%eax,4)
extern void intr_stub_41(void);
  101be8:	83 c4 10             	add    $0x10,%esp
  101beb:	5b                   	pop    %ebx
  101bec:	5e                   	pop    %esi
  101bed:	5f                   	pop    %edi
  101bee:	5d                   	pop    %ebp
  101bef:	c3                   	ret    

00101bf0 <pmm_mark_used>:
extern void intr_stub_42(void);
extern void intr_stub_43(void);
  101bf0:	55                   	push   %ebp
  101bf1:	89 e5                	mov    %esp,%ebp
  101bf3:	57                   	push   %edi
  101bf4:	56                   	push   %esi
  101bf5:	53                   	push   %ebx
  101bf6:	83 ec 10             	sub    $0x10,%esp
extern void intr_stub_44(void);
  101bf9:	8b 45 08             	mov    0x8(%ebp),%eax
  101bfc:	c1 e8 0c             	shr    $0xc,%eax
  101bff:	89 45 e8             	mov    %eax,-0x18(%ebp)
extern void intr_stub_45(void);
extern void intr_stub_46(void);
  101c02:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101c05:	83 e0 1f             	and    $0x1f,%eax
  101c08:	89 45 ec             	mov    %eax,-0x14(%ebp)
extern void intr_stub_47(void);
  101c0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101c0e:	c1 e8 05             	shr    $0x5,%eax
  101c11:	89 45 f0             	mov    %eax,-0x10(%ebp)

extern void intr_stub_48(void);
  101c14:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101c17:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101c1a:	8b 1c 95 c0 85 16 00 	mov    0x1685c0(,%edx,4),%ebx
  101c21:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101c24:	be 01 00 00 00       	mov    $0x1,%esi
  101c29:	89 f7                	mov    %esi,%edi
  101c2b:	88 d1                	mov    %dl,%cl
  101c2d:	d3 e7                	shl    %cl,%edi
  101c2f:	89 fa                	mov    %edi,%edx
  101c31:	f7 d2                	not    %edx
  101c33:	21 da                	and    %ebx,%edx
  101c35:	89 14 85 c0 85 16 00 	mov    %edx,0x1685c0(,%eax,4)

  101c3c:	83 c4 10             	add    $0x10,%esp
  101c3f:	5b                   	pop    %ebx
  101c40:	5e                   	pop    %esi
  101c41:	5f                   	pop    %edi
  101c42:	5d                   	pop    %ebp
  101c43:	c3                   	ret    

00101c44 <pmm_init>:
void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
	unsigned long int handler = (unsigned long int) fn;
  101c44:	55                   	push   %ebp
  101c45:	89 e5                	mov    %esp,%ebp
  101c47:	83 ec 28             	sub    $0x28,%esp
	idt[i] = handler & 0xffffLL;
  101c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  101c4d:	8b 40 30             	mov    0x30(%eax),%eax
  101c50:	89 45 dc             	mov    %eax,-0x24(%ebp)
	idt[i] |= (selector & 0xffffLL) << 16;
  101c53:	8b 45 08             	mov    0x8(%ebp),%eax
  101c56:	8b 40 30             	mov    0x30(%eax),%eax
  101c59:	89 c2                	mov    %eax,%edx
  101c5b:	8b 45 08             	mov    0x8(%ebp),%eax
  101c5e:	8b 40 2c             	mov    0x2c(%eax),%eax
  101c61:	8d 04 02             	lea    (%edx,%eax,1),%eax
	idt[i] |= (flags & 0xffLL) << 40;
  101c64:	89 45 e0             	mov    %eax,-0x20(%ebp)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
}
  101c67:	83 ec 04             	sub    $0x4,%esp
  101c6a:	68 00 00 02 00       	push   $0x20000
  101c6f:	6a 00                	push   $0x0
  101c71:	68 c0 85 16 00       	push   $0x1685c0
  101c76:	e8 c5 1c 00 00       	call   103940 <memset>
  101c7b:	83 c4 10             	add    $0x10,%esp

void init_idt() {
  101c7e:	b8 c0 85 18 00       	mov    $0x1885c0,%eax
  101c83:	83 ec 04             	sub    $0x4,%esp
  101c86:	50                   	push   %eax
  101c87:	68 c0 85 16 00       	push   $0x1685c0
  101c8c:	68 4d 76 10 00       	push   $0x10764d
  101c91:	e8 d7 e8 ff ff       	call   10056d <kprintf>
  101c96:	83 c4 10             	add    $0x10,%esp
	struct {
		unsigned short int limit;
  101c99:	eb 5c                	jmp    101cf7 <pmm_init+0xb3>
		void* pointer;
  101c9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101c9e:	8b 40 14             	mov    0x14(%eax),%eax
  101ca1:	83 f8 01             	cmp    $0x1,%eax
  101ca4:	75 4d                	jne    101cf3 <pmm_init+0xaf>
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
  101ca6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101ca9:	8b 50 08             	mov    0x8(%eax),%edx
  101cac:	8b 40 04             	mov    0x4(%eax),%eax
  101caf:	89 45 f0             	mov    %eax,-0x10(%ebp)
			idt, };
  101cb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101cb5:	8b 50 10             	mov    0x10(%eax),%edx
  101cb8:	8b 40 0c             	mov    0xc(%eax),%eax
  101cbb:	03 45 f0             	add    -0x10(%ebp),%eax
  101cbe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	int i = 0;
  101cc1:	eb 28                	jmp    101ceb <pmm_init+0xa7>

  101cc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cc6:	83 ec 0c             	sub    $0xc,%esp
  101cc9:	50                   	push   %eax
  101cca:	e8 cf fe ff ff       	call   101b9e <pmm_free>
  101ccf:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < IDT_ENTRIES; i++) {
  101cd2:	a1 20 85 12 00       	mov    0x128520,%eax
  101cd7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  101cda:	76 08                	jbe    101ce4 <pmm_init+0xa0>
		handler_set[i] = 0;
  101cdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cdf:	a3 20 85 12 00       	mov    %eax,0x128520
		irq_rpcs[i] = 0;
  101ce4:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;
  101ceb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cee:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  101cf1:	72 d0                	jb     101cc3 <pmm_init+0x7f>
	for (i = 0; i < IDT_ENTRIES; i++) {
		handler_set[i] = 0;
		irq_rpcs[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  101cf3:	83 45 dc 18          	addl   $0x18,-0x24(%ebp)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
}

void init_idt() {
	struct {
		unsigned short int limit;
  101cf7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101cfa:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  101cfd:	72 9c                	jb     101c9b <pmm_init+0x57>
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
	outb(0x21, 0x01); // ICW 4

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  101cff:	c7 45 e4 00 00 10 00 	movl   $0x100000,-0x1c(%ebp)
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  101d06:	eb 16                	jmp    101d1e <pmm_init+0xda>
	outb(0xa1, 0x01); // ICW 4
  101d08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101d0b:	83 ec 0c             	sub    $0xc,%esp
  101d0e:	50                   	push   %eax
  101d0f:	e8 dc fe ff ff       	call   101bf0 <pmm_mark_used>
  101d14:	83 c4 10             	add    $0x10,%esp

  101d17:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
	outb(0x21, 0x01); // ICW 4

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  101d1e:	b8 00 90 1c 00       	mov    $0x1c9000,%eax
  101d23:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  101d26:	72 e0                	jb     101d08 <pmm_init+0xc4>
	outb(0xa1, 0x01); // ICW 4

	outb(0x20, 0x0);
	outb(0xa0, 0x0);

  101d28:	8b 45 08             	mov    0x8(%ebp),%eax
  101d2b:	8b 40 18             	mov    0x18(%eax),%eax
  101d2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	idt_set_entry(0, intr_stub_0, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101d31:	83 ec 0c             	sub    $0xc,%esp
  101d34:	ff 75 08             	pushl  0x8(%ebp)
  101d37:	e8 b4 fe ff ff       	call   101bf0 <pmm_mark_used>
  101d3c:	83 c4 10             	add    $0x10,%esp
	idt_set_entry(1, intr_stub_1, 0x8,
  101d3f:	83 ec 0c             	sub    $0xc,%esp
  101d42:	ff 75 e8             	pushl  -0x18(%ebp)
  101d45:	e8 a6 fe ff ff       	call   101bf0 <pmm_mark_used>
  101d4a:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101d4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101d54:	eb 3a                	jmp    101d90 <pmm_init+0x14c>
	idt_set_entry(3, intr_stub_3, 0x8,
  101d56:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101d59:	c1 e0 04             	shl    $0x4,%eax
  101d5c:	03 45 e8             	add    -0x18(%ebp),%eax
  101d5f:	8b 00                	mov    (%eax),%eax
  101d61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101d64:	eb 16                	jmp    101d7c <pmm_init+0x138>
	idt_set_entry(4, intr_stub_4, 0x8,
  101d66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101d69:	83 ec 0c             	sub    $0xc,%esp
  101d6c:	50                   	push   %eax
  101d6d:	e8 7e fe ff ff       	call   101bf0 <pmm_mark_used>
  101d72:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101d75:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
	idt_set_entry(1, intr_stub_1, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101d7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101d7f:	c1 e0 04             	shl    $0x4,%eax
  101d82:	03 45 e8             	add    -0x18(%ebp),%eax
  101d85:	8b 40 04             	mov    0x4(%eax),%eax
  101d88:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  101d8b:	77 d9                	ja     101d66 <pmm_init+0x122>
	idt_set_entry(0, intr_stub_0, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
  101d8d:	ff 45 ec             	incl   -0x14(%ebp)
  101d90:	8b 45 08             	mov    0x8(%ebp),%eax
  101d93:	8b 40 14             	mov    0x14(%eax),%eax
  101d96:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  101d99:	77 bb                	ja     101d56 <pmm_init+0x112>
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  101d9b:	c9                   	leave  
  101d9c:	c3                   	ret    
  101d9d:	00 00                	add    %al,(%eax)
	...

00101da0 <free_ports_for_pid>:
#include "idt.h"
#include "console.h"
#include "ports.h"
#include "kernel.h"
  101da0:	55                   	push   %ebp
  101da1:	89 e5                	mov    %esp,%ebp
  101da3:	83 ec 10             	sub    $0x10,%esp
#include "scheduler.h"
  101da6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  101dad:	eb 20                	jmp    101dcf <free_ports_for_pid+0x2f>
#include "gdt.h"
  101daf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101db2:	8b 04 85 80 85 12 00 	mov    0x128580(,%eax,4),%eax
  101db9:	3b 45 08             	cmp    0x8(%ebp),%eax
  101dbc:	75 0e                	jne    101dcc <free_ports_for_pid+0x2c>
#include "catofdeath.h"
  101dbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101dc1:	c7 04 85 80 85 12 00 	movl   $0x0,0x128580(,%eax,4)
  101dc8:	00 00 00 00 
#include "idt.h"
#include "console.h"
#include "ports.h"
#include "kernel.h"
#include "scheduler.h"
  101dcc:	ff 45 fc             	incl   -0x4(%ebp)
  101dcf:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%ebp)
  101dd6:	7e d7                	jle    101daf <free_ports_for_pid+0xf>
#include "gdt.h"
#include "catofdeath.h"

#define IDT_ENTRIES 64

  101dd8:	c9                   	leave  
  101dd9:	c3                   	ret    

00101dda <require_port>:
extern uint8_t* interrupt_stack;

  101dda:	55                   	push   %ebp
  101ddb:	89 e5                	mov    %esp,%ebp
  101ddd:	53                   	push   %ebx
  101dde:	83 ec 14             	sub    $0x14,%esp
  101de1:	8b 45 08             	mov    0x8(%ebp),%eax
  101de4:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
static uint32_t tss[32] = { 0, (uint32_t) &interrupt_stack, 0x10 };
  101de8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101deb:	25 ff ff 00 00       	and    $0xffff,%eax
  101df0:	8b 04 85 80 85 12 00 	mov    0x128580(,%eax,4),%eax
  101df7:	85 c0                	test   %eax,%eax
  101df9:	74 07                	je     101e02 <require_port+0x28>
  101dfb:	b8 00 00 00 00       	mov    $0x0,%eax
  101e00:	eb 1e                	jmp    101e20 <require_port+0x46>

  101e02:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e05:	89 c3                	mov    %eax,%ebx
  101e07:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  101e0d:	e8 1b 0d 00 00       	call   102b2d <get_current_task>
  101e12:	8b 00                	mov    (%eax),%eax
  101e14:	89 04 9d 80 85 12 00 	mov    %eax,0x128580(,%ebx,4)
static uint64_t idt[IDT_ENTRIES];
  101e1b:	b8 01 00 00 00       	mov    $0x1,%eax
static void (*handlers[IDT_ENTRIES])();
  101e20:	83 c4 14             	add    $0x14,%esp
  101e23:	5b                   	pop    %ebx
  101e24:	5d                   	pop    %ebp
  101e25:	c3                   	ret    

00101e26 <port_in>:
static int handler_set[IDT_ENTRIES];

  101e26:	55                   	push   %ebp
  101e27:	89 e5                	mov    %esp,%ebp
  101e29:	53                   	push   %ebx
  101e2a:	83 ec 14             	sub    $0x14,%esp
  101e2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  101e30:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
static int irq_rpcs[IDT_ENTRIES];
  101e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e37:	25 ff ff 00 00       	and    $0xffff,%eax
  101e3c:	8b 1c 85 80 85 12 00 	mov    0x128580(,%eax,4),%ebx
  101e43:	e8 e5 0c 00 00       	call   102b2d <get_current_task>
  101e48:	8b 00                	mov    (%eax),%eax
  101e4a:	39 c3                	cmp    %eax,%ebx
  101e4c:	74 26                	je     101e74 <port_in+0x4e>

  101e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e51:	89 c3                	mov    %eax,%ebx
  101e53:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  101e59:	e8 cf 0c 00 00       	call   102b2d <get_current_task>
  101e5e:	8b 00                	mov    (%eax),%eax
  101e60:	83 ec 04             	sub    $0x4,%esp
  101e63:	53                   	push   %ebx
  101e64:	50                   	push   %eax
  101e65:	68 64 76 10 00       	push   $0x107664
  101e6a:	e8 fe e6 ff ff       	call   10056d <kprintf>
  101e6f:	83 c4 10             	add    $0x10,%esp
extern void intr_stub_0(void);
  101e72:	eb fe                	jmp    101e72 <port_in+0x4c>
extern void intr_stub_1(void);
extern void intr_stub_2(void);
extern void intr_stub_3(void);
extern void intr_stub_4(void);
  101e74:	8b 45 08             	mov    0x8(%ebp),%eax
  101e77:	83 f8 01             	cmp    $0x1,%eax
  101e7a:	74 27                	je     101ea3 <port_in+0x7d>
  101e7c:	83 f8 01             	cmp    $0x1,%eax
  101e7f:	72 07                	jb     101e88 <port_in+0x62>
  101e81:	83 f8 02             	cmp    $0x2,%eax
  101e84:	74 38                	je     101ebe <port_in+0x98>
  101e86:	eb 4c                	jmp    101ed4 <port_in+0xae>
extern void intr_stub_5(void);
extern void intr_stub_6(void);
  101e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e8b:	25 ff ff 00 00       	and    $0xffff,%eax
  101e90:	83 ec 0c             	sub    $0xc,%esp
  101e93:	50                   	push   %eax
  101e94:	e8 1e 01 00 00       	call   101fb7 <inb>
  101e99:	83 c4 10             	add    $0x10,%esp
  101e9c:	25 ff 00 00 00       	and    $0xff,%eax
  101ea1:	eb 36                	jmp    101ed9 <port_in+0xb3>
extern void intr_stub_7(void);
extern void intr_stub_8(void);
  101ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ea6:	25 ff ff 00 00       	and    $0xffff,%eax
  101eab:	83 ec 0c             	sub    $0xc,%esp
  101eae:	50                   	push   %eax
  101eaf:	e8 e5 00 00 00       	call   101f99 <inw>
  101eb4:	83 c4 10             	add    $0x10,%esp
  101eb7:	25 ff ff 00 00       	and    $0xffff,%eax
  101ebc:	eb 1b                	jmp    101ed9 <port_in+0xb3>
extern void intr_stub_9(void);
extern void intr_stub_10(void);
  101ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ec1:	25 ff ff 00 00       	and    $0xffff,%eax
  101ec6:	83 ec 0c             	sub    $0xc,%esp
  101ec9:	50                   	push   %eax
  101eca:	e8 03 01 00 00       	call   101fd2 <inl>
  101ecf:	83 c4 10             	add    $0x10,%esp
  101ed2:	eb 05                	jmp    101ed9 <port_in+0xb3>
extern void intr_stub_11(void);
extern void intr_stub_12(void);
extern void intr_stub_13(void);
  101ed4:	b8 00 00 00 00       	mov    $0x0,%eax
extern void intr_stub_14(void);
  101ed9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101edc:	c9                   	leave  
  101edd:	c3                   	ret    

00101ede <port_out>:
extern void intr_stub_15(void);
extern void intr_stub_16(void);
  101ede:	55                   	push   %ebp
  101edf:	89 e5                	mov    %esp,%ebp
  101ee1:	53                   	push   %ebx
  101ee2:	83 ec 14             	sub    $0x14,%esp
  101ee5:	8b 45 0c             	mov    0xc(%ebp),%eax
  101ee8:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
extern void intr_stub_17(void);
  101eec:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101eef:	25 ff ff 00 00       	and    $0xffff,%eax
  101ef4:	8b 1c 85 80 85 12 00 	mov    0x128580(,%eax,4),%ebx
  101efb:	e8 2d 0c 00 00       	call   102b2d <get_current_task>
  101f00:	8b 00                	mov    (%eax),%eax
  101f02:	39 c3                	cmp    %eax,%ebx
  101f04:	74 0a                	je     101f10 <port_out+0x32>
extern void intr_stub_18(void);
  101f06:	b8 00 00 00 00       	mov    $0x0,%eax
  101f0b:	e9 84 00 00 00       	jmp    101f94 <port_out+0xb6>

extern void intr_stub_32(void);
extern void intr_stub_33(void);
  101f10:	8b 45 08             	mov    0x8(%ebp),%eax
  101f13:	83 f8 01             	cmp    $0x1,%eax
  101f16:	74 32                	je     101f4a <port_out+0x6c>
  101f18:	83 f8 01             	cmp    $0x1,%eax
  101f1b:	72 07                	jb     101f24 <port_out+0x46>
  101f1d:	83 f8 02             	cmp    $0x2,%eax
  101f20:	74 4f                	je     101f71 <port_out+0x93>
  101f22:	eb 6b                	jmp    101f8f <port_out+0xb1>
extern void intr_stub_34(void);
extern void intr_stub_35(void);
  101f24:	8b 45 10             	mov    0x10(%ebp),%eax
  101f27:	ba 00 00 00 00       	mov    $0x0,%edx
  101f2c:	88 c2                	mov    %al,%dl
  101f2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f31:	25 ff ff 00 00       	and    $0xffff,%eax
  101f36:	83 ec 08             	sub    $0x8,%esp
  101f39:	52                   	push   %edx
  101f3a:	50                   	push   %eax
  101f3b:	e8 cb 00 00 00       	call   10200b <outb>
  101f40:	83 c4 10             	add    $0x10,%esp
extern void intr_stub_36(void);
  101f43:	b8 01 00 00 00       	mov    $0x1,%eax
  101f48:	eb 4a                	jmp    101f94 <port_out+0xb6>
extern void intr_stub_37(void);
extern void intr_stub_38(void);
  101f4a:	8b 45 10             	mov    0x10(%ebp),%eax
  101f4d:	89 c2                	mov    %eax,%edx
  101f4f:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  101f55:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f58:	25 ff ff 00 00       	and    $0xffff,%eax
  101f5d:	83 ec 08             	sub    $0x8,%esp
  101f60:	52                   	push   %edx
  101f61:	50                   	push   %eax
  101f62:	e8 86 00 00 00       	call   101fed <outw>
  101f67:	83 c4 10             	add    $0x10,%esp
extern void intr_stub_39(void);
  101f6a:	b8 01 00 00 00       	mov    $0x1,%eax
  101f6f:	eb 23                	jmp    101f94 <port_out+0xb6>
extern void intr_stub_40(void);
extern void intr_stub_41(void);
  101f71:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f74:	25 ff ff 00 00       	and    $0xffff,%eax
  101f79:	83 ec 08             	sub    $0x8,%esp
  101f7c:	ff 75 10             	pushl  0x10(%ebp)
  101f7f:	50                   	push   %eax
  101f80:	e8 a2 00 00 00       	call   102027 <outl>
  101f85:	83 c4 10             	add    $0x10,%esp
extern void intr_stub_42(void);
  101f88:	b8 01 00 00 00       	mov    $0x1,%eax
  101f8d:	eb 05                	jmp    101f94 <port_out+0xb6>
extern void intr_stub_43(void);
extern void intr_stub_44(void);
extern void intr_stub_45(void);
  101f8f:	b8 00 00 00 00       	mov    $0x0,%eax
extern void intr_stub_46(void);
  101f94:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101f97:	c9                   	leave  
  101f98:	c3                   	ret    

00101f99 <inw>:
extern void intr_stub_47(void);

  101f99:	55                   	push   %ebp
  101f9a:	89 e5                	mov    %esp,%ebp
  101f9c:	83 ec 14             	sub    $0x14,%esp
  101f9f:	8b 45 08             	mov    0x8(%ebp),%eax
  101fa2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
extern void intr_stub_48(void);

  101fa6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fa9:	89 c2                	mov    %eax,%edx
  101fab:	66 ed                	in     (%dx),%ax
  101fad:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  101fb1:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
	unsigned long int handler = (unsigned long int) fn;
  101fb5:	c9                   	leave  
  101fb6:	c3                   	ret    

00101fb7 <inb>:
	idt[i] = handler & 0xffffLL;
	idt[i] |= (selector & 0xffffLL) << 16;
  101fb7:	55                   	push   %ebp
  101fb8:	89 e5                	mov    %esp,%ebp
  101fba:	83 ec 14             	sub    $0x14,%esp
  101fbd:	8b 45 08             	mov    0x8(%ebp),%eax
  101fc0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	idt[i] |= (flags & 0xffLL) << 40;
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  101fc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fc7:	89 c2                	mov    %eax,%edx
  101fc9:	ec                   	in     (%dx),%al
  101fca:	88 45 ff             	mov    %al,-0x1(%ebp)
}
  101fcd:	8a 45 ff             	mov    -0x1(%ebp),%al

  101fd0:	c9                   	leave  
  101fd1:	c3                   	ret    

00101fd2 <inl>:
void init_idt() {
	struct {
  101fd2:	55                   	push   %ebp
  101fd3:	89 e5                	mov    %esp,%ebp
  101fd5:	83 ec 14             	sub    $0x14,%esp
  101fd8:	8b 45 08             	mov    0x8(%ebp),%eax
  101fdb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
		unsigned short int limit;
		void* pointer;
  101fdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fe2:	89 c2                	mov    %eax,%edx
  101fe4:	ed                   	in     (%dx),%eax
  101fe5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
  101fe8:	8b 45 fc             	mov    -0x4(%ebp),%eax
			idt, };
  101feb:	c9                   	leave  
  101fec:	c3                   	ret    

00101fed <outw>:

	int i = 0;
  101fed:	55                   	push   %ebp
  101fee:	89 e5                	mov    %esp,%ebp
  101ff0:	83 ec 08             	sub    $0x8,%esp
  101ff3:	8b 55 08             	mov    0x8(%ebp),%edx
  101ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
  101ff9:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
  101ffd:	66 89 45 f8          	mov    %ax,-0x8(%ebp)

  102001:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102004:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102007:	66 ef                	out    %ax,(%dx)
	for (i = 0; i < IDT_ENTRIES; i++) {
  102009:	c9                   	leave  
  10200a:	c3                   	ret    

0010200b <outb>:
		handler_set[i] = 0;
		irq_rpcs[i] = 0;
  10200b:	55                   	push   %ebp
  10200c:	89 e5                	mov    %esp,%ebp
  10200e:	83 ec 08             	sub    $0x8,%esp
  102011:	8b 45 08             	mov    0x8(%ebp),%eax
  102014:	8b 55 0c             	mov    0xc(%ebp),%edx
  102017:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  10201b:	88 55 f8             	mov    %dl,-0x8(%ebp)
	}
  10201e:	8a 45 f8             	mov    -0x8(%ebp),%al
  102021:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102024:	ee                   	out    %al,(%dx)

  102025:	c9                   	leave  
  102026:	c3                   	ret    

00102027 <outl>:
	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  102027:	55                   	push   %ebp
  102028:	89 e5                	mov    %esp,%ebp
  10202a:	83 ec 04             	sub    $0x4,%esp
  10202d:	8b 45 08             	mov    0x8(%ebp),%eax
  102030:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  102034:	8b 45 0c             	mov    0xc(%ebp),%eax
  102037:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10203a:	ef                   	out    %eax,(%dx)
	outb(0x21, 0x01); // ICW 4
  10203b:	c9                   	leave  
  10203c:	c3                   	ret    

0010203d <outb_wait>:

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  10203d:	55                   	push   %ebp
  10203e:	89 e5                	mov    %esp,%ebp
  102040:	83 ec 08             	sub    $0x8,%esp
  102043:	8b 45 08             	mov    0x8(%ebp),%eax
  102046:	8b 55 0c             	mov    0xc(%ebp),%edx
  102049:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  10204d:	88 55 f8             	mov    %dl,-0x8(%ebp)
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  102050:	8a 45 f8             	mov    -0x8(%ebp),%al
  102053:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102056:	ee                   	out    %al,(%dx)
  102057:	eb 00                	jmp    102059 <outb_wait+0x1c>
  102059:	eb 00                	jmp    10205b <outb_wait+0x1e>
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  10205b:	c9                   	leave  
  10205c:	c3                   	ret    
  10205d:	00 00                	add    %al,(%eax)
	...

00102060 <ramfs_block_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  102060:	55                   	push   %ebp
  102061:	89 e5                	mov    %esp,%ebp
  102063:	83 ec 08             	sub    $0x8,%esp
    memset(buffer, 0, sizeof(buffer));
  102066:	83 ec 04             	sub    $0x4,%esp
  102069:	68 00 00 04 00       	push   $0x40000
  10206e:	6a 00                	push   $0x0
  102070:	68 c0 85 18 00       	push   $0x1885c0
  102075:	e8 c6 18 00 00       	call   103940 <memset>
  10207a:	83 c4 10             	add    $0x10,%esp
}
  10207d:	c9                   	leave  
  10207e:	c3                   	ret    

0010207f <ramfs_block_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  10207f:	55                   	push   %ebp
  102080:	89 e5                	mov    %esp,%ebp
    return &block_driver;
  102082:	b8 a0 60 10 00       	mov    $0x1060a0,%eax
}
  102087:	5d                   	pop    %ebp
  102088:	c3                   	ret    

00102089 <ramfs_block_available>:

uint32_t ramfs_block_available(struct res_handle* handle) {
  102089:	55                   	push   %ebp
  10208a:	89 e5                	mov    %esp,%ebp
  10208c:	83 ec 10             	sub    $0x10,%esp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10208f:	8b 45 08             	mov    0x8(%ebp),%eax
  102092:	8b 40 04             	mov    0x4(%eax),%eax
  102095:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(buffer[kf->id] != 0) {
  102098:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10209b:	8b 00                	mov    (%eax),%eax
  10209d:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1020a4:	85 c0                	test   %eax,%eax
  1020a6:	74 1d                	je     1020c5 <ramfs_block_available+0x3c>
        return buffer[kf->id]->size - handle->position;
  1020a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020ab:	8b 00                	mov    (%eax),%eax
  1020ad:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1020b4:	8b 50 04             	mov    0x4(%eax),%edx
  1020b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1020ba:	8b 40 08             	mov    0x8(%eax),%eax
  1020bd:	89 d1                	mov    %edx,%ecx
  1020bf:	29 c1                	sub    %eax,%ecx
  1020c1:	89 c8                	mov    %ecx,%eax
  1020c3:	eb 05                	jmp    1020ca <ramfs_block_available+0x41>
    }

    return 0;
  1020c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1020ca:	c9                   	leave  
  1020cb:	c3                   	ret    

001020cc <ramfs_block_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  1020cc:	55                   	push   %ebp
  1020cd:	89 e5                	mov    %esp,%ebp
  1020cf:	53                   	push   %ebx
  1020d0:	83 ec 14             	sub    $0x14,%esp
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  1020d3:	83 ec 0c             	sub    $0xc,%esp
  1020d6:	6a 08                	push   $0x8
  1020d8:	e8 c9 15 00 00       	call   1036a6 <malloc>
  1020dd:	83 c4 10             	add    $0x10,%esp
  1020e0:	89 45 f0             	mov    %eax,-0x10(%ebp)

    for(int i = 0; i < 65536; i++) {
  1020e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1020ea:	e9 86 00 00 00       	jmp    102175 <ramfs_block_create+0xa9>
        if(buffer[i] == 0) {
  1020ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1020f2:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1020f9:	85 c0                	test   %eax,%eax
  1020fb:	75 75                	jne    102172 <ramfs_block_create+0xa6>
            buffer[i] = malloc(sizeof(struct block_buffer));
  1020fd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  102100:	83 ec 0c             	sub    $0xc,%esp
  102103:	6a 10                	push   $0x10
  102105:	e8 9c 15 00 00       	call   1036a6 <malloc>
  10210a:	83 c4 10             	add    $0x10,%esp
  10210d:	89 04 9d c0 85 18 00 	mov    %eax,0x1885c0(,%ebx,4)
            buffer[i]->buffer = malloc(args[0]);
  102114:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102117:	8b 1c 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%ebx
  10211e:	8b 45 08             	mov    0x8(%ebp),%eax
  102121:	8b 00                	mov    (%eax),%eax
  102123:	83 ec 0c             	sub    $0xc,%esp
  102126:	50                   	push   %eax
  102127:	e8 7a 15 00 00       	call   1036a6 <malloc>
  10212c:	83 c4 10             	add    $0x10,%esp
  10212f:	89 03                	mov    %eax,(%ebx)
            buffer[i]->size   = args[0];
  102131:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102134:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10213b:	8b 55 08             	mov    0x8(%ebp),%edx
  10213e:	8b 12                	mov    (%edx),%edx
  102140:	89 50 04             	mov    %edx,0x4(%eax)

            buffer[i]->writers = 0;
  102143:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102146:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10214d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            buffer[i]->readers = 0;
  102154:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102157:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10215e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

            kfret->id = i;
  102165:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102168:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10216b:	89 10                	mov    %edx,(%eax)

            return kfret;
  10216d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102170:	eb 15                	jmp    102187 <ramfs_block_create+0xbb>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  102172:	ff 45 f4             	incl   -0xc(%ebp)
  102175:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
  10217c:	0f 8e 6d ff ff ff    	jle    1020ef <ramfs_block_create+0x23>

            return kfret;
        }
    }

    return 0;
  102182:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102187:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10218a:	c9                   	leave  
  10218b:	c3                   	ret    

0010218c <ramfs_block_read>:

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  10218c:	55                   	push   %ebp
  10218d:	89 e5                	mov    %esp,%ebp
  10218f:	83 ec 18             	sub    $0x18,%esp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102192:	8b 45 08             	mov    0x8(%ebp),%eax
  102195:	8b 40 04             	mov    0x4(%eax),%eax
  102198:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  10219b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10219e:	8b 00                	mov    (%eax),%eax
  1021a0:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1021a7:	85 c0                	test   %eax,%eax
  1021a9:	74 55                	je     102200 <ramfs_block_read+0x74>
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;
  1021ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1021ae:	8b 40 08             	mov    0x8(%eax),%eax
  1021b1:	89 c2                	mov    %eax,%edx
  1021b3:	03 55 10             	add    0x10(%ebp),%edx
  1021b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021b9:	8b 00                	mov    (%eax),%eax
  1021bb:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1021c2:	8b 40 04             	mov    0x4(%eax),%eax
  1021c5:	39 c2                	cmp    %eax,%edx
  1021c7:	76 07                	jbe    1021d0 <ramfs_block_read+0x44>
  1021c9:	b8 06 00 00 00       	mov    $0x6,%eax
  1021ce:	eb 35                	jmp    102205 <ramfs_block_read+0x79>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  1021d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021d3:	8b 00                	mov    (%eax),%eax
  1021d5:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1021dc:	8b 10                	mov    (%eax),%edx
  1021de:	8b 45 08             	mov    0x8(%ebp),%eax
  1021e1:	8b 40 08             	mov    0x8(%eax),%eax
  1021e4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1021e7:	83 ec 04             	sub    $0x4,%esp
  1021ea:	ff 75 10             	pushl  0x10(%ebp)
  1021ed:	50                   	push   %eax
  1021ee:	ff 75 0c             	pushl  0xc(%ebp)
  1021f1:	e8 78 17 00 00       	call   10396e <memcpy>
  1021f6:	83 c4 10             	add    $0x10,%esp

        return RW_OK;
  1021f9:	b8 00 00 00 00       	mov    $0x0,%eax
  1021fe:	eb 05                	jmp    102205 <ramfs_block_read+0x79>
    }

    return RW_ERR_DRIVER;
  102200:	b8 03 00 00 00       	mov    $0x3,%eax
}
  102205:	c9                   	leave  
  102206:	c3                   	ret    

00102207 <ramfs_block_write>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  102207:	55                   	push   %ebp
  102208:	89 e5                	mov    %esp,%ebp
  10220a:	83 ec 18             	sub    $0x18,%esp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10220d:	8b 45 08             	mov    0x8(%ebp),%eax
  102210:	8b 40 04             	mov    0x4(%eax),%eax
  102213:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  102216:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102219:	8b 00                	mov    (%eax),%eax
  10221b:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102222:	85 c0                	test   %eax,%eax
  102224:	74 55                	je     10227b <ramfs_block_write+0x74>
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF; //Can't write  that much biatch TODO realloc so file may grow and implement RW_EOF
  102226:	8b 45 08             	mov    0x8(%ebp),%eax
  102229:	8b 40 08             	mov    0x8(%eax),%eax
  10222c:	89 c2                	mov    %eax,%edx
  10222e:	03 55 10             	add    0x10(%ebp),%edx
  102231:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102234:	8b 00                	mov    (%eax),%eax
  102236:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10223d:	8b 40 04             	mov    0x4(%eax),%eax
  102240:	39 c2                	cmp    %eax,%edx
  102242:	76 07                	jbe    10224b <ramfs_block_write+0x44>
  102244:	b8 06 00 00 00       	mov    $0x6,%eax
  102249:	eb 35                	jmp    102280 <ramfs_block_write+0x79>

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  10224b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10224e:	8b 00                	mov    (%eax),%eax
  102250:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102257:	8b 10                	mov    (%eax),%edx
  102259:	8b 45 08             	mov    0x8(%ebp),%eax
  10225c:	8b 40 08             	mov    0x8(%eax),%eax
  10225f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  102262:	83 ec 04             	sub    $0x4,%esp
  102265:	ff 75 10             	pushl  0x10(%ebp)
  102268:	ff 75 0c             	pushl  0xc(%ebp)
  10226b:	50                   	push   %eax
  10226c:	e8 fd 16 00 00       	call   10396e <memcpy>
  102271:	83 c4 10             	add    $0x10,%esp

        return RW_OK;
  102274:	b8 00 00 00 00       	mov    $0x0,%eax
  102279:	eb 05                	jmp    102280 <ramfs_block_write+0x79>
    }

    return RW_ERR_DRIVER;
  10227b:	b8 03 00 00 00       	mov    $0x3,%eax
}
  102280:	c9                   	leave  
  102281:	c3                   	ret    

00102282 <ramfs_block_open>:

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  102282:	55                   	push   %ebp
  102283:	89 e5                	mov    %esp,%ebp
  102285:	83 ec 18             	sub    $0x18,%esp
    if(buffer[kf->id] != 0) {
  102288:	8b 45 08             	mov    0x8(%ebp),%eax
  10228b:	8b 00                	mov    (%eax),%eax
  10228d:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102294:	85 c0                	test   %eax,%eax
  102296:	74 74                	je     10230c <ramfs_block_open+0x8a>
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  102298:	8b 45 0c             	mov    0xc(%ebp),%eax
  10229b:	83 e0 01             	and    $0x1,%eax
  10229e:	84 c0                	test   %al,%al
  1022a0:	74 13                	je     1022b5 <ramfs_block_open+0x33>
  1022a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1022a5:	8b 00                	mov    (%eax),%eax
  1022a7:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1022ae:	8b 50 08             	mov    0x8(%eax),%edx
  1022b1:	42                   	inc    %edx
  1022b2:	89 50 08             	mov    %edx,0x8(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  1022b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  1022b8:	83 e0 02             	and    $0x2,%eax
  1022bb:	85 c0                	test   %eax,%eax
  1022bd:	74 13                	je     1022d2 <ramfs_block_open+0x50>
  1022bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1022c2:	8b 00                	mov    (%eax),%eax
  1022c4:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1022cb:	8b 50 0c             	mov    0xc(%eax),%edx
  1022ce:	42                   	inc    %edx
  1022cf:	89 50 0c             	mov    %edx,0xc(%eax)

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  1022d2:	83 ec 0c             	sub    $0xc,%esp
  1022d5:	6a 10                	push   $0x10
  1022d7:	e8 ca 13 00 00       	call   1036a6 <malloc>
  1022dc:	83 c4 10             	add    $0x10,%esp
  1022df:	89 45 f4             	mov    %eax,-0xc(%ebp)

        rethandle->filemode = filemode;
  1022e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1022e8:	89 50 0c             	mov    %edx,0xc(%eax)
        rethandle->position = 0;
  1022eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022ee:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  1022f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022f8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  1022fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102301:	8b 55 08             	mov    0x8(%ebp),%edx
  102304:	89 50 04             	mov    %edx,0x4(%eax)

        return rethandle;
  102307:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10230a:	eb 05                	jmp    102311 <ramfs_block_open+0x8f>
    }

    return (void*)1;
  10230c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  102311:	c9                   	leave  
  102312:	c3                   	ret    

00102313 <ramfs_block_close>:

uint32_t ramfs_block_close(struct res_handle* handle) {
  102313:	55                   	push   %ebp
  102314:	89 e5                	mov    %esp,%ebp
  102316:	83 ec 18             	sub    $0x18,%esp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102319:	8b 45 08             	mov    0x8(%ebp),%eax
  10231c:	8b 40 04             	mov    0x4(%eax),%eax
  10231f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  102322:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102325:	8b 00                	mov    (%eax),%eax
  102327:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10232e:	85 c0                	test   %eax,%eax
  102330:	74 40                	je     102372 <ramfs_block_close+0x5f>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  102332:	8b 45 08             	mov    0x8(%ebp),%eax
  102335:	8b 40 0c             	mov    0xc(%eax),%eax
  102338:	83 e0 01             	and    $0x1,%eax
  10233b:	84 c0                	test   %al,%al
  10233d:	74 13                	je     102352 <ramfs_block_close+0x3f>
  10233f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102342:	8b 00                	mov    (%eax),%eax
  102344:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10234b:	8b 50 08             	mov    0x8(%eax),%edx
  10234e:	4a                   	dec    %edx
  10234f:	89 50 08             	mov    %edx,0x8(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  102352:	8b 45 08             	mov    0x8(%ebp),%eax
  102355:	8b 40 0c             	mov    0xc(%eax),%eax
  102358:	83 e0 02             	and    $0x2,%eax
  10235b:	85 c0                	test   %eax,%eax
  10235d:	74 13                	je     102372 <ramfs_block_close+0x5f>
  10235f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102362:	8b 00                	mov    (%eax),%eax
  102364:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10236b:	8b 50 0c             	mov    0xc(%eax),%edx
  10236e:	4a                   	dec    %edx
  10236f:	89 50 0c             	mov    %edx,0xc(%eax)
    }

    free(handle);
  102372:	83 ec 0c             	sub    $0xc,%esp
  102375:	ff 75 08             	pushl  0x8(%ebp)
  102378:	e8 6f 15 00 00       	call   1038ec <free>
  10237d:	83 c4 10             	add    $0x10,%esp

    return 0;
  102380:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102385:	c9                   	leave  
  102386:	c3                   	ret    
	...

00102388 <ramfs_fifo_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  102388:	55                   	push   %ebp
  102389:	89 e5                	mov    %esp,%ebp
  10238b:	83 ec 08             	sub    $0x8,%esp
    memset(buffer, 0, sizeof(buffer));
  10238e:	83 ec 04             	sub    $0x4,%esp
  102391:	68 00 00 04 00       	push   $0x40000
  102396:	6a 00                	push   $0x0
  102398:	68 c0 85 18 00       	push   $0x1885c0
  10239d:	e8 9e 15 00 00       	call   103940 <memset>
  1023a2:	83 c4 10             	add    $0x10,%esp
}
  1023a5:	c9                   	leave  
  1023a6:	c3                   	ret    

001023a7 <ramfs_fifo_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  1023a7:	55                   	push   %ebp
  1023a8:	89 e5                	mov    %esp,%ebp
    return &block_driver;
  1023aa:	b8 bc 60 10 00       	mov    $0x1060bc,%eax
}
  1023af:	5d                   	pop    %ebp
  1023b0:	c3                   	ret    

001023b1 <ramfs_fifo_available>:

uint32_t ramfs_block_available(struct res_handle* handle) {
  1023b1:	55                   	push   %ebp
  1023b2:	89 e5                	mov    %esp,%ebp
  1023b4:	83 ec 10             	sub    $0x10,%esp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1023b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1023ba:	8b 40 04             	mov    0x4(%eax),%eax
  1023bd:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(buffer[kf->id] != 0) {
  1023c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1023c3:	8b 00                	mov    (%eax),%eax
  1023c5:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1023cc:	85 c0                	test   %eax,%eax
  1023ce:	74 11                	je     1023e1 <ramfs_fifo_available+0x30>
        return buffer[kf->id]->size - handle->position;
  1023d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1023d3:	8b 00                	mov    (%eax),%eax
  1023d5:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1023dc:	8b 40 08             	mov    0x8(%eax),%eax
  1023df:	eb 05                	jmp    1023e6 <ramfs_fifo_available+0x35>
    }

    return 0;
  1023e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1023e6:	c9                   	leave  
  1023e7:	c3                   	ret    

001023e8 <ramfs_fifo_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  1023e8:	55                   	push   %ebp
  1023e9:	89 e5                	mov    %esp,%ebp
  1023eb:	53                   	push   %ebx
  1023ec:	83 ec 14             	sub    $0x14,%esp
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  1023ef:	83 ec 0c             	sub    $0xc,%esp
  1023f2:	6a 08                	push   $0x8
  1023f4:	e8 ad 12 00 00       	call   1036a6 <malloc>
  1023f9:	83 c4 10             	add    $0x10,%esp
  1023fc:	89 45 f0             	mov    %eax,-0x10(%ebp)

    for(int i = 0; i < 65536; i++) {
  1023ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102406:	e9 9b 00 00 00       	jmp    1024a6 <ramfs_fifo_create+0xbe>
        if(buffer[i] == 0) {
  10240b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10240e:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102415:	85 c0                	test   %eax,%eax
  102417:	0f 85 86 00 00 00    	jne    1024a3 <ramfs_fifo_create+0xbb>
            buffer[i] = malloc(sizeof(struct block_buffer));
  10241d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  102420:	83 ec 0c             	sub    $0xc,%esp
  102423:	6a 14                	push   $0x14
  102425:	e8 7c 12 00 00       	call   1036a6 <malloc>
  10242a:	83 c4 10             	add    $0x10,%esp
  10242d:	89 04 9d c0 85 18 00 	mov    %eax,0x1885c0(,%ebx,4)
            buffer[i]->buffer = malloc(args[0]);
  102434:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102437:	8b 1c 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%ebx
  10243e:	8b 45 08             	mov    0x8(%ebp),%eax
  102441:	8b 00                	mov    (%eax),%eax
  102443:	83 ec 0c             	sub    $0xc,%esp
  102446:	50                   	push   %eax
  102447:	e8 5a 12 00 00       	call   1036a6 <malloc>
  10244c:	83 c4 10             	add    $0x10,%esp
  10244f:	89 03                	mov    %eax,(%ebx)
            buffer[i]->size   = args[0];
  102451:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102454:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10245b:	8b 55 08             	mov    0x8(%ebp),%edx
  10245e:	8b 12                	mov    (%edx),%edx
  102460:	89 50 04             	mov    %edx,0x4(%eax)

            buffer[i]->writers = 0;
  102463:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102466:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10246d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            buffer[i]->readers = 0;
  102474:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102477:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10247e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  102485:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102488:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10248f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            kfret->id = i;

  102496:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102499:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10249c:	89 10                	mov    %edx,(%eax)
            return kfret;
        }
  10249e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1024a1:	eb 15                	jmp    1024b8 <ramfs_fifo_create+0xd0>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  1024a3:	ff 45 f4             	incl   -0xc(%ebp)
  1024a6:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
  1024ad:	0f 8e 58 ff ff ff    	jle    10240b <ramfs_fifo_create+0x23>
            return kfret;
        }
    }

    return 0;
}
  1024b3:	b8 00 00 00 00       	mov    $0x0,%eax

  1024b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1024bb:	c9                   	leave  
  1024bc:	c3                   	ret    

001024bd <ramfs_fifo_read>:
uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1024bd:	55                   	push   %ebp
  1024be:	89 e5                	mov    %esp,%ebp
  1024c0:	83 ec 18             	sub    $0x18,%esp

  1024c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1024c6:	8b 40 04             	mov    0x4(%eax),%eax
  1024c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;
  1024cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024cf:	8b 00                	mov    (%eax),%eax
  1024d1:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1024d8:	85 c0                	test   %eax,%eax
  1024da:	0f 84 c7 00 00 00    	je     1025a7 <ramfs_fifo_read+0xea>

  1024e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024e3:	8b 00                	mov    (%eax),%eax
  1024e5:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1024ec:	8b 40 04             	mov    0x4(%eax),%eax
  1024ef:	3b 45 10             	cmp    0x10(%ebp),%eax
  1024f2:	73 0a                	jae    1024fe <ramfs_fifo_read+0x41>
  1024f4:	b8 03 00 00 00       	mov    $0x3,%eax
  1024f9:	e9 ae 00 00 00       	jmp    1025ac <ramfs_fifo_read+0xef>
        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  1024fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102501:	8b 00                	mov    (%eax),%eax
  102503:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10250a:	8b 40 08             	mov    0x8(%eax),%eax
  10250d:	3b 45 10             	cmp    0x10(%ebp),%eax
  102510:	73 0a                	jae    10251c <ramfs_fifo_read+0x5f>
  102512:	b8 01 00 00 00       	mov    $0x1,%eax
  102517:	e9 90 00 00 00       	jmp    1025ac <ramfs_fifo_read+0xef>

        return RW_OK;
  10251c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10251f:	8b 00                	mov    (%eax),%eax
  102521:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102528:	8b 00                	mov    (%eax),%eax
  10252a:	83 ec 04             	sub    $0x4,%esp
  10252d:	ff 75 10             	pushl  0x10(%ebp)
  102530:	50                   	push   %eax
  102531:	ff 75 0c             	pushl  0xc(%ebp)
  102534:	e8 35 14 00 00       	call   10396e <memcpy>
  102539:	83 c4 10             	add    $0x10,%esp
    }
  10253c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10253f:	8b 00                	mov    (%eax),%eax
  102541:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102548:	8b 40 08             	mov    0x8(%eax),%eax
  10254b:	89 c1                	mov    %eax,%ecx
  10254d:	2b 4d 10             	sub    0x10(%ebp),%ecx
  102550:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102553:	8b 00                	mov    (%eax),%eax
  102555:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10255c:	8b 00                	mov    (%eax),%eax
  10255e:	89 c2                	mov    %eax,%edx
  102560:	03 55 10             	add    0x10(%ebp),%edx
  102563:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102566:	8b 00                	mov    (%eax),%eax
  102568:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10256f:	8b 00                	mov    (%eax),%eax
  102571:	83 ec 04             	sub    $0x4,%esp
  102574:	51                   	push   %ecx
  102575:	52                   	push   %edx
  102576:	50                   	push   %eax
  102577:	e8 f2 13 00 00       	call   10396e <memcpy>
  10257c:	83 c4 10             	add    $0x10,%esp

  10257f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102582:	8b 00                	mov    (%eax),%eax
  102584:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10258b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10258e:	8b 12                	mov    (%edx),%edx
  102590:	8b 14 95 c0 85 18 00 	mov    0x1885c0(,%edx,4),%edx
  102597:	8b 52 08             	mov    0x8(%edx),%edx
  10259a:	2b 55 10             	sub    0x10(%ebp),%edx
  10259d:	89 50 08             	mov    %edx,0x8(%eax)
    return RW_ERR_DRIVER;
}
  1025a0:	b8 00 00 00 00       	mov    $0x0,%eax
  1025a5:	eb 05                	jmp    1025ac <ramfs_fifo_read+0xef>

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1025a7:	b8 03 00 00 00       	mov    $0x3,%eax

  1025ac:	c9                   	leave  
  1025ad:	c3                   	ret    

001025ae <ramfs_fifo_write>:
    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF; //Can't write  that much biatch TODO realloc so file may grow and implement RW_EOF
  1025ae:	55                   	push   %ebp
  1025af:	89 e5                	mov    %esp,%ebp
  1025b1:	83 ec 18             	sub    $0x18,%esp

  1025b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1025b7:	8b 40 04             	mov    0x4(%eax),%eax
  1025ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        memcpy(buffer[kf->id]->buffer + handle->position, src, length);

  1025bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025c0:	8b 00                	mov    (%eax),%eax
  1025c2:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1025c9:	85 c0                	test   %eax,%eax
  1025cb:	0f 84 a8 00 00 00    	je     102679 <ramfs_fifo_write+0xcb>
        return RW_OK;
  1025d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025d4:	8b 00                	mov    (%eax),%eax
  1025d6:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1025dd:	8b 40 04             	mov    0x4(%eax),%eax
  1025e0:	3b 45 10             	cmp    0x10(%ebp),%eax
  1025e3:	73 0a                	jae    1025ef <ramfs_fifo_write+0x41>
  1025e5:	b8 03 00 00 00       	mov    $0x3,%eax
  1025ea:	e9 8f 00 00 00       	jmp    10267e <ramfs_fifo_write+0xd0>
    }
  1025ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025f2:	8b 00                	mov    (%eax),%eax
  1025f4:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1025fb:	8b 50 04             	mov    0x4(%eax),%edx
  1025fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102601:	8b 00                	mov    (%eax),%eax
  102603:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10260a:	8b 40 08             	mov    0x8(%eax),%eax
  10260d:	89 d1                	mov    %edx,%ecx
  10260f:	29 c1                	sub    %eax,%ecx
  102611:	89 c8                	mov    %ecx,%eax
  102613:	3b 45 10             	cmp    0x10(%ebp),%eax
  102616:	73 07                	jae    10261f <ramfs_fifo_write+0x71>
  102618:	b8 01 00 00 00       	mov    $0x1,%eax
  10261d:	eb 5f                	jmp    10267e <ramfs_fifo_write+0xd0>

    return RW_ERR_DRIVER;
  10261f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102622:	8b 00                	mov    (%eax),%eax
  102624:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10262b:	8b 10                	mov    (%eax),%edx
  10262d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102630:	8b 00                	mov    (%eax),%eax
  102632:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102639:	8b 40 08             	mov    0x8(%eax),%eax
  10263c:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10263f:	83 ec 04             	sub    $0x4,%esp
  102642:	ff 75 10             	pushl  0x10(%ebp)
  102645:	ff 75 0c             	pushl  0xc(%ebp)
  102648:	50                   	push   %eax
  102649:	e8 20 13 00 00       	call   10396e <memcpy>
  10264e:	83 c4 10             	add    $0x10,%esp
}
  102651:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102654:	8b 00                	mov    (%eax),%eax
  102656:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10265d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102660:	8b 12                	mov    (%edx),%edx
  102662:	8b 14 95 c0 85 18 00 	mov    0x1885c0(,%edx,4),%edx
  102669:	8b 52 08             	mov    0x8(%edx),%edx
  10266c:	03 55 10             	add    0x10(%ebp),%edx
  10266f:	89 50 08             	mov    %edx,0x8(%eax)

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  102672:	b8 00 00 00 00       	mov    $0x0,%eax
  102677:	eb 05                	jmp    10267e <ramfs_fifo_write+0xd0>
    if(buffer[kf->id] != 0) {
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  102679:	b8 03 00 00 00       	mov    $0x3,%eax

  10267e:	c9                   	leave  
  10267f:	c3                   	ret    

00102680 <ramfs_fifo_open>:
        struct res_handle* rethandle = malloc(sizeof(struct res_handle));

  102680:	55                   	push   %ebp
  102681:	89 e5                	mov    %esp,%ebp
  102683:	83 ec 18             	sub    $0x18,%esp
        rethandle->filemode = filemode;
  102686:	8b 45 08             	mov    0x8(%ebp),%eax
  102689:	8b 00                	mov    (%eax),%eax
  10268b:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102692:	85 c0                	test   %eax,%eax
  102694:	0f 84 85 00 00 00    	je     10271f <ramfs_fifo_open+0x9f>
        rethandle->position = 0;
  10269a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10269d:	83 e0 04             	and    $0x4,%eax
  1026a0:	85 c0                	test   %eax,%eax
  1026a2:	74 07                	je     1026ab <ramfs_fifo_open+0x2b>
  1026a4:	b8 00 00 00 00       	mov    $0x0,%eax
  1026a9:	eb 79                	jmp    102724 <ramfs_fifo_open+0xa4>
        rethandle->res_type = RES_KERNDRV;
        rethandle->res_ptr  = kf;
  1026ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026ae:	83 e0 01             	and    $0x1,%eax
  1026b1:	84 c0                	test   %al,%al
  1026b3:	74 13                	je     1026c8 <ramfs_fifo_open+0x48>
  1026b5:	8b 45 08             	mov    0x8(%ebp),%eax
  1026b8:	8b 00                	mov    (%eax),%eax
  1026ba:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1026c1:	8b 50 0c             	mov    0xc(%eax),%edx
  1026c4:	42                   	inc    %edx
  1026c5:	89 50 0c             	mov    %edx,0xc(%eax)

  1026c8:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026cb:	83 e0 02             	and    $0x2,%eax
  1026ce:	85 c0                	test   %eax,%eax
  1026d0:	74 13                	je     1026e5 <ramfs_fifo_open+0x65>
  1026d2:	8b 45 08             	mov    0x8(%ebp),%eax
  1026d5:	8b 00                	mov    (%eax),%eax
  1026d7:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1026de:	8b 50 10             	mov    0x10(%eax),%edx
  1026e1:	42                   	inc    %edx
  1026e2:	89 50 10             	mov    %edx,0x10(%eax)
        return rethandle;
    }
  1026e5:	83 ec 0c             	sub    $0xc,%esp
  1026e8:	6a 10                	push   $0x10
  1026ea:	e8 b7 0f 00 00       	call   1036a6 <malloc>
  1026ef:	83 c4 10             	add    $0x10,%esp
  1026f2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return (void*)1;
  1026f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026f8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1026fb:	89 50 0c             	mov    %edx,0xc(%eax)
}
  1026fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102701:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  102708:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10270b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
uint32_t ramfs_block_close(struct res_handle* handle) {
  102711:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102714:	8b 55 08             	mov    0x8(%ebp),%edx
  102717:	89 50 04             	mov    %edx,0x4(%eax)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

  10271a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10271d:	eb 05                	jmp    102724 <ramfs_fifo_open+0xa4>
    if(buffer[kf->id] != 0) {
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  10271f:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  102724:	c9                   	leave  
  102725:	c3                   	ret    

00102726 <ramfs_fifo_close>:

    free(handle);
  102726:	55                   	push   %ebp
  102727:	89 e5                	mov    %esp,%ebp
  102729:	83 ec 18             	sub    $0x18,%esp

  10272c:	8b 45 08             	mov    0x8(%ebp),%eax
  10272f:	8b 40 04             	mov    0x4(%eax),%eax
  102732:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return 0;
}
  102735:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102738:	8b 00                	mov    (%eax),%eax
  10273a:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102741:	85 c0                	test   %eax,%eax
  102743:	74 40                	je     102785 <ramfs_fifo_close+0x5f>
  102745:	8b 45 08             	mov    0x8(%ebp),%eax
  102748:	8b 40 0c             	mov    0xc(%eax),%eax
  10274b:	83 e0 01             	and    $0x1,%eax
  10274e:	84 c0                	test   %al,%al
  102750:	74 13                	je     102765 <ramfs_fifo_close+0x3f>
  102752:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102755:	8b 00                	mov    (%eax),%eax
  102757:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10275e:	8b 50 0c             	mov    0xc(%eax),%edx
  102761:	4a                   	dec    %edx
  102762:	89 50 0c             	mov    %edx,0xc(%eax)
  102765:	8b 45 08             	mov    0x8(%ebp),%eax
  102768:	8b 40 0c             	mov    0xc(%eax),%eax
  10276b:	83 e0 02             	and    $0x2,%eax
  10276e:	85 c0                	test   %eax,%eax
  102770:	74 13                	je     102785 <ramfs_fifo_close+0x5f>
  102772:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102775:	8b 00                	mov    (%eax),%eax
  102777:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10277e:	8b 50 10             	mov    0x10(%eax),%edx
  102781:	4a                   	dec    %edx
  102782:	89 50 10             	mov    %edx,0x10(%eax)
  102785:	83 ec 0c             	sub    $0xc,%esp
  102788:	ff 75 08             	pushl  0x8(%ebp)
  10278b:	e8 5c 11 00 00       	call   1038ec <free>
  102790:	83 c4 10             	add    $0x10,%esp
  102793:	b8 00 00 00 00       	mov    $0x0,%eax
  102798:	c9                   	leave  
  102799:	c3                   	ret    
	...

0010279c <tar_parse_number>:
  10279c:	55                   	push   %ebp
  10279d:	89 e5                	mov    %esp,%ebp
  10279f:	83 ec 10             	sub    $0x10,%esp
  1027a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1027a9:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1027b0:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
  1027b7:	eb 1d                	jmp    1027d6 <tar_parse_number+0x3a>
  1027b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1027bc:	48                   	dec    %eax
  1027bd:	03 45 08             	add    0x8(%ebp),%eax
  1027c0:	8a 00                	mov    (%eax),%al
  1027c2:	0f be c0             	movsbl %al,%eax
  1027c5:	83 e8 30             	sub    $0x30,%eax
  1027c8:	0f af 45 fc          	imul   -0x4(%ebp),%eax
  1027cc:	01 45 f4             	add    %eax,-0xc(%ebp)
  1027cf:	ff 4d f8             	decl   -0x8(%ebp)
  1027d2:	c1 65 fc 03          	shll   $0x3,-0x4(%ebp)
  1027d6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1027da:	75 dd                	jne    1027b9 <tar_parse_number+0x1d>
  1027dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027df:	c9                   	leave  
  1027e0:	c3                   	ret    

001027e1 <tar_load_ramfs>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  1027e1:	55                   	push   %ebp
  1027e2:	89 e5                	mov    %esp,%ebp
  1027e4:	83 ec 28             	sub    $0x28,%esp
    return &block_driver;
  1027e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1027ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

uint32_t ramfs_block_available(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1027ed:	83 ec 08             	sub    $0x8,%esp
  1027f0:	ff 75 e4             	pushl  -0x1c(%ebp)
  1027f3:	68 94 76 10 00       	push   $0x107694
  1027f8:	e8 70 dd ff ff       	call   10056d <kprintf>
  1027fd:	83 c4 10             	add    $0x10,%esp

    if(buffer[kf->id] != 0) {
  102800:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        return buffer[kf->id]->size - handle->position;
    }

  102807:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10280a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    return 0;
}
  10280d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102810:	8a 00                	mov    (%eax),%al
  102812:	84 c0                	test   %al,%al
  102814:	75 12                	jne    102828 <tar_load_ramfs+0x47>
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);

        return RW_OK;
    }
  102816:	83 ec 0c             	sub    $0xc,%esp
  102819:	68 c0 76 10 00       	push   $0x1076c0
  10281e:	e8 4a dd ff ff       	call   10056d <kprintf>
  102823:	83 c4 10             	add    $0x10,%esp

  102826:	c9                   	leave  
  102827:	c3                   	ret    

    return 0;
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  102828:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10282b:	83 c0 7c             	add    $0x7c,%eax
  10282e:	83 ec 0c             	sub    $0xc,%esp
  102831:	50                   	push   %eax
  102832:	e8 65 ff ff ff       	call   10279c <tar_parse_number>
  102837:	83 c4 10             	add    $0x10,%esp
  10283a:	89 45 e0             	mov    %eax,-0x20(%ebp)

  10283d:	81 45 e4 00 02 00 00 	addl   $0x200,-0x1c(%ebp)
    for(int i = 0; i < 65536; i++) {
        if(buffer[i] == 0) {
  102844:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102847:	85 c0                	test   %eax,%eax
  102849:	0f 84 85 00 00 00    	je     1028d4 <tar_load_ramfs+0xf3>
            buffer[i] = malloc(sizeof(struct block_buffer));
  10284f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102852:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102855:	83 ec 04             	sub    $0x4,%esp
  102858:	52                   	push   %edx
  102859:	50                   	push   %eax
  10285a:	68 e8 76 10 00       	push   $0x1076e8
  10285f:	e8 09 dd ff ff       	call   10056d <kprintf>
  102864:	83 c4 10             	add    $0x10,%esp
            buffer[i]->buffer = malloc(args[0]);
            buffer[i]->size   = args[0];
  102867:	e8 13 f8 ff ff       	call   10207f <ramfs_block_driver_struct>
  10286c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10286f:	83 ec 04             	sub    $0x4,%esp
  102872:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  102875:	51                   	push   %ecx
  102876:	50                   	push   %eax
  102877:	52                   	push   %edx
  102878:	e8 51 19 00 00       	call   1041ce <vfs_create_kfile>
  10287d:	83 c4 10             	add    $0x10,%esp

  102880:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102883:	83 ec 08             	sub    $0x8,%esp
  102886:	6a 02                	push   $0x2
  102888:	50                   	push   %eax
  102889:	e8 df 19 00 00       	call   10426d <vfs_open>
  10288e:	83 c4 10             	add    $0x10,%esp
  102891:	89 45 f0             	mov    %eax,-0x10(%ebp)
            buffer[i]->writers = 0;
            buffer[i]->readers = 0;
  102894:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102897:	6a 01                	push   $0x1
  102899:	50                   	push   %eax
  10289a:	ff 75 e4             	pushl  -0x1c(%ebp)
  10289d:	ff 75 f0             	pushl  -0x10(%ebp)
  1028a0:	e8 e4 1a 00 00       	call   104389 <vfs_write>
  1028a5:	83 c4 10             	add    $0x10,%esp
  1028a8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  1028ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1028af:	74 13                	je     1028c4 <tar_load_ramfs+0xe3>
            kfret->id = i;
  1028b1:	83 ec 08             	sub    $0x8,%esp
  1028b4:	ff 75 f4             	pushl  -0xc(%ebp)
  1028b7:	68 0c 77 10 00       	push   $0x10770c
  1028bc:	e8 ac dc ff ff       	call   10056d <kprintf>
  1028c1:	83 c4 10             	add    $0x10,%esp

            return kfret;
        }
  1028c4:	83 ec 0c             	sub    $0xc,%esp
  1028c7:	ff 75 f0             	pushl  -0x10(%ebp)
  1028ca:	e8 fb 19 00 00       	call   1042ca <vfs_close>
  1028cf:	83 c4 10             	add    $0x10,%esp
  1028d2:	eb 27                	jmp    1028fb <tar_load_ramfs+0x11a>
    }

    return 0;
}
  1028d4:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1028d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1028da:	83 ec 04             	sub    $0x4,%esp
  1028dd:	52                   	push   %edx
  1028de:	50                   	push   %eax
  1028df:	68 28 77 10 00       	push   $0x107728
  1028e4:	e8 84 dc ff ff       	call   10056d <kprintf>
  1028e9:	83 c4 10             	add    $0x10,%esp

  1028ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1028ef:	83 ec 0c             	sub    $0xc,%esp
  1028f2:	50                   	push   %eax
  1028f3:	e8 c0 18 00 00       	call   1041b8 <vfs_create_dir>
  1028f8:	83 c4 10             	add    $0x10,%esp
uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

  1028fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1028fe:	c1 e8 09             	shr    $0x9,%eax
  102901:	c1 e0 09             	shl    $0x9,%eax
  102904:	01 45 e4             	add    %eax,-0x1c(%ebp)
    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;
  102907:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10290a:	25 ff 01 00 00       	and    $0x1ff,%eax
  10290f:	85 c0                	test   %eax,%eax
  102911:	74 07                	je     10291a <tar_load_ramfs+0x139>

  102913:	81 45 e4 00 02 00 00 	addl   $0x200,-0x1c(%ebp)
}

uint32_t ramfs_block_available(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

    if(buffer[kf->id] != 0) {
  10291a:	ff 45 e8             	incl   -0x18(%ebp)

    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);

  10291d:	e9 e5 fe ff ff       	jmp    102807 <tar_load_ramfs+0x26>
	...

00102924 <ramfs_vga_driver_struct>:
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
  102924:	55                   	push   %ebp
  102925:	89 e5                	mov    %esp,%ebp
    return &vga_driver;
  102927:	b8 dc 60 10 00       	mov    $0x1060dc,%eax
}
  10292c:	5d                   	pop    %ebp
  10292d:	c3                   	ret    

0010292e <ramfs_vga_writers>:

uint32_t ramfs_vga_writers() {
  10292e:	55                   	push   %ebp
  10292f:	89 e5                	mov    %esp,%ebp
    return vga_writers;
  102931:	a1 24 85 12 00       	mov    0x128524,%eax
}
  102936:	5d                   	pop    %ebp
  102937:	c3                   	ret    

00102938 <ramfs_vga_available>:

uint32_t ramfs_vga_available(struct res_handle* handle) {
  102938:	55                   	push   %ebp
  102939:	89 e5                	mov    %esp,%ebp
    return sizeof(struct vga_command);
  10293b:	b8 06 00 00 00       	mov    $0x6,%eax
}
  102940:	5d                   	pop    %ebp
  102941:	c3                   	ret    

00102942 <ramfs_vga_create>:

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  102942:	55                   	push   %ebp
  102943:	89 e5                	mov    %esp,%ebp
  102945:	83 ec 08             	sub    $0x8,%esp
    return malloc(sizeof(struct res_kfile));
  102948:	83 ec 0c             	sub    $0xc,%esp
  10294b:	6a 08                	push   $0x8
  10294d:	e8 54 0d 00 00       	call   1036a6 <malloc>
  102952:	83 c4 10             	add    $0x10,%esp
}
  102955:	c9                   	leave  
  102956:	c3                   	ret    

00102957 <ramfs_vga_read>:

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  102957:	55                   	push   %ebp
  102958:	89 e5                	mov    %esp,%ebp
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  10295a:	b8 03 00 00 00       	mov    $0x3,%eax
}
  10295f:	5d                   	pop    %ebp
  102960:	c3                   	ret    

00102961 <ramfs_vga_write>:

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  102961:	55                   	push   %ebp
  102962:	89 e5                	mov    %esp,%ebp
  102964:	83 ec 10             	sub    $0x10,%esp
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  102967:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
  10296b:	74 0a                	je     102977 <ramfs_vga_write+0x16>
  10296d:	b8 03 00 00 00       	mov    $0x3,%eax
  102972:	e9 d7 00 00 00       	jmp    102a4e <ramfs_vga_write+0xed>

    struct vga_command* vgac = src;
  102977:	8b 45 0c             	mov    0xc(%ebp),%eax
  10297a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(vgac->command == CMD_SET) {
  10297d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102980:	66 8b 00             	mov    (%eax),%ax
  102983:	66 85 c0             	test   %ax,%ax
  102986:	75 2d                	jne    1029b5 <ramfs_vga_write+0x54>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  102988:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10298b:	66 8b 40 02          	mov    0x2(%eax),%ax
  10298f:	66 3d cf 07          	cmp    $0x7cf,%ax
  102993:	77 20                	ja     1029b5 <ramfs_vga_write+0x54>
  102995:	8b 15 d8 60 10 00    	mov    0x1060d8,%edx
  10299b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10299e:	66 8b 40 02          	mov    0x2(%eax),%ax
  1029a2:	25 ff ff 00 00       	and    $0xffff,%eax
  1029a7:	01 c0                	add    %eax,%eax
  1029a9:	01 c2                	add    %eax,%edx
  1029ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029ae:	66 8b 40 04          	mov    0x4(%eax),%ax
  1029b2:	66 89 02             	mov    %ax,(%edx)
    }

    if(vgac->command == CMD_CLEAR) {
  1029b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029b8:	66 8b 00             	mov    (%eax),%ax
  1029bb:	66 83 f8 01          	cmp    $0x1,%ax
  1029bf:	75 26                	jne    1029e7 <ramfs_vga_write+0x86>
        for(int i = 0; i < (80 * 25); i++) {
  1029c1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1029c8:	eb 14                	jmp    1029de <ramfs_vga_write+0x7d>
            vga_buffer[i] = 0;
  1029ca:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  1029cf:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1029d2:	01 d2                	add    %edx,%edx
  1029d4:	01 d0                	add    %edx,%eax
  1029d6:	66 c7 00 00 00       	movw   $0x0,(%eax)
    if(vgac->command == CMD_SET) {
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
  1029db:	ff 45 f8             	incl   -0x8(%ebp)
  1029de:	81 7d f8 cf 07 00 00 	cmpl   $0x7cf,-0x8(%ebp)
  1029e5:	7e e3                	jle    1029ca <ramfs_vga_write+0x69>
            vga_buffer[i] = 0;
        }
    }

    if(vgac->command == CMD_SCROLL) {
  1029e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029ea:	66 8b 00             	mov    (%eax),%ax
  1029ed:	66 83 f8 02          	cmp    $0x2,%ax
  1029f1:	75 56                	jne    102a49 <ramfs_vga_write+0xe8>
        int i;
        for (i = 0; i < 24 * 80; i++) {
  1029f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1029fa:	eb 25                	jmp    102a21 <ramfs_vga_write+0xc0>
            vga_buffer[i] = vga_buffer[i + 80];
  1029fc:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  102a01:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102a04:	01 d2                	add    %edx,%edx
  102a06:	8d 14 10             	lea    (%eax,%edx,1),%edx
  102a09:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  102a0e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  102a11:	83 c1 50             	add    $0x50,%ecx
  102a14:	01 c9                	add    %ecx,%ecx
  102a16:	01 c8                	add    %ecx,%eax
  102a18:	66 8b 00             	mov    (%eax),%ax
  102a1b:	66 89 02             	mov    %ax,(%edx)
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  102a1e:	ff 45 fc             	incl   -0x4(%ebp)
  102a21:	81 7d fc 7f 07 00 00 	cmpl   $0x77f,-0x4(%ebp)
  102a28:	7e d2                	jle    1029fc <ramfs_vga_write+0x9b>
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  102a2a:	eb 14                	jmp    102a40 <ramfs_vga_write+0xdf>
            vga_buffer[i] = 0;
  102a2c:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  102a31:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102a34:	01 d2                	add    %edx,%edx
  102a36:	01 d0                	add    %edx,%eax
  102a38:	66 c7 00 00 00       	movw   $0x0,(%eax)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  102a3d:	ff 45 fc             	incl   -0x4(%ebp)
  102a40:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
  102a47:	7e e3                	jle    102a2c <ramfs_vga_write+0xcb>
            vga_buffer[i] = 0;
        }
    }

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  102a49:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102a4e:	c9                   	leave  
  102a4f:	c3                   	ret    

00102a50 <ramfs_vga_open>:

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
  102a50:	55                   	push   %ebp
  102a51:	89 e5                	mov    %esp,%ebp
  102a53:	83 ec 18             	sub    $0x18,%esp
    if(filemode & FM_EXEC) return 0;
  102a56:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a59:	83 e0 04             	and    $0x4,%eax
  102a5c:	85 c0                	test   %eax,%eax
  102a5e:	74 07                	je     102a67 <ramfs_vga_open+0x17>
  102a60:	b8 00 00 00 00       	mov    $0x0,%eax
  102a65:	eb 78                	jmp    102adf <ramfs_vga_open+0x8f>
    if(filemode & FM_READ) return 0;
  102a67:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a6a:	83 e0 01             	and    $0x1,%eax
  102a6d:	84 c0                	test   %al,%al
  102a6f:	74 07                	je     102a78 <ramfs_vga_open+0x28>
  102a71:	b8 00 00 00 00       	mov    $0x0,%eax
  102a76:	eb 67                	jmp    102adf <ramfs_vga_open+0x8f>

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  102a78:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a7b:	83 e0 02             	and    $0x2,%eax
  102a7e:	85 c0                	test   %eax,%eax
  102a80:	74 10                	je     102a92 <ramfs_vga_open+0x42>
  102a82:	a1 24 85 12 00       	mov    0x128524,%eax
  102a87:	85 c0                	test   %eax,%eax
  102a89:	74 07                	je     102a92 <ramfs_vga_open+0x42>
  102a8b:	b8 00 00 00 00       	mov    $0x0,%eax
  102a90:	eb 4d                	jmp    102adf <ramfs_vga_open+0x8f>
    if((filemode & FM_WRITE)) vga_writers++;
  102a92:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a95:	83 e0 02             	and    $0x2,%eax
  102a98:	85 c0                	test   %eax,%eax
  102a9a:	74 0b                	je     102aa7 <ramfs_vga_open+0x57>
  102a9c:	a1 24 85 12 00       	mov    0x128524,%eax
  102aa1:	40                   	inc    %eax
  102aa2:	a3 24 85 12 00       	mov    %eax,0x128524

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  102aa7:	83 ec 0c             	sub    $0xc,%esp
  102aaa:	6a 10                	push   $0x10
  102aac:	e8 f5 0b 00 00       	call   1036a6 <malloc>
  102ab1:	83 c4 10             	add    $0x10,%esp
  102ab4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    rethandle->filemode = filemode;
  102ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102aba:	8b 55 0c             	mov    0xc(%ebp),%edx
  102abd:	89 50 0c             	mov    %edx,0xc(%eax)
    rethandle->position = 0;
  102ac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ac3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    rethandle->res_type = RES_KERNDRV;
  102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102acd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    rethandle->res_ptr  = kf;
  102ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ad6:	8b 55 08             	mov    0x8(%ebp),%edx
  102ad9:	89 50 04             	mov    %edx,0x4(%eax)

    return rethandle;
  102adc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  102adf:	c9                   	leave  
  102ae0:	c3                   	ret    

00102ae1 <ramfs_vga_close>:

uint32_t ramfs_vga_close(struct res_handle* handle) {
  102ae1:	55                   	push   %ebp
  102ae2:	89 e5                	mov    %esp,%ebp
  102ae4:	83 ec 08             	sub    $0x8,%esp
    if(handle->filemode & FM_WRITE) vga_writers--;
  102ae7:	8b 45 08             	mov    0x8(%ebp),%eax
  102aea:	8b 40 0c             	mov    0xc(%eax),%eax
  102aed:	83 e0 02             	and    $0x2,%eax
  102af0:	85 c0                	test   %eax,%eax
  102af2:	74 0b                	je     102aff <ramfs_vga_close+0x1e>
  102af4:	a1 24 85 12 00       	mov    0x128524,%eax
  102af9:	48                   	dec    %eax
  102afa:	a3 24 85 12 00       	mov    %eax,0x128524

    free(handle);
  102aff:	83 ec 0c             	sub    $0xc,%esp
  102b02:	ff 75 08             	pushl  0x8(%ebp)
  102b05:	e8 e2 0d 00 00       	call   1038ec <free>
  102b0a:	83 c4 10             	add    $0x10,%esp

    return 0;
  102b0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102b12:	c9                   	leave  
  102b13:	c3                   	ret    

00102b14 <enableScheduling>:
    .rread     = ramfs_block_read,
    .rwrite    = ramfs_block_write,
    .open      = ramfs_block_open,
    .create    = ramfs_block_create,
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
  102b14:	55                   	push   %ebp
  102b15:	89 e5                	mov    %esp,%ebp
    .drvname   = "RAMFILE"
  102b17:	c7 05 28 85 12 00 01 	movl   $0x1,0x128528
  102b1e:	00 00 00 
};
  102b21:	5d                   	pop    %ebp
  102b22:	c3                   	ret    

00102b23 <isSchedulingEnabled>:

struct kfs_driver* ramfs_block_driver_struct() {
  102b23:	55                   	push   %ebp
  102b24:	89 e5                	mov    %esp,%ebp
    return &block_driver;
  102b26:	a1 28 85 12 00       	mov    0x128528,%eax
}
  102b2b:	5d                   	pop    %ebp
  102b2c:	c3                   	ret    

00102b2d <get_current_task>:

uint32_t ramfs_block_available(struct res_handle* handle) {
  102b2d:	55                   	push   %ebp
  102b2e:	89 e5                	mov    %esp,%ebp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102b30:	a1 30 85 12 00       	mov    0x128530,%eax

  102b35:	5d                   	pop    %ebp
  102b36:	c3                   	ret    

00102b37 <get_task_by_pid>:
    if(buffer[kf->id] != 0) {
        return buffer[kf->id]->size - handle->position;
  102b37:	55                   	push   %ebp
  102b38:	89 e5                	mov    %esp,%ebp
  102b3a:	83 ec 10             	sub    $0x10,%esp
    }
  102b3d:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102b42:	89 45 fc             	mov    %eax,-0x4(%ebp)

    return 0;
  102b45:	eb 18                	jmp    102b5f <get_task_by_pid+0x28>
}
  102b47:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102b4a:	8b 00                	mov    (%eax),%eax
  102b4c:	3b 45 08             	cmp    0x8(%ebp),%eax
  102b4f:	75 05                	jne    102b56 <get_task_by_pid+0x1f>
  102b51:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102b54:	eb 14                	jmp    102b6a <get_task_by_pid+0x33>

  102b56:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102b59:	8b 40 08             	mov    0x8(%eax),%eax
  102b5c:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(buffer[kf->id] != 0) {
        return buffer[kf->id]->size - handle->position;
    }

    return 0;
  102b5f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  102b63:	75 e2                	jne    102b47 <get_task_by_pid+0x10>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

  102b65:	b8 00 00 00 00       	mov    $0x0,%eax
    for(int i = 0; i < 65536; i++) {
  102b6a:	c9                   	leave  
  102b6b:	c3                   	ret    

00102b6c <register_handle>:
        if(buffer[i] == 0) {
            buffer[i] = malloc(sizeof(struct block_buffer));
  102b6c:	55                   	push   %ebp
  102b6d:	89 e5                	mov    %esp,%ebp
  102b6f:	53                   	push   %ebx
  102b70:	83 ec 14             	sub    $0x14,%esp
            buffer[i]->buffer = malloc(args[0]);
  102b73:	a1 30 85 12 00       	mov    0x128530,%eax
  102b78:	8b 40 3c             	mov    0x3c(%eax),%eax
  102b7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
            buffer[i]->size   = args[0];

  102b7e:	8b 1d 30 85 12 00    	mov    0x128530,%ebx
  102b84:	83 ec 0c             	sub    $0xc,%esp
  102b87:	6a 08                	push   $0x8
  102b89:	e8 18 0b 00 00       	call   1036a6 <malloc>
  102b8e:	83 c4 10             	add    $0x10,%esp
  102b91:	89 43 3c             	mov    %eax,0x3c(%ebx)
            buffer[i]->writers = 0;
  102b94:	a1 30 85 12 00       	mov    0x128530,%eax
  102b99:	8b 40 3c             	mov    0x3c(%eax),%eax
  102b9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102b9f:	89 50 04             	mov    %edx,0x4(%eax)
            buffer[i]->readers = 0;
  102ba2:	a1 30 85 12 00       	mov    0x128530,%eax
  102ba7:	8b 40 3c             	mov    0x3c(%eax),%eax
  102baa:	8b 55 08             	mov    0x8(%ebp),%edx
  102bad:	89 10                	mov    %edx,(%eax)

            kfret->id = i;
  102baf:	b8 00 00 00 00       	mov    $0x0,%eax

  102bb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102bb7:	c9                   	leave  
  102bb8:	c3                   	ret    

00102bb9 <unregister_handle>:
            return kfret;
        }
  102bb9:	55                   	push   %ebp
  102bba:	89 e5                	mov    %esp,%ebp
  102bbc:	83 ec 18             	sub    $0x18,%esp
    }
  102bbf:	a1 30 85 12 00       	mov    0x128530,%eax
  102bc4:	8b 40 3c             	mov    0x3c(%eax),%eax
  102bc7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return 0;
  102bca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102bce:	75 0a                	jne    102bda <unregister_handle+0x21>
  102bd0:	b8 02 00 00 00       	mov    $0x2,%eax
  102bd5:	e9 88 00 00 00       	jmp    102c62 <unregister_handle+0xa9>
}
  102bda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102bde:	75 07                	jne    102be7 <unregister_handle+0x2e>
  102be0:	b8 01 00 00 00       	mov    $0x1,%eax
  102be5:	eb 7b                	jmp    102c62 <unregister_handle+0xa9>

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  102be7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102bea:	8b 00                	mov    (%eax),%eax
  102bec:	3b 45 08             	cmp    0x8(%ebp),%eax
  102bef:	75 66                	jne    102c57 <unregister_handle+0x9e>
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102bf1:	a1 30 85 12 00       	mov    0x128530,%eax
  102bf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102bf9:	8b 52 04             	mov    0x4(%edx),%edx
  102bfc:	89 50 3c             	mov    %edx,0x3c(%eax)

  102bff:	83 ec 0c             	sub    $0xc,%esp
  102c02:	ff 75 f0             	pushl  -0x10(%ebp)
  102c05:	e8 e2 0c 00 00       	call   1038ec <free>
  102c0a:	83 c4 10             	add    $0x10,%esp
    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;
  102c0d:	b8 00 00 00 00       	mov    $0x0,%eax
  102c12:	eb 4e                	jmp    102c62 <unregister_handle+0xa9>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);

        return RW_OK;
  102c14:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c17:	8b 40 04             	mov    0x4(%eax),%eax
  102c1a:	8b 00                	mov    (%eax),%eax
  102c1c:	3b 45 08             	cmp    0x8(%ebp),%eax
  102c1f:	75 2d                	jne    102c4e <unregister_handle+0x95>
    }
  102c21:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c24:	8b 40 04             	mov    0x4(%eax),%eax
  102c27:	89 45 f4             	mov    %eax,-0xc(%ebp)

  102c2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c2d:	8b 40 04             	mov    0x4(%eax),%eax
  102c30:	8b 50 04             	mov    0x4(%eax),%edx
  102c33:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c36:	89 50 04             	mov    %edx,0x4(%eax)
    return RW_ERR_DRIVER;
}
  102c39:	83 ec 0c             	sub    $0xc,%esp
  102c3c:	ff 75 f4             	pushl  -0xc(%ebp)
  102c3f:	e8 a8 0c 00 00       	call   1038ec <free>
  102c44:	83 c4 10             	add    $0x10,%esp

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  102c47:	b8 00 00 00 00       	mov    $0x0,%eax
  102c4c:	eb 14                	jmp    102c62 <unregister_handle+0xa9>
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

    if(buffer[kf->id] != 0) {
  102c4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c51:	8b 40 04             	mov    0x4(%eax),%eax
  102c54:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);

  102c57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102c5b:	75 b7                	jne    102c14 <unregister_handle+0x5b>
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF; //Can't write  that much biatch TODO realloc so file may grow and implement RW_EOF

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  102c5d:	b8 03 00 00 00       	mov    $0x3,%eax

  102c62:	c9                   	leave  
  102c63:	c3                   	ret    

00102c64 <schedule_exception>:
        return RW_OK;
    }
  102c64:	55                   	push   %ebp
  102c65:	89 e5                	mov    %esp,%ebp
  102c67:	53                   	push   %ebx
  102c68:	83 ec 04             	sub    $0x4,%esp

  102c6b:	8b 15 30 85 12 00    	mov    0x128530,%edx
  102c71:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102c76:	39 c2                	cmp    %eax,%edx
  102c78:	75 62                	jne    102cdc <schedule_exception+0x78>
  102c7a:	a1 30 85 12 00       	mov    0x128530,%eax
  102c7f:	8b 40 08             	mov    0x8(%eax),%eax
  102c82:	85 c0                	test   %eax,%eax
  102c84:	75 56                	jne    102cdc <schedule_exception+0x78>
    return RW_ERR_DRIVER;
}
  102c86:	83 ec 0c             	sub    $0xc,%esp
  102c89:	6a 04                	push   $0x4
  102c8b:	e8 c7 d8 ff ff       	call   100557 <setclr>
  102c90:	83 c4 10             	add    $0x10,%esp

  102c93:	8b 45 08             	mov    0x8(%ebp),%eax
  102c96:	8b 58 20             	mov    0x20(%eax),%ebx
  102c99:	8b 45 08             	mov    0x8(%ebp),%eax
  102c9c:	8b 48 1c             	mov    0x1c(%eax),%ecx
  102c9f:	a1 30 85 12 00       	mov    0x128530,%eax
  102ca4:	8b 50 24             	mov    0x24(%eax),%edx
  102ca7:	a1 30 85 12 00       	mov    0x128530,%eax
  102cac:	8b 00                	mov    (%eax),%eax
  102cae:	83 ec 0c             	sub    $0xc,%esp
  102cb1:	53                   	push   %ebx
  102cb2:	51                   	push   %ecx
  102cb3:	52                   	push   %edx
  102cb4:	50                   	push   %eax
  102cb5:	68 5c 77 10 00       	push   $0x10775c
  102cba:	e8 ae d8 ff ff       	call   10056d <kprintf>
  102cbf:	83 c4 20             	add    $0x20,%esp
struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  102cc2:	83 ec 08             	sub    $0x8,%esp
  102cc5:	68 9c 77 10 00       	push   $0x10779c
  102cca:	ff 75 08             	pushl  0x8(%ebp)
  102ccd:	e8 04 d5 ff ff       	call   1001d6 <show_cod>
  102cd2:	83 c4 10             	add    $0x10,%esp
    if(buffer[kf->id] != 0) {
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  102cd5:	b8 00 00 00 00       	mov    $0x0,%eax
  102cda:	eb 75                	jmp    102d51 <schedule_exception+0xed>

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));

  102cdc:	83 ec 0c             	sub    $0xc,%esp
  102cdf:	6a 04                	push   $0x4
  102ce1:	e8 71 d8 ff ff       	call   100557 <setclr>
  102ce6:	83 c4 10             	add    $0x10,%esp
        rethandle->filemode = filemode;
  102ce9:	8b 45 08             	mov    0x8(%ebp),%eax
  102cec:	8b 58 20             	mov    0x20(%eax),%ebx
  102cef:	8b 45 08             	mov    0x8(%ebp),%eax
  102cf2:	8b 48 1c             	mov    0x1c(%eax),%ecx
  102cf5:	a1 30 85 12 00       	mov    0x128530,%eax
  102cfa:	8b 50 24             	mov    0x24(%eax),%edx
  102cfd:	a1 30 85 12 00       	mov    0x128530,%eax
  102d02:	8b 00                	mov    (%eax),%eax
  102d04:	83 ec 0c             	sub    $0xc,%esp
  102d07:	53                   	push   %ebx
  102d08:	51                   	push   %ecx
  102d09:	52                   	push   %edx
  102d0a:	50                   	push   %eax
  102d0b:	68 5c 77 10 00       	push   $0x10775c
  102d10:	e8 58 d8 ff ff       	call   10056d <kprintf>
  102d15:	83 c4 20             	add    $0x20,%esp
        rethandle->position = 0;
  102d18:	83 ec 0c             	sub    $0xc,%esp
  102d1b:	68 c5 77 10 00       	push   $0x1077c5
  102d20:	e8 48 d8 ff ff       	call   10056d <kprintf>
  102d25:	83 c4 10             	add    $0x10,%esp
        rethandle->res_type = RES_KERNDRV;
  102d28:	83 ec 0c             	sub    $0xc,%esp
  102d2b:	ff 75 08             	pushl  0x8(%ebp)
  102d2e:	e8 fe d4 ff ff       	call   100231 <show_dump>
  102d33:	83 c4 10             	add    $0x10,%esp
        rethandle->res_ptr  = kf;
  102d36:	83 ec 0c             	sub    $0xc,%esp
  102d39:	6a 07                	push   $0x7
  102d3b:	e8 17 d8 ff ff       	call   100557 <setclr>
  102d40:	83 c4 10             	add    $0x10,%esp

        return rethandle;
  102d43:	83 ec 0c             	sub    $0xc,%esp
  102d46:	ff 75 08             	pushl  0x8(%ebp)
  102d49:	e8 08 00 00 00       	call   102d56 <terminate_current>
  102d4e:	83 c4 10             	add    $0x10,%esp
    }

  102d51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102d54:	c9                   	leave  
  102d55:	c3                   	ret    

00102d56 <terminate_current>:
    return (void*)1;
}
  102d56:	55                   	push   %ebp
  102d57:	89 e5                	mov    %esp,%ebp
  102d59:	83 ec 18             	sub    $0x18,%esp

  102d5c:	a1 30 85 12 00       	mov    0x128530,%eax
  102d61:	8b 40 08             	mov    0x8(%eax),%eax
  102d64:	89 45 ec             	mov    %eax,-0x14(%ebp)
uint32_t ramfs_block_close(struct res_handle* handle) {
  102d67:	a1 30 85 12 00       	mov    0x128530,%eax
  102d6c:	8b 40 0c             	mov    0xc(%eax),%eax
  102d6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102d72:	a1 30 85 12 00       	mov    0x128530,%eax
  102d77:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  102d7a:	a1 30 85 12 00       	mov    0x128530,%eax
  102d7f:	8b 40 40             	mov    0x40(%eax),%eax
  102d82:	85 c0                	test   %eax,%eax
  102d84:	74 3a                	je     102dc0 <terminate_current+0x6a>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  102d86:	a1 30 85 12 00       	mov    0x128530,%eax
  102d8b:	8b 40 40             	mov    0x40(%eax),%eax
  102d8e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
    }
  102d95:	a1 30 85 12 00       	mov    0x128530,%eax
  102d9a:	8b 40 40             	mov    0x40(%eax),%eax
  102d9d:	8b 40 28             	mov    0x28(%eax),%eax
  102da0:	83 ec 0c             	sub    $0xc,%esp
  102da3:	50                   	push   %eax
  102da4:	e8 43 0b 00 00       	call   1038ec <free>
  102da9:	83 c4 10             	add    $0x10,%esp

  102dac:	a1 30 85 12 00       	mov    0x128530,%eax
  102db1:	8b 40 40             	mov    0x40(%eax),%eax
  102db4:	8b 15 30 85 12 00    	mov    0x128530,%edx
  102dba:	8b 52 28             	mov    0x28(%edx),%edx
  102dbd:	89 50 28             	mov    %edx,0x28(%eax)
    free(handle);

    return 0;
  102dc0:	e8 ec 1f 00 00       	call   104db1 <vmm_free_current_pagetables>
}
  102dc5:	8b 15 30 85 12 00    	mov    0x128530,%edx
  102dcb:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102dd0:	39 c2                	cmp    %eax,%edx
  102dd2:	75 0d                	jne    102de1 <terminate_current+0x8b>
  102dd4:	a1 30 85 12 00       	mov    0x128530,%eax
  102dd9:	8b 40 08             	mov    0x8(%eax),%eax
  102ddc:	a3 2c 85 12 00       	mov    %eax,0x12852c
  102de1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102de5:	74 09                	je     102df0 <terminate_current+0x9a>
  102de7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102dea:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102ded:	89 50 0c             	mov    %edx,0xc(%eax)
  102df0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102df4:	74 09                	je     102dff <terminate_current+0xa9>
  102df6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102df9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102dfc:	89 50 08             	mov    %edx,0x8(%eax)
  102dff:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102e03:	75 08                	jne    102e0d <terminate_current+0xb7>
  102e05:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102e0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102e0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102e10:	a3 30 85 12 00       	mov    %eax,0x128530
  102e15:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e18:	8b 40 04             	mov    0x4(%eax),%eax
  102e1b:	83 ec 0c             	sub    $0xc,%esp
  102e1e:	50                   	push   %eax
  102e1f:	e8 c8 0a 00 00       	call   1038ec <free>
  102e24:	83 c4 10             	add    $0x10,%esp
  102e27:	83 ec 0c             	sub    $0xc,%esp
  102e2a:	ff 75 f4             	pushl  -0xc(%ebp)
  102e2d:	e8 ba 0a 00 00       	call   1038ec <free>
  102e32:	83 c4 10             	add    $0x10,%esp
  102e35:	a1 30 85 12 00       	mov    0x128530,%eax
  102e3a:	85 c0                	test   %eax,%eax
  102e3c:	75 13                	jne    102e51 <terminate_current+0xfb>
  102e3e:	83 ec 08             	sub    $0x8,%esp
  102e41:	68 c7 77 10 00       	push   $0x1077c7
  102e46:	ff 75 08             	pushl  0x8(%ebp)
  102e49:	e8 88 d3 ff ff       	call   1001d6 <show_cod>
  102e4e:	83 c4 10             	add    $0x10,%esp
  102e51:	a1 30 85 12 00       	mov    0x128530,%eax
  102e56:	8b 40 14             	mov    0x14(%eax),%eax
  102e59:	83 ec 0c             	sub    $0xc,%esp
  102e5c:	50                   	push   %eax
  102e5d:	e8 12 25 00 00       	call   105374 <vmm_activate_pagedir>
  102e62:	83 c4 10             	add    $0x10,%esp
  102e65:	a1 30 85 12 00       	mov    0x128530,%eax
  102e6a:	8b 40 04             	mov    0x4(%eax),%eax
  102e6d:	c9                   	leave  
  102e6e:	c3                   	ret    

00102e6f <init_task>:
  102e6f:	55                   	push   %ebp
  102e70:	89 e5                	mov    %esp,%ebp
  102e72:	57                   	push   %edi
  102e73:	56                   	push   %esi
  102e74:	53                   	push   %ebx
  102e75:	83 ec 6c             	sub    $0x6c,%esp
  102e78:	83 ec 08             	sub    $0x8,%esp
  102e7b:	6a 48                	push   $0x48
  102e7d:	6a 01                	push   $0x1
  102e7f:	e8 98 09 00 00       	call   10381c <calloc>
  102e84:	83 c4 10             	add    $0x10,%esp
  102e87:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102e8a:	83 ec 08             	sub    $0x8,%esp
  102e8d:	6a 38                	push   $0x38
  102e8f:	6a 01                	push   $0x1
  102e91:	e8 86 09 00 00       	call   10381c <calloc>
  102e96:	83 c4 10             	add    $0x10,%esp
  102e99:	89 c2                	mov    %eax,%edx
  102e9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102e9e:	89 50 04             	mov    %edx,0x4(%eax)
  102ea1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ea4:	8b 55 08             	mov    0x8(%ebp),%edx
  102ea7:	89 50 14             	mov    %edx,0x14(%eax)
  102eaa:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ead:	c7 40 10 00 00 ff ff 	movl   $0xffff0000,0x10(%eax)
  102eb4:	a1 f8 60 10 00       	mov    0x1060f8,%eax
  102eb9:	8b 55 dc             	mov    -0x24(%ebp),%edx
  102ebc:	89 02                	mov    %eax,(%edx)
  102ebe:	40                   	inc    %eax
  102ebf:	a3 f8 60 10 00       	mov    %eax,0x1060f8
  102ec4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ec7:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  102ece:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ed1:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  102ed8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102edb:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  102ee2:	8b 15 2c 85 12 00    	mov    0x12852c,%edx
  102ee8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102eeb:	89 50 08             	mov    %edx,0x8(%eax)
  102eee:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ef1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  102ef8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102efb:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  102f02:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f05:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  102f0c:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102f11:	85 c0                	test   %eax,%eax
  102f13:	74 0b                	je     102f20 <init_task+0xb1>
  102f15:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102f1a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  102f1d:	89 50 0c             	mov    %edx,0xc(%eax)
  102f20:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f23:	a3 2c 85 12 00       	mov    %eax,0x12852c
  102f28:	e8 4f 1e 00 00       	call   104d7c <vmm_get_current_pagedir>
  102f2d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  102f30:	83 ec 0c             	sub    $0xc,%esp
  102f33:	ff 75 08             	pushl  0x8(%ebp)
  102f36:	e8 39 24 00 00       	call   105374 <vmm_activate_pagedir>
  102f3b:	83 c4 10             	add    $0x10,%esp
  102f3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f41:	8b 40 10             	mov    0x10(%eax),%eax
  102f44:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  102f47:	eb 17                	jmp    102f60 <init_task+0xf1>
  102f49:	83 ec 08             	sub    $0x8,%esp
  102f4c:	6a 00                	push   $0x0
  102f4e:	ff 75 e4             	pushl  -0x1c(%ebp)
  102f51:	e8 79 23 00 00       	call   1052cf <vmm_alloc_addr>
  102f56:	83 c4 10             	add    $0x10,%esp
  102f59:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  102f60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102f63:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
  102f68:	76 df                	jbe    102f49 <init_task+0xda>
  102f6a:	8b 75 0c             	mov    0xc(%ebp),%esi
  102f6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f70:	8b 40 10             	mov    0x10(%eax),%eax
  102f73:	05 00 10 00 00       	add    $0x1000,%eax
  102f78:	89 45 94             	mov    %eax,-0x6c(%ebp)
  102f7b:	8d 5d a4             	lea    -0x5c(%ebp),%ebx
  102f7e:	b8 00 00 00 00       	mov    $0x0,%eax
  102f83:	ba 0e 00 00 00       	mov    $0xe,%edx
  102f88:	89 df                	mov    %ebx,%edi
  102f8a:	89 d1                	mov    %edx,%ecx
  102f8c:	f3 ab                	rep stos %eax,%es:(%edi)
  102f8e:	89 75 c8             	mov    %esi,-0x38(%ebp)
  102f91:	c7 45 cc 1b 00 00 00 	movl   $0x1b,-0x34(%ebp)
  102f98:	c7 45 d0 00 02 00 00 	movl   $0x200,-0x30(%ebp)
  102f9f:	8b 45 94             	mov    -0x6c(%ebp),%eax
  102fa2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102fa5:	c7 45 d8 23 00 00 00 	movl   $0x23,-0x28(%ebp)
  102fac:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102faf:	8b 40 04             	mov    0x4(%eax),%eax
  102fb2:	83 ec 04             	sub    $0x4,%esp
  102fb5:	6a 38                	push   $0x38
  102fb7:	8d 55 a4             	lea    -0x5c(%ebp),%edx
  102fba:	52                   	push   %edx
  102fbb:	50                   	push   %eax
  102fbc:	e8 ad 09 00 00       	call   10396e <memcpy>
  102fc1:	83 c4 10             	add    $0x10,%esp
  102fc4:	83 ec 0c             	sub    $0xc,%esp
  102fc7:	ff 75 e0             	pushl  -0x20(%ebp)
  102fca:	e8 a5 23 00 00       	call   105374 <vmm_activate_pagedir>
  102fcf:	83 c4 10             	add    $0x10,%esp
  102fd2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102fd5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102fd8:	83 c4 00             	add    $0x0,%esp
  102fdb:	5b                   	pop    %ebx
  102fdc:	5e                   	pop    %esi
  102fdd:	5f                   	pop    %edi
  102fde:	5d                   	pop    %ebp
  102fdf:	c3                   	ret    

00102fe0 <save_cpu_state>:
  102fe0:	55                   	push   %ebp
  102fe1:	89 e5                	mov    %esp,%ebp
  102fe3:	83 ec 08             	sub    $0x8,%esp
  102fe6:	a1 30 85 12 00       	mov    0x128530,%eax
  102feb:	8b 40 18             	mov    0x18(%eax),%eax
  102fee:	85 c0                	test   %eax,%eax
  102ff0:	74 38                	je     10302a <save_cpu_state+0x4a>
  102ff2:	a1 30 85 12 00       	mov    0x128530,%eax
  102ff7:	8b 40 18             	mov    0x18(%eax),%eax
  102ffa:	8a 40 14             	mov    0x14(%eax),%al
  102ffd:	84 c0                	test   %al,%al
  102fff:	74 29                	je     10302a <save_cpu_state+0x4a>
  103001:	a1 30 85 12 00       	mov    0x128530,%eax
  103006:	8b 40 18             	mov    0x18(%eax),%eax
  103009:	8b 40 18             	mov    0x18(%eax),%eax
  10300c:	83 ec 04             	sub    $0x4,%esp
  10300f:	6a 38                	push   $0x38
  103011:	ff 75 08             	pushl  0x8(%ebp)
  103014:	50                   	push   %eax
  103015:	e8 54 09 00 00       	call   10396e <memcpy>
  10301a:	83 c4 10             	add    $0x10,%esp
  10301d:	a1 30 85 12 00       	mov    0x128530,%eax
  103022:	8b 40 18             	mov    0x18(%eax),%eax
  103025:	8b 40 18             	mov    0x18(%eax),%eax
  103028:	eb 21                	jmp    10304b <save_cpu_state+0x6b>
  10302a:	a1 30 85 12 00       	mov    0x128530,%eax
  10302f:	8b 40 04             	mov    0x4(%eax),%eax
  103032:	83 ec 04             	sub    $0x4,%esp
  103035:	6a 38                	push   $0x38
  103037:	ff 75 08             	pushl  0x8(%ebp)
  10303a:	50                   	push   %eax
  10303b:	e8 2e 09 00 00       	call   10396e <memcpy>
  103040:	83 c4 10             	add    $0x10,%esp
  103043:	a1 30 85 12 00       	mov    0x128530,%eax
  103048:	8b 40 04             	mov    0x4(%eax),%eax
  10304b:	c9                   	leave  
  10304c:	c3                   	ret    

0010304d <schedule_to_task>:
  10304d:	55                   	push   %ebp
  10304e:	89 e5                	mov    %esp,%ebp
  103050:	83 ec 08             	sub    $0x8,%esp
  103053:	8b 45 08             	mov    0x8(%ebp),%eax
  103056:	a3 30 85 12 00       	mov    %eax,0x128530
  10305b:	8b 45 08             	mov    0x8(%ebp),%eax
  10305e:	8b 40 14             	mov    0x14(%eax),%eax
  103061:	83 ec 0c             	sub    $0xc,%esp
  103064:	50                   	push   %eax
  103065:	e8 0a 23 00 00       	call   105374 <vmm_activate_pagedir>
  10306a:	83 c4 10             	add    $0x10,%esp
  10306d:	8b 45 08             	mov    0x8(%ebp),%eax
  103070:	8b 40 18             	mov    0x18(%eax),%eax
  103073:	85 c0                	test   %eax,%eax
  103075:	75 08                	jne    10307f <schedule_to_task+0x32>
  103077:	8b 45 08             	mov    0x8(%ebp),%eax
  10307a:	8b 40 04             	mov    0x4(%eax),%eax
  10307d:	eb 24                	jmp    1030a3 <schedule_to_task+0x56>
  10307f:	8b 45 08             	mov    0x8(%ebp),%eax
  103082:	8b 40 18             	mov    0x18(%eax),%eax
  103085:	8a 40 14             	mov    0x14(%eax),%al
  103088:	84 c0                	test   %al,%al
  10308a:	75 0e                	jne    10309a <schedule_to_task+0x4d>
  10308c:	83 ec 0c             	sub    $0xc,%esp
  10308f:	ff 75 08             	pushl  0x8(%ebp)
  103092:	e8 ad 00 00 00       	call   103144 <init_rpc_call>
  103097:	83 c4 10             	add    $0x10,%esp
  10309a:	8b 45 08             	mov    0x8(%ebp),%eax
  10309d:	8b 40 18             	mov    0x18(%eax),%eax
  1030a0:	8b 40 18             	mov    0x18(%eax),%eax
  1030a3:	c9                   	leave  
  1030a4:	c3                   	ret    

001030a5 <schedule>:
  1030a5:	55                   	push   %ebp
  1030a6:	89 e5                	mov    %esp,%ebp
  1030a8:	83 ec 18             	sub    $0x18,%esp
  1030ab:	a1 2c 85 12 00       	mov    0x12852c,%eax
  1030b0:	85 c0                	test   %eax,%eax
  1030b2:	0f 84 86 00 00 00    	je     10313e <schedule+0x99>
  1030b8:	a1 28 85 12 00       	mov    0x128528,%eax
  1030bd:	85 c0                	test   %eax,%eax
  1030bf:	74 7d                	je     10313e <schedule+0x99>
  1030c1:	a1 30 85 12 00       	mov    0x128530,%eax
  1030c6:	85 c0                	test   %eax,%eax
  1030c8:	75 28                	jne    1030f2 <schedule+0x4d>
  1030ca:	a1 2c 85 12 00       	mov    0x12852c,%eax
  1030cf:	a3 30 85 12 00       	mov    %eax,0x128530
  1030d4:	a1 30 85 12 00       	mov    0x128530,%eax
  1030d9:	8b 40 14             	mov    0x14(%eax),%eax
  1030dc:	83 ec 0c             	sub    $0xc,%esp
  1030df:	50                   	push   %eax
  1030e0:	e8 8f 22 00 00       	call   105374 <vmm_activate_pagedir>
  1030e5:	83 c4 10             	add    $0x10,%esp
  1030e8:	a1 30 85 12 00       	mov    0x128530,%eax
  1030ed:	8b 40 04             	mov    0x4(%eax),%eax
  1030f0:	eb 4f                	jmp    103141 <schedule+0x9c>
  1030f2:	a1 30 85 12 00       	mov    0x128530,%eax
  1030f7:	8b 40 08             	mov    0x8(%eax),%eax
  1030fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1030fd:	a1 30 85 12 00       	mov    0x128530,%eax
  103102:	8b 40 08             	mov    0x8(%eax),%eax
  103105:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103108:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10310c:	75 08                	jne    103116 <schedule+0x71>
  10310e:	a1 2c 85 12 00       	mov    0x12852c,%eax
  103113:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103116:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103119:	8b 40 44             	mov    0x44(%eax),%eax
  10311c:	85 c0                	test   %eax,%eax
  10311e:	75 dd                	jne    1030fd <schedule+0x58>
  103120:	83 ec 0c             	sub    $0xc,%esp
  103123:	ff 75 08             	pushl  0x8(%ebp)
  103126:	e8 b5 fe ff ff       	call   102fe0 <save_cpu_state>
  10312b:	83 c4 10             	add    $0x10,%esp
  10312e:	83 ec 0c             	sub    $0xc,%esp
  103131:	ff 75 f4             	pushl  -0xc(%ebp)
  103134:	e8 14 ff ff ff       	call   10304d <schedule_to_task>
  103139:	83 c4 10             	add    $0x10,%esp
  10313c:	eb 03                	jmp    103141 <schedule+0x9c>
  10313e:	8b 45 08             	mov    0x8(%ebp),%eax
  103141:	c9                   	leave  
  103142:	c3                   	ret    
	...

00103144 <init_rpc_call>:
uint16_t* vga_buffer = (void*) 0xB8000;
uint32_t  vga_writers = 0;

struct kfs_driver vga_driver = {
    .rread     = ramfs_vga_read,
    .rwrite    = ramfs_vga_write,
  103144:	55                   	push   %ebp
  103145:	89 e5                	mov    %esp,%ebp
  103147:	57                   	push   %edi
  103148:	56                   	push   %esi
  103149:	53                   	push   %ebx
  10314a:	83 ec 5c             	sub    $0x5c,%esp
    .open      = ramfs_vga_open,
  10314d:	8b 45 08             	mov    0x8(%ebp),%eax
  103150:	8b 40 18             	mov    0x18(%eax),%eax
  103153:	89 45 e0             	mov    %eax,-0x20(%ebp)
    .create    = ramfs_vga_create,
    .close     = ramfs_vga_close,
  103156:	83 ec 08             	sub    $0x8,%esp
  103159:	6a 38                	push   $0x38
  10315b:	6a 01                	push   $0x1
  10315d:	e8 ba 06 00 00       	call   10381c <calloc>
  103162:	83 c4 10             	add    $0x10,%esp
  103165:	89 c2                	mov    %eax,%edx
  103167:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10316a:	89 50 18             	mov    %edx,0x18(%eax)
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
}
  10316d:	8b 45 08             	mov    0x8(%ebp),%eax
  103170:	8b 70 1c             	mov    0x1c(%eax),%esi
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
  103173:	8b 45 08             	mov    0x8(%ebp),%eax
  103176:	8b 40 04             	mov    0x4(%eax),%eax
}

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

  103179:	8b 40 30             	mov    0x30(%eax),%eax
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
  10317c:	83 e8 10             	sub    $0x10,%eax
  10317f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
}

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

  103182:	8d 5d a8             	lea    -0x58(%ebp),%ebx
  103185:	b8 00 00 00 00       	mov    $0x0,%eax
  10318a:	ba 0e 00 00 00       	mov    $0xe,%edx
  10318f:	89 df                	mov    %ebx,%edi
  103191:	89 d1                	mov    %edx,%ecx
  103193:	f3 ab                	rep stos %eax,%es:(%edi)
  103195:	89 75 cc             	mov    %esi,-0x34(%ebp)
  103198:	c7 45 d0 1b 00 00 00 	movl   $0x1b,-0x30(%ebp)
  10319f:	c7 45 d4 00 02 00 00 	movl   $0x200,-0x2c(%ebp)
  1031a6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1031a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1031ac:	c7 45 dc 23 00 00 00 	movl   $0x23,-0x24(%ebp)
uint32_t ramfs_vga_available(struct res_handle* handle) {
    return sizeof(struct vga_command);
  1031b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031b6:	8b 40 18             	mov    0x18(%eax),%eax
  1031b9:	83 ec 04             	sub    $0x4,%esp
  1031bc:	6a 38                	push   $0x38
  1031be:	8d 55 a8             	lea    -0x58(%ebp),%edx
  1031c1:	52                   	push   %edx
  1031c2:	50                   	push   %eax
  1031c3:	e8 a6 07 00 00       	call   10396e <memcpy>
  1031c8:	83 c4 10             	add    $0x10,%esp
}

  1031cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031ce:	8b 40 18             	mov    0x18(%eax),%eax
  1031d1:	8b 40 30             	mov    0x30(%eax),%eax
  1031d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
  1031d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1031da:	8d 50 04             	lea    0x4(%eax),%edx
  1031dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031e0:	8b 40 04             	mov    0x4(%eax),%eax
  1031e3:	89 02                	mov    %eax,(%edx)
}
  1031e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1031e8:	8d 50 08             	lea    0x8(%eax),%edx
  1031eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031ee:	8b 40 08             	mov    0x8(%eax),%eax
  1031f1:	89 02                	mov    %eax,(%edx)

  1031f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1031f6:	8d 50 0c             	lea    0xc(%eax),%edx
  1031f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031fc:	8b 40 10             	mov    0x10(%eax),%eax
  1031ff:	89 02                	mov    %eax,(%edx)
uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  103201:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103204:	c6 40 14 01          	movb   $0x1,0x14(%eax)
}
  103208:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10320b:	83 c4 00             	add    $0x0,%esp
  10320e:	5b                   	pop    %ebx
  10320f:	5e                   	pop    %esi
  103210:	5f                   	pop    %edi
  103211:	5d                   	pop    %ebp
  103212:	c3                   	ret    

00103213 <create_rpc_call>:

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  103213:	55                   	push   %ebp
  103214:	89 e5                	mov    %esp,%ebp
  103216:	83 ec 18             	sub    $0x18,%esp
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  103219:	83 ec 08             	sub    $0x8,%esp
  10321c:	6a 20                	push   $0x20
  10321e:	6a 01                	push   $0x1
  103220:	e8 f7 05 00 00       	call   10381c <calloc>
  103225:	83 c4 10             	add    $0x10,%esp
  103228:	89 45 ec             	mov    %eax,-0x14(%ebp)

  10322b:	83 ec 0c             	sub    $0xc,%esp
  10322e:	ff 75 08             	pushl  0x8(%ebp)
  103231:	e8 01 f9 ff ff       	call   102b37 <get_task_by_pid>
  103236:	83 c4 10             	add    $0x10,%esp
  103239:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct vga_command* vgac = src;

  10323c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103240:	75 34                	jne    103276 <create_rpc_call+0x63>
    if(vgac->command == CMD_SET) {
  103242:	83 ec 0c             	sub    $0xc,%esp
  103245:	6a 0a                	push   $0xa
  103247:	e8 0b d3 ff ff       	call   100557 <setclr>
  10324c:	83 c4 10             	add    $0x10,%esp
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  10324f:	83 ec 0c             	sub    $0xc,%esp
  103252:	68 e0 77 10 00       	push   $0x1077e0
  103257:	e8 11 d3 ff ff       	call   10056d <kprintf>
  10325c:	83 c4 10             	add    $0x10,%esp
    }
  10325f:	83 ec 0c             	sub    $0xc,%esp
  103262:	6a 07                	push   $0x7
  103264:	e8 ee d2 ff ff       	call   100557 <setclr>
  103269:	83 c4 10             	add    $0x10,%esp

  10326c:	b8 02 00 00 00       	mov    $0x2,%eax
  103271:	e9 06 01 00 00       	jmp    10337c <create_rpc_call+0x169>
    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
            vga_buffer[i] = 0;
  103276:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103279:	8b 40 1c             	mov    0x1c(%eax),%eax
  10327c:	85 c0                	test   %eax,%eax
  10327e:	75 34                	jne    1032b4 <create_rpc_call+0xa1>
        }
  103280:	83 ec 0c             	sub    $0xc,%esp
  103283:	6a 0a                	push   $0xa
  103285:	e8 cd d2 ff ff       	call   100557 <setclr>
  10328a:	83 c4 10             	add    $0x10,%esp
    }
  10328d:	83 ec 0c             	sub    $0xc,%esp
  103290:	68 0c 78 10 00       	push   $0x10780c
  103295:	e8 d3 d2 ff ff       	call   10056d <kprintf>
  10329a:	83 c4 10             	add    $0x10,%esp

  10329d:	83 ec 0c             	sub    $0xc,%esp
  1032a0:	6a 07                	push   $0x7
  1032a2:	e8 b0 d2 ff ff       	call   100557 <setclr>
  1032a7:	83 c4 10             	add    $0x10,%esp
    if(vgac->command == CMD_SCROLL) {
  1032aa:	b8 03 00 00 00       	mov    $0x3,%eax
  1032af:	e9 c8 00 00 00       	jmp    10337c <create_rpc_call+0x169>
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
  1032b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032b7:	8b 55 0c             	mov    0xc(%ebp),%edx
  1032ba:	89 50 04             	mov    %edx,0x4(%eax)
        }
  1032bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032c0:	8b 55 10             	mov    0x10(%ebp),%edx
  1032c3:	89 50 08             	mov    %edx,0x8(%eax)

  1032c6:	e8 62 f8 ff ff       	call   102b2d <get_current_task>
  1032cb:	85 c0                	test   %eax,%eax
  1032cd:	74 09                	je     1032d8 <create_rpc_call+0xc5>
  1032cf:	e8 59 f8 ff ff       	call   102b2d <get_current_task>
  1032d4:	8b 00                	mov    (%eax),%eax
  1032d6:	eb 05                	jmp    1032dd <create_rpc_call+0xca>
  1032d8:	b8 00 00 00 00       	mov    $0x0,%eax
  1032dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1032e0:	89 02                	mov    %eax,(%edx)
        for (; i < 25 * 80; i++) {
            vga_buffer[i] = 0;
  1032e2:	83 ec 0c             	sub    $0xc,%esp
  1032e5:	ff 75 14             	pushl  0x14(%ebp)
  1032e8:	e8 b9 03 00 00       	call   1036a6 <malloc>
  1032ed:	83 c4 10             	add    $0x10,%esp
  1032f0:	89 c2                	mov    %eax,%edx
  1032f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032f5:	89 50 0c             	mov    %edx,0xc(%eax)
        }
  1032f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032fb:	8b 40 0c             	mov    0xc(%eax),%eax
  1032fe:	83 ec 04             	sub    $0x4,%esp
  103301:	ff 75 14             	pushl  0x14(%ebp)
  103304:	ff 75 18             	pushl  0x18(%ebp)
  103307:	50                   	push   %eax
  103308:	e8 61 06 00 00       	call   10396e <memcpy>
  10330d:	83 c4 10             	add    $0x10,%esp
    }
  103310:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103313:	8b 55 14             	mov    0x14(%ebp),%edx
  103316:	89 50 10             	mov    %edx,0x10(%eax)

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103319:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10331c:	8b 40 18             	mov    0x18(%eax),%eax
  10331f:	85 c0                	test   %eax,%eax
  103321:	75 10                	jne    103333 <create_rpc_call+0x120>
}
  103323:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103326:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103329:	89 50 18             	mov    %edx,0x18(%eax)

  10332c:	b8 00 00 00 00       	mov    $0x0,%eax
  103331:	eb 49                	jmp    10337c <create_rpc_call+0x169>
struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
    if(filemode & FM_READ) return 0;

  103333:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103336:	8b 40 18             	mov    0x18(%eax),%eax
  103339:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
    if((filemode & FM_WRITE)) vga_writers++;
  10333c:	eb 33                	jmp    103371 <create_rpc_call+0x15e>

  10333e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103341:	8b 40 1c             	mov    0x1c(%eax),%eax
  103344:	85 c0                	test   %eax,%eax
  103346:	75 20                	jne    103368 <create_rpc_call+0x155>
    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103348:	83 ec 0c             	sub    $0xc,%esp
  10334b:	68 3b 78 10 00       	push   $0x10783b
  103350:	e8 18 d2 ff ff       	call   10056d <kprintf>
  103355:	83 c4 10             	add    $0x10,%esp

    rethandle->filemode = filemode;
  103358:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10335b:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10335e:	89 50 1c             	mov    %edx,0x1c(%eax)
    rethandle->position = 0;
  103361:	b8 00 00 00 00       	mov    $0x0,%eax
  103366:	eb 14                	jmp    10337c <create_rpc_call+0x169>
    rethandle->res_type = RES_KERNDRV;
    rethandle->res_ptr  = kf;
  103368:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10336b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10336e:	89 45 f4             	mov    %eax,-0xc(%ebp)
struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
    if(filemode & FM_READ) return 0;

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
    if((filemode & FM_WRITE)) vga_writers++;
  103371:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103375:	75 c7                	jne    10333e <create_rpc_call+0x12b>
    rethandle->res_type = RES_KERNDRV;
    rethandle->res_ptr  = kf;

    return rethandle;
}

  103377:	b8 01 00 00 00       	mov    $0x1,%eax
uint32_t ramfs_vga_close(struct res_handle* handle) {
  10337c:	c9                   	leave  
  10337d:	c3                   	ret    

0010337e <return_rpc_call>:
    if(handle->filemode & FM_WRITE) vga_writers--;

  10337e:	55                   	push   %ebp
  10337f:	89 e5                	mov    %esp,%ebp
  103381:	83 ec 18             	sub    $0x18,%esp
    free(handle);
  103384:	e8 a4 f7 ff ff       	call   102b2d <get_current_task>
  103389:	89 45 ec             	mov    %eax,-0x14(%ebp)

    return 0;
  10338c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10338f:	8b 40 18             	mov    0x18(%eax),%eax
  103392:	85 c0                	test   %eax,%eax
  103394:	75 68                	jne    1033fe <return_rpc_call+0x80>
}
  103396:	83 ec 0c             	sub    $0xc,%esp
  103399:	6a 04                	push   $0x4
  10339b:	e8 b7 d1 ff ff       	call   100557 <setclr>
  1033a0:	83 c4 10             	add    $0x10,%esp
  1033a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033a6:	8b 50 24             	mov    0x24(%eax),%edx
  1033a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033ac:	8b 00                	mov    (%eax),%eax
  1033ae:	83 ec 04             	sub    $0x4,%esp
  1033b1:	52                   	push   %edx
  1033b2:	50                   	push   %eax
  1033b3:	68 50 78 10 00       	push   $0x107850
  1033b8:	e8 b0 d1 ff ff       	call   10056d <kprintf>
  1033bd:	83 c4 10             	add    $0x10,%esp
  1033c0:	83 ec 0c             	sub    $0xc,%esp
  1033c3:	68 8e 78 10 00       	push   $0x10788e
  1033c8:	e8 a0 d1 ff ff       	call   10056d <kprintf>
  1033cd:	83 c4 10             	add    $0x10,%esp
  1033d0:	83 ec 0c             	sub    $0xc,%esp
  1033d3:	ff 75 08             	pushl  0x8(%ebp)
  1033d6:	e8 56 ce ff ff       	call   100231 <show_dump>
  1033db:	83 c4 10             	add    $0x10,%esp
  1033de:	83 ec 0c             	sub    $0xc,%esp
  1033e1:	6a 07                	push   $0x7
  1033e3:	e8 6f d1 ff ff       	call   100557 <setclr>
  1033e8:	83 c4 10             	add    $0x10,%esp
  1033eb:	83 ec 0c             	sub    $0xc,%esp
  1033ee:	ff 75 08             	pushl  0x8(%ebp)
  1033f1:	e8 60 f9 ff ff       	call   102d56 <terminate_current>
  1033f6:	83 c4 10             	add    $0x10,%esp
  1033f9:	e9 b5 00 00 00       	jmp    1034b3 <return_rpc_call+0x135>
  1033fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103401:	8b 40 18             	mov    0x18(%eax),%eax
  103404:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103407:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10340a:	8b 40 18             	mov    0x18(%eax),%eax
  10340d:	8b 50 1c             	mov    0x1c(%eax),%edx
  103410:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103413:	89 50 18             	mov    %edx,0x18(%eax)
  103416:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103419:	8b 00                	mov    (%eax),%eax
  10341b:	85 c0                	test   %eax,%eax
  10341d:	0f 84 82 00 00 00    	je     1034a5 <return_rpc_call+0x127>
  103423:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103426:	8b 00                	mov    (%eax),%eax
  103428:	83 ec 0c             	sub    $0xc,%esp
  10342b:	50                   	push   %eax
  10342c:	e8 06 f7 ff ff       	call   102b37 <get_task_by_pid>
  103431:	83 c4 10             	add    $0x10,%esp
  103434:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103437:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10343a:	8b 40 04             	mov    0x4(%eax),%eax
  10343d:	85 c0                	test   %eax,%eax
  10343f:	75 12                	jne    103453 <return_rpc_call+0xd5>
  103441:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103444:	8b 40 08             	mov    0x8(%eax),%eax
  103447:	83 ec 0c             	sub    $0xc,%esp
  10344a:	50                   	push   %eax
  10344b:	e8 1c db ff ff       	call   100f6c <enable_irq_rpc>
  103450:	83 c4 10             	add    $0x10,%esp
  103453:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103456:	8b 40 18             	mov    0x18(%eax),%eax
  103459:	83 ec 0c             	sub    $0xc,%esp
  10345c:	50                   	push   %eax
  10345d:	e8 8a 04 00 00       	call   1038ec <free>
  103462:	83 c4 10             	add    $0x10,%esp
  103465:	83 ec 0c             	sub    $0xc,%esp
  103468:	ff 75 f0             	pushl  -0x10(%ebp)
  10346b:	e8 7c 04 00 00       	call   1038ec <free>
  103470:	83 c4 10             	add    $0x10,%esp
  103473:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103477:	75 10                	jne    103489 <return_rpc_call+0x10b>
  103479:	83 ec 0c             	sub    $0xc,%esp
  10347c:	ff 75 ec             	pushl  -0x14(%ebp)
  10347f:	e8 c9 fb ff ff       	call   10304d <schedule_to_task>
  103484:	83 c4 10             	add    $0x10,%esp
  103487:	eb 2a                	jmp    1034b3 <return_rpc_call+0x135>
  103489:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10348c:	8b 40 04             	mov    0x4(%eax),%eax
  10348f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  103495:	83 ec 0c             	sub    $0xc,%esp
  103498:	ff 75 f4             	pushl  -0xc(%ebp)
  10349b:	e8 ad fb ff ff       	call   10304d <schedule_to_task>
  1034a0:	83 c4 10             	add    $0x10,%esp
  1034a3:	eb 0e                	jmp    1034b3 <return_rpc_call+0x135>
  1034a5:	83 ec 0c             	sub    $0xc,%esp
  1034a8:	ff 75 ec             	pushl  -0x14(%ebp)
  1034ab:	e8 9d fb ff ff       	call   10304d <schedule_to_task>
  1034b0:	83 c4 10             	add    $0x10,%esp
  1034b3:	c9                   	leave  
  1034b4:	c3                   	ret    
  1034b5:	00 00                	add    %al,(%eax)
	...

001034b8 <remove_from_list>:
struct block_buffer* buffer[65536];

void ramfs_block_init() {
    memset(buffer, 0, sizeof(buffer));
}

  1034b8:	55                   	push   %ebp
  1034b9:	89 e5                	mov    %esp,%ebp
  1034bb:	83 ec 10             	sub    $0x10,%esp
struct kfs_driver block_driver = {
  1034be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    .rread     = ramfs_block_read,
  1034c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1034c8:	8b 00                	mov    (%eax),%eax
  1034ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
    .rwrite    = ramfs_block_write,
    .open      = ramfs_block_open,
  1034cd:	eb 38                	jmp    103507 <remove_from_list+0x4f>
    .create    = ramfs_block_create,
  1034cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034d2:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1034d5:	75 21                	jne    1034f8 <remove_from_list+0x40>
    .close     = ramfs_block_close,
  1034d7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1034db:	75 0d                	jne    1034ea <remove_from_list+0x32>
    .available = ramfs_block_available,
  1034dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034e0:	8b 50 08             	mov    0x8(%eax),%edx
  1034e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1034e6:	89 10                	mov    %edx,(%eax)
    .drvname   = "RAMFILE"
  1034e8:	eb 23                	jmp    10350d <remove_from_list+0x55>
};

  1034ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034ed:	8b 50 08             	mov    0x8(%eax),%edx
  1034f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1034f3:	89 50 08             	mov    %edx,0x8(%eax)
struct kfs_driver* ramfs_block_driver_struct() {
  1034f6:	eb 15                	jmp    10350d <remove_from_list+0x55>
    return &block_driver;
}

  1034f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
uint32_t ramfs_block_available(struct res_handle* handle) {
  1034fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103501:	8b 40 08             	mov    0x8(%eax),%eax
  103504:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

struct kfs_driver block_driver = {
    .rread     = ramfs_block_read,
    .rwrite    = ramfs_block_write,
    .open      = ramfs_block_open,
  103507:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10350b:	75 c2                	jne    1034cf <remove_from_list+0x17>
    return &block_driver;
}

uint32_t ramfs_block_available(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

  10350d:	c9                   	leave  
  10350e:	c3                   	ret    

0010350f <append_to_list>:
    if(buffer[kf->id] != 0) {
        return buffer[kf->id]->size - handle->position;
    }
  10350f:	55                   	push   %ebp
  103510:	89 e5                	mov    %esp,%ebp

  103512:	8b 45 08             	mov    0x8(%ebp),%eax
  103515:	8b 10                	mov    (%eax),%edx
  103517:	8b 45 0c             	mov    0xc(%ebp),%eax
  10351a:	89 50 08             	mov    %edx,0x8(%eax)
    return 0;
  10351d:	8b 45 08             	mov    0x8(%ebp),%eax
  103520:	8b 55 0c             	mov    0xc(%ebp),%edx
  103523:	89 10                	mov    %edx,(%eax)
}
  103525:	5d                   	pop    %ebp
  103526:	c3                   	ret    

00103527 <pop_from_list>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  103527:	55                   	push   %ebp
  103528:	89 e5                	mov    %esp,%ebp
  10352a:	83 ec 10             	sub    $0x10,%esp
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  10352d:	8b 45 08             	mov    0x8(%ebp),%eax
  103530:	8b 00                	mov    (%eax),%eax
  103532:	85 c0                	test   %eax,%eax
  103534:	75 07                	jne    10353d <pop_from_list+0x16>

  103536:	b8 00 00 00 00       	mov    $0x0,%eax
  10353b:	eb 19                	jmp    103556 <pop_from_list+0x2f>
    for(int i = 0; i < 65536; i++) {
  10353d:	8b 45 08             	mov    0x8(%ebp),%eax
  103540:	8b 00                	mov    (%eax),%eax
  103542:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if(buffer[i] == 0) {
  103545:	ff 75 fc             	pushl  -0x4(%ebp)
  103548:	ff 75 08             	pushl  0x8(%ebp)
  10354b:	e8 68 ff ff ff       	call   1034b8 <remove_from_list>
  103550:	83 c4 08             	add    $0x8,%esp
            buffer[i] = malloc(sizeof(struct block_buffer));
  103553:	8b 45 fc             	mov    -0x4(%ebp),%eax
            buffer[i]->buffer = malloc(args[0]);
  103556:	c9                   	leave  
  103557:	c3                   	ret    

00103558 <allocate_unused_nodes>:
            buffer[i]->size   = args[0];

  103558:	55                   	push   %ebp
  103559:	89 e5                	mov    %esp,%ebp
  10355b:	83 ec 18             	sub    $0x18,%esp
            buffer[i]->writers = 0;
  10355e:	83 ec 0c             	sub    $0xc,%esp
  103561:	6a 01                	push   $0x1
  103563:	e8 29 1d 00 00       	call   105291 <vmm_alloc_cont>
  103568:	83 c4 10             	add    $0x10,%esp
  10356b:	89 45 f0             	mov    %eax,-0x10(%ebp)
            buffer[i]->readers = 0;
  10356e:	83 ec 04             	sub    $0x4,%esp
  103571:	68 00 10 00 00       	push   $0x1000
  103576:	6a 00                	push   $0x0
  103578:	ff 75 f0             	pushl  -0x10(%ebp)
  10357b:	e8 c0 03 00 00       	call   103940 <memset>
  103580:	83 c4 10             	add    $0x10,%esp

            kfret->id = i;
  103583:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  10358a:	eb 23                	jmp    1035af <allocate_unused_nodes+0x57>

  10358c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10358f:	89 d0                	mov    %edx,%eax
  103591:	01 c0                	add    %eax,%eax
  103593:	01 d0                	add    %edx,%eax
  103595:	c1 e0 02             	shl    $0x2,%eax
  103598:	03 45 f0             	add    -0x10(%ebp),%eax
  10359b:	83 ec 08             	sub    $0x8,%esp
  10359e:	50                   	push   %eax
  10359f:	68 34 85 12 00       	push   $0x128534
  1035a4:	e8 66 ff ff ff       	call   10350f <append_to_list>
  1035a9:	83 c4 10             	add    $0x10,%esp
            buffer[i]->size   = args[0];

            buffer[i]->writers = 0;
            buffer[i]->readers = 0;

            kfret->id = i;
  1035ac:	ff 45 f4             	incl   -0xc(%ebp)
  1035af:	81 7d f4 54 01 00 00 	cmpl   $0x154,-0xc(%ebp)
  1035b6:	76 d4                	jbe    10358c <allocate_unused_nodes+0x34>

            return kfret;
        }
  1035b8:	c9                   	leave  
  1035b9:	c3                   	ret    

001035ba <pop_unused_node>:
    }

  1035ba:	55                   	push   %ebp
  1035bb:	89 e5                	mov    %esp,%ebp
  1035bd:	83 ec 18             	sub    $0x18,%esp
    return 0;
  1035c0:	68 34 85 12 00       	push   $0x128534
  1035c5:	e8 5d ff ff ff       	call   103527 <pop_from_list>
  1035ca:	83 c4 04             	add    $0x4,%esp
  1035cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

  1035d0:	eb 18                	jmp    1035ea <pop_unused_node+0x30>
uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  1035d2:	e8 81 ff ff ff       	call   103558 <allocate_unused_nodes>
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1035d7:	83 ec 0c             	sub    $0xc,%esp
  1035da:	68 34 85 12 00       	push   $0x128534
  1035df:	e8 43 ff ff ff       	call   103527 <pop_from_list>
  1035e4:	83 c4 10             	add    $0x10,%esp
  1035e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }
    }

    return 0;
}

  1035ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1035ee:	74 e2                	je     1035d2 <pop_unused_node+0x18>
uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;
  1035f0:	8b 45 f4             	mov    -0xc(%ebp),%eax

  1035f3:	c9                   	leave  
  1035f4:	c3                   	ret    

001035f5 <merge_into_frees>:
        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);

  1035f5:	55                   	push   %ebp
  1035f6:	89 e5                	mov    %esp,%ebp
  1035f8:	83 ec 10             	sub    $0x10,%esp
        return RW_OK;
  1035fb:	ff 75 08             	pushl  0x8(%ebp)
  1035fe:	68 38 85 12 00       	push   $0x128538
  103603:	e8 b0 fe ff ff       	call   1034b8 <remove_from_list>
  103608:	83 c4 08             	add    $0x8,%esp
    }

    return RW_ERR_DRIVER;
}

  10360b:	a1 3c 85 12 00       	mov    0x12853c,%eax
  103610:	89 45 fc             	mov    %eax,-0x4(%ebp)
uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103613:	eb 79                	jmp    10368e <merge_into_frees+0x99>

  103615:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103618:	8b 50 04             	mov    0x4(%eax),%edx
  10361b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10361e:	8b 00                	mov    (%eax),%eax
  103620:	01 c2                	add    %eax,%edx
  103622:	8b 45 08             	mov    0x8(%ebp),%eax
  103625:	8b 40 04             	mov    0x4(%eax),%eax
  103628:	39 c2                	cmp    %eax,%edx
  10362a:	75 1e                	jne    10364a <merge_into_frees+0x55>
    if(buffer[kf->id] != 0) {
  10362c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10362f:	8b 50 04             	mov    0x4(%eax),%edx
  103632:	8b 45 08             	mov    0x8(%ebp),%eax
  103635:	89 50 04             	mov    %edx,0x4(%eax)
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF; //Can't write  that much biatch TODO realloc so file may grow and implement RW_EOF
  103638:	ff 75 fc             	pushl  -0x4(%ebp)
  10363b:	68 3c 85 12 00       	push   $0x12853c
  103640:	e8 73 fe ff ff       	call   1034b8 <remove_from_list>
  103645:	83 c4 08             	add    $0x8,%esp

  103648:	eb c1                	jmp    10360b <merge_into_frees+0x16>
        memcpy(buffer[kf->id]->buffer + handle->position, src, length);

        return RW_OK;
  10364a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10364d:	8b 50 04             	mov    0x4(%eax),%edx
  103650:	8b 45 08             	mov    0x8(%ebp),%eax
  103653:	8b 48 04             	mov    0x4(%eax),%ecx
  103656:	8b 45 08             	mov    0x8(%ebp),%eax
  103659:	8b 00                	mov    (%eax),%eax
  10365b:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  10365e:	39 c2                	cmp    %eax,%edx
  103660:	75 23                	jne    103685 <merge_into_frees+0x90>
    }
  103662:	8b 45 08             	mov    0x8(%ebp),%eax
  103665:	8b 10                	mov    (%eax),%edx
  103667:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10366a:	8b 00                	mov    (%eax),%eax
  10366c:	01 c2                	add    %eax,%edx
  10366e:	8b 45 08             	mov    0x8(%ebp),%eax
  103671:	89 10                	mov    %edx,(%eax)

  103673:	ff 75 fc             	pushl  -0x4(%ebp)
  103676:	68 3c 85 12 00       	push   $0x12853c
  10367b:	e8 38 fe ff ff       	call   1034b8 <remove_from_list>
  103680:	83 c4 08             	add    $0x8,%esp
    return RW_ERR_DRIVER;
  103683:	eb 86                	jmp    10360b <merge_into_frees+0x16>
}

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  103685:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103688:	8b 40 08             	mov    0x8(%eax),%eax
  10368b:	89 45 fc             	mov    %eax,-0x4(%ebp)

    return RW_ERR_DRIVER;
}

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10368e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103692:	75 81                	jne    103615 <merge_into_frees+0x20>
}

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
    if(buffer[kf->id] != 0) {
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  103694:	ff 75 08             	pushl  0x8(%ebp)
  103697:	68 3c 85 12 00       	push   $0x12853c
  10369c:	e8 6e fe ff ff       	call   10350f <append_to_list>
  1036a1:	83 c4 08             	add    $0x8,%esp

  1036a4:	c9                   	leave  
  1036a5:	c3                   	ret    

001036a6 <malloc>:
        struct res_handle* rethandle = malloc(sizeof(struct res_handle));

        rethandle->filemode = filemode;
        rethandle->position = 0;
        rethandle->res_type = RES_KERNDRV;
  1036a6:	55                   	push   %ebp
  1036a7:	89 e5                	mov    %esp,%ebp
  1036a9:	83 ec 28             	sub    $0x28,%esp
  1036ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1036b0:	75 0a                	jne    1036bc <malloc+0x16>
  1036b2:	b8 00 00 00 00       	mov    $0x0,%eax
  1036b7:	e9 5e 01 00 00       	jmp    10381a <malloc+0x174>
        rethandle->res_ptr  = kf;

  1036bc:	a1 40 85 12 00       	mov    0x128540,%eax
  1036c1:	03 45 08             	add    0x8(%ebp),%eax
  1036c4:	a3 40 85 12 00       	mov    %eax,0x128540
        return rethandle;
    }
  1036c9:	a1 3c 85 12 00       	mov    0x12853c,%eax
  1036ce:	89 45 dc             	mov    %eax,-0x24(%ebp)

    return (void*)1;
  1036d1:	eb 13                	jmp    1036e6 <malloc+0x40>
}
  1036d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1036d6:	8b 00                	mov    (%eax),%eax
  1036d8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1036db:	73 11                	jae    1036ee <malloc+0x48>

uint32_t ramfs_block_close(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1036dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1036e0:	8b 40 08             	mov    0x8(%eax),%eax
  1036e3:	89 45 dc             	mov    %eax,-0x24(%ebp)
        rethandle->res_ptr  = kf;

        return rethandle;
    }

    return (void*)1;
  1036e6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1036ea:	75 e7                	jne    1036d3 <malloc+0x2d>
  1036ec:	eb 01                	jmp    1036ef <malloc+0x49>
}

  1036ee:	90                   	nop    
uint32_t ramfs_block_close(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

    if(buffer[kf->id] != 0) {
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  1036ef:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1036f3:	0f 85 a6 00 00 00    	jne    10379f <malloc+0xf9>
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  1036f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1036fc:	c1 e8 0c             	shr    $0xc,%eax
  1036ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

  103702:	8b 45 08             	mov    0x8(%ebp),%eax
  103705:	25 ff 0f 00 00       	and    $0xfff,%eax
  10370a:	85 c0                	test   %eax,%eax
  10370c:	74 03                	je     103711 <malloc+0x6b>
    free(handle);
  10370e:	ff 45 e0             	incl   -0x20(%ebp)

    return 0;
  103711:	83 ec 0c             	sub    $0xc,%esp
  103714:	ff 75 e0             	pushl  -0x20(%ebp)
  103717:	e8 75 1b 00 00       	call   105291 <vmm_alloc_cont>
  10371c:	83 c4 10             	add    $0x10,%esp
  10371f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}
  103722:	e8 93 fe ff ff       	call   1035ba <pop_unused_node>
  103727:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10372a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10372d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103730:	89 50 04             	mov    %edx,0x4(%eax)
  103733:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103736:	8b 55 08             	mov    0x8(%ebp),%edx
  103739:	89 10                	mov    %edx,(%eax)
  10373b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10373e:	c1 e0 0c             	shl    $0xc,%eax
  103741:	3b 45 08             	cmp    0x8(%ebp),%eax
  103744:	76 3e                	jbe    103784 <malloc+0xde>
  103746:	e8 6f fe ff ff       	call   1035ba <pop_unused_node>
  10374b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10374e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103751:	8b 50 04             	mov    0x4(%eax),%edx
  103754:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103757:	8b 00                	mov    (%eax),%eax
  103759:	01 c2                	add    %eax,%edx
  10375b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10375e:	89 50 04             	mov    %edx,0x4(%eax)
  103761:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103764:	c1 e0 0c             	shl    $0xc,%eax
  103767:	89 c2                	mov    %eax,%edx
  103769:	2b 55 08             	sub    0x8(%ebp),%edx
  10376c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10376f:	89 10                	mov    %edx,(%eax)
  103771:	83 ec 08             	sub    $0x8,%esp
  103774:	ff 75 ec             	pushl  -0x14(%ebp)
  103777:	68 3c 85 12 00       	push   $0x12853c
  10377c:	e8 8e fd ff ff       	call   10350f <append_to_list>
  103781:	83 c4 10             	add    $0x10,%esp
  103784:	83 ec 08             	sub    $0x8,%esp
  103787:	ff 75 e8             	pushl  -0x18(%ebp)
  10378a:	68 38 85 12 00       	push   $0x128538
  10378f:	e8 7b fd ff ff       	call   10350f <append_to_list>
  103794:	83 c4 10             	add    $0x10,%esp
  103797:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10379a:	8b 40 04             	mov    0x4(%eax),%eax
  10379d:	eb 7b                	jmp    10381a <malloc+0x174>
  10379f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037a2:	8b 00                	mov    (%eax),%eax
  1037a4:	2b 45 08             	sub    0x8(%ebp),%eax
  1037a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1037aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037ad:	8b 55 08             	mov    0x8(%ebp),%edx
  1037b0:	89 10                	mov    %edx,(%eax)
  1037b2:	83 ec 08             	sub    $0x8,%esp
  1037b5:	ff 75 dc             	pushl  -0x24(%ebp)
  1037b8:	68 3c 85 12 00       	push   $0x12853c
  1037bd:	e8 f6 fc ff ff       	call   1034b8 <remove_from_list>
  1037c2:	83 c4 10             	add    $0x10,%esp
  1037c5:	83 ec 08             	sub    $0x8,%esp
  1037c8:	ff 75 dc             	pushl  -0x24(%ebp)
  1037cb:	68 38 85 12 00       	push   $0x128538
  1037d0:	e8 3a fd ff ff       	call   10350f <append_to_list>
  1037d5:	83 c4 10             	add    $0x10,%esp
  1037d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1037dc:	74 36                	je     103814 <malloc+0x16e>
  1037de:	e8 d7 fd ff ff       	call   1035ba <pop_unused_node>
  1037e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1037e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037e9:	8b 50 04             	mov    0x4(%eax),%edx
  1037ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037ef:	8b 00                	mov    (%eax),%eax
  1037f1:	01 c2                	add    %eax,%edx
  1037f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037f6:	89 50 04             	mov    %edx,0x4(%eax)
  1037f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1037ff:	89 10                	mov    %edx,(%eax)
  103801:	83 ec 08             	sub    $0x8,%esp
  103804:	ff 75 f4             	pushl  -0xc(%ebp)
  103807:	68 3c 85 12 00       	push   $0x12853c
  10380c:	e8 fe fc ff ff       	call   10350f <append_to_list>
  103811:	83 c4 10             	add    $0x10,%esp
  103814:	8b 45 dc             	mov    -0x24(%ebp),%eax
  103817:	8b 40 04             	mov    0x4(%eax),%eax
  10381a:	c9                   	leave  
  10381b:	c3                   	ret    

0010381c <calloc>:
  10381c:	55                   	push   %ebp
  10381d:	89 e5                	mov    %esp,%ebp
  10381f:	83 ec 18             	sub    $0x18,%esp
  103822:	8b 45 08             	mov    0x8(%ebp),%eax
  103825:	0f af 45 0c          	imul   0xc(%ebp),%eax
  103829:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10382c:	83 ec 0c             	sub    $0xc,%esp
  10382f:	ff 75 f0             	pushl  -0x10(%ebp)
  103832:	e8 6f fe ff ff       	call   1036a6 <malloc>
  103837:	83 c4 10             	add    $0x10,%esp
  10383a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10383d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103841:	74 13                	je     103856 <calloc+0x3a>
  103843:	83 ec 04             	sub    $0x4,%esp
  103846:	ff 75 f0             	pushl  -0x10(%ebp)
  103849:	6a 00                	push   $0x0
  10384b:	ff 75 f4             	pushl  -0xc(%ebp)
  10384e:	e8 ed 00 00 00       	call   103940 <memset>
  103853:	83 c4 10             	add    $0x10,%esp
  103856:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103859:	c9                   	leave  
  10385a:	c3                   	ret    

0010385b <realloc>:
  10385b:	55                   	push   %ebp
  10385c:	89 e5                	mov    %esp,%ebp
  10385e:	83 ec 18             	sub    $0x18,%esp
  103861:	a1 38 85 12 00       	mov    0x128538,%eax
  103866:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103869:	eb 74                	jmp    1038df <realloc+0x84>
  10386b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10386e:	8b 50 04             	mov    0x4(%eax),%edx
  103871:	8b 45 08             	mov    0x8(%ebp),%eax
  103874:	39 c2                	cmp    %eax,%edx
  103876:	75 5e                	jne    1038d6 <realloc+0x7b>
  103878:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10387c:	75 15                	jne    103893 <realloc+0x38>
  10387e:	83 ec 0c             	sub    $0xc,%esp
  103881:	ff 75 08             	pushl  0x8(%ebp)
  103884:	e8 63 00 00 00       	call   1038ec <free>
  103889:	83 c4 10             	add    $0x10,%esp
  10388c:	b8 00 00 00 00       	mov    $0x0,%eax
  103891:	eb 57                	jmp    1038ea <realloc+0x8f>
  103893:	83 ec 0c             	sub    $0xc,%esp
  103896:	ff 75 0c             	pushl  0xc(%ebp)
  103899:	e8 08 fe ff ff       	call   1036a6 <malloc>
  10389e:	83 c4 10             	add    $0x10,%esp
  1038a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1038a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038a7:	8b 10                	mov    (%eax),%edx
  1038a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038ac:	8b 40 04             	mov    0x4(%eax),%eax
  1038af:	83 ec 04             	sub    $0x4,%esp
  1038b2:	52                   	push   %edx
  1038b3:	50                   	push   %eax
  1038b4:	ff 75 f4             	pushl  -0xc(%ebp)
  1038b7:	e8 b2 00 00 00       	call   10396e <memcpy>
  1038bc:	83 c4 10             	add    $0x10,%esp
  1038bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038c2:	8b 40 04             	mov    0x4(%eax),%eax
  1038c5:	83 ec 0c             	sub    $0xc,%esp
  1038c8:	50                   	push   %eax
  1038c9:	e8 1e 00 00 00       	call   1038ec <free>
  1038ce:	83 c4 10             	add    $0x10,%esp
  1038d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1038d4:	eb 14                	jmp    1038ea <realloc+0x8f>
  1038d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038d9:	8b 40 08             	mov    0x8(%eax),%eax
  1038dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1038df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1038e3:	75 86                	jne    10386b <realloc+0x10>
  1038e5:	b8 00 00 00 00       	mov    $0x0,%eax
  1038ea:	c9                   	leave  
  1038eb:	c3                   	ret    

001038ec <free>:
  1038ec:	55                   	push   %ebp
  1038ed:	89 e5                	mov    %esp,%ebp
  1038ef:	83 ec 10             	sub    $0x10,%esp
  1038f2:	a1 38 85 12 00       	mov    0x128538,%eax
  1038f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1038fa:	eb 39                	jmp    103935 <free+0x49>
  1038fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1038ff:	8b 50 04             	mov    0x4(%eax),%edx
  103902:	8b 45 08             	mov    0x8(%ebp),%eax
  103905:	39 c2                	cmp    %eax,%edx
  103907:	75 23                	jne    10392c <free+0x40>
  103909:	8b 15 40 85 12 00    	mov    0x128540,%edx
  10390f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103912:	8b 00                	mov    (%eax),%eax
  103914:	89 d1                	mov    %edx,%ecx
  103916:	29 c1                	sub    %eax,%ecx
  103918:	89 c8                	mov    %ecx,%eax
  10391a:	a3 40 85 12 00       	mov    %eax,0x128540
  10391f:	ff 75 fc             	pushl  -0x4(%ebp)
  103922:	e8 ce fc ff ff       	call   1035f5 <merge_into_frees>
  103927:	83 c4 04             	add    $0x4,%esp
  10392a:	eb 0f                	jmp    10393b <free+0x4f>
  10392c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10392f:	8b 40 08             	mov    0x8(%eax),%eax
  103932:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103935:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103939:	75 c1                	jne    1038fc <free+0x10>
  10393b:	c9                   	leave  
  10393c:	c3                   	ret    
  10393d:	00 00                	add    %al,(%eax)
	...

00103940 <memset>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  103940:	55                   	push   %ebp
  103941:	89 e5                	mov    %esp,%ebp
  103943:	83 ec 10             	sub    $0x10,%esp
  103946:	8b 45 08             	mov    0x8(%ebp),%eax
  103949:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(buffer, 0, sizeof(buffer));
}
  10394c:	eb 0d                	jmp    10395b <memset+0x1b>

  10394e:	8b 45 0c             	mov    0xc(%ebp),%eax
  103951:	88 c2                	mov    %al,%dl
  103953:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103956:	88 10                	mov    %dl,(%eax)
  103958:	ff 45 fc             	incl   -0x4(%ebp)

struct block_buffer* buffer[65536];

void ramfs_block_init() {
    memset(buffer, 0, sizeof(buffer));
}
  10395b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  10395f:	0f 95 c0             	setne  %al
  103962:	ff 4d 10             	decl   0x10(%ebp)
  103965:	84 c0                	test   %al,%al
  103967:	75 e5                	jne    10394e <memset+0xe>

struct kfs_driver block_driver = {
    .rread     = ramfs_block_read,
    .rwrite    = ramfs_block_write,
  103969:	8b 45 08             	mov    0x8(%ebp),%eax
    .open      = ramfs_block_open,
  10396c:	c9                   	leave  
  10396d:	c3                   	ret    

0010396e <memcpy>:
    .create    = ramfs_block_create,
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
  10396e:	55                   	push   %ebp
  10396f:	89 e5                	mov    %esp,%ebp
  103971:	83 ec 10             	sub    $0x10,%esp
  103974:	8b 45 08             	mov    0x8(%ebp),%eax
  103977:	89 45 f8             	mov    %eax,-0x8(%ebp)
    .drvname   = "RAMFILE"
  10397a:	8b 45 0c             	mov    0xc(%ebp),%eax
  10397d:	89 45 fc             	mov    %eax,-0x4(%ebp)
};

  103980:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103984:	75 19                	jne    10399f <memcpy+0x31>
  103986:	b8 00 00 00 00       	mov    $0x0,%eax
  10398b:	eb 24                	jmp    1039b1 <memcpy+0x43>
struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
}
  10398d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103990:	8a 10                	mov    (%eax),%dl
  103992:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103995:	88 10                	mov    %dl,(%eax)
  103997:	ff 45 f8             	incl   -0x8(%ebp)
  10399a:	ff 45 fc             	incl   -0x4(%ebp)
  10399d:	eb 01                	jmp    1039a0 <memcpy+0x32>
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
  10399f:	90                   	nop    
  1039a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1039a4:	0f 95 c0             	setne  %al
  1039a7:	ff 4d 10             	decl   0x10(%ebp)
  1039aa:	84 c0                	test   %al,%al
  1039ac:	75 df                	jne    10398d <memcpy+0x1f>
}

uint32_t ramfs_block_available(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1039ae:	8b 45 08             	mov    0x8(%ebp),%eax

  1039b1:	c9                   	leave  
  1039b2:	c3                   	ret    

001039b3 <memcmp>:
    if(buffer[kf->id] != 0) {
        return buffer[kf->id]->size - handle->position;
    }
  1039b3:	55                   	push   %ebp
  1039b4:	89 e5                	mov    %esp,%ebp
  1039b6:	83 ec 10             	sub    $0x10,%esp
  1039b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1039bd:	75 0a                	jne    1039c9 <memcmp+0x16>

  1039bf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1039c4:	e9 83 00 00 00       	jmp    103a4c <memcmp+0x99>
    return 0;
  1039c9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1039cd:	75 07                	jne    1039d6 <memcmp+0x23>
}
  1039cf:	b8 01 00 00 00       	mov    $0x1,%eax
  1039d4:	eb 76                	jmp    103a4c <memcmp+0x99>

  1039d6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1039da:	75 07                	jne    1039e3 <memcmp+0x30>
struct res_kfile* ramfs_block_create(uint32_t* args) {
  1039dc:	b8 00 00 00 00       	mov    $0x0,%eax
  1039e1:	eb 69                	jmp    103a4c <memcmp+0x99>
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

  1039e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1039e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i = 0; i < 65536; i++) {
  1039e9:	8b 45 0c             	mov    0xc(%ebp),%eax
  1039ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if(buffer[i] == 0) {
            buffer[i] = malloc(sizeof(struct block_buffer));
  1039ef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1039f6:	eb 47                	jmp    103a3f <memcmp+0x8c>
            buffer[i]->buffer = malloc(args[0]);
  1039f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1039fe:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103a01:	8a 10                	mov    (%eax),%dl
  103a03:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a06:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103a09:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103a0c:	8a 00                	mov    (%eax),%al
  103a0e:	38 c2                	cmp    %al,%dl
  103a10:	74 2a                	je     103a3c <memcmp+0x89>
            buffer[i]->size   = args[0];
  103a12:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a15:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103a18:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103a1b:	8a 00                	mov    (%eax),%al
  103a1d:	ba 00 00 00 00       	mov    $0x0,%edx
  103a22:	88 c2                	mov    %al,%dl
  103a24:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a27:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103a2a:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103a2d:	8a 00                	mov    (%eax),%al
  103a2f:	25 ff 00 00 00       	and    $0xff,%eax
  103a34:	89 d1                	mov    %edx,%ecx
  103a36:	29 c1                	sub    %eax,%ecx
  103a38:	89 c8                	mov    %ecx,%eax
  103a3a:	eb 10                	jmp    103a4c <memcmp+0x99>
struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
        if(buffer[i] == 0) {
            buffer[i] = malloc(sizeof(struct block_buffer));
  103a3c:	ff 45 fc             	incl   -0x4(%ebp)
  103a3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a42:	3b 45 10             	cmp    0x10(%ebp),%eax
  103a45:	72 b1                	jb     1039f8 <memcmp+0x45>
            buffer[i]->buffer = malloc(args[0]);
            buffer[i]->size   = args[0];

            buffer[i]->writers = 0;
            buffer[i]->readers = 0;
  103a47:	b8 00 00 00 00       	mov    $0x0,%eax

  103a4c:	c9                   	leave  
  103a4d:	c3                   	ret    

00103a4e <strcmp>:
            kfret->id = i;

            return kfret;
  103a4e:	55                   	push   %ebp
  103a4f:	89 e5                	mov    %esp,%ebp
  103a51:	83 ec 18             	sub    $0x18,%esp
  103a54:	83 ec 0c             	sub    $0xc,%esp
  103a57:	ff 75 08             	pushl  0x8(%ebp)
  103a5a:	e8 3e 00 00 00       	call   103a9d <strlen>
  103a5f:	83 c4 10             	add    $0x10,%esp
  103a62:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
  103a65:	83 ec 0c             	sub    $0xc,%esp
  103a68:	ff 75 0c             	pushl  0xc(%ebp)
  103a6b:	e8 2d 00 00 00       	call   103a9d <strlen>
  103a70:	83 c4 10             	add    $0x10,%esp
  103a73:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  103a76:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103a79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a7c:	39 d0                	cmp    %edx,%eax
  103a7e:	7e 02                	jle    103a82 <strcmp+0x34>
  103a80:	89 d0                	mov    %edx,%eax
  103a82:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return 0;
  103a85:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a88:	40                   	inc    %eax
  103a89:	83 ec 04             	sub    $0x4,%esp
  103a8c:	50                   	push   %eax
  103a8d:	ff 75 0c             	pushl  0xc(%ebp)
  103a90:	ff 75 08             	pushl  0x8(%ebp)
  103a93:	e8 1b ff ff ff       	call   1039b3 <memcmp>
  103a98:	83 c4 10             	add    $0x10,%esp
}
  103a9b:	c9                   	leave  
  103a9c:	c3                   	ret    

00103a9d <strlen>:

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103a9d:	55                   	push   %ebp
  103a9e:	89 e5                	mov    %esp,%ebp
  103aa0:	83 ec 10             	sub    $0x10,%esp
  103aa3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103aa7:	75 07                	jne    103ab0 <strlen+0x13>

  103aa9:	b8 00 00 00 00       	mov    $0x0,%eax
  103aae:	eb 1b                	jmp    103acb <strlen+0x2e>
    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF;
  103ab0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103ab7:	eb 03                	jmp    103abc <strlen+0x1f>
  103ab9:	ff 45 fc             	incl   -0x4(%ebp)
  103abc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103abf:	03 45 08             	add    0x8(%ebp),%eax
  103ac2:	8a 00                	mov    (%eax),%al
  103ac4:	84 c0                	test   %al,%al
  103ac6:	75 f1                	jne    103ab9 <strlen+0x1c>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  103ac8:	8b 45 fc             	mov    -0x4(%ebp),%eax

  103acb:	c9                   	leave  
  103acc:	c3                   	ret    

00103acd <strcpy>:
        return RW_OK;
    }

  103acd:	55                   	push   %ebp
  103ace:	89 e5                	mov    %esp,%ebp
  103ad0:	ff 75 0c             	pushl  0xc(%ebp)
  103ad3:	e8 c5 ff ff ff       	call   103a9d <strlen>
  103ad8:	83 c4 04             	add    $0x4,%esp
  103adb:	40                   	inc    %eax
  103adc:	50                   	push   %eax
  103add:	ff 75 0c             	pushl  0xc(%ebp)
  103ae0:	ff 75 08             	pushl  0x8(%ebp)
  103ae3:	e8 86 fe ff ff       	call   10396e <memcpy>
  103ae8:	83 c4 0c             	add    $0xc,%esp
    return RW_ERR_DRIVER;
  103aeb:	8b 45 08             	mov    0x8(%ebp),%eax
}
  103aee:	c9                   	leave  
  103aef:	c3                   	ret    

00103af0 <strclone>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  103af0:	55                   	push   %ebp
  103af1:	89 e5                	mov    %esp,%ebp
  103af3:	83 ec 18             	sub    $0x18,%esp
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103af6:	ff 75 08             	pushl  0x8(%ebp)
  103af9:	e8 9f ff ff ff       	call   103a9d <strlen>
  103afe:	83 c4 04             	add    $0x4,%esp
  103b01:	40                   	inc    %eax
  103b02:	83 ec 0c             	sub    $0xc,%esp
  103b05:	50                   	push   %eax
  103b06:	e8 9b fb ff ff       	call   1036a6 <malloc>
  103b0b:	83 c4 10             	add    $0x10,%esp
  103b0e:	89 45 f4             	mov    %eax,-0xc(%ebp)

  103b11:	83 ec 08             	sub    $0x8,%esp
  103b14:	ff 75 08             	pushl  0x8(%ebp)
  103b17:	ff 75 f4             	pushl  -0xc(%ebp)
  103b1a:	e8 ae ff ff ff       	call   103acd <strcpy>
  103b1f:	83 c4 10             	add    $0x10,%esp
    if(buffer[kf->id] != 0) {
        if(handle->position + length > buffer[kf->id]->size) return RW_EOF; //Can't write  that much biatch TODO realloc so file may grow and implement RW_EOF
  103b22:	8b 45 f4             	mov    -0xc(%ebp),%eax

  103b25:	c9                   	leave  
  103b26:	c3                   	ret    

00103b27 <strtok>:
        memcpy(buffer[kf->id]->buffer + handle->position, src, length);

        return RW_OK;
    }

  103b27:	55                   	push   %ebp
  103b28:	89 e5                	mov    %esp,%ebp
  103b2a:	83 ec 08             	sub    $0x8,%esp
    return RW_ERR_DRIVER;
  103b2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103b31:	74 43                	je     103b76 <strtok+0x4f>
}
  103b33:	a1 48 85 12 00       	mov    0x128548,%eax
  103b38:	85 c0                	test   %eax,%eax
  103b3a:	74 11                	je     103b4d <strtok+0x26>

  103b3c:	a1 48 85 12 00       	mov    0x128548,%eax
  103b41:	83 ec 0c             	sub    $0xc,%esp
  103b44:	50                   	push   %eax
  103b45:	e8 a2 fd ff ff       	call   1038ec <free>
  103b4a:	83 c4 10             	add    $0x10,%esp
struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
    if(buffer[kf->id] != 0) {
  103b4d:	83 ec 0c             	sub    $0xc,%esp
  103b50:	ff 75 08             	pushl  0x8(%ebp)
  103b53:	e8 98 ff ff ff       	call   103af0 <strclone>
  103b58:	83 c4 10             	add    $0x10,%esp
  103b5b:	a3 48 85 12 00       	mov    %eax,0x128548
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  103b60:	a1 48 85 12 00       	mov    0x128548,%eax
  103b65:	83 ec 08             	sub    $0x8,%esp
  103b68:	ff 75 0c             	pushl  0xc(%ebp)
  103b6b:	50                   	push   %eax
  103b6c:	e8 17 00 00 00       	call   103b88 <strtoknc>
  103b71:	83 c4 10             	add    $0x10,%esp
  103b74:	eb 10                	jmp    103b86 <strtok+0x5f>
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;

  103b76:	83 ec 08             	sub    $0x8,%esp
  103b79:	ff 75 0c             	pushl  0xc(%ebp)
  103b7c:	6a 00                	push   $0x0
  103b7e:	e8 05 00 00 00       	call   103b88 <strtoknc>
  103b83:	83 c4 10             	add    $0x10,%esp
        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103b86:	c9                   	leave  
  103b87:	c3                   	ret    

00103b88 <strtoknc>:

        rethandle->filemode = filemode;
  103b88:	55                   	push   %ebp
  103b89:	89 e5                	mov    %esp,%ebp
  103b8b:	83 ec 10             	sub    $0x10,%esp
        rethandle->position = 0;
  103b8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        rethandle->res_type = RES_KERNDRV;
  103b95:	ff 75 0c             	pushl  0xc(%ebp)
  103b98:	e8 00 ff ff ff       	call   103a9d <strlen>
  103b9d:	83 c4 04             	add    $0x4,%esp
  103ba0:	89 45 f8             	mov    %eax,-0x8(%ebp)
        rethandle->res_ptr  = kf;

        return rethandle;
  103ba3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  103ba7:	75 0a                	jne    103bb3 <strtoknc+0x2b>
    }
  103ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  103bae:	e9 e0 00 00 00       	jmp    103c93 <strtoknc+0x10b>

    return (void*)1;
}
  103bb3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103bb7:	75 13                	jne    103bcc <strtoknc+0x44>
  103bb9:	a1 44 85 12 00       	mov    0x128544,%eax
  103bbe:	85 c0                	test   %eax,%eax
  103bc0:	75 0a                	jne    103bcc <strtoknc+0x44>

  103bc2:	b8 00 00 00 00       	mov    $0x0,%eax
  103bc7:	e9 c7 00 00 00       	jmp    103c93 <strtoknc+0x10b>
uint32_t ramfs_block_close(struct res_handle* handle) {
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);

  103bcc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103bd0:	74 08                	je     103bda <strtoknc+0x52>
    if(buffer[kf->id] != 0) {
  103bd2:	8b 45 08             	mov    0x8(%ebp),%eax
  103bd5:	a3 44 85 12 00       	mov    %eax,0x128544
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
    }

  103bda:	a1 44 85 12 00       	mov    0x128544,%eax
  103bdf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103be2:	eb 01                	jmp    103be5 <strtoknc+0x5d>
  103be4:	90                   	nop    
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
    }

    free(handle);

  103be5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103bec:	eb 19                	jmp    103c07 <strtoknc+0x7f>
    return 0;
  103bee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bf1:	8a 10                	mov    (%eax),%dl
  103bf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bf6:	03 45 0c             	add    0xc(%ebp),%eax
  103bf9:	8a 00                	mov    (%eax),%al
  103bfb:	38 c2                	cmp    %al,%dl
  103bfd:	75 05                	jne    103c04 <strtoknc+0x7c>
}
  103bff:	ff 45 fc             	incl   -0x4(%ebp)
  103c02:	eb 0b                	jmp    103c0f <strtoknc+0x87>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
    }

    free(handle);

  103c04:	ff 45 f4             	incl   -0xc(%ebp)
  103c07:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c0a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c0d:	7c df                	jl     103bee <strtoknc+0x66>
}
  103c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c12:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c15:	75 cd                	jne    103be4 <strtoknc+0x5c>
  103c17:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c1a:	a3 44 85 12 00       	mov    %eax,0x128544
  103c1f:	a1 44 85 12 00       	mov    0x128544,%eax
  103c24:	8a 00                	mov    (%eax),%al
  103c26:	84 c0                	test   %al,%al
  103c28:	75 57                	jne    103c81 <strtoknc+0xf9>
  103c2a:	c7 05 44 85 12 00 00 	movl   $0x0,0x128544
  103c31:	00 00 00 
  103c34:	a1 44 85 12 00       	mov    0x128544,%eax
  103c39:	eb 58                	jmp    103c93 <strtoknc+0x10b>
  103c3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103c42:	eb 20                	jmp    103c64 <strtoknc+0xdc>
  103c44:	a1 44 85 12 00       	mov    0x128544,%eax
  103c49:	8a 10                	mov    (%eax),%dl
  103c4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c4e:	03 45 0c             	add    0xc(%ebp),%eax
  103c51:	8a 00                	mov    (%eax),%al
  103c53:	38 c2                	cmp    %al,%dl
  103c55:	75 0a                	jne    103c61 <strtoknc+0xd9>
  103c57:	a1 44 85 12 00       	mov    0x128544,%eax
  103c5c:	c6 00 00             	movb   $0x0,(%eax)
  103c5f:	eb 0b                	jmp    103c6c <strtoknc+0xe4>
  103c61:	ff 45 f4             	incl   -0xc(%ebp)
  103c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c67:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c6a:	7c d8                	jl     103c44 <strtoknc+0xbc>
  103c6c:	a1 44 85 12 00       	mov    0x128544,%eax
  103c71:	40                   	inc    %eax
  103c72:	a3 44 85 12 00       	mov    %eax,0x128544
  103c77:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c7a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c7d:	7c 10                	jl     103c8f <strtoknc+0x107>
  103c7f:	eb 01                	jmp    103c82 <strtoknc+0xfa>
  103c81:	90                   	nop    
  103c82:	a1 44 85 12 00       	mov    0x128544,%eax
  103c87:	8a 00                	mov    (%eax),%al
  103c89:	84 c0                	test   %al,%al
  103c8b:	75 ae                	jne    103c3b <strtoknc+0xb3>
  103c8d:	eb 01                	jmp    103c90 <strtoknc+0x108>
  103c8f:	90                   	nop    
  103c90:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c93:	c9                   	leave  
  103c94:	c3                   	ret    
  103c95:	00 00                	add    %al,(%eax)
	...

00103c98 <vfs_set_error>:
uint16_t* vga_buffer = (void*) 0xB8000;
uint32_t  vga_writers = 0;

struct kfs_driver vga_driver = {
    .rread     = ramfs_vga_read,
    .rwrite    = ramfs_vga_write,
  103c98:	55                   	push   %ebp
  103c99:	89 e5                	mov    %esp,%ebp
  103c9b:	83 ec 08             	sub    $0x8,%esp
    .open      = ramfs_vga_open,
  103c9e:	e8 8a ee ff ff       	call   102b2d <get_current_task>
  103ca3:	85 c0                	test   %eax,%eax
  103ca5:	74 17                	je     103cbe <vfs_set_error+0x26>
    .create    = ramfs_vga_create,
  103ca7:	e8 81 ee ff ff       	call   102b2d <get_current_task>
  103cac:	8b 40 2c             	mov    0x2c(%eax),%eax
  103caf:	85 c0                	test   %eax,%eax
  103cb1:	75 0b                	jne    103cbe <vfs_set_error+0x26>
    .close     = ramfs_vga_close,
  103cb3:	e8 75 ee ff ff       	call   102b2d <get_current_task>
  103cb8:	8b 55 08             	mov    0x8(%ebp),%edx
  103cbb:	89 50 2c             	mov    %edx,0x2c(%eax)
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};
  103cbe:	c9                   	leave  
  103cbf:	c3                   	ret    

00103cc0 <vfs_reset_error>:

struct kfs_driver* ramfs_vga_driver_struct() {
  103cc0:	55                   	push   %ebp
  103cc1:	89 e5                	mov    %esp,%ebp
  103cc3:	83 ec 08             	sub    $0x8,%esp
    return &vga_driver;
  103cc6:	e8 62 ee ff ff       	call   102b2d <get_current_task>
  103ccb:	85 c0                	test   %eax,%eax
  103ccd:	74 0c                	je     103cdb <vfs_reset_error+0x1b>
}
  103ccf:	e8 59 ee ff ff       	call   102b2d <get_current_task>
  103cd4:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)

uint32_t ramfs_vga_writers() {
  103cdb:	c9                   	leave  
  103cdc:	c3                   	ret    

00103cdd <vfs_construct_absolute_path_for_node>:
    return vga_writers;
}

uint32_t ramfs_vga_available(struct res_handle* handle) {
  103cdd:	55                   	push   %ebp
  103cde:	89 e5                	mov    %esp,%ebp
  103ce0:	83 ec 18             	sub    $0x18,%esp
    return sizeof(struct vga_command);
  103ce3:	c6 05 c0 87 1c 00 00 	movb   $0x0,0x1c87c0
}
  103cea:	c7 45 f4 bf 87 1c 00 	movl   $0x1c87bf,-0xc(%ebp)

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  103cf1:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103cf6:	39 45 08             	cmp    %eax,0x8(%ebp)
  103cf9:	75 67                	jne    103d62 <vfs_construct_absolute_path_for_node+0x85>
    return malloc(sizeof(struct res_kfile));
  103cfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103cfe:	c6 00 2f             	movb   $0x2f,(%eax)
}

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  103d01:	eb 60                	jmp    103d63 <vfs_construct_absolute_path_for_node+0x86>
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  103d03:	8b 45 08             	mov    0x8(%ebp),%eax
  103d06:	83 ec 0c             	sub    $0xc,%esp
  103d09:	50                   	push   %eax
  103d0a:	e8 8e fd ff ff       	call   103a9d <strlen>
  103d0f:	83 c4 10             	add    $0x10,%esp
  103d12:	f7 d8                	neg    %eax
  103d14:	01 45 f4             	add    %eax,-0xc(%ebp)
}
  103d17:	8b 45 08             	mov    0x8(%ebp),%eax
  103d1a:	83 ec 08             	sub    $0x8,%esp
  103d1d:	50                   	push   %eax
  103d1e:	ff 75 f4             	pushl  -0xc(%ebp)
  103d21:	e8 a7 fd ff ff       	call   103acd <strcpy>
  103d26:	83 c4 10             	add    $0x10,%esp

  103d29:	8b 45 08             	mov    0x8(%ebp),%eax
  103d2c:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103d32:	85 c0                	test   %eax,%eax
  103d34:	75 15                	jne    103d4b <vfs_construct_absolute_path_for_node+0x6e>
  103d36:	8b 45 08             	mov    0x8(%ebp),%eax
  103d39:	83 ec 0c             	sub    $0xc,%esp
  103d3c:	50                   	push   %eax
  103d3d:	e8 5b fd ff ff       	call   103a9d <strlen>
  103d42:	83 c4 10             	add    $0x10,%esp
  103d45:	03 45 f4             	add    -0xc(%ebp),%eax
  103d48:	c6 00 2f             	movb   $0x2f,(%eax)
uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  103d4b:	ff 4d f4             	decl   -0xc(%ebp)
  103d4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d51:	c6 00 2f             	movb   $0x2f,(%eax)
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;

  103d54:	8b 45 08             	mov    0x8(%ebp),%eax
  103d57:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  103d5d:	89 45 08             	mov    %eax,0x8(%ebp)
  103d60:	eb 01                	jmp    103d63 <vfs_construct_absolute_path_for_node+0x86>

struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
}

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  103d62:	90                   	nop    
  103d63:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103d68:	39 45 08             	cmp    %eax,0x8(%ebp)
  103d6b:	75 96                	jne    103d03 <vfs_construct_absolute_path_for_node+0x26>
uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;

    struct vga_command* vgac = src;

    if(vgac->command == CMD_SET) {
  103d6d:	83 ec 0c             	sub    $0xc,%esp
  103d70:	ff 75 f4             	pushl  -0xc(%ebp)
  103d73:	e8 78 fd ff ff       	call   103af0 <strclone>
  103d78:	83 c4 10             	add    $0x10,%esp
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  103d7b:	c9                   	leave  
  103d7c:	c3                   	ret    

00103d7d <vfs_find_node>:
    }

  103d7d:	55                   	push   %ebp
  103d7e:	89 e5                	mov    %esp,%ebp
  103d80:	83 ec 18             	sub    $0x18,%esp
    if(vgac->command == CMD_CLEAR) {
  103d83:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103d87:	75 08                	jne    103d91 <vfs_find_node+0x14>
  103d89:	8b 45 08             	mov    0x8(%ebp),%eax
  103d8c:	e9 ab 00 00 00       	jmp    103e3c <vfs_find_node+0xbf>
        for(int i = 0; i < (80 * 25); i++) {
  103d91:	8b 45 0c             	mov    0xc(%ebp),%eax
  103d94:	8a 00                	mov    (%eax),%al
  103d96:	84 c0                	test   %al,%al
  103d98:	75 08                	jne    103da2 <vfs_find_node+0x25>
  103d9a:	8b 45 08             	mov    0x8(%ebp),%eax
  103d9d:	e9 9a 00 00 00       	jmp    103e3c <vfs_find_node+0xbf>
            vga_buffer[i] = 0;
        }
  103da2:	83 ec 08             	sub    $0x8,%esp
  103da5:	68 90 78 10 00       	push   $0x107890
  103daa:	ff 75 0c             	pushl  0xc(%ebp)
  103dad:	e8 9c fc ff ff       	call   103a4e <strcmp>
  103db2:	83 c4 10             	add    $0x10,%esp
  103db5:	85 c0                	test   %eax,%eax
  103db7:	75 05                	jne    103dbe <vfs_find_node+0x41>
  103db9:	8b 45 08             	mov    0x8(%ebp),%eax
  103dbc:	eb 7e                	jmp    103e3c <vfs_find_node+0xbf>
    }
  103dbe:	83 ec 08             	sub    $0x8,%esp
  103dc1:	68 92 78 10 00       	push   $0x107892
  103dc6:	ff 75 0c             	pushl  0xc(%ebp)
  103dc9:	e8 80 fc ff ff       	call   103a4e <strcmp>
  103dce:	83 c4 10             	add    $0x10,%esp
  103dd1:	85 c0                	test   %eax,%eax
  103dd3:	75 1a                	jne    103def <vfs_find_node+0x72>

  103dd5:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103dda:	39 45 08             	cmp    %eax,0x8(%ebp)
  103ddd:	75 05                	jne    103de4 <vfs_find_node+0x67>
  103ddf:	8b 45 08             	mov    0x8(%ebp),%eax
  103de2:	eb 58                	jmp    103e3c <vfs_find_node+0xbf>
    if(vgac->command == CMD_SCROLL) {
  103de4:	8b 45 08             	mov    0x8(%ebp),%eax
  103de7:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  103ded:	eb 4d                	jmp    103e3c <vfs_find_node+0xbf>
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
  103def:	8b 45 08             	mov    0x8(%ebp),%eax
  103df2:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103df8:	85 c0                	test   %eax,%eax
  103dfa:	75 3b                	jne    103e37 <vfs_find_node+0xba>
        }
  103dfc:	8b 45 08             	mov    0x8(%ebp),%eax
  103dff:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103e05:	89 45 f4             	mov    %eax,-0xc(%ebp)

        for (; i < 25 * 80; i++) {
  103e08:	eb 27                	jmp    103e31 <vfs_find_node+0xb4>
            vga_buffer[i] = 0;
  103e0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e0d:	83 ec 08             	sub    $0x8,%esp
  103e10:	50                   	push   %eax
  103e11:	ff 75 0c             	pushl  0xc(%ebp)
  103e14:	e8 35 fc ff ff       	call   103a4e <strcmp>
  103e19:	83 c4 10             	add    $0x10,%esp
  103e1c:	85 c0                	test   %eax,%eax
  103e1e:	75 05                	jne    103e25 <vfs_find_node+0xa8>
        }
  103e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e23:	eb 17                	jmp    103e3c <vfs_find_node+0xbf>
    }

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103e25:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e28:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  103e2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  103e31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103e35:	75 d3                	jne    103e0a <vfs_find_node+0x8d>

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
}

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
  103e37:	b8 00 00 00 00       	mov    $0x0,%eax
    if(filemode & FM_READ) return 0;
  103e3c:	c9                   	leave  
  103e3d:	c3                   	ret    

00103e3e <vfs_insert_node>:

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  103e3e:	55                   	push   %ebp
  103e3f:	89 e5                	mov    %esp,%ebp
    if((filemode & FM_WRITE)) vga_writers++;
  103e41:	8b 45 08             	mov    0x8(%ebp),%eax
  103e44:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103e4a:	85 c0                	test   %eax,%eax
  103e4c:	75 0d                	jne    103e5b <vfs_insert_node+0x1d>

  103e4e:	8b 45 08             	mov    0x8(%ebp),%eax
  103e51:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  103e58:	00 00 00 
    struct res_handle* rethandle = malloc(sizeof(struct res_handle));

    rethandle->filemode = filemode;
  103e5b:	8b 45 08             	mov    0x8(%ebp),%eax
  103e5e:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103e64:	85 c0                	test   %eax,%eax
  103e66:	75 33                	jne    103e9b <vfs_insert_node+0x5d>
    rethandle->position = 0;
  103e68:	8b 45 08             	mov    0x8(%ebp),%eax
  103e6b:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103e71:	89 c2                	mov    %eax,%edx
  103e73:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e76:	89 90 08 01 00 00    	mov    %edx,0x108(%eax)
    rethandle->res_type = RES_KERNDRV;
  103e7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e7f:	8b 55 08             	mov    0x8(%ebp),%edx
  103e82:	89 90 0c 01 00 00    	mov    %edx,0x10c(%eax)
    rethandle->res_ptr  = kf;
  103e88:	8b 45 08             	mov    0x8(%ebp),%eax
  103e8b:	8b 55 0c             	mov    0xc(%ebp),%edx
  103e8e:	89 90 04 01 00 00    	mov    %edx,0x104(%eax)

    return rethandle;
  103e94:	b8 00 00 00 00       	mov    $0x0,%eax
  103e99:	eb 05                	jmp    103ea0 <vfs_insert_node+0x62>
}

uint32_t ramfs_vga_close(struct res_handle* handle) {
  103e9b:	b8 01 00 00 00       	mov    $0x1,%eax
    if(handle->filemode & FM_WRITE) vga_writers--;
  103ea0:	5d                   	pop    %ebp
  103ea1:	c3                   	ret    

00103ea2 <vfs_get_relative_node>:

    free(handle);

  103ea2:	55                   	push   %ebp
  103ea3:	89 e5                	mov    %esp,%ebp
  103ea5:	83 ec 18             	sub    $0x18,%esp
    return 0;
}
  103ea8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103eaf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103eb3:	75 17                	jne    103ecc <vfs_get_relative_node+0x2a>
  103eb5:	83 ec 0c             	sub    $0xc,%esp
  103eb8:	6a 05                	push   $0x5
  103eba:	e8 d9 fd ff ff       	call   103c98 <vfs_set_error>
  103ebf:	83 c4 10             	add    $0x10,%esp
  103ec2:	b8 00 00 00 00       	mov    $0x0,%eax
  103ec7:	e9 af 00 00 00       	jmp    103f7b <vfs_get_relative_node+0xd9>
  103ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
  103ecf:	8a 00                	mov    (%eax),%al
  103ed1:	84 c0                	test   %al,%al
  103ed3:	75 17                	jne    103eec <vfs_get_relative_node+0x4a>
  103ed5:	83 ec 0c             	sub    $0xc,%esp
  103ed8:	6a 05                	push   $0x5
  103eda:	e8 b9 fd ff ff       	call   103c98 <vfs_set_error>
  103edf:	83 c4 10             	add    $0x10,%esp
  103ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  103ee7:	e9 8f 00 00 00       	jmp    103f7b <vfs_get_relative_node+0xd9>
  103eec:	83 ec 08             	sub    $0x8,%esp
  103eef:	68 95 78 10 00       	push   $0x107895
  103ef4:	ff 75 0c             	pushl  0xc(%ebp)
  103ef7:	e8 2b fc ff ff       	call   103b27 <strtok>
  103efc:	83 c4 10             	add    $0x10,%esp
  103eff:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103f02:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103f06:	75 05                	jne    103f0d <vfs_get_relative_node+0x6b>
  103f08:	8b 45 08             	mov    0x8(%ebp),%eax
  103f0b:	eb 6e                	jmp    103f7b <vfs_get_relative_node+0xd9>
  103f0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103f10:	8a 00                	mov    (%eax),%al
  103f12:	84 c0                	test   %al,%al
  103f14:	75 15                	jne    103f2b <vfs_get_relative_node+0x89>
  103f16:	83 ec 08             	sub    $0x8,%esp
  103f19:	68 95 78 10 00       	push   $0x107895
  103f1e:	6a 00                	push   $0x0
  103f20:	e8 02 fc ff ff       	call   103b27 <strtok>
  103f25:	83 c4 10             	add    $0x10,%esp
  103f28:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103f2b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103f2f:	75 41                	jne    103f72 <vfs_get_relative_node+0xd0>
  103f31:	8b 45 08             	mov    0x8(%ebp),%eax
  103f34:	eb 45                	jmp    103f7b <vfs_get_relative_node+0xd9>
  103f36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103f3a:	75 07                	jne    103f43 <vfs_get_relative_node+0xa1>
  103f3c:	b8 00 00 00 00       	mov    $0x0,%eax
  103f41:	eb 38                	jmp    103f7b <vfs_get_relative_node+0xd9>
  103f43:	83 ec 08             	sub    $0x8,%esp
  103f46:	ff 75 f0             	pushl  -0x10(%ebp)
  103f49:	ff 75 08             	pushl  0x8(%ebp)
  103f4c:	e8 2c fe ff ff       	call   103d7d <vfs_find_node>
  103f51:	83 c4 10             	add    $0x10,%esp
  103f54:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103f57:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f5a:	89 45 08             	mov    %eax,0x8(%ebp)
  103f5d:	83 ec 08             	sub    $0x8,%esp
  103f60:	68 95 78 10 00       	push   $0x107895
  103f65:	6a 00                	push   $0x0
  103f67:	e8 bb fb ff ff       	call   103b27 <strtok>
  103f6c:	83 c4 10             	add    $0x10,%esp
  103f6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103f72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103f76:	75 be                	jne    103f36 <vfs_get_relative_node+0x94>
  103f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f7b:	c9                   	leave  
  103f7c:	c3                   	ret    

00103f7d <vfs_get_current_task_root_node_for_path>:
  103f7d:	55                   	push   %ebp
  103f7e:	89 e5                	mov    %esp,%ebp
  103f80:	83 ec 08             	sub    $0x8,%esp
  103f83:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103f87:	74 09                	je     103f92 <vfs_get_current_task_root_node_for_path+0x15>
  103f89:	8b 45 08             	mov    0x8(%ebp),%eax
  103f8c:	8a 00                	mov    (%eax),%al
  103f8e:	84 c0                	test   %al,%al
  103f90:	75 14                	jne    103fa6 <vfs_get_current_task_root_node_for_path+0x29>
  103f92:	83 ec 0c             	sub    $0xc,%esp
  103f95:	6a 05                	push   $0x5
  103f97:	e8 fc fc ff ff       	call   103c98 <vfs_set_error>
  103f9c:	83 c4 10             	add    $0x10,%esp
  103f9f:	b8 00 00 00 00       	mov    $0x0,%eax
  103fa4:	eb 4d                	jmp    103ff3 <vfs_get_current_task_root_node_for_path+0x76>
  103fa6:	8b 45 08             	mov    0x8(%ebp),%eax
  103fa9:	8a 00                	mov    (%eax),%al
  103fab:	3c 2f                	cmp    $0x2f,%al
  103fad:	75 07                	jne    103fb6 <vfs_get_current_task_root_node_for_path+0x39>
  103faf:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fb4:	eb 3d                	jmp    103ff3 <vfs_get_current_task_root_node_for_path+0x76>
  103fb6:	e8 72 eb ff ff       	call   102b2d <get_current_task>
  103fbb:	85 c0                	test   %eax,%eax
  103fbd:	75 07                	jne    103fc6 <vfs_get_current_task_root_node_for_path+0x49>
  103fbf:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fc4:	eb 2d                	jmp    103ff3 <vfs_get_current_task_root_node_for_path+0x76>
  103fc6:	e8 62 eb ff ff       	call   102b2d <get_current_task>
  103fcb:	8b 40 28             	mov    0x28(%eax),%eax
  103fce:	85 c0                	test   %eax,%eax
  103fd0:	75 07                	jne    103fd9 <vfs_get_current_task_root_node_for_path+0x5c>
  103fd2:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fd7:	eb 1a                	jmp    103ff3 <vfs_get_current_task_root_node_for_path+0x76>
  103fd9:	e8 4f eb ff ff       	call   102b2d <get_current_task>
  103fde:	8b 50 28             	mov    0x28(%eax),%edx
  103fe1:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fe6:	83 ec 08             	sub    $0x8,%esp
  103fe9:	52                   	push   %edx
  103fea:	50                   	push   %eax
  103feb:	e8 b2 fe ff ff       	call   103ea2 <vfs_get_relative_node>
  103ff0:	83 c4 10             	add    $0x10,%esp
  103ff3:	c9                   	leave  
  103ff4:	c3                   	ret    

00103ff5 <vfs_get_node>:
  103ff5:	55                   	push   %ebp
  103ff6:	89 e5                	mov    %esp,%ebp
  103ff8:	83 ec 08             	sub    $0x8,%esp
  103ffb:	83 ec 0c             	sub    $0xc,%esp
  103ffe:	ff 75 08             	pushl  0x8(%ebp)
  104001:	e8 77 ff ff ff       	call   103f7d <vfs_get_current_task_root_node_for_path>
  104006:	83 c4 10             	add    $0x10,%esp
  104009:	83 ec 08             	sub    $0x8,%esp
  10400c:	ff 75 08             	pushl  0x8(%ebp)
  10400f:	50                   	push   %eax
  104010:	e8 8d fe ff ff       	call   103ea2 <vfs_get_relative_node>
  104015:	83 c4 10             	add    $0x10,%esp
  104018:	c9                   	leave  
  104019:	c3                   	ret    

0010401a <vfs_create_path>:
  10401a:	55                   	push   %ebp
  10401b:	89 e5                	mov    %esp,%ebp
  10401d:	83 ec 18             	sub    $0x18,%esp
  104020:	83 ec 0c             	sub    $0xc,%esp
  104023:	ff 75 08             	pushl  0x8(%ebp)
  104026:	e8 52 ff ff ff       	call   103f7d <vfs_get_current_task_root_node_for_path>
  10402b:	83 c4 10             	add    $0x10,%esp
  10402e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104031:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104038:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10403f:	83 ec 08             	sub    $0x8,%esp
  104042:	68 95 78 10 00       	push   $0x107895
  104047:	ff 75 08             	pushl  0x8(%ebp)
  10404a:	e8 d8 fa ff ff       	call   103b27 <strtok>
  10404f:	83 c4 10             	add    $0x10,%esp
  104052:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104055:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104058:	8a 00                	mov    (%eax),%al
  10405a:	84 c0                	test   %al,%al
  10405c:	0f 85 c4 00 00 00    	jne    104126 <vfs_create_path+0x10c>
  104062:	83 ec 08             	sub    $0x8,%esp
  104065:	68 95 78 10 00       	push   $0x107895
  10406a:	6a 00                	push   $0x0
  10406c:	e8 b6 fa ff ff       	call   103b27 <strtok>
  104071:	83 c4 10             	add    $0x10,%esp
  104074:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104077:	e9 aa 00 00 00       	jmp    104126 <vfs_create_path+0x10c>
  10407c:	83 ec 08             	sub    $0x8,%esp
  10407f:	ff 75 e8             	pushl  -0x18(%ebp)
  104082:	ff 75 ec             	pushl  -0x14(%ebp)
  104085:	e8 f3 fc ff ff       	call   103d7d <vfs_find_node>
  10408a:	83 c4 10             	add    $0x10,%esp
  10408d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104090:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104094:	75 75                	jne    10410b <vfs_create_path+0xf1>
  104096:	83 ec 0c             	sub    $0xc,%esp
  104099:	68 10 01 00 00       	push   $0x110
  10409e:	e8 03 f6 ff ff       	call   1036a6 <malloc>
  1040a3:	83 c4 10             	add    $0x10,%esp
  1040a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1040a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040ac:	83 ec 08             	sub    $0x8,%esp
  1040af:	ff 75 e8             	pushl  -0x18(%ebp)
  1040b2:	50                   	push   %eax
  1040b3:	e8 15 fa ff ff       	call   103acd <strcpy>
  1040b8:	83 c4 10             	add    $0x10,%esp
  1040bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040be:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  1040c5:	00 00 00 
  1040c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040cb:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  1040d2:	00 00 00 
  1040d5:	ff 45 f4             	incl   -0xc(%ebp)
  1040d8:	83 ec 08             	sub    $0x8,%esp
  1040db:	ff 75 f0             	pushl  -0x10(%ebp)
  1040de:	ff 75 ec             	pushl  -0x14(%ebp)
  1040e1:	e8 58 fd ff ff       	call   103e3e <vfs_insert_node>
  1040e6:	83 c4 10             	add    $0x10,%esp
  1040e9:	85 c0                	test   %eax,%eax
  1040eb:	74 1e                	je     10410b <vfs_create_path+0xf1>
  1040ed:	83 ec 0c             	sub    $0xc,%esp
  1040f0:	6a 38                	push   $0x38
  1040f2:	e8 af f5 ff ff       	call   1036a6 <malloc>
  1040f7:	83 c4 10             	add    $0x10,%esp
  1040fa:	83 ec 08             	sub    $0x8,%esp
  1040fd:	68 98 78 10 00       	push   $0x107898
  104102:	50                   	push   %eax
  104103:	e8 ce c0 ff ff       	call   1001d6 <show_cod>
  104108:	83 c4 10             	add    $0x10,%esp
  10410b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10410e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104111:	83 ec 08             	sub    $0x8,%esp
  104114:	68 95 78 10 00       	push   $0x107895
  104119:	6a 00                	push   $0x0
  10411b:	e8 07 fa ff ff       	call   103b27 <strtok>
  104120:	83 c4 10             	add    $0x10,%esp
  104123:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104126:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  10412a:	0f 85 4c ff ff ff    	jne    10407c <vfs_create_path+0x62>
  104130:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104133:	c9                   	leave  
  104134:	c3                   	ret    

00104135 <vfs_get_child_of_exec_path>:
  104135:	55                   	push   %ebp
  104136:	89 e5                	mov    %esp,%ebp
  104138:	83 ec 18             	sub    $0x18,%esp
  10413b:	e8 ed e9 ff ff       	call   102b2d <get_current_task>
  104140:	8b 40 28             	mov    0x28(%eax),%eax
  104143:	83 ec 0c             	sub    $0xc,%esp
  104146:	50                   	push   %eax
  104147:	e8 a9 fe ff ff       	call   103ff5 <vfs_get_node>
  10414c:	83 c4 10             	add    $0x10,%esp
  10414f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104152:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104156:	74 59                	je     1041b1 <vfs_get_child_of_exec_path+0x7c>
  104158:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10415b:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104161:	85 c0                	test   %eax,%eax
  104163:	74 07                	je     10416c <vfs_get_child_of_exec_path+0x37>
  104165:	b8 00 00 00 00       	mov    $0x0,%eax
  10416a:	eb 4a                	jmp    1041b6 <vfs_get_child_of_exec_path+0x81>
  10416c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10416f:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104175:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104178:	eb 19                	jmp    104193 <vfs_get_child_of_exec_path+0x5e>
  10417a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10417d:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  104183:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104186:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10418a:	75 07                	jne    104193 <vfs_get_child_of_exec_path+0x5e>
  10418c:	b8 00 00 00 00       	mov    $0x0,%eax
  104191:	eb 23                	jmp    1041b6 <vfs_get_child_of_exec_path+0x81>
  104193:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104197:	0f 95 c0             	setne  %al
  10419a:	ff 4d 08             	decl   0x8(%ebp)
  10419d:	84 c0                	test   %al,%al
  10419f:	75 d9                	jne    10417a <vfs_get_child_of_exec_path+0x45>
  1041a1:	83 ec 0c             	sub    $0xc,%esp
  1041a4:	ff 75 f4             	pushl  -0xc(%ebp)
  1041a7:	e8 31 fb ff ff       	call   103cdd <vfs_construct_absolute_path_for_node>
  1041ac:	83 c4 10             	add    $0x10,%esp
  1041af:	eb 05                	jmp    1041b6 <vfs_get_child_of_exec_path+0x81>
  1041b1:	b8 00 00 00 00       	mov    $0x0,%eax
  1041b6:	c9                   	leave  
  1041b7:	c3                   	ret    

001041b8 <vfs_create_dir>:
  1041b8:	55                   	push   %ebp
  1041b9:	89 e5                	mov    %esp,%ebp
  1041bb:	83 ec 08             	sub    $0x8,%esp
  1041be:	83 ec 0c             	sub    $0xc,%esp
  1041c1:	ff 75 08             	pushl  0x8(%ebp)
  1041c4:	e8 51 fe ff ff       	call   10401a <vfs_create_path>
  1041c9:	83 c4 10             	add    $0x10,%esp
  1041cc:	c9                   	leave  
  1041cd:	c3                   	ret    

001041ce <vfs_create_kfile>:
  1041ce:	55                   	push   %ebp
  1041cf:	89 e5                	mov    %esp,%ebp
  1041d1:	53                   	push   %ebx
  1041d2:	83 ec 14             	sub    $0x14,%esp
  1041d5:	83 ec 0c             	sub    $0xc,%esp
  1041d8:	ff 75 08             	pushl  0x8(%ebp)
  1041db:	e8 bd f8 ff ff       	call   103a9d <strlen>
  1041e0:	83 c4 10             	add    $0x10,%esp
  1041e3:	40                   	inc    %eax
  1041e4:	83 ec 0c             	sub    $0xc,%esp
  1041e7:	50                   	push   %eax
  1041e8:	e8 b9 f4 ff ff       	call   1036a6 <malloc>
  1041ed:	83 c4 10             	add    $0x10,%esp
  1041f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1041f3:	83 ec 08             	sub    $0x8,%esp
  1041f6:	ff 75 08             	pushl  0x8(%ebp)
  1041f9:	ff 75 f0             	pushl  -0x10(%ebp)
  1041fc:	e8 cc f8 ff ff       	call   103acd <strcpy>
  104201:	83 c4 10             	add    $0x10,%esp
  104204:	83 ec 0c             	sub    $0xc,%esp
  104207:	ff 75 f0             	pushl  -0x10(%ebp)
  10420a:	e8 0b fe ff ff       	call   10401a <vfs_create_path>
  10420f:	83 c4 10             	add    $0x10,%esp
  104212:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104215:	83 ec 0c             	sub    $0xc,%esp
  104218:	ff 75 08             	pushl  0x8(%ebp)
  10421b:	e8 d5 fd ff ff       	call   103ff5 <vfs_get_node>
  104220:	83 c4 10             	add    $0x10,%esp
  104223:	a3 60 85 12 00       	mov    %eax,0x128560
  104228:	a1 60 85 12 00       	mov    0x128560,%eax
  10422d:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  104234:	00 00 00 
  104237:	8b 1d 60 85 12 00    	mov    0x128560,%ebx
  10423d:	8b 45 0c             	mov    0xc(%ebp),%eax
  104240:	8b 40 14             	mov    0x14(%eax),%eax
  104243:	83 ec 0c             	sub    $0xc,%esp
  104246:	ff 75 10             	pushl  0x10(%ebp)
  104249:	ff d0                	call   *%eax
  10424b:	83 c4 10             	add    $0x10,%esp
  10424e:	89 83 04 01 00 00    	mov    %eax,0x104(%ebx)
  104254:	a1 60 85 12 00       	mov    0x128560,%eax
  104259:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10425f:	8b 55 0c             	mov    0xc(%ebp),%edx
  104262:	89 50 04             	mov    %edx,0x4(%eax)
  104265:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104268:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10426b:	c9                   	leave  
  10426c:	c3                   	ret    

0010426d <vfs_open>:
  10426d:	55                   	push   %ebp
  10426e:	89 e5                	mov    %esp,%ebp
  104270:	83 ec 18             	sub    $0x18,%esp
  104273:	83 ec 0c             	sub    $0xc,%esp
  104276:	ff 75 08             	pushl  0x8(%ebp)
  104279:	e8 77 fd ff ff       	call   103ff5 <vfs_get_node>
  10427e:	83 c4 10             	add    $0x10,%esp
  104281:	a3 5c 85 12 00       	mov    %eax,0x12855c
  104286:	a1 5c 85 12 00       	mov    0x12855c,%eax
  10428b:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104291:	83 f8 01             	cmp    $0x1,%eax
  104294:	75 2d                	jne    1042c3 <vfs_open+0x56>
  104296:	a1 5c 85 12 00       	mov    0x12855c,%eax
  10429b:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1042a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1042a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1042a7:	8b 40 04             	mov    0x4(%eax),%eax
  1042aa:	8b 40 08             	mov    0x8(%eax),%eax
  1042ad:	83 ec 08             	sub    $0x8,%esp
  1042b0:	ff 75 0c             	pushl  0xc(%ebp)
  1042b3:	ff 75 f0             	pushl  -0x10(%ebp)
  1042b6:	ff d0                	call   *%eax
  1042b8:	83 c4 10             	add    $0x10,%esp
  1042bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1042be:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1042c1:	eb 05                	jmp    1042c8 <vfs_open+0x5b>
  1042c3:	b8 00 00 00 00       	mov    $0x0,%eax
  1042c8:	c9                   	leave  
  1042c9:	c3                   	ret    

001042ca <vfs_close>:
  1042ca:	55                   	push   %ebp
  1042cb:	89 e5                	mov    %esp,%ebp
  1042cd:	83 ec 18             	sub    $0x18,%esp
  1042d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1042d3:	8b 00                	mov    (%eax),%eax
  1042d5:	83 f8 01             	cmp    $0x1,%eax
  1042d8:	75 1f                	jne    1042f9 <vfs_close+0x2f>
  1042da:	8b 45 08             	mov    0x8(%ebp),%eax
  1042dd:	8b 40 04             	mov    0x4(%eax),%eax
  1042e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1042e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1042e6:	8b 40 04             	mov    0x4(%eax),%eax
  1042e9:	8b 40 0c             	mov    0xc(%eax),%eax
  1042ec:	83 ec 0c             	sub    $0xc,%esp
  1042ef:	ff 75 08             	pushl  0x8(%ebp)
  1042f2:	ff d0                	call   *%eax
  1042f4:	83 c4 10             	add    $0x10,%esp
  1042f7:	eb 05                	jmp    1042fe <vfs_close+0x34>
  1042f9:	b8 00 00 00 00       	mov    $0x0,%eax
  1042fe:	c9                   	leave  
  1042ff:	c3                   	ret    

00104300 <vfs_read>:
  104300:	55                   	push   %ebp
  104301:	89 e5                	mov    %esp,%ebp
  104303:	83 ec 18             	sub    $0x18,%esp
  104306:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10430a:	75 07                	jne    104313 <vfs_read+0x13>
  10430c:	b8 02 00 00 00       	mov    $0x2,%eax
  104311:	eb 74                	jmp    104387 <vfs_read+0x87>
  104313:	8b 45 08             	mov    0x8(%ebp),%eax
  104316:	8b 40 0c             	mov    0xc(%eax),%eax
  104319:	83 e0 01             	and    $0x1,%eax
  10431c:	85 c0                	test   %eax,%eax
  10431e:	75 07                	jne    104327 <vfs_read+0x27>
  104320:	b8 04 00 00 00       	mov    $0x4,%eax
  104325:	eb 60                	jmp    104387 <vfs_read+0x87>
  104327:	8b 45 08             	mov    0x8(%ebp),%eax
  10432a:	8b 00                	mov    (%eax),%eax
  10432c:	83 f8 01             	cmp    $0x1,%eax
  10432f:	75 51                	jne    104382 <vfs_read+0x82>
  104331:	8b 45 08             	mov    0x8(%ebp),%eax
  104334:	8b 40 04             	mov    0x4(%eax),%eax
  104337:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10433a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10433d:	8b 40 04             	mov    0x4(%eax),%eax
  104340:	8b 10                	mov    (%eax),%edx
  104342:	8b 45 10             	mov    0x10(%ebp),%eax
  104345:	0f af 45 14          	imul   0x14(%ebp),%eax
  104349:	83 ec 04             	sub    $0x4,%esp
  10434c:	50                   	push   %eax
  10434d:	ff 75 0c             	pushl  0xc(%ebp)
  104350:	ff 75 08             	pushl  0x8(%ebp)
  104353:	ff d2                	call   *%edx
  104355:	83 c4 10             	add    $0x10,%esp
  104358:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10435b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10435f:	75 1c                	jne    10437d <vfs_read+0x7d>
  104361:	8b 45 08             	mov    0x8(%ebp),%eax
  104364:	8b 50 08             	mov    0x8(%eax),%edx
  104367:	8b 45 10             	mov    0x10(%ebp),%eax
  10436a:	0f af 45 14          	imul   0x14(%ebp),%eax
  10436e:	01 c2                	add    %eax,%edx
  104370:	8b 45 08             	mov    0x8(%ebp),%eax
  104373:	89 50 08             	mov    %edx,0x8(%eax)
  104376:	b8 00 00 00 00       	mov    $0x0,%eax
  10437b:	eb 0a                	jmp    104387 <vfs_read+0x87>
  10437d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104380:	eb 05                	jmp    104387 <vfs_read+0x87>
  104382:	b8 02 00 00 00       	mov    $0x2,%eax
  104387:	c9                   	leave  
  104388:	c3                   	ret    

00104389 <vfs_write>:
  104389:	55                   	push   %ebp
  10438a:	89 e5                	mov    %esp,%ebp
  10438c:	83 ec 18             	sub    $0x18,%esp
  10438f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104393:	75 07                	jne    10439c <vfs_write+0x13>
  104395:	b8 02 00 00 00       	mov    $0x2,%eax
  10439a:	eb 75                	jmp    104411 <vfs_write+0x88>
  10439c:	8b 45 08             	mov    0x8(%ebp),%eax
  10439f:	8b 40 0c             	mov    0xc(%eax),%eax
  1043a2:	83 e0 02             	and    $0x2,%eax
  1043a5:	85 c0                	test   %eax,%eax
  1043a7:	75 07                	jne    1043b0 <vfs_write+0x27>
  1043a9:	b8 05 00 00 00       	mov    $0x5,%eax
  1043ae:	eb 61                	jmp    104411 <vfs_write+0x88>
  1043b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1043b3:	8b 00                	mov    (%eax),%eax
  1043b5:	83 f8 01             	cmp    $0x1,%eax
  1043b8:	75 52                	jne    10440c <vfs_write+0x83>
  1043ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1043bd:	8b 40 04             	mov    0x4(%eax),%eax
  1043c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1043c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043c6:	8b 40 04             	mov    0x4(%eax),%eax
  1043c9:	8b 50 04             	mov    0x4(%eax),%edx
  1043cc:	8b 45 10             	mov    0x10(%ebp),%eax
  1043cf:	0f af 45 14          	imul   0x14(%ebp),%eax
  1043d3:	83 ec 04             	sub    $0x4,%esp
  1043d6:	50                   	push   %eax
  1043d7:	ff 75 0c             	pushl  0xc(%ebp)
  1043da:	ff 75 08             	pushl  0x8(%ebp)
  1043dd:	ff d2                	call   *%edx
  1043df:	83 c4 10             	add    $0x10,%esp
  1043e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1043e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1043e9:	75 1c                	jne    104407 <vfs_write+0x7e>
  1043eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1043ee:	8b 50 08             	mov    0x8(%eax),%edx
  1043f1:	8b 45 10             	mov    0x10(%ebp),%eax
  1043f4:	0f af 45 14          	imul   0x14(%ebp),%eax
  1043f8:	01 c2                	add    %eax,%edx
  1043fa:	8b 45 08             	mov    0x8(%ebp),%eax
  1043fd:	89 50 08             	mov    %edx,0x8(%eax)
  104400:	b8 00 00 00 00       	mov    $0x0,%eax
  104405:	eb 0a                	jmp    104411 <vfs_write+0x88>
  104407:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10440a:	eb 05                	jmp    104411 <vfs_write+0x88>
  10440c:	b8 02 00 00 00       	mov    $0x2,%eax
  104411:	c9                   	leave  
  104412:	c3                   	ret    

00104413 <vfs_available>:
  104413:	55                   	push   %ebp
  104414:	89 e5                	mov    %esp,%ebp
  104416:	83 ec 18             	sub    $0x18,%esp
  104419:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10441d:	75 07                	jne    104426 <vfs_available+0x13>
  10441f:	b8 00 00 00 00       	mov    $0x0,%eax
  104424:	eb 2e                	jmp    104454 <vfs_available+0x41>
  104426:	8b 45 08             	mov    0x8(%ebp),%eax
  104429:	8b 00                	mov    (%eax),%eax
  10442b:	83 f8 01             	cmp    $0x1,%eax
  10442e:	75 1f                	jne    10444f <vfs_available+0x3c>
  104430:	8b 45 08             	mov    0x8(%ebp),%eax
  104433:	8b 40 04             	mov    0x4(%eax),%eax
  104436:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104439:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10443c:	8b 40 04             	mov    0x4(%eax),%eax
  10443f:	8b 40 10             	mov    0x10(%eax),%eax
  104442:	83 ec 0c             	sub    $0xc,%esp
  104445:	ff 75 08             	pushl  0x8(%ebp)
  104448:	ff d0                	call   *%eax
  10444a:	83 c4 10             	add    $0x10,%esp
  10444d:	eb 05                	jmp    104454 <vfs_available+0x41>
  10444f:	b8 00 00 00 00       	mov    $0x0,%eax
  104454:	c9                   	leave  
  104455:	c3                   	ret    

00104456 <vfs_exists>:
  104456:	55                   	push   %ebp
  104457:	89 e5                	mov    %esp,%ebp
  104459:	83 ec 08             	sub    $0x8,%esp
  10445c:	83 ec 0c             	sub    $0xc,%esp
  10445f:	ff 75 08             	pushl  0x8(%ebp)
  104462:	e8 8e fb ff ff       	call   103ff5 <vfs_get_node>
  104467:	83 c4 10             	add    $0x10,%esp
  10446a:	85 c0                	test   %eax,%eax
  10446c:	74 07                	je     104475 <vfs_exists+0x1f>
  10446e:	b8 01 00 00 00       	mov    $0x1,%eax
  104473:	eb 05                	jmp    10447a <vfs_exists+0x24>
  104475:	b8 00 00 00 00       	mov    $0x0,%eax
  10447a:	c9                   	leave  
  10447b:	c3                   	ret    

0010447c <vfs_seek>:
  10447c:	55                   	push   %ebp
  10447d:	89 e5                	mov    %esp,%ebp
  10447f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  104483:	75 09                	jne    10448e <vfs_seek+0x12>
  104485:	8b 45 08             	mov    0x8(%ebp),%eax
  104488:	8b 55 0c             	mov    0xc(%ebp),%edx
  10448b:	89 50 08             	mov    %edx,0x8(%eax)
  10448e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  104492:	75 11                	jne    1044a5 <vfs_seek+0x29>
  104494:	8b 45 08             	mov    0x8(%ebp),%eax
  104497:	8b 40 08             	mov    0x8(%eax),%eax
  10449a:	89 c2                	mov    %eax,%edx
  10449c:	03 55 0c             	add    0xc(%ebp),%edx
  10449f:	8b 45 08             	mov    0x8(%ebp),%eax
  1044a2:	89 50 08             	mov    %edx,0x8(%eax)
  1044a5:	5d                   	pop    %ebp
  1044a6:	c3                   	ret    

001044a7 <vfs_exec>:
  1044a7:	55                   	push   %ebp
  1044a8:	89 e5                	mov    %esp,%ebp
  1044aa:	53                   	push   %ebx
  1044ab:	83 ec 64             	sub    $0x64,%esp
  1044ae:	83 ec 0c             	sub    $0xc,%esp
  1044b1:	ff 75 08             	pushl  0x8(%ebp)
  1044b4:	e8 37 f6 ff ff       	call   103af0 <strclone>
  1044b9:	83 c4 10             	add    $0x10,%esp
  1044bc:	89 45 08             	mov    %eax,0x8(%ebp)
  1044bf:	83 ec 0c             	sub    $0xc,%esp
  1044c2:	ff 75 08             	pushl  0x8(%ebp)
  1044c5:	e8 8c ff ff ff       	call   104456 <vfs_exists>
  1044ca:	83 c4 10             	add    $0x10,%esp
  1044cd:	85 c0                	test   %eax,%eax
  1044cf:	75 25                	jne    1044f6 <vfs_exec+0x4f>
  1044d1:	83 ec 0c             	sub    $0xc,%esp
  1044d4:	ff 75 08             	pushl  0x8(%ebp)
  1044d7:	e8 10 f4 ff ff       	call   1038ec <free>
  1044dc:	83 c4 10             	add    $0x10,%esp
  1044df:	83 ec 0c             	sub    $0xc,%esp
  1044e2:	6a 01                	push   $0x1
  1044e4:	e8 af f7 ff ff       	call   103c98 <vfs_set_error>
  1044e9:	83 c4 10             	add    $0x10,%esp
  1044ec:	b8 00 00 00 00       	mov    $0x0,%eax
  1044f1:	e9 ba 04 00 00       	jmp    1049b0 <vfs_exec+0x509>
  1044f6:	e8 8b 08 00 00       	call   104d86 <vmm_create_pagedir>
  1044fb:	89 45 a0             	mov    %eax,-0x60(%ebp)
  1044fe:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  104505:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104509:	74 14                	je     10451f <vfs_exec+0x78>
  10450b:	eb 03                	jmp    104510 <vfs_exec+0x69>
  10450d:	ff 45 a4             	incl   -0x5c(%ebp)
  104510:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104513:	c1 e0 02             	shl    $0x2,%eax
  104516:	03 45 0c             	add    0xc(%ebp),%eax
  104519:	8b 00                	mov    (%eax),%eax
  10451b:	85 c0                	test   %eax,%eax
  10451d:	75 ee                	jne    10450d <vfs_exec+0x66>
  10451f:	ff 45 a4             	incl   -0x5c(%ebp)
  104522:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104525:	40                   	inc    %eax
  104526:	c1 e0 02             	shl    $0x2,%eax
  104529:	83 ec 0c             	sub    $0xc,%esp
  10452c:	50                   	push   %eax
  10452d:	e8 74 f1 ff ff       	call   1036a6 <malloc>
  104532:	83 c4 10             	add    $0x10,%esp
  104535:	89 45 a8             	mov    %eax,-0x58(%ebp)
  104538:	83 ec 0c             	sub    $0xc,%esp
  10453b:	ff 75 08             	pushl  0x8(%ebp)
  10453e:	e8 ad f5 ff ff       	call   103af0 <strclone>
  104543:	83 c4 10             	add    $0x10,%esp
  104546:	8b 55 a8             	mov    -0x58(%ebp),%edx
  104549:	89 02                	mov    %eax,(%edx)
  10454b:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
  104552:	eb 59                	jmp    1045ad <vfs_exec+0x106>
  104554:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104557:	c1 e0 02             	shl    $0x2,%eax
  10455a:	89 c3                	mov    %eax,%ebx
  10455c:	03 5d a8             	add    -0x58(%ebp),%ebx
  10455f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104562:	48                   	dec    %eax
  104563:	c1 e0 02             	shl    $0x2,%eax
  104566:	03 45 0c             	add    0xc(%ebp),%eax
  104569:	8b 00                	mov    (%eax),%eax
  10456b:	83 ec 0c             	sub    $0xc,%esp
  10456e:	50                   	push   %eax
  10456f:	e8 29 f5 ff ff       	call   103a9d <strlen>
  104574:	83 c4 10             	add    $0x10,%esp
  104577:	40                   	inc    %eax
  104578:	83 ec 0c             	sub    $0xc,%esp
  10457b:	50                   	push   %eax
  10457c:	e8 25 f1 ff ff       	call   1036a6 <malloc>
  104581:	83 c4 10             	add    $0x10,%esp
  104584:	89 03                	mov    %eax,(%ebx)
  104586:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104589:	48                   	dec    %eax
  10458a:	c1 e0 02             	shl    $0x2,%eax
  10458d:	03 45 0c             	add    0xc(%ebp),%eax
  104590:	8b 10                	mov    (%eax),%edx
  104592:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104595:	c1 e0 02             	shl    $0x2,%eax
  104598:	03 45 a8             	add    -0x58(%ebp),%eax
  10459b:	8b 00                	mov    (%eax),%eax
  10459d:	83 ec 08             	sub    $0x8,%esp
  1045a0:	52                   	push   %edx
  1045a1:	50                   	push   %eax
  1045a2:	e8 26 f5 ff ff       	call   103acd <strcpy>
  1045a7:	83 c4 10             	add    $0x10,%esp
  1045aa:	ff 45 d4             	incl   -0x2c(%ebp)
  1045ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1045b0:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
  1045b3:	72 9f                	jb     104554 <vfs_exec+0xad>
  1045b5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1045b8:	c1 e0 02             	shl    $0x2,%eax
  1045bb:	03 45 a8             	add    -0x58(%ebp),%eax
  1045be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  1045c4:	83 ec 08             	sub    $0x8,%esp
  1045c7:	6a 05                	push   $0x5
  1045c9:	ff 75 08             	pushl  0x8(%ebp)
  1045cc:	e8 9c fc ff ff       	call   10426d <vfs_open>
  1045d1:	83 c4 10             	add    $0x10,%esp
  1045d4:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1045d7:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
  1045db:	75 25                	jne    104602 <vfs_exec+0x15b>
  1045dd:	83 ec 0c             	sub    $0xc,%esp
  1045e0:	6a 02                	push   $0x2
  1045e2:	e8 b1 f6 ff ff       	call   103c98 <vfs_set_error>
  1045e7:	83 c4 10             	add    $0x10,%esp
  1045ea:	83 ec 0c             	sub    $0xc,%esp
  1045ed:	ff 75 08             	pushl  0x8(%ebp)
  1045f0:	e8 f7 f2 ff ff       	call   1038ec <free>
  1045f5:	83 c4 10             	add    $0x10,%esp
  1045f8:	b8 00 00 00 00       	mov    $0x0,%eax
  1045fd:	e9 ae 03 00 00       	jmp    1049b0 <vfs_exec+0x509>
  104602:	83 ec 0c             	sub    $0xc,%esp
  104605:	ff 75 ac             	pushl  -0x54(%ebp)
  104608:	e8 06 fe ff ff       	call   104413 <vfs_available>
  10460d:	83 c4 10             	add    $0x10,%esp
  104610:	89 45 b0             	mov    %eax,-0x50(%ebp)
  104613:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  104617:	75 25                	jne    10463e <vfs_exec+0x197>
  104619:	83 ec 0c             	sub    $0xc,%esp
  10461c:	6a 03                	push   $0x3
  10461e:	e8 75 f6 ff ff       	call   103c98 <vfs_set_error>
  104623:	83 c4 10             	add    $0x10,%esp
  104626:	83 ec 0c             	sub    $0xc,%esp
  104629:	ff 75 08             	pushl  0x8(%ebp)
  10462c:	e8 bb f2 ff ff       	call   1038ec <free>
  104631:	83 c4 10             	add    $0x10,%esp
  104634:	b8 00 00 00 00       	mov    $0x0,%eax
  104639:	e9 72 03 00 00       	jmp    1049b0 <vfs_exec+0x509>
  10463e:	83 ec 0c             	sub    $0xc,%esp
  104641:	ff 75 b0             	pushl  -0x50(%ebp)
  104644:	e8 5d f0 ff ff       	call   1036a6 <malloc>
  104649:	83 c4 10             	add    $0x10,%esp
  10464c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  10464f:	6a 01                	push   $0x1
  104651:	ff 75 b0             	pushl  -0x50(%ebp)
  104654:	ff 75 b4             	pushl  -0x4c(%ebp)
  104657:	ff 75 ac             	pushl  -0x54(%ebp)
  10465a:	e8 a1 fc ff ff       	call   104300 <vfs_read>
  10465f:	83 c4 10             	add    $0x10,%esp
  104662:	89 45 b8             	mov    %eax,-0x48(%ebp)
  104665:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  104669:	74 33                	je     10469e <vfs_exec+0x1f7>
  10466b:	83 ec 0c             	sub    $0xc,%esp
  10466e:	ff 75 08             	pushl  0x8(%ebp)
  104671:	e8 76 f2 ff ff       	call   1038ec <free>
  104676:	83 c4 10             	add    $0x10,%esp
  104679:	83 ec 0c             	sub    $0xc,%esp
  10467c:	ff 75 b4             	pushl  -0x4c(%ebp)
  10467f:	e8 68 f2 ff ff       	call   1038ec <free>
  104684:	83 c4 10             	add    $0x10,%esp
  104687:	83 ec 0c             	sub    $0xc,%esp
  10468a:	6a 04                	push   $0x4
  10468c:	e8 07 f6 ff ff       	call   103c98 <vfs_set_error>
  104691:	83 c4 10             	add    $0x10,%esp
  104694:	b8 00 00 00 00       	mov    $0x0,%eax
  104699:	e9 12 03 00 00       	jmp    1049b0 <vfs_exec+0x509>
  10469e:	e8 d9 06 00 00       	call   104d7c <vmm_get_current_pagedir>
  1046a3:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1046a6:	83 ec 0c             	sub    $0xc,%esp
  1046a9:	ff 75 a0             	pushl  -0x60(%ebp)
  1046ac:	e8 c3 0c 00 00       	call   105374 <vmm_activate_pagedir>
  1046b1:	83 c4 10             	add    $0x10,%esp
  1046b4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  1046b7:	89 45 c0             	mov    %eax,-0x40(%ebp)
  1046ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1046bd:	8b 00                	mov    (%eax),%eax
  1046bf:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  1046c4:	74 33                	je     1046f9 <vfs_exec+0x252>
  1046c6:	83 ec 0c             	sub    $0xc,%esp
  1046c9:	ff 75 b4             	pushl  -0x4c(%ebp)
  1046cc:	e8 1b f2 ff ff       	call   1038ec <free>
  1046d1:	83 c4 10             	add    $0x10,%esp
  1046d4:	83 ec 0c             	sub    $0xc,%esp
  1046d7:	ff 75 08             	pushl  0x8(%ebp)
  1046da:	e8 0d f2 ff ff       	call   1038ec <free>
  1046df:	83 c4 10             	add    $0x10,%esp
  1046e2:	83 ec 0c             	sub    $0xc,%esp
  1046e5:	6a 03                	push   $0x3
  1046e7:	e8 ac f5 ff ff       	call   103c98 <vfs_set_error>
  1046ec:	83 c4 10             	add    $0x10,%esp
  1046ef:	b8 00 00 00 00       	mov    $0x0,%eax
  1046f4:	e9 b7 02 00 00       	jmp    1049b0 <vfs_exec+0x509>
  1046f9:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1046fc:	8b 40 18             	mov    0x18(%eax),%eax
  1046ff:	89 45 c8             	mov    %eax,-0x38(%ebp)
  104702:	8b 55 c0             	mov    -0x40(%ebp),%edx
  104705:	8b 45 c0             	mov    -0x40(%ebp),%eax
  104708:	8b 40 1c             	mov    0x1c(%eax),%eax
  10470b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10470e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  104711:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104718:	e9 88 00 00 00       	jmp    1047a5 <vfs_exec+0x2fe>
  10471d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104720:	8b 40 08             	mov    0x8(%eax),%eax
  104723:	89 45 dc             	mov    %eax,-0x24(%ebp)
  104726:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104729:	8b 40 04             	mov    0x4(%eax),%eax
  10472c:	03 45 c0             	add    -0x40(%ebp),%eax
  10472f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104732:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104735:	8b 00                	mov    (%eax),%eax
  104737:	83 f8 01             	cmp    $0x1,%eax
  10473a:	75 61                	jne    10479d <vfs_exec+0x2f6>
  10473c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104743:	eb 33                	jmp    104778 <vfs_exec+0x2d1>
  104745:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104748:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10474b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10474e:	83 ec 0c             	sub    $0xc,%esp
  104751:	50                   	push   %eax
  104752:	e8 62 09 00 00       	call   1050b9 <vmm_free>
  104757:	83 c4 10             	add    $0x10,%esp
  10475a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10475d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104760:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104763:	83 ec 08             	sub    $0x8,%esp
  104766:	6a 00                	push   $0x0
  104768:	50                   	push   %eax
  104769:	e8 61 0b 00 00       	call   1052cf <vmm_alloc_addr>
  10476e:	83 c4 10             	add    $0x10,%esp
  104771:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  104778:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10477b:	8b 40 14             	mov    0x14(%eax),%eax
  10477e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  104781:	77 c2                	ja     104745 <vfs_exec+0x29e>
  104783:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104786:	8b 40 10             	mov    0x10(%eax),%eax
  104789:	83 ec 04             	sub    $0x4,%esp
  10478c:	50                   	push   %eax
  10478d:	ff 75 e0             	pushl  -0x20(%ebp)
  104790:	ff 75 dc             	pushl  -0x24(%ebp)
  104793:	e8 d6 f1 ff ff       	call   10396e <memcpy>
  104798:	83 c4 10             	add    $0x10,%esp
  10479b:	eb 01                	jmp    10479e <vfs_exec+0x2f7>
  10479d:	90                   	nop    
  10479e:	ff 45 d8             	incl   -0x28(%ebp)
  1047a1:	83 45 c4 20          	addl   $0x20,-0x3c(%ebp)
  1047a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1047a8:	66 8b 40 2c          	mov    0x2c(%eax),%ax
  1047ac:	25 ff ff 00 00       	and    $0xffff,%eax
  1047b1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  1047b4:	0f 87 63 ff ff ff    	ja     10471d <vfs_exec+0x276>
  1047ba:	83 ec 0c             	sub    $0xc,%esp
  1047bd:	6a 01                	push   $0x1
  1047bf:	e8 8f 0a 00 00       	call   105253 <vmm_alloc_ucont>
  1047c4:	83 c4 10             	add    $0x10,%esp
  1047c7:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1047ca:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1047d1:	eb 57                	jmp    10482a <vfs_exec+0x383>
  1047d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1047d6:	c1 e0 02             	shl    $0x2,%eax
  1047d9:	89 c3                	mov    %eax,%ebx
  1047db:	03 5d cc             	add    -0x34(%ebp),%ebx
  1047de:	83 ec 0c             	sub    $0xc,%esp
  1047e1:	6a 01                	push   $0x1
  1047e3:	e8 6b 0a 00 00       	call   105253 <vmm_alloc_ucont>
  1047e8:	83 c4 10             	add    $0x10,%esp
  1047eb:	89 03                	mov    %eax,(%ebx)
  1047ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1047f0:	c1 e0 02             	shl    $0x2,%eax
  1047f3:	03 45 a8             	add    -0x58(%ebp),%eax
  1047f6:	8b 10                	mov    (%eax),%edx
  1047f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1047fb:	c1 e0 02             	shl    $0x2,%eax
  1047fe:	03 45 cc             	add    -0x34(%ebp),%eax
  104801:	8b 00                	mov    (%eax),%eax
  104803:	83 ec 08             	sub    $0x8,%esp
  104806:	52                   	push   %edx
  104807:	50                   	push   %eax
  104808:	e8 c0 f2 ff ff       	call   103acd <strcpy>
  10480d:	83 c4 10             	add    $0x10,%esp
  104810:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104813:	c1 e0 02             	shl    $0x2,%eax
  104816:	03 45 a8             	add    -0x58(%ebp),%eax
  104819:	8b 00                	mov    (%eax),%eax
  10481b:	83 ec 0c             	sub    $0xc,%esp
  10481e:	50                   	push   %eax
  10481f:	e8 c8 f0 ff ff       	call   1038ec <free>
  104824:	83 c4 10             	add    $0x10,%esp
  104827:	ff 45 e8             	incl   -0x18(%ebp)
  10482a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10482d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
  104830:	72 a1                	jb     1047d3 <vfs_exec+0x32c>
  104832:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104835:	c1 e0 02             	shl    $0x2,%eax
  104838:	03 45 cc             	add    -0x34(%ebp),%eax
  10483b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  104841:	83 ec 0c             	sub    $0xc,%esp
  104844:	ff 75 a8             	pushl  -0x58(%ebp)
  104847:	e8 a0 f0 ff ff       	call   1038ec <free>
  10484c:	83 c4 10             	add    $0x10,%esp
  10484f:	83 ec 08             	sub    $0x8,%esp
  104852:	ff 75 c8             	pushl  -0x38(%ebp)
  104855:	ff 75 a0             	pushl  -0x60(%ebp)
  104858:	e8 12 e6 ff ff       	call   102e6f <init_task>
  10485d:	83 c4 10             	add    $0x10,%esp
  104860:	89 45 d0             	mov    %eax,-0x30(%ebp)
  104863:	e8 c5 e2 ff ff       	call   102b2d <get_current_task>
  104868:	85 c0                	test   %eax,%eax
  10486a:	74 38                	je     1048a4 <vfs_exec+0x3fd>
  10486c:	e8 bc e2 ff ff       	call   102b2d <get_current_task>
  104871:	8b 50 38             	mov    0x38(%eax),%edx
  104874:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104877:	89 50 38             	mov    %edx,0x38(%eax)
  10487a:	e8 ae e2 ff ff       	call   102b2d <get_current_task>
  10487f:	8b 50 30             	mov    0x30(%eax),%edx
  104882:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104885:	89 50 30             	mov    %edx,0x30(%eax)
  104888:	e8 a0 e2 ff ff       	call   102b2d <get_current_task>
  10488d:	8b 50 34             	mov    0x34(%eax),%edx
  104890:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104893:	89 50 34             	mov    %edx,0x34(%eax)
  104896:	e8 92 e2 ff ff       	call   102b2d <get_current_task>
  10489b:	8b 50 28             	mov    0x28(%eax),%edx
  10489e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048a1:	89 50 28             	mov    %edx,0x28(%eax)
  1048a4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1048a8:	74 09                	je     1048b3 <vfs_exec+0x40c>
  1048aa:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048ad:	8b 55 10             	mov    0x10(%ebp),%edx
  1048b0:	89 50 28             	mov    %edx,0x28(%eax)
  1048b3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1048b7:	74 34                	je     1048ed <vfs_exec+0x446>
  1048b9:	83 ec 0c             	sub    $0xc,%esp
  1048bc:	ff 75 14             	pushl  0x14(%ebp)
  1048bf:	e8 92 fb ff ff       	call   104456 <vfs_exists>
  1048c4:	83 c4 10             	add    $0x10,%esp
  1048c7:	85 c0                	test   %eax,%eax
  1048c9:	74 22                	je     1048ed <vfs_exec+0x446>
  1048cb:	83 ec 08             	sub    $0x8,%esp
  1048ce:	6a 01                	push   $0x1
  1048d0:	ff 75 14             	pushl  0x14(%ebp)
  1048d3:	e8 95 f9 ff ff       	call   10426d <vfs_open>
  1048d8:	83 c4 10             	add    $0x10,%esp
  1048db:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1048de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1048e2:	74 09                	je     1048ed <vfs_exec+0x446>
  1048e4:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1048ea:	89 50 38             	mov    %edx,0x38(%eax)
  1048ed:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1048f1:	74 34                	je     104927 <vfs_exec+0x480>
  1048f3:	83 ec 0c             	sub    $0xc,%esp
  1048f6:	ff 75 18             	pushl  0x18(%ebp)
  1048f9:	e8 58 fb ff ff       	call   104456 <vfs_exists>
  1048fe:	83 c4 10             	add    $0x10,%esp
  104901:	85 c0                	test   %eax,%eax
  104903:	74 22                	je     104927 <vfs_exec+0x480>
  104905:	83 ec 08             	sub    $0x8,%esp
  104908:	6a 01                	push   $0x1
  10490a:	ff 75 18             	pushl  0x18(%ebp)
  10490d:	e8 5b f9 ff ff       	call   10426d <vfs_open>
  104912:	83 c4 10             	add    $0x10,%esp
  104915:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104918:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10491c:	74 09                	je     104927 <vfs_exec+0x480>
  10491e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104921:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104924:	89 50 30             	mov    %edx,0x30(%eax)
  104927:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  10492b:	74 34                	je     104961 <vfs_exec+0x4ba>
  10492d:	83 ec 0c             	sub    $0xc,%esp
  104930:	ff 75 1c             	pushl  0x1c(%ebp)
  104933:	e8 1e fb ff ff       	call   104456 <vfs_exists>
  104938:	83 c4 10             	add    $0x10,%esp
  10493b:	85 c0                	test   %eax,%eax
  10493d:	74 22                	je     104961 <vfs_exec+0x4ba>
  10493f:	83 ec 08             	sub    $0x8,%esp
  104942:	6a 01                	push   $0x1
  104944:	ff 75 1c             	pushl  0x1c(%ebp)
  104947:	e8 21 f9 ff ff       	call   10426d <vfs_open>
  10494c:	83 c4 10             	add    $0x10,%esp
  10494f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104952:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104956:	74 09                	je     104961 <vfs_exec+0x4ba>
  104958:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10495b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10495e:	89 50 34             	mov    %edx,0x34(%eax)
  104961:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104964:	8b 55 cc             	mov    -0x34(%ebp),%edx
  104967:	89 50 20             	mov    %edx,0x20(%eax)
  10496a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10496d:	8b 55 08             	mov    0x8(%ebp),%edx
  104970:	89 50 24             	mov    %edx,0x24(%eax)
  104973:	83 ec 0c             	sub    $0xc,%esp
  104976:	ff 75 bc             	pushl  -0x44(%ebp)
  104979:	e8 f6 09 00 00       	call   105374 <vmm_activate_pagedir>
  10497e:	83 c4 10             	add    $0x10,%esp
  104981:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  104985:	74 16                	je     10499d <vfs_exec+0x4f6>
  104987:	e8 a1 e1 ff ff       	call   102b2d <get_current_task>
  10498c:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10498f:	89 50 44             	mov    %edx,0x44(%eax)
  104992:	e8 96 e1 ff ff       	call   102b2d <get_current_task>
  104997:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10499a:	89 42 40             	mov    %eax,0x40(%edx)
  10499d:	83 ec 0c             	sub    $0xc,%esp
  1049a0:	ff 75 b4             	pushl  -0x4c(%ebp)
  1049a3:	e8 44 ef ff ff       	call   1038ec <free>
  1049a8:	83 c4 10             	add    $0x10,%esp
  1049ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1049ae:	8b 00                	mov    (%eax),%eax
  1049b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1049b3:	c9                   	leave  
  1049b4:	c3                   	ret    

001049b5 <vfs_resolve_path>:
  1049b5:	55                   	push   %ebp
  1049b6:	89 e5                	mov    %esp,%ebp
  1049b8:	83 ec 18             	sub    $0x18,%esp
  1049bb:	83 ec 0c             	sub    $0xc,%esp
  1049be:	ff 75 08             	pushl  0x8(%ebp)
  1049c1:	e8 2f f6 ff ff       	call   103ff5 <vfs_get_node>
  1049c6:	83 c4 10             	add    $0x10,%esp
  1049c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1049cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1049d0:	75 07                	jne    1049d9 <vfs_resolve_path+0x24>
  1049d2:	b8 00 00 00 00       	mov    $0x0,%eax
  1049d7:	eb 0e                	jmp    1049e7 <vfs_resolve_path+0x32>
  1049d9:	83 ec 0c             	sub    $0xc,%esp
  1049dc:	ff 75 f4             	pushl  -0xc(%ebp)
  1049df:	e8 f9 f2 ff ff       	call   103cdd <vfs_construct_absolute_path_for_node>
  1049e4:	83 c4 10             	add    $0x10,%esp
  1049e7:	c9                   	leave  
  1049e8:	c3                   	ret    

001049e9 <vfs_init_root>:
  1049e9:	55                   	push   %ebp
  1049ea:	89 e5                	mov    %esp,%ebp
  1049ec:	83 ec 08             	sub    $0x8,%esp
  1049ef:	a1 4c 85 12 00       	mov    0x12854c,%eax
  1049f4:	85 c0                	test   %eax,%eax
  1049f6:	75 69                	jne    104a61 <vfs_init_root+0x78>
  1049f8:	83 ec 0c             	sub    $0xc,%esp
  1049fb:	68 10 01 00 00       	push   $0x110
  104a00:	e8 a1 ec ff ff       	call   1036a6 <malloc>
  104a05:	83 c4 10             	add    $0x10,%esp
  104a08:	a3 4c 85 12 00       	mov    %eax,0x12854c
  104a0d:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a12:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  104a19:	00 00 00 
  104a1c:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a21:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  104a28:	00 00 00 
  104a2b:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a30:	83 ec 04             	sub    $0x4,%esp
  104a33:	6a 02                	push   $0x2
  104a35:	68 ca 78 10 00       	push   $0x1078ca
  104a3a:	50                   	push   %eax
  104a3b:	e8 2e ef ff ff       	call   10396e <memcpy>
  104a40:	83 c4 10             	add    $0x10,%esp
  104a43:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a48:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  104a4f:	00 00 00 
  104a52:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a57:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  104a5e:	00 00 00 
  104a61:	c9                   	leave  
  104a62:	c3                   	ret    

00104a63 <vfs_debug_ls>:
  104a63:	55                   	push   %ebp
  104a64:	89 e5                	mov    %esp,%ebp
  104a66:	83 ec 18             	sub    $0x18,%esp
  104a69:	83 ec 0c             	sub    $0xc,%esp
  104a6c:	ff 75 08             	pushl  0x8(%ebp)
  104a6f:	e8 81 f5 ff ff       	call   103ff5 <vfs_get_node>
  104a74:	83 c4 10             	add    $0x10,%esp
  104a77:	a3 58 85 12 00       	mov    %eax,0x128558
  104a7c:	a1 58 85 12 00       	mov    0x128558,%eax
  104a81:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104a87:	a3 58 85 12 00       	mov    %eax,0x128558
  104a8c:	eb 6a                	jmp    104af8 <vfs_debug_ls+0x95>
  104a8e:	c7 45 f4 cc 78 10 00 	movl   $0x1078cc,-0xc(%ebp)
  104a95:	a1 58 85 12 00       	mov    0x128558,%eax
  104a9a:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104aa0:	85 c0                	test   %eax,%eax
  104aa2:	75 07                	jne    104aab <vfs_debug_ls+0x48>
  104aa4:	c7 45 f4 d0 78 10 00 	movl   $0x1078d0,-0xc(%ebp)
  104aab:	a1 58 85 12 00       	mov    0x128558,%eax
  104ab0:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104ab6:	83 f8 01             	cmp    $0x1,%eax
  104ab9:	75 14                	jne    104acf <vfs_debug_ls+0x6c>
  104abb:	a1 58 85 12 00       	mov    0x128558,%eax
  104ac0:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104ac6:	8b 40 04             	mov    0x4(%eax),%eax
  104ac9:	8b 40 18             	mov    0x18(%eax),%eax
  104acc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104acf:	a1 58 85 12 00       	mov    0x128558,%eax
  104ad4:	ff 75 f4             	pushl  -0xc(%ebp)
  104ad7:	50                   	push   %eax
  104ad8:	ff 75 08             	pushl  0x8(%ebp)
  104adb:	68 d4 78 10 00       	push   $0x1078d4
  104ae0:	e8 88 ba ff ff       	call   10056d <kprintf>
  104ae5:	83 c4 10             	add    $0x10,%esp
  104ae8:	a1 58 85 12 00       	mov    0x128558,%eax
  104aed:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  104af3:	a3 58 85 12 00       	mov    %eax,0x128558
  104af8:	a1 58 85 12 00       	mov    0x128558,%eax
  104afd:	85 c0                	test   %eax,%eax
  104aff:	75 8d                	jne    104a8e <vfs_debug_ls+0x2b>
  104b01:	c9                   	leave  
  104b02:	c3                   	ret    
	...

00104b04 <vmm_create_vpdraw>:
    .rwrite    = ramfs_vga_write,
    .open      = ramfs_vga_open,
    .create    = ramfs_vga_create,
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
  104b04:	55                   	push   %ebp
  104b05:	89 e5                	mov    %esp,%ebp
  104b07:	53                   	push   %ebx
  104b08:	83 ec 34             	sub    $0x34,%esp
};
  104b0b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  104b12:	83 ec 0c             	sub    $0xc,%esp
  104b15:	8d 45 dc             	lea    -0x24(%ebp),%eax
  104b18:	50                   	push   %eax
  104b19:	e8 92 07 00 00       	call   1052b0 <vmm_alloc>
  104b1e:	83 c4 10             	add    $0x10,%esp
  104b21:	89 45 e0             	mov    %eax,-0x20(%ebp)
struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
  104b24:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
}
  104b2b:	83 ec 0c             	sub    $0xc,%esp
  104b2e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  104b31:	50                   	push   %eax
  104b32:	e8 79 07 00 00       	call   1052b0 <vmm_alloc>
  104b37:	83 c4 10             	add    $0x10,%esp
  104b3a:	89 c2                	mov    %eax,%edx
  104b3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104b3f:	89 10                	mov    %edx,(%eax)

  104b41:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104b45:	74 08                	je     104b4f <vmm_create_vpdraw+0x4b>
uint32_t ramfs_vga_writers() {
  104b47:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104b4a:	8b 45 08             	mov    0x8(%ebp),%eax
  104b4d:	89 10                	mov    %edx,(%eax)
    return vga_writers;
}
  104b4f:	83 ec 0c             	sub    $0xc,%esp
  104b52:	6a 00                	push   $0x0
  104b54:	e8 57 07 00 00       	call   1052b0 <vmm_alloc>
  104b59:	83 c4 10             	add    $0x10,%esp
  104b5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

uint32_t ramfs_vga_available(struct res_handle* handle) {
    return sizeof(struct vga_command);
  104b5f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104b66:	e9 f9 00 00 00       	jmp    104c64 <vmm_create_vpdraw+0x160>
}
  104b6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b6e:	c1 e0 02             	shl    $0x2,%eax
  104b71:	89 c3                	mov    %eax,%ebx
  104b73:	03 5d e4             	add    -0x1c(%ebp),%ebx
  104b76:	83 ec 0c             	sub    $0xc,%esp
  104b79:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  104b7c:	50                   	push   %eax
  104b7d:	e8 2e 07 00 00       	call   1052b0 <vmm_alloc>
  104b82:	83 c4 10             	add    $0x10,%esp
  104b85:	89 03                	mov    %eax,(%ebx)

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  104b87:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
  104b8b:	77 48                	ja     104bd5 <vmm_create_vpdraw+0xd1>
    return malloc(sizeof(struct res_kfile));
  104b8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b90:	c1 e0 02             	shl    $0x2,%eax
  104b93:	03 45 e4             	add    -0x1c(%ebp),%eax
  104b96:	8b 00                	mov    (%eax),%eax
  104b98:	83 ec 0c             	sub    $0xc,%esp
  104b9b:	50                   	push   %eax
  104b9c:	e8 18 05 00 00       	call   1050b9 <vmm_free>
  104ba1:	83 c4 10             	add    $0x10,%esp
}
  104ba4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104ba7:	8b 14 85 e0 87 1c 00 	mov    0x1c87e0(,%eax,4),%edx
  104bae:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bb1:	c1 e0 02             	shl    $0x2,%eax
  104bb4:	03 45 e4             	add    -0x1c(%ebp),%eax
  104bb7:	8b 00                	mov    (%eax),%eax
  104bb9:	83 ec 04             	sub    $0x4,%esp
  104bbc:	6a 00                	push   $0x0
  104bbe:	52                   	push   %edx
  104bbf:	50                   	push   %eax
  104bc0:	e8 9f 04 00 00       	call   105064 <map_address_active>
  104bc5:	83 c4 10             	add    $0x10,%esp

  104bc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bcb:	8b 04 85 e0 87 1c 00 	mov    0x1c87e0(,%eax,4),%eax
  104bd2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
}
  104bd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104bd8:	8b 00                	mov    (%eax),%eax
  104bda:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104bdd:	c1 e2 02             	shl    $0x2,%edx
  104be0:	01 d0                	add    %edx,%eax
  104be2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  104be5:	83 ca 07             	or     $0x7,%edx
  104be8:	89 10                	mov    %edx,(%eax)

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  104bea:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
  104bee:	76 71                	jbe    104c61 <vmm_create_vpdraw+0x15d>
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  104bf0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  104bf7:	eb 5f                	jmp    104c58 <vmm_create_vpdraw+0x154>

  104bf9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bfc:	89 c2                	mov    %eax,%edx
  104bfe:	c1 e2 16             	shl    $0x16,%edx
  104c01:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c04:	c1 e0 0c             	shl    $0xc,%eax
  104c07:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104c0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct vga_command* vgac = src;

  104c0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c10:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  104c17:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c1a:	c1 e0 02             	shl    $0x2,%eax
  104c1d:	03 45 e4             	add    -0x1c(%ebp),%eax
  104c20:	8b 00                	mov    (%eax),%eax
  104c22:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104c25:	89 c1                	mov    %eax,%ecx
  104c27:	81 7d f4 00 10 40 01 	cmpl   $0x1401000,-0xc(%ebp)
  104c2e:	76 07                	jbe    104c37 <vmm_create_vpdraw+0x133>
  104c30:	ba 00 02 00 00       	mov    $0x200,%edx
  104c35:	eb 05                	jmp    104c3c <vmm_create_vpdraw+0x138>
  104c37:	ba 00 00 00 00       	mov    $0x0,%edx
  104c3c:	81 7d f4 00 10 40 01 	cmpl   $0x1401000,-0xc(%ebp)
  104c43:	76 07                	jbe    104c4c <vmm_create_vpdraw+0x148>
  104c45:	b8 04 00 00 00       	mov    $0x4,%eax
  104c4a:	eb 05                	jmp    104c51 <vmm_create_vpdraw+0x14d>
  104c4c:	b8 00 00 00 00       	mov    $0x0,%eax
  104c51:	09 d0                	or     %edx,%eax
  104c53:	89 01                	mov    %eax,(%ecx)
uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
}

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  104c55:	ff 45 ec             	incl   -0x14(%ebp)
  104c58:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
  104c5f:	76 98                	jbe    104bf9 <vmm_create_vpdraw+0xf5>
uint32_t ramfs_vga_writers() {
    return vga_writers;
}

uint32_t ramfs_vga_available(struct res_handle* handle) {
    return sizeof(struct vga_command);
  104c61:	ff 45 e8             	incl   -0x18(%ebp)
  104c64:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  104c6b:	0f 86 fa fe ff ff    	jbe    104b6b <vmm_create_vpdraw+0x67>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
            vga_buffer[i] = 0;
  104c71:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104c78:	eb 3d                	jmp    104cb7 <vmm_create_vpdraw+0x1b3>
        }
  104c7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104c7d:	8b 00                	mov    (%eax),%eax
  104c7f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104c82:	c1 e2 02             	shl    $0x2,%edx
  104c85:	01 d0                	add    %edx,%eax
  104c87:	8b 00                	mov    (%eax),%eax
  104c89:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104c8e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }
  104c91:	8b 45 d4             	mov    -0x2c(%ebp),%eax

  104c94:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104c97:	89 d1                	mov    %edx,%ecx
  104c99:	c1 e1 0c             	shl    $0xc,%ecx

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
            vga_buffer[i] = 0;
        }
    }
  104c9c:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  104ca2:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  104ca5:	6a 00                	push   $0x0
  104ca7:	50                   	push   %eax
  104ca8:	52                   	push   %edx
  104ca9:	ff 75 e4             	pushl  -0x1c(%ebp)
  104cac:	e8 2f 03 00 00       	call   104fe0 <map_address_context>
  104cb1:	83 c4 10             	add    $0x10,%esp
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
            vga_buffer[i] = 0;
  104cb4:	ff 45 e8             	incl   -0x18(%ebp)
  104cb7:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  104cbe:	76 ba                	jbe    104c7a <vmm_create_vpdraw+0x176>
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  104cc0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104cc3:	a1 00 61 10 00       	mov    0x106100,%eax
  104cc8:	6a 00                	push   $0x0
  104cca:	52                   	push   %edx
  104ccb:	50                   	push   %eax
  104ccc:	ff 75 e4             	pushl  -0x1c(%ebp)
  104ccf:	e8 0c 03 00 00       	call   104fe0 <map_address_context>
  104cd4:	83 c4 10             	add    $0x10,%esp
            vga_buffer[i] = vga_buffer[i + 80];
        }

  104cd7:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
  104cde:	eb 1a                	jmp    104cfa <vmm_create_vpdraw+0x1f6>
        for (; i < 25 * 80; i++) {
  104ce0:	6a 00                	push   $0x0
  104ce2:	ff 75 e8             	pushl  -0x18(%ebp)
  104ce5:	ff 75 e8             	pushl  -0x18(%ebp)
  104ce8:	ff 75 e4             	pushl  -0x1c(%ebp)
  104ceb:	e8 f0 02 00 00       	call   104fe0 <map_address_context>
  104cf0:	83 c4 10             	add    $0x10,%esp
    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

  104cf3:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
  104cfa:	b8 00 90 1c 00       	mov    $0x1c9000,%eax
  104cff:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  104d02:	72 dc                	jb     104ce0 <vmm_create_vpdraw+0x1dc>
        for (; i < 25 * 80; i++) {
            vga_buffer[i] = 0;
        }
    }
  104d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104d07:	8b 00                	mov    (%eax),%eax
  104d09:	89 45 f0             	mov    %eax,-0x10(%ebp)

  104d0c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104d0f:	89 c2                	mov    %eax,%edx
  104d11:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104d14:	89 10                	mov    %edx,(%eax)
    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
}
  104d16:	83 ec 0c             	sub    $0xc,%esp
  104d19:	ff 75 f0             	pushl  -0x10(%ebp)
  104d1c:	e8 18 04 00 00       	call   105139 <vmm_unmap>
  104d21:	83 c4 10             	add    $0x10,%esp

  104d24:	83 ec 0c             	sub    $0xc,%esp
  104d27:	ff 75 e0             	pushl  -0x20(%ebp)
  104d2a:	e8 0a 04 00 00       	call   105139 <vmm_unmap>
  104d2f:	83 c4 10             	add    $0x10,%esp
struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
  104d32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    if(filemode & FM_READ) return 0;
  104d35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104d38:	c9                   	leave  
  104d39:	c3                   	ret    

00104d3a <vmm_free_pdptr>:

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  104d3a:	55                   	push   %ebp
  104d3b:	89 e5                	mov    %esp,%ebp
  104d3d:	83 ec 18             	sub    $0x18,%esp
    if((filemode & FM_WRITE)) vga_writers++;
  104d40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104d47:	eb 1a                	jmp    104d63 <vmm_free_pdptr+0x29>

  104d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d4c:	c1 e0 02             	shl    $0x2,%eax
  104d4f:	03 45 08             	add    0x8(%ebp),%eax
  104d52:	8b 00                	mov    (%eax),%eax
  104d54:	83 ec 0c             	sub    $0xc,%esp
  104d57:	50                   	push   %eax
  104d58:	e8 dc 03 00 00       	call   105139 <vmm_unmap>
  104d5d:	83 c4 10             	add    $0x10,%esp
struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
    if(filemode & FM_READ) return 0;

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
    if((filemode & FM_WRITE)) vga_writers++;
  104d60:	ff 45 f4             	incl   -0xc(%ebp)
  104d63:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  104d6a:	76 dd                	jbe    104d49 <vmm_free_pdptr+0xf>

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));

    rethandle->filemode = filemode;
  104d6c:	83 ec 0c             	sub    $0xc,%esp
  104d6f:	ff 75 08             	pushl  0x8(%ebp)
  104d72:	e8 c2 03 00 00       	call   105139 <vmm_unmap>
  104d77:	83 c4 10             	add    $0x10,%esp
    rethandle->position = 0;
  104d7a:	c9                   	leave  
  104d7b:	c3                   	ret    

00104d7c <vmm_get_current_pagedir>:
    rethandle->res_type = RES_KERNDRV;
    rethandle->res_ptr  = kf;
  104d7c:	55                   	push   %ebp
  104d7d:	89 e5                	mov    %esp,%ebp

  104d7f:	a1 64 85 12 00       	mov    0x128564,%eax
    return rethandle;
  104d84:	5d                   	pop    %ebp
  104d85:	c3                   	ret    

00104d86 <vmm_create_pagedir>:
}

  104d86:	55                   	push   %ebp
  104d87:	89 e5                	mov    %esp,%ebp
  104d89:	83 ec 18             	sub    $0x18,%esp
uint32_t ramfs_vga_close(struct res_handle* handle) {
    if(handle->filemode & FM_WRITE) vga_writers--;
  104d8c:	83 ec 0c             	sub    $0xc,%esp
  104d8f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104d92:	50                   	push   %eax
  104d93:	e8 6c fd ff ff       	call   104b04 <vmm_create_vpdraw>
  104d98:	83 c4 10             	add    $0x10,%esp
  104d9b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  104d9e:	83 ec 0c             	sub    $0xc,%esp
  104da1:	ff 75 f4             	pushl  -0xc(%ebp)
  104da4:	e8 91 ff ff ff       	call   104d3a <vmm_free_pdptr>
  104da9:	83 c4 10             	add    $0x10,%esp
    free(handle);

  104dac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    return 0;
  104daf:	c9                   	leave  
  104db0:	c3                   	ret    

00104db1 <vmm_free_current_pagetables>:
}
  104db1:	55                   	push   %ebp
  104db2:	89 e5                	mov    %esp,%ebp
  104db4:	83 ec 18             	sub    $0x18,%esp
  104db7:	83 ec 0c             	sub    $0xc,%esp
  104dba:	6a 00                	push   $0x0
  104dbc:	e8 ef 04 00 00       	call   1052b0 <vmm_alloc>
  104dc1:	83 c4 10             	add    $0x10,%esp
  104dc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104dc7:	83 ec 0c             	sub    $0xc,%esp
  104dca:	6a 00                	push   $0x0
  104dcc:	e8 df 04 00 00       	call   1052b0 <vmm_alloc>
  104dd1:	83 c4 10             	add    $0x10,%esp
  104dd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104dd7:	83 ec 0c             	sub    $0xc,%esp
  104dda:	ff 75 e8             	pushl  -0x18(%ebp)
  104ddd:	e8 d7 02 00 00       	call   1050b9 <vmm_free>
  104de2:	83 c4 10             	add    $0x10,%esp
  104de5:	83 ec 0c             	sub    $0xc,%esp
  104de8:	ff 75 ec             	pushl  -0x14(%ebp)
  104deb:	e8 c9 02 00 00       	call   1050b9 <vmm_free>
  104df0:	83 c4 10             	add    $0x10,%esp
  104df3:	e8 35 dd ff ff       	call   102b2d <get_current_task>
  104df8:	8b 50 14             	mov    0x14(%eax),%edx
  104dfb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104dfe:	83 ec 04             	sub    $0x4,%esp
  104e01:	6a 00                	push   $0x0
  104e03:	52                   	push   %edx
  104e04:	50                   	push   %eax
  104e05:	e8 5a 02 00 00       	call   105064 <map_address_active>
  104e0a:	83 c4 10             	add    $0x10,%esp
  104e0d:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
  104e14:	e9 99 00 00 00       	jmp    104eb2 <vmm_free_current_pagetables+0x101>
  104e19:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e1c:	c1 e0 02             	shl    $0x2,%eax
  104e1f:	03 45 e8             	add    -0x18(%ebp),%eax
  104e22:	8b 00                	mov    (%eax),%eax
  104e24:	89 c2                	mov    %eax,%edx
  104e26:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  104e2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104e2f:	83 ec 04             	sub    $0x4,%esp
  104e32:	6a 00                	push   $0x0
  104e34:	52                   	push   %edx
  104e35:	50                   	push   %eax
  104e36:	e8 29 02 00 00       	call   105064 <map_address_active>
  104e3b:	83 c4 10             	add    $0x10,%esp
  104e3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104e45:	eb 31                	jmp    104e78 <vmm_free_current_pagetables+0xc7>
  104e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e4a:	c1 e0 02             	shl    $0x2,%eax
  104e4d:	03 45 ec             	add    -0x14(%ebp),%eax
  104e50:	8b 00                	mov    (%eax),%eax
  104e52:	83 e0 01             	and    $0x1,%eax
  104e55:	84 c0                	test   %al,%al
  104e57:	74 1c                	je     104e75 <vmm_free_current_pagetables+0xc4>
  104e59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e5c:	c1 e0 02             	shl    $0x2,%eax
  104e5f:	03 45 ec             	add    -0x14(%ebp),%eax
  104e62:	8b 00                	mov    (%eax),%eax
  104e64:	25 00 f0 ff 0f       	and    $0xffff000,%eax
  104e69:	83 ec 0c             	sub    $0xc,%esp
  104e6c:	50                   	push   %eax
  104e6d:	e8 2c cd ff ff       	call   101b9e <pmm_free>
  104e72:	83 c4 10             	add    $0x10,%esp
  104e75:	ff 45 f4             	incl   -0xc(%ebp)
  104e78:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  104e7f:	76 c6                	jbe    104e47 <vmm_free_current_pagetables+0x96>
  104e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e84:	c1 e0 02             	shl    $0x2,%eax
  104e87:	03 45 e8             	add    -0x18(%ebp),%eax
  104e8a:	8b 00                	mov    (%eax),%eax
  104e8c:	83 e0 01             	and    $0x1,%eax
  104e8f:	84 c0                	test   %al,%al
  104e91:	74 1c                	je     104eaf <vmm_free_current_pagetables+0xfe>
  104e93:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e96:	c1 e0 02             	shl    $0x2,%eax
  104e99:	03 45 e8             	add    -0x18(%ebp),%eax
  104e9c:	8b 00                	mov    (%eax),%eax
  104e9e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104ea3:	83 ec 0c             	sub    $0xc,%esp
  104ea6:	50                   	push   %eax
  104ea7:	e8 f2 cc ff ff       	call   101b9e <pmm_free>
  104eac:	83 c4 10             	add    $0x10,%esp
  104eaf:	ff 45 f0             	incl   -0x10(%ebp)
  104eb2:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
  104eb9:	0f 86 5a ff ff ff    	jbe    104e19 <vmm_free_current_pagetables+0x68>
  104ebf:	e8 69 dc ff ff       	call   102b2d <get_current_task>
  104ec4:	8b 40 14             	mov    0x14(%eax),%eax
  104ec7:	83 ec 0c             	sub    $0xc,%esp
  104eca:	50                   	push   %eax
  104ecb:	e8 ce cc ff ff       	call   101b9e <pmm_free>
  104ed0:	83 c4 10             	add    $0x10,%esp
  104ed3:	c9                   	leave  
  104ed4:	c3                   	ret    

00104ed5 <vmm_resolve>:
  104ed5:	55                   	push   %ebp
  104ed6:	89 e5                	mov    %esp,%ebp
  104ed8:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  104edd:	8b 55 08             	mov    0x8(%ebp),%edx
  104ee0:	c1 ea 0c             	shr    $0xc,%edx
  104ee3:	c1 e2 02             	shl    $0x2,%edx
  104ee6:	01 d0                	add    %edx,%eax
  104ee8:	8b 00                	mov    (%eax),%eax
  104eea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104eef:	5d                   	pop    %ebp
  104ef0:	c3                   	ret    

00104ef1 <vmm_resolve_ppd>:
  104ef1:	55                   	push   %ebp
  104ef2:	89 e5                	mov    %esp,%ebp
  104ef4:	83 ec 28             	sub    $0x28,%esp
  104ef7:	8b 45 0c             	mov    0xc(%ebp),%eax
  104efa:	c1 e8 16             	shr    $0x16,%eax
  104efd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104f00:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f03:	c1 e8 0c             	shr    $0xc,%eax
  104f06:	25 ff 03 00 00       	and    $0x3ff,%eax
  104f0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104f0e:	83 ec 0c             	sub    $0xc,%esp
  104f11:	6a 00                	push   $0x0
  104f13:	e8 98 03 00 00       	call   1052b0 <vmm_alloc>
  104f18:	83 c4 10             	add    $0x10,%esp
  104f1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104f1e:	83 ec 0c             	sub    $0xc,%esp
  104f21:	ff 75 ec             	pushl  -0x14(%ebp)
  104f24:	e8 90 01 00 00       	call   1050b9 <vmm_free>
  104f29:	83 c4 10             	add    $0x10,%esp
  104f2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f2f:	83 ec 04             	sub    $0x4,%esp
  104f32:	6a 00                	push   $0x0
  104f34:	ff 75 08             	pushl  0x8(%ebp)
  104f37:	50                   	push   %eax
  104f38:	e8 27 01 00 00       	call   105064 <map_address_active>
  104f3d:	83 c4 10             	add    $0x10,%esp
  104f40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104f43:	c1 e0 02             	shl    $0x2,%eax
  104f46:	03 45 ec             	add    -0x14(%ebp),%eax
  104f49:	8b 00                	mov    (%eax),%eax
  104f4b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104f50:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104f53:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f56:	83 ec 04             	sub    $0x4,%esp
  104f59:	6a 00                	push   $0x0
  104f5b:	ff 75 f0             	pushl  -0x10(%ebp)
  104f5e:	50                   	push   %eax
  104f5f:	e8 00 01 00 00       	call   105064 <map_address_active>
  104f64:	83 c4 10             	add    $0x10,%esp
  104f67:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104f6a:	c1 e0 02             	shl    $0x2,%eax
  104f6d:	03 45 ec             	add    -0x14(%ebp),%eax
  104f70:	8b 00                	mov    (%eax),%eax
  104f72:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104f77:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104f7d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104f82:	c9                   	leave  
  104f83:	c3                   	ret    

00104f84 <vmm_map_range>:
  104f84:	55                   	push   %ebp
  104f85:	89 e5                	mov    %esp,%ebp
  104f87:	83 ec 18             	sub    $0x18,%esp
  104f8a:	8b 45 08             	mov    0x8(%ebp),%eax
  104f8d:	25 ff 0f 00 00       	and    $0xfff,%eax
  104f92:	85 c0                	test   %eax,%eax
  104f94:	75 44                	jne    104fda <vmm_map_range+0x56>
  104f96:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f99:	25 ff 0f 00 00       	and    $0xfff,%eax
  104f9e:	85 c0                	test   %eax,%eax
  104fa0:	75 3b                	jne    104fdd <vmm_map_range+0x59>
  104fa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104fa9:	eb 25                	jmp    104fd0 <vmm_map_range+0x4c>
  104fab:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fae:	89 c2                	mov    %eax,%edx
  104fb0:	03 55 f4             	add    -0xc(%ebp),%edx
  104fb3:	8b 45 08             	mov    0x8(%ebp),%eax
  104fb6:	03 45 f4             	add    -0xc(%ebp),%eax
  104fb9:	83 ec 04             	sub    $0x4,%esp
  104fbc:	ff 75 14             	pushl  0x14(%ebp)
  104fbf:	52                   	push   %edx
  104fc0:	50                   	push   %eax
  104fc1:	e8 9e 00 00 00       	call   105064 <map_address_active>
  104fc6:	83 c4 10             	add    $0x10,%esp
  104fc9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  104fd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104fd3:	3b 45 10             	cmp    0x10(%ebp),%eax
  104fd6:	72 d3                	jb     104fab <vmm_map_range+0x27>
  104fd8:	eb 04                	jmp    104fde <vmm_map_range+0x5a>
  104fda:	90                   	nop    
  104fdb:	eb 01                	jmp    104fde <vmm_map_range+0x5a>
  104fdd:	90                   	nop    
  104fde:	c9                   	leave  
  104fdf:	c3                   	ret    

00104fe0 <map_address_context>:
  104fe0:	55                   	push   %ebp
  104fe1:	89 e5                	mov    %esp,%ebp
  104fe3:	53                   	push   %ebx
  104fe4:	83 ec 10             	sub    $0x10,%esp
  104fe7:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fea:	c1 e8 16             	shr    $0x16,%eax
  104fed:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104ff0:	8b 45 0c             	mov    0xc(%ebp),%eax
  104ff3:	c1 e8 0c             	shr    $0xc,%eax
  104ff6:	25 ff 03 00 00       	and    $0x3ff,%eax
  104ffb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104ffe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105001:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  105008:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10500b:	c1 e0 02             	shl    $0x2,%eax
  10500e:	03 45 08             	add    0x8(%ebp),%eax
  105011:	8b 00                	mov    (%eax),%eax
  105013:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105018:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10501b:	8b 55 10             	mov    0x10(%ebp),%edx
  10501e:	89 d1                	mov    %edx,%ecx
  105020:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  105026:	8b 55 14             	mov    0x14(%ebp),%edx
  105029:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  10502f:	09 d1                	or     %edx,%ecx
  105031:	8b 55 f8             	mov    -0x8(%ebp),%edx
  105034:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
  10503b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10503e:	c1 e2 02             	shl    $0x2,%edx
  105041:	03 55 08             	add    0x8(%ebp),%edx
  105044:	8b 12                	mov    (%edx),%edx
  105046:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  10504c:	8d 14 13             	lea    (%ebx,%edx,1),%edx
  10504f:	8b 12                	mov    (%edx),%edx
  105051:	81 e2 04 02 00 00    	and    $0x204,%edx
  105057:	09 ca                	or     %ecx,%edx
  105059:	83 ca 03             	or     $0x3,%edx
  10505c:	89 10                	mov    %edx,(%eax)
  10505e:	83 c4 10             	add    $0x10,%esp
  105061:	5b                   	pop    %ebx
  105062:	5d                   	pop    %ebp
  105063:	c3                   	ret    

00105064 <map_address_active>:
  105064:	55                   	push   %ebp
  105065:	89 e5                	mov    %esp,%ebp
  105067:	53                   	push   %ebx
  105068:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10506d:	8b 55 08             	mov    0x8(%ebp),%edx
  105070:	c1 ea 0c             	shr    $0xc,%edx
  105073:	c1 e2 02             	shl    $0x2,%edx
  105076:	01 d0                	add    %edx,%eax
  105078:	8b 55 0c             	mov    0xc(%ebp),%edx
  10507b:	89 d1                	mov    %edx,%ecx
  10507d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  105083:	8b 55 10             	mov    0x10(%ebp),%edx
  105086:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  10508c:	89 cb                	mov    %ecx,%ebx
  10508e:	09 d3                	or     %edx,%ebx
  105090:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  105096:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105099:	c1 e9 0c             	shr    $0xc,%ecx
  10509c:	c1 e1 02             	shl    $0x2,%ecx
  10509f:	01 ca                	add    %ecx,%edx
  1050a1:	8b 12                	mov    (%edx),%edx
  1050a3:	81 e2 04 02 00 00    	and    $0x204,%edx
  1050a9:	09 da                	or     %ebx,%edx
  1050ab:	83 ca 03             	or     $0x3,%edx
  1050ae:	89 10                	mov    %edx,(%eax)
  1050b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1050b3:	0f 01 38             	invlpg (%eax)
  1050b6:	5b                   	pop    %ebx
  1050b7:	5d                   	pop    %ebp
  1050b8:	c3                   	ret    

001050b9 <vmm_free>:
  1050b9:	55                   	push   %ebp
  1050ba:	89 e5                	mov    %esp,%ebp
  1050bc:	83 ec 18             	sub    $0x18,%esp
  1050bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1050c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1050c5:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1050ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1050cd:	c1 ea 0c             	shr    $0xc,%edx
  1050d0:	c1 e2 02             	shl    $0x2,%edx
  1050d3:	01 d0                	add    %edx,%eax
  1050d5:	8b 00                	mov    (%eax),%eax
  1050d7:	25 01 02 00 00       	and    $0x201,%eax
  1050dc:	3d 01 02 00 00       	cmp    $0x201,%eax
  1050e1:	75 54                	jne    105137 <vmm_free+0x7e>
  1050e3:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1050e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1050eb:	c1 ea 0c             	shr    $0xc,%edx
  1050ee:	c1 e2 02             	shl    $0x2,%edx
  1050f1:	01 d0                	add    %edx,%eax
  1050f3:	8b 00                	mov    (%eax),%eax
  1050f5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1050fa:	83 ec 0c             	sub    $0xc,%esp
  1050fd:	50                   	push   %eax
  1050fe:	e8 9b ca ff ff       	call   101b9e <pmm_free>
  105103:	83 c4 10             	add    $0x10,%esp
  105106:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10510b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10510e:	c1 ea 0c             	shr    $0xc,%edx
  105111:	c1 e2 02             	shl    $0x2,%edx
  105114:	01 d0                	add    %edx,%eax
  105116:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  10511c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10511f:	c1 e9 0c             	shr    $0xc,%ecx
  105122:	c1 e1 02             	shl    $0x2,%ecx
  105125:	01 ca                	add    %ecx,%edx
  105127:	8b 12                	mov    (%edx),%edx
  105129:	83 e2 04             	and    $0x4,%edx
  10512c:	80 ce 02             	or     $0x2,%dh
  10512f:	89 10                	mov    %edx,(%eax)
  105131:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105134:	0f 01 38             	invlpg (%eax)
  105137:	c9                   	leave  
  105138:	c3                   	ret    

00105139 <vmm_unmap>:
  105139:	55                   	push   %ebp
  10513a:	89 e5                	mov    %esp,%ebp
  10513c:	83 ec 10             	sub    $0x10,%esp
  10513f:	8b 45 08             	mov    0x8(%ebp),%eax
  105142:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105145:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10514a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10514d:	c1 ea 0c             	shr    $0xc,%edx
  105150:	c1 e2 02             	shl    $0x2,%edx
  105153:	01 d0                	add    %edx,%eax
  105155:	8b 00                	mov    (%eax),%eax
  105157:	25 01 02 00 00       	and    $0x201,%eax
  10515c:	3d 01 02 00 00       	cmp    $0x201,%eax
  105161:	75 31                	jne    105194 <vmm_unmap+0x5b>
  105163:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  105168:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10516b:	c1 ea 0c             	shr    $0xc,%edx
  10516e:	c1 e2 02             	shl    $0x2,%edx
  105171:	01 d0                	add    %edx,%eax
  105173:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  105179:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10517c:	c1 e9 0c             	shr    $0xc,%ecx
  10517f:	c1 e1 02             	shl    $0x2,%ecx
  105182:	01 ca                	add    %ecx,%edx
  105184:	8b 12                	mov    (%edx),%edx
  105186:	83 e2 04             	and    $0x4,%edx
  105189:	80 ce 02             	or     $0x2,%dh
  10518c:	89 10                	mov    %edx,(%eax)
  10518e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105191:	0f 01 38             	invlpg (%eax)
  105194:	c9                   	leave  
  105195:	c3                   	ret    

00105196 <vmm_alloc_in_range>:
  105196:	55                   	push   %ebp
  105197:	89 e5                	mov    %esp,%ebp
  105199:	83 ec 18             	sub    $0x18,%esp
  10519c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1051a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1051aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1051b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1051b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1051b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1051bc:	eb 48                	jmp    105206 <vmm_alloc_in_range+0x70>
  1051be:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1051c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1051c6:	c1 ea 0c             	shr    $0xc,%edx
  1051c9:	c1 e2 02             	shl    $0x2,%edx
  1051cc:	01 d0                	add    %edx,%eax
  1051ce:	8b 00                	mov    (%eax),%eax
  1051d0:	25 01 02 00 00       	and    $0x201,%eax
  1051d5:	3d 00 02 00 00       	cmp    $0x200,%eax
  1051da:	75 19                	jne    1051f5 <vmm_alloc_in_range+0x5f>
  1051dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1051e0:	75 06                	jne    1051e8 <vmm_alloc_in_range+0x52>
  1051e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1051e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1051e8:	ff 45 f0             	incl   -0x10(%ebp)
  1051eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1051ee:	3b 45 14             	cmp    0x14(%ebp),%eax
  1051f1:	72 0b                	jb     1051fe <vmm_alloc_in_range+0x68>
  1051f3:	eb 19                	jmp    10520e <vmm_alloc_in_range+0x78>
  1051f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1051fc:	eb 01                	jmp    1051ff <vmm_alloc_in_range+0x69>
  1051fe:	90                   	nop    
  1051ff:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
  105206:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105209:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10520c:	72 b0                	jb     1051be <vmm_alloc_in_range+0x28>
  10520e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  105215:	eb 29                	jmp    105240 <vmm_alloc_in_range+0xaa>
  105217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10521b:	75 05                	jne    105222 <vmm_alloc_in_range+0x8c>
  10521d:	8b 45 10             	mov    0x10(%ebp),%eax
  105220:	eb 05                	jmp    105227 <vmm_alloc_in_range+0x91>
  105222:	b8 00 00 00 00       	mov    $0x0,%eax
  105227:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10522a:	c1 e2 0c             	shl    $0xc,%edx
  10522d:	03 55 e8             	add    -0x18(%ebp),%edx
  105230:	83 ec 08             	sub    $0x8,%esp
  105233:	50                   	push   %eax
  105234:	52                   	push   %edx
  105235:	e8 95 00 00 00       	call   1052cf <vmm_alloc_addr>
  10523a:	83 c4 10             	add    $0x10,%esp
  10523d:	ff 45 f4             	incl   -0xc(%ebp)
  105240:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  105244:	0f 95 c0             	setne  %al
  105247:	ff 4d f0             	decl   -0x10(%ebp)
  10524a:	84 c0                	test   %al,%al
  10524c:	75 c9                	jne    105217 <vmm_alloc_in_range+0x81>
  10524e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105251:	c9                   	leave  
  105252:	c3                   	ret    

00105253 <vmm_alloc_ucont>:
  105253:	55                   	push   %ebp
  105254:	89 e5                	mov    %esp,%ebp
  105256:	83 ec 08             	sub    $0x8,%esp
  105259:	ff 75 08             	pushl  0x8(%ebp)
  10525c:	6a 00                	push   $0x0
  10525e:	68 00 f0 ff ff       	push   $0xfffff000
  105263:	68 00 10 40 01       	push   $0x1401000
  105268:	e8 29 ff ff ff       	call   105196 <vmm_alloc_in_range>
  10526d:	83 c4 10             	add    $0x10,%esp
  105270:	c9                   	leave  
  105271:	c3                   	ret    

00105272 <vmm_alloc_user>:
  105272:	55                   	push   %ebp
  105273:	89 e5                	mov    %esp,%ebp
  105275:	83 ec 08             	sub    $0x8,%esp
  105278:	6a 01                	push   $0x1
  10527a:	ff 75 08             	pushl  0x8(%ebp)
  10527d:	68 00 f0 ff ff       	push   $0xfffff000
  105282:	68 00 10 40 01       	push   $0x1401000
  105287:	e8 0a ff ff ff       	call   105196 <vmm_alloc_in_range>
  10528c:	83 c4 10             	add    $0x10,%esp
  10528f:	c9                   	leave  
  105290:	c3                   	ret    

00105291 <vmm_alloc_cont>:
  105291:	55                   	push   %ebp
  105292:	89 e5                	mov    %esp,%ebp
  105294:	83 ec 08             	sub    $0x8,%esp
  105297:	ff 75 08             	pushl  0x8(%ebp)
  10529a:	6a 00                	push   $0x0
  10529c:	68 00 00 00 20       	push   $0x20000000
  1052a1:	68 00 10 40 01       	push   $0x1401000
  1052a6:	e8 eb fe ff ff       	call   105196 <vmm_alloc_in_range>
  1052ab:	83 c4 10             	add    $0x10,%esp
  1052ae:	c9                   	leave  
  1052af:	c3                   	ret    

001052b0 <vmm_alloc>:
  1052b0:	55                   	push   %ebp
  1052b1:	89 e5                	mov    %esp,%ebp
  1052b3:	83 ec 08             	sub    $0x8,%esp
  1052b6:	6a 01                	push   $0x1
  1052b8:	ff 75 08             	pushl  0x8(%ebp)
  1052bb:	68 00 00 00 20       	push   $0x20000000
  1052c0:	68 00 10 40 01       	push   $0x1401000
  1052c5:	e8 cc fe ff ff       	call   105196 <vmm_alloc_in_range>
  1052ca:	83 c4 10             	add    $0x10,%esp
  1052cd:	c9                   	leave  
  1052ce:	c3                   	ret    

001052cf <vmm_alloc_addr>:
  1052cf:	55                   	push   %ebp
  1052d0:	89 e5                	mov    %esp,%ebp
  1052d2:	83 ec 18             	sub    $0x18,%esp
  1052d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1052d9:	75 1c                	jne    1052f7 <vmm_alloc_addr+0x28>
  1052db:	83 ec 04             	sub    $0x4,%esp
  1052de:	6a 00                	push   $0x0
  1052e0:	ff 75 08             	pushl  0x8(%ebp)
  1052e3:	68 e4 78 10 00       	push   $0x1078e4
  1052e8:	e8 80 b2 ff ff       	call   10056d <kprintf>
  1052ed:	83 c4 10             	add    $0x10,%esp
  1052f0:	b8 00 00 00 00       	mov    $0x0,%eax
  1052f5:	eb 7b                	jmp    105372 <vmm_alloc_addr+0xa3>
  1052f7:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1052fc:	8b 55 08             	mov    0x8(%ebp),%edx
  1052ff:	c1 ea 0c             	shr    $0xc,%edx
  105302:	c1 e2 02             	shl    $0x2,%edx
  105305:	01 d0                	add    %edx,%eax
  105307:	8b 00                	mov    (%eax),%eax
  105309:	25 01 02 00 00       	and    $0x201,%eax
  10530e:	3d 00 02 00 00       	cmp    $0x200,%eax
  105313:	74 2d                	je     105342 <vmm_alloc_addr+0x73>
  105315:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10531a:	8b 55 08             	mov    0x8(%ebp),%edx
  10531d:	c1 ea 0c             	shr    $0xc,%edx
  105320:	c1 e2 02             	shl    $0x2,%edx
  105323:	01 d0                	add    %edx,%eax
  105325:	8b 00                	mov    (%eax),%eax
  105327:	83 ec 04             	sub    $0x4,%esp
  10532a:	50                   	push   %eax
  10532b:	ff 75 08             	pushl  0x8(%ebp)
  10532e:	68 e4 78 10 00       	push   $0x1078e4
  105333:	e8 35 b2 ff ff       	call   10056d <kprintf>
  105338:	83 c4 10             	add    $0x10,%esp
  10533b:	b8 00 00 00 00       	mov    $0x0,%eax
  105340:	eb 30                	jmp    105372 <vmm_alloc_addr+0xa3>
  105342:	e8 e5 c6 ff ff       	call   101a2c <pmm_alloc>
  105347:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10534a:	8b 45 08             	mov    0x8(%ebp),%eax
  10534d:	83 ec 04             	sub    $0x4,%esp
  105350:	68 04 02 00 00       	push   $0x204
  105355:	ff 75 f4             	pushl  -0xc(%ebp)
  105358:	50                   	push   %eax
  105359:	e8 06 fd ff ff       	call   105064 <map_address_active>
  10535e:	83 c4 10             	add    $0x10,%esp
  105361:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  105365:	74 08                	je     10536f <vmm_alloc_addr+0xa0>
  105367:	8b 45 0c             	mov    0xc(%ebp),%eax
  10536a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10536d:	89 10                	mov    %edx,(%eax)
  10536f:	8b 45 08             	mov    0x8(%ebp),%eax
  105372:	c9                   	leave  
  105373:	c3                   	ret    

00105374 <vmm_activate_pagedir>:
  105374:	55                   	push   %ebp
  105375:	89 e5                	mov    %esp,%ebp
  105377:	8b 45 08             	mov    0x8(%ebp),%eax
  10537a:	a3 64 85 12 00       	mov    %eax,0x128564
  10537f:	8b 45 08             	mov    0x8(%ebp),%eax
  105382:	0f 22 d8             	mov    %eax,%cr3
  105385:	5d                   	pop    %ebp
  105386:	c3                   	ret    

00105387 <vmm_init>:
  105387:	55                   	push   %ebp
  105388:	89 e5                	mov    %esp,%ebp
  10538a:	53                   	push   %ebx
  10538b:	83 ec 24             	sub    $0x24,%esp
  10538e:	e8 99 c6 ff ff       	call   101a2c <pmm_alloc>
  105393:	89 45 e0             	mov    %eax,-0x20(%ebp)
  105396:	e8 91 c6 ff ff       	call   101a2c <pmm_alloc>
  10539b:	89 c2                	mov    %eax,%edx
  10539d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053a0:	89 10                	mov    %edx,(%eax)
  1053a2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1053a9:	e9 d3 00 00 00       	jmp    105481 <vmm_init+0xfa>
  1053ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053b1:	8b 00                	mov    (%eax),%eax
  1053b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1053b6:	c1 e2 02             	shl    $0x2,%edx
  1053b9:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  1053bc:	e8 6b c6 ff ff       	call   101a2c <pmm_alloc>
  1053c1:	89 03                	mov    %eax,(%ebx)
  1053c3:	83 7d e4 7f          	cmpl   $0x7f,-0x1c(%ebp)
  1053c7:	77 19                	ja     1053e2 <vmm_init+0x5b>
  1053c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1053cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1053cf:	8b 12                	mov    (%edx),%edx
  1053d1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1053d4:	c1 e1 02             	shl    $0x2,%ecx
  1053d7:	01 ca                	add    %ecx,%edx
  1053d9:	8b 12                	mov    (%edx),%edx
  1053db:	89 14 85 e0 87 1c 00 	mov    %edx,0x1c87e0(,%eax,4)
  1053e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053e5:	8b 00                	mov    (%eax),%eax
  1053e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1053ea:	c1 e2 02             	shl    $0x2,%edx
  1053ed:	8d 14 10             	lea    (%eax,%edx,1),%edx
  1053f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053f3:	8b 00                	mov    (%eax),%eax
  1053f5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1053f8:	c1 e1 02             	shl    $0x2,%ecx
  1053fb:	01 c8                	add    %ecx,%eax
  1053fd:	8b 00                	mov    (%eax),%eax
  1053ff:	83 c8 07             	or     $0x7,%eax
  105402:	89 02                	mov    %eax,(%edx)
  105404:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10540b:	eb 68                	jmp    105475 <vmm_init+0xee>
  10540d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105410:	89 c2                	mov    %eax,%edx
  105412:	c1 e2 16             	shl    $0x16,%edx
  105415:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105418:	c1 e0 0c             	shl    $0xc,%eax
  10541b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10541e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105421:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105424:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  10542b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10542e:	8b 00                	mov    (%eax),%eax
  105430:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  105433:	c1 e2 02             	shl    $0x2,%edx
  105436:	01 d0                	add    %edx,%eax
  105438:	8b 00                	mov    (%eax),%eax
  10543a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10543f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  105442:	89 c1                	mov    %eax,%ecx
  105444:	81 7d f0 00 10 40 01 	cmpl   $0x1401000,-0x10(%ebp)
  10544b:	76 07                	jbe    105454 <vmm_init+0xcd>
  10544d:	ba 00 02 00 00       	mov    $0x200,%edx
  105452:	eb 05                	jmp    105459 <vmm_init+0xd2>
  105454:	ba 00 00 00 00       	mov    $0x0,%edx
  105459:	81 7d f0 00 10 40 01 	cmpl   $0x1401000,-0x10(%ebp)
  105460:	76 07                	jbe    105469 <vmm_init+0xe2>
  105462:	b8 04 00 00 00       	mov    $0x4,%eax
  105467:	eb 05                	jmp    10546e <vmm_init+0xe7>
  105469:	b8 00 00 00 00       	mov    $0x0,%eax
  10546e:	09 d0                	or     %edx,%eax
  105470:	89 01                	mov    %eax,(%ecx)
  105472:	ff 45 e8             	incl   -0x18(%ebp)
  105475:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  10547c:	76 8f                	jbe    10540d <vmm_init+0x86>
  10547e:	ff 45 e4             	incl   -0x1c(%ebp)
  105481:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
  105488:	0f 86 20 ff ff ff    	jbe    1053ae <vmm_init+0x27>
  10548e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  105495:	eb 3d                	jmp    1054d4 <vmm_init+0x14d>
  105497:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10549a:	8b 00                	mov    (%eax),%eax
  10549c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10549f:	c1 e2 02             	shl    $0x2,%edx
  1054a2:	01 d0                	add    %edx,%eax
  1054a4:	8b 00                	mov    (%eax),%eax
  1054a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1054ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1054ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1054b1:	89 c2                	mov    %eax,%edx
  1054b3:	c1 e2 0c             	shl    $0xc,%edx
  1054b6:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1054bb:	01 c2                	add    %eax,%edx
  1054bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1054c0:	8b 00                	mov    (%eax),%eax
  1054c2:	6a 00                	push   $0x0
  1054c4:	ff 75 f4             	pushl  -0xc(%ebp)
  1054c7:	52                   	push   %edx
  1054c8:	50                   	push   %eax
  1054c9:	e8 12 fb ff ff       	call   104fe0 <map_address_context>
  1054ce:	83 c4 10             	add    $0x10,%esp
  1054d1:	ff 45 e4             	incl   -0x1c(%ebp)
  1054d4:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
  1054db:	76 ba                	jbe    105497 <vmm_init+0x110>
  1054dd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1054e0:	a1 00 61 10 00       	mov    0x106100,%eax
  1054e5:	89 c2                	mov    %eax,%edx
  1054e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1054ea:	8b 00                	mov    (%eax),%eax
  1054ec:	6a 00                	push   $0x0
  1054ee:	51                   	push   %ecx
  1054ef:	52                   	push   %edx
  1054f0:	50                   	push   %eax
  1054f1:	e8 ea fa ff ff       	call   104fe0 <map_address_context>
  1054f6:	83 c4 10             	add    $0x10,%esp
  1054f9:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
  105500:	eb 1d                	jmp    10551f <vmm_init+0x198>
  105502:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105505:	8b 00                	mov    (%eax),%eax
  105507:	6a 00                	push   $0x0
  105509:	ff 75 e4             	pushl  -0x1c(%ebp)
  10550c:	ff 75 e4             	pushl  -0x1c(%ebp)
  10550f:	50                   	push   %eax
  105510:	e8 cb fa ff ff       	call   104fe0 <map_address_context>
  105515:	83 c4 10             	add    $0x10,%esp
  105518:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  10551f:	b8 00 90 1c 00       	mov    $0x1c9000,%eax
  105524:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  105527:	72 d9                	jb     105502 <vmm_init+0x17b>
  105529:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10552c:	8b 00                	mov    (%eax),%eax
  10552e:	83 ec 0c             	sub    $0xc,%esp
  105531:	50                   	push   %eax
  105532:	e8 3d fe ff ff       	call   105374 <vmm_activate_pagedir>
  105537:	83 c4 10             	add    $0x10,%esp
  10553a:	0f 20 c0             	mov    %cr0,%eax
  10553d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105540:	81 4d ec 00 00 00 80 	orl    $0x80000000,-0x14(%ebp)
  105547:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10554a:	0f 22 c0             	mov    %eax,%cr0
  10554d:	a1 00 61 10 00       	mov    0x106100,%eax
  105552:	8b 00                	mov    (%eax),%eax
  105554:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  105557:	c9                   	leave  
  105558:	c3                   	ret    
