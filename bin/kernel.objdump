
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <kernel_start>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 66                	in     $0x66,%al
  10000d:	90                   	nop
  10000e:	66 90                	xchg   %ax,%ax

00100010 <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
  100010:	55                   	push   %ebp
  100011:	89 e5                	mov    %esp,%ebp
  100013:	83 ec 28             	sub    $0x28,%esp
  100016:	8b 45 08             	mov    0x8(%ebp),%eax
  100019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	clrscr();
  10001c:	e8 0f 02 00 00       	call   100230 <clrscr>
	pmm_init(mb_info);
  100021:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100024:	89 04 24             	mov    %eax,(%esp)
  100027:	e8 a4 31 00 00       	call   1031d0 <pmm_init>
  10002c:	8d 05 e4 90 10 00    	lea    0x1090e4,%eax
  100032:	8d 0d 07 91 10 00    	lea    0x109107,%ecx

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100038:	89 04 24             	mov    %eax,(%esp)
  10003b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10003f:	e8 6c 02 00 00       	call   1002b0 <kprintf>
  100044:	8d 0d 1b 91 10 00    	lea    0x10911b,%ecx
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10004a:	89 0c 24             	mov    %ecx,(%esp)
  10004d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100050:	e8 5b 02 00 00       	call   1002b0 <kprintf>
  100055:	8d 0d 5a 91 10 00    	lea    0x10915a,%ecx

	kprintf("Initializing GDT...\n");
  10005b:	89 0c 24             	mov    %ecx,(%esp)
  10005e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100061:	e8 4a 02 00 00       	call   1002b0 <kprintf>

	init_gdt();
  100066:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100069:	e8 b2 0f 00 00       	call   101020 <init_gdt>
  10006e:	8d 05 6f 91 10 00    	lea    0x10916f,%eax

	kprintf("Initializing IDT...\n");
  100074:	89 04 24             	mov    %eax,(%esp)
  100077:	e8 34 02 00 00       	call   1002b0 <kprintf>
  10007c:	8d 0d 84 91 10 00    	lea    0x109184,%ecx

	init_idt();
  100082:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100085:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100088:	e8 b3 11 00 00       	call   101240 <init_idt>

	kprintf("Initializing Kernel...\n");
  10008d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100090:	89 04 24             	mov    %eax,(%esp)
  100093:	e8 18 02 00 00       	call   1002b0 <kprintf>

	pmm_print_stats();
  100098:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10009b:	e8 40 2f 00 00       	call   102fe0 <pmm_print_stats>

	kernel_main(mb_info);
  1000a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000a3:	89 04 24             	mov    %eax,(%esp)
  1000a6:	e8 75 2b 00 00       	call   102c20 <kernel_main>

	return;
  1000ab:	83 c4 28             	add    $0x28,%esp
  1000ae:	5d                   	pop    %ebp
  1000af:	c3                   	ret    

001000b0 <in_cod>:
#include "catofdeath.h"

static uint32_t icod = 0;

uint32_t in_cod() {
  1000b0:	55                   	push   %ebp
  1000b1:	89 e5                	mov    %esp,%ebp
    return icod;
  1000b3:	a1 00 a0 10 00       	mov    0x10a000,%eax
  1000b8:	5d                   	pop    %ebp
  1000b9:	c3                   	ret    
  1000ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001000c0 <show_cod>:
}

void show_cod(struct cpu_state* cpu, char* fstr) {
  1000c0:	55                   	push   %ebp
  1000c1:	89 e5                	mov    %esp,%ebp
  1000c3:	56                   	push   %esi
  1000c4:	83 ec 24             	sub    $0x24,%esp
  1000c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1000cd:	ba 04 00 00 00       	mov    $0x4,%edx
  1000d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1000d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    icod = 1;
  1000d8:	c7 05 00 a0 10 00 01 	movl   $0x1,0x10a000
  1000df:	00 00 00 
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
  1000e2:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1000e9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1000ec:	e8 9f 01 00 00       	call   100290 <setclr>
    kprintf(fstr);
  1000f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1000f4:	89 04 24             	mov    %eax,(%esp)
  1000f7:	e8 b4 01 00 00       	call   1002b0 <kprintf>
  1000fc:	8d 0d 9c 91 10 00    	lea    0x10919c,%ecx
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  100102:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100105:	8b 52 1c             	mov    0x1c(%edx),%edx
  100108:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10010b:	8b 76 20             	mov    0x20(%esi),%esi
  10010e:	89 0c 24             	mov    %ecx,(%esp)
  100111:	89 54 24 04          	mov    %edx,0x4(%esp)
  100115:	89 74 24 08          	mov    %esi,0x8(%esp)
  100119:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10011c:	e8 8f 01 00 00       	call   1002b0 <kprintf>
    show_dump(cpu);
  100121:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100124:	89 0c 24             	mov    %ecx,(%esp)
  100127:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10012a:	e8 11 00 00 00       	call   100140 <show_dump>

    while (1) {
        asm volatile("cli; hlt");
  10012f:	fa                   	cli    
  100130:	f4                   	hlt    
    }
  100131:	e9 f9 ff ff ff       	jmp    10012f <show_cod+0x6f>
  100136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10013d:	00 00 00 

00100140 <show_dump>:
}

void show_dump(struct cpu_state* cpu) {
  100140:	55                   	push   %ebp
  100141:	89 e5                	mov    %esp,%ebp
  100143:	53                   	push   %ebx
  100144:	57                   	push   %edi
  100145:	56                   	push   %esi
  100146:	83 ec 2c             	sub    $0x2c,%esp
  100149:	8b 45 08             	mov    0x8(%ebp),%eax
  10014c:	8d 0d c1 91 10 00    	lea    0x1091c1,%ecx
  100152:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  100155:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100158:	8b 00                	mov    (%eax),%eax
  10015a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10015d:	8b 52 04             	mov    0x4(%edx),%edx
  100160:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100163:	8b 76 08             	mov    0x8(%esi),%esi
  100166:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100169:	8b 7f 0c             	mov    0xc(%edi),%edi
  10016c:	89 0c 24             	mov    %ecx,(%esp)
  10016f:	89 44 24 04          	mov    %eax,0x4(%esp)
  100173:	89 54 24 08          	mov    %edx,0x8(%esp)
  100177:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10017b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10017f:	e8 2c 01 00 00       	call   1002b0 <kprintf>
  100184:	8d 0d e2 91 10 00    	lea    0x1091e2,%ecx
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  10018a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10018d:	8b 52 10             	mov    0x10(%edx),%edx
  100190:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100193:	8b 76 14             	mov    0x14(%esi),%esi
  100196:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100199:	8b 7f 18             	mov    0x18(%edi),%edi
  10019c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10019f:	8b 5b 24             	mov    0x24(%ebx),%ebx
  1001a2:	89 0c 24             	mov    %ecx,(%esp)
  1001a5:	89 54 24 04          	mov    %edx,0x4(%esp)
  1001a9:	89 74 24 08          	mov    %esi,0x8(%esp)
  1001ad:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1001b1:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1001b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1001b8:	e8 f3 00 00 00       	call   1002b0 <kprintf>
  1001bd:	8d 0d 03 92 10 00    	lea    0x109203,%ecx
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
  1001c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1001c6:	8b 52 28             	mov    0x28(%edx),%edx
  1001c9:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1001cc:	8b 76 2c             	mov    0x2c(%esi),%esi
  1001cf:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1001d2:	8b 7f 30             	mov    0x30(%edi),%edi
  1001d5:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  1001d8:	8b 5b 34             	mov    0x34(%ebx),%ebx
  1001db:	89 0c 24             	mov    %ecx,(%esp)
  1001de:	89 54 24 04          	mov    %edx,0x4(%esp)
  1001e2:	89 74 24 08          	mov    %esi,0x8(%esp)
  1001e6:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1001ea:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1001ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1001f1:	e8 ba 00 00 00       	call   1002b0 <kprintf>
  1001f6:	8d 0d 25 92 10 00    	lea    0x109225,%ecx
            cpu->esp, cpu->ss);

    uint32_t cr2 = 0;
  1001fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  100203:	0f 20 d2             	mov    %cr2,%edx
  100206:	89 55 ec             	mov    %edx,-0x14(%ebp)

    kprintf("CR2: %x \n", cr2);
  100209:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10020c:	89 0c 24             	mov    %ecx,(%esp)
  10020f:	89 54 24 04          	mov    %edx,0x4(%esp)
  100213:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100216:	e8 95 00 00 00       	call   1002b0 <kprintf>
}
  10021b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10021e:	83 c4 2c             	add    $0x2c,%esp
  100221:	5e                   	pop    %esi
  100222:	5f                   	pop    %edi
  100223:	5b                   	pop    %ebx
  100224:	5d                   	pop    %ebp
  100225:	c3                   	ret    
  100226:	66 90                	xchg   %ax,%ax
  100228:	66 90                	xchg   %ax,%ax
  10022a:	66 90                	xchg   %ax,%ax
  10022c:	66 90                	xchg   %ax,%ax
  10022e:	66 90                	xchg   %ax,%ax

00100230 <clrscr>:
        x /= base;
    } while (x);
    kputs(p);
}

void clrscr(void) {
  100230:	55                   	push   %ebp
  100231:	89 e5                	mov    %esp,%ebp
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  100233:	50                   	push   %eax
  100234:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10023b:	81 7d fc a0 0f 00 00 	cmpl   $0xfa0,-0x4(%ebp)
  100242:	0f 8d 1d 00 00 00    	jge    100265 <clrscr+0x35>
        video[i] = 0;
  100248:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10024b:	8b 0d 00 80 10 00    	mov    0x108000,%ecx
  100251:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    kputs(p);
}

void clrscr(void) {
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  100255:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100258:	05 01 00 00 00       	add    $0x1,%eax
  10025d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100260:	e9 d6 ff ff ff       	jmp    10023b <clrscr+0xb>
        video[i] = 0;
    }

    color = 0x07;
  100265:	c6 05 04 80 10 00 07 	movb   $0x7,0x108004

    x = y = 0;
  10026c:	c7 05 04 a0 10 00 00 	movl   $0x0,0x10a004
  100273:	00 00 00 
  100276:	c7 05 08 a0 10 00 00 	movl   $0x0,0x10a008
  10027d:	00 00 00 
}
  100280:	83 c4 04             	add    $0x4,%esp
  100283:	5d                   	pop    %ebp
  100284:	c3                   	ret    
  100285:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10028c:	00 00 00 00 

00100290 <setclr>:

void setclr(char clr) {
  100290:	55                   	push   %ebp
  100291:	89 e5                	mov    %esp,%ebp
  100293:	50                   	push   %eax
  100294:	8a 45 08             	mov    0x8(%ebp),%al
  100297:	88 45 ff             	mov    %al,-0x1(%ebp)
    color = clr;
  10029a:	8a 45 ff             	mov    -0x1(%ebp),%al
  10029d:	a2 04 80 10 00       	mov    %al,0x108004
}
  1002a2:	83 c4 04             	add    $0x4,%esp
  1002a5:	5d                   	pop    %ebp
  1002a6:	c3                   	ret    
  1002a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1002ae:	00 00 

001002b0 <kprintf>:

int kprintf(const char* fmt, ...) {
  1002b0:	55                   	push   %ebp
  1002b1:	89 e5                	mov    %esp,%ebp
  1002b3:	83 ec 58             	sub    $0x58,%esp
  1002b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002b9:	8d 4d f8             	lea    -0x8(%ebp),%ecx
  1002bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1002bf:	8d 45 0c             	lea    0xc(%ebp),%eax
    va_list ap;
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
  1002c2:	89 01                	mov    %eax,(%ecx)
    kprintf_res = 0;
  1002c4:	c7 05 0c a0 10 00 00 	movl   $0x0,0x10a00c
  1002cb:	00 00 00 
    while (*fmt) {
  1002ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002d1:	80 38 00             	cmpb   $0x0,(%eax)
  1002d4:	0f 84 dd 01 00 00    	je     1004b7 <kprintf+0x207>
        if (*fmt == '%') {
  1002da:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002dd:	0f be 00             	movsbl (%eax),%eax
  1002e0:	3d 25 00 00 00       	cmp    $0x25,%eax
  1002e5:	0f 85 ae 01 00 00    	jne    100499 <kprintf+0x1e9>
            fmt++;
  1002eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002ee:	89 c1                	mov    %eax,%ecx
  1002f0:	41                   	inc    %ecx
  1002f1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
            switch (*fmt) {
  1002f4:	0f be 40 01          	movsbl 0x1(%eax),%eax
  1002f8:	89 c1                	mov    %eax,%ecx
  1002fa:	83 e9 24             	sub    $0x24,%ecx
  1002fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100300:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100303:	0f 8f 15 00 00 00    	jg     10031e <kprintf+0x6e>
  100309:	e9 00 00 00 00       	jmp    10030e <kprintf+0x5e>
  10030e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100311:	85 c0                	test   %eax,%eax
  100313:	0f 84 54 01 00 00    	je     10046d <kprintf+0x1bd>
  100319:	e9 54 01 00 00       	jmp    100472 <kprintf+0x1c2>
  10031e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100321:	83 e8 62             	sub    $0x62,%eax
  100324:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100327:	0f 8f 19 00 00 00    	jg     100346 <kprintf+0x96>
  10032d:	e9 00 00 00 00       	jmp    100332 <kprintf+0x82>
  100332:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100335:	83 e8 25             	sub    $0x25,%eax
  100338:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10033b:	0f 84 13 01 00 00    	je     100454 <kprintf+0x1a4>
  100341:	e9 2c 01 00 00       	jmp    100472 <kprintf+0x1c2>
  100346:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100349:	83 e8 6f             	sub    $0x6f,%eax
  10034c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10034f:	0f 8f 2d 00 00 00    	jg     100382 <kprintf+0xd2>
  100355:	e9 00 00 00 00       	jmp    10035a <kprintf+0xaa>
  10035a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10035d:	83 e8 63             	sub    $0x63,%eax
  100360:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100363:	0f 84 c5 00 00 00    	je     10042e <kprintf+0x17e>
  100369:	e9 00 00 00 00       	jmp    10036e <kprintf+0xbe>
  10036e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100371:	83 e8 64             	sub    $0x64,%eax
  100374:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100377:	0f 84 4b 00 00 00    	je     1003c8 <kprintf+0x118>
  10037d:	e9 f0 00 00 00       	jmp    100472 <kprintf+0x1c2>
  100382:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100385:	83 c0 90             	add    $0xffffff90,%eax
  100388:	89 c1                	mov    %eax,%ecx
  10038a:	83 e9 08             	sub    $0x8,%ecx
  10038d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100390:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  100393:	0f 87 d9 00 00 00    	ja     100472 <kprintf+0x1c2>
  100399:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10039c:	8b 0c 85 00 90 10 00 	mov    0x109000(,%eax,4),%ecx
  1003a3:	ff e1                	jmp    *%ecx
            case 's':
                s = va_arg(ap, char*);
  1003a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1003a8:	89 c1                	mov    %eax,%ecx
  1003aa:	81 c1 04 00 00 00    	add    $0x4,%ecx
  1003b0:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1003b3:	8b 00                	mov    (%eax),%eax
  1003b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                kputs(s);
  1003b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003bb:	89 04 24             	mov    %eax,(%esp)
  1003be:	e8 0d 01 00 00       	call   1004d0 <kputs>
                break;
  1003c3:	e9 cc 00 00 00       	jmp    100494 <kprintf+0x1e4>
  1003c8:	b8 0a 00 00 00       	mov    $0xa,%eax
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
  1003cd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1003d0:	89 ca                	mov    %ecx,%edx
  1003d2:	81 c2 04 00 00 00    	add    $0x4,%edx
  1003d8:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1003db:	8b 09                	mov    (%ecx),%ecx
  1003dd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 10);
  1003e0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1003e3:	89 0c 24             	mov    %ecx,(%esp)
  1003e6:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1003ed:	00 
  1003ee:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1003f1:	e8 1a 01 00 00       	call   100510 <kputn>
                break;
  1003f6:	e9 99 00 00 00       	jmp    100494 <kprintf+0x1e4>
  1003fb:	b8 10 00 00 00       	mov    $0x10,%eax
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
  100400:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100403:	89 ca                	mov    %ecx,%edx
  100405:	81 c2 04 00 00 00    	add    $0x4,%edx
  10040b:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10040e:	8b 09                	mov    (%ecx),%ecx
  100410:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 16);
  100413:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100416:	89 0c 24             	mov    %ecx,(%esp)
  100419:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  100420:	00 
  100421:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100424:	e8 e7 00 00 00       	call   100510 <kputn>
                break;
  100429:	e9 66 00 00 00       	jmp    100494 <kprintf+0x1e4>
            case 'c':
                c = va_arg(ap, int);
  10042e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100431:	89 c1                	mov    %eax,%ecx
  100433:	81 c1 04 00 00 00    	add    $0x4,%ecx
  100439:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10043c:	8b 00                	mov    (%eax),%eax
  10043e:	88 c2                	mov    %al,%dl
  100440:	88 55 ef             	mov    %dl,-0x11(%ebp)
                kputc(c);
  100443:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  100447:	89 04 24             	mov    %eax,(%esp)
  10044a:	e8 61 01 00 00       	call   1005b0 <kputc>
                break;
  10044f:	e9 40 00 00 00       	jmp    100494 <kprintf+0x1e4>
  100454:	b8 25 00 00 00       	mov    $0x25,%eax
            case '%':
                kputc('%');
  100459:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100460:	89 45 bc             	mov    %eax,-0x44(%ebp)
  100463:	e8 48 01 00 00       	call   1005b0 <kputc>
                break;
  100468:	e9 27 00 00 00       	jmp    100494 <kprintf+0x1e4>
            case '\0':
                goto out;
  10046d:	e9 4a 00 00 00       	jmp    1004bc <kprintf+0x20c>
  100472:	b8 25 00 00 00       	mov    $0x25,%eax
            default:
                kputc('%');
  100477:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10047e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100481:	e8 2a 01 00 00       	call   1005b0 <kputc>
                kputc(*fmt);
  100486:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100489:	0f be 00             	movsbl (%eax),%eax
  10048c:	89 04 24             	mov    %eax,(%esp)
  10048f:	e8 1c 01 00 00       	call   1005b0 <kputc>
                break;
            }
        } else {
  100494:	e9 0e 00 00 00       	jmp    1004a7 <kprintf+0x1f7>
            kputc(*fmt);
  100499:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10049c:	0f be 00             	movsbl (%eax),%eax
  10049f:	89 04 24             	mov    %eax,(%esp)
  1004a2:	e8 09 01 00 00       	call   1005b0 <kputc>
        }

        fmt++;
  1004a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004aa:	05 01 00 00 00       	add    $0x1,%eax
  1004af:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  1004b2:	e9 17 fe ff ff       	jmp    1002ce <kprintf+0x1e>
  1004b7:	e9 00 00 00 00       	jmp    1004bc <kprintf+0x20c>

    out:
    va_end(ap);

    return kprintf_res;
  1004bc:	a1 0c a0 10 00       	mov    0x10a00c,%eax
  1004c1:	83 c4 58             	add    $0x58,%esp
  1004c4:	5d                   	pop    %ebp
  1004c5:	c3                   	ret    
  1004c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1004cd:	00 00 00 

001004d0 <kputs>:

    x++;
    kprintf_res++;
}

static void kputs(const char* s) {
  1004d0:	55                   	push   %ebp
  1004d1:	89 e5                	mov    %esp,%ebp
  1004d3:	83 ec 08             	sub    $0x8,%esp
  1004d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1004d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*s) {
  1004dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004df:	80 38 00             	cmpb   $0x0,(%eax)
  1004e2:	0f 84 1e 00 00 00    	je     100506 <kputs+0x36>
        kputc(*s++);
  1004e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004eb:	89 c1                	mov    %eax,%ecx
  1004ed:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1004f3:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1004f6:	0f be 00             	movsbl (%eax),%eax
  1004f9:	89 04 24             	mov    %eax,(%esp)
  1004fc:	e8 af 00 00 00       	call   1005b0 <kputc>
    }
  100501:	e9 d6 ff ff ff       	jmp    1004dc <kputs+0xc>
}
  100506:	83 c4 08             	add    $0x8,%esp
  100509:	5d                   	pop    %ebp
  10050a:	c3                   	ret    
  10050b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00100510 <kputn>:

static void kputn(unsigned long x, int base) {
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	56                   	push   %esi
  100514:	83 ec 64             	sub    $0x64,%esp
  100517:	8b 45 0c             	mov    0xc(%ebp),%eax
  10051a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10051d:	8d 15 2f 92 10 00    	lea    0x10922f,%edx
  100523:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100526:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  100529:	89 55 ac             	mov    %edx,-0x54(%ebp)
    char* p;

    if (base > 36) {
  10052c:	81 7d f4 24 00 00 00 	cmpl   $0x24,-0xc(%ebp)
  100533:	0f 8e 05 00 00 00    	jle    10053e <kputn+0x2e>
        return;
  100539:	e9 5d 00 00 00       	jmp    10059b <kputn+0x8b>
  10053e:	8d 45 b3             	lea    -0x4d(%ebp),%eax
    }

    p = buf + 64;
  100541:	05 40 00 00 00       	add    $0x40,%eax
  100546:	89 45 a8             	mov    %eax,-0x58(%ebp)
    *p = '\0';
  100549:	8b 45 a8             	mov    -0x58(%ebp),%eax
  10054c:	c6 00 00             	movb   $0x0,(%eax)
    do {
        *--p = digits[x % base];
  10054f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100552:	31 d2                	xor    %edx,%edx
  100554:	f7 75 f4             	divl   -0xc(%ebp)
  100557:	8b 45 ac             	mov    -0x54(%ebp),%eax
  10055a:	8a 0c 10             	mov    (%eax,%edx,1),%cl
  10055d:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100560:	89 c2                	mov    %eax,%edx
  100562:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
  100568:	89 55 a8             	mov    %edx,-0x58(%ebp)
  10056b:	88 48 ff             	mov    %cl,-0x1(%eax)
        x /= base;
  10056e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100571:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100574:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  100577:	89 d0                	mov    %edx,%eax
  100579:	31 d2                	xor    %edx,%edx
  10057b:	8b 75 a4             	mov    -0x5c(%ebp),%esi
  10057e:	f7 f6                	div    %esi
  100580:	89 45 f8             	mov    %eax,-0x8(%ebp)
    } while (x);
  100583:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10058a:	0f 85 bf ff ff ff    	jne    10054f <kputn+0x3f>
    kputs(p);
  100590:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100593:	89 04 24             	mov    %eax,(%esp)
  100596:	e8 35 ff ff ff       	call   1004d0 <kputs>
}
  10059b:	83 c4 64             	add    $0x64,%esp
  10059e:	5e                   	pop    %esi
  10059f:	5d                   	pop    %ebp
  1005a0:	c3                   	ret    
  1005a1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1005a8:	0f 1f 84 00 00 00 00 
  1005af:	00 

001005b0 <kputc>:
static int kprintf_res = 0;
static char color = 0x07;

static char* video = (char*) 0xb8000;

static void kputc(char c) {
  1005b0:	55                   	push   %ebp
  1005b1:	89 e5                	mov    %esp,%ebp
  1005b3:	83 ec 38             	sub    $0x38,%esp
  1005b6:	8a 45 08             	mov    0x8(%ebp),%al
  1005b9:	88 45 ff             	mov    %al,-0x1(%ebp)
    if(in_cod()) {
  1005bc:	e8 ef fa ff ff       	call   1000b0 <in_cod>
  1005c1:	3d 00 00 00 00       	cmp    $0x0,%eax
  1005c6:	0f 84 05 00 00 00    	je     1005d1 <kputc+0x21>
        goto doKPutc;
  1005cc:	e9 e3 00 00 00       	jmp    1006b4 <kputc+0x104>
    }

    if(get_current_task() != 0) {
  1005d1:	e8 ba 3d 00 00       	call   104390 <get_current_task>
  1005d6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1005db:	0f 84 b9 00 00 00    	je     10069a <kputc+0xea>
        if(get_current_task()->stdout != 0) {
  1005e1:	e8 aa 3d 00 00       	call   104390 <get_current_task>
  1005e6:	81 78 30 00 00 00 00 	cmpl   $0x0,0x30(%eax)
  1005ed:	0f 84 a2 00 00 00    	je     100695 <kputc+0xe5>
            vfs_write(get_current_task()->stdout, &(char){0x11}, sizeof(char), 1);
  1005f3:	e8 98 3d 00 00       	call   104390 <get_current_task>
  1005f8:	8d 4d fe             	lea    -0x2(%ebp),%ecx
  1005fb:	ba 01 00 00 00       	mov    $0x1,%edx
  100600:	8b 40 30             	mov    0x30(%eax),%eax
  100603:	c6 45 fe 11          	movb   $0x11,-0x2(%ebp)
  100607:	89 04 24             	mov    %eax,(%esp)
  10060a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10060e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100615:	00 
  100616:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10061d:	00 
  10061e:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100621:	e8 da 5a 00 00       	call   106100 <vfs_write>
            vfs_write(get_current_task()->stdout, &color, sizeof(char), 1);
  100626:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100629:	e8 62 3d 00 00       	call   104390 <get_current_task>
  10062e:	8d 0d 04 80 10 00    	lea    0x108004,%ecx
  100634:	ba 01 00 00 00       	mov    $0x1,%edx
  100639:	8b 40 30             	mov    0x30(%eax),%eax
  10063c:	89 04 24             	mov    %eax,(%esp)
  10063f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100643:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10064a:	00 
  10064b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100652:	00 
  100653:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100656:	e8 a5 5a 00 00       	call   106100 <vfs_write>
            vfs_write(get_current_task()->stdout, &c, sizeof(char), 1);
  10065b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10065e:	e8 2d 3d 00 00       	call   104390 <get_current_task>
  100663:	8d 4d ff             	lea    -0x1(%ebp),%ecx
  100666:	ba 01 00 00 00       	mov    $0x1,%edx
  10066b:	8b 40 30             	mov    0x30(%eax),%eax
  10066e:	89 04 24             	mov    %eax,(%esp)
  100671:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100675:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10067c:	00 
  10067d:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100684:	00 
  100685:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  100688:	e8 73 5a 00 00       	call   106100 <vfs_write>

            return;
  10068d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100690:	e9 5e 01 00 00       	jmp    1007f3 <kputc+0x243>
        }
    }
  100695:	e9 00 00 00 00       	jmp    10069a <kputc+0xea>

    if(ramfs_vga_writers()) {
  10069a:	e8 c1 3c 00 00       	call   104360 <ramfs_vga_writers>
  10069f:	3d 00 00 00 00       	cmp    $0x0,%eax
  1006a4:	0f 84 05 00 00 00    	je     1006af <kputc+0xff>
        return;
  1006aa:	e9 44 01 00 00       	jmp    1007f3 <kputc+0x243>
    }
  1006af:	e9 00 00 00 00       	jmp    1006b4 <kputc+0x104>

    doKPutc:

    if ((c == '\n') || (x > 79)) {
  1006b4:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  1006b8:	3d 0a 00 00 00       	cmp    $0xa,%eax
  1006bd:	0f 84 10 00 00 00    	je     1006d3 <kputc+0x123>
  1006c3:	81 3d 08 a0 10 00 4f 	cmpl   $0x4f,0x10a008
  1006ca:	00 00 00 
  1006cd:	0f 8e 19 00 00 00    	jle    1006ec <kputc+0x13c>
        x = 0;
  1006d3:	c7 05 08 a0 10 00 00 	movl   $0x0,0x10a008
  1006da:	00 00 00 
        y++;
  1006dd:	a1 04 a0 10 00       	mov    0x10a004,%eax
  1006e2:	05 01 00 00 00       	add    $0x1,%eax
  1006e7:	a3 04 a0 10 00       	mov    %eax,0x10a004
    }

    if (c == '\n') {
  1006ec:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  1006f0:	3d 0a 00 00 00       	cmp    $0xa,%eax
  1006f5:	0f 85 05 00 00 00    	jne    100700 <kputc+0x150>
        return;
  1006fb:	e9 f3 00 00 00       	jmp    1007f3 <kputc+0x243>
    }

    if (y > 24) {
  100700:	81 3d 04 a0 10 00 18 	cmpl   $0x18,0x10a004
  100707:	00 00 00 
  10070a:	0f 8e 7e 00 00 00    	jle    10078e <kputc+0x1de>
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  100710:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  100717:	81 7d f8 00 0f 00 00 	cmpl   $0xf00,-0x8(%ebp)
  10071e:	0f 8d 2c 00 00 00    	jge    100750 <kputc+0x1a0>
            video[i] = video[i + 160];
  100724:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100727:	8b 0d 00 80 10 00    	mov    0x108000,%ecx
  10072d:	8a 94 01 a0 00 00 00 	mov    0xa0(%ecx,%eax,1),%dl
  100734:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100737:	8b 0d 00 80 10 00    	mov    0x108000,%ecx
  10073d:	88 14 01             	mov    %dl,(%ecx,%eax,1)
        return;
    }

    if (y > 24) {
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  100740:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100743:	05 01 00 00 00       	add    $0x1,%eax
  100748:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10074b:	e9 c7 ff ff ff       	jmp    100717 <kputc+0x167>
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  100750:	e9 00 00 00 00       	jmp    100755 <kputc+0x1a5>
  100755:	81 7d f8 a0 0f 00 00 	cmpl   $0xfa0,-0x8(%ebp)
  10075c:	0f 8d 1d 00 00 00    	jge    10077f <kputc+0x1cf>
            video[i] = 0;
  100762:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100765:	8b 0d 00 80 10 00    	mov    0x108000,%ecx
  10076b:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  10076f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100772:	05 01 00 00 00       	add    $0x1,%eax
  100777:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10077a:	e9 d6 ff ff ff       	jmp    100755 <kputc+0x1a5>
            video[i] = 0;
        }
        y--;
  10077f:	a1 04 a0 10 00       	mov    0x10a004,%eax
  100784:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100789:	a3 04 a0 10 00       	mov    %eax,0x10a004
    }

    video[2 * (y * 80 + x)] = c;
  10078e:	8a 45 ff             	mov    -0x1(%ebp),%al
  100791:	69 0d 04 a0 10 00 50 	imul   $0x50,0x10a004,%ecx
  100798:	00 00 00 
  10079b:	03 0d 08 a0 10 00    	add    0x10a008,%ecx
  1007a1:	c1 e1 01             	shl    $0x1,%ecx
  1007a4:	8b 15 00 80 10 00    	mov    0x108000,%edx
  1007aa:	88 04 0a             	mov    %al,(%edx,%ecx,1)
    video[2 * (y * 80 + x) + 1] = color;
  1007ad:	a0 04 80 10 00       	mov    0x108004,%al
  1007b2:	69 0d 04 a0 10 00 50 	imul   $0x50,0x10a004,%ecx
  1007b9:	00 00 00 
  1007bc:	03 0d 08 a0 10 00    	add    0x10a008,%ecx
  1007c2:	c1 e1 01             	shl    $0x1,%ecx
  1007c5:	8b 15 00 80 10 00    	mov    0x108000,%edx
  1007cb:	88 44 0a 01          	mov    %al,0x1(%edx,%ecx,1)

    x++;
  1007cf:	8b 0d 08 a0 10 00    	mov    0x10a008,%ecx
  1007d5:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1007db:	89 0d 08 a0 10 00    	mov    %ecx,0x10a008
    kprintf_res++;
  1007e1:	8b 0d 0c a0 10 00    	mov    0x10a00c,%ecx
  1007e7:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1007ed:	89 0d 0c a0 10 00    	mov    %ecx,0x10a00c
}
  1007f3:	83 c4 38             	add    $0x38,%esp
  1007f6:	5d                   	pop    %ebp
  1007f7:	c3                   	ret    
  1007f8:	66 90                	xchg   %ax,%ax
  1007fa:	66 90                	xchg   %ax,%ax
  1007fc:	66 90                	xchg   %ax,%ax
  1007fe:	66 90                	xchg   %ax,%ax

00100800 <irq_handler>:
        while ((inb(0x64) & 0x1) == 0) {
        }
    } while (inb(0x60) == 0xfe);
}

void irq_handler() {
  100800:	55                   	push   %ebp
  100801:	89 e5                	mov    %esp,%ebp
    uint8_t scancode;
    uint8_t keycode = 0;
  100803:	57                   	push   %edi
  100804:	56                   	push   %esi
  100805:	83 ec 40             	sub    $0x40,%esp
  100808:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
    int break_code = 0;
  10080c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
  100813:	81 3d 10 a0 10 00 00 	cmpl   $0x0,0x10a010
  10081a:	00 00 00 
  10081d:	0f 85 05 00 00 00    	jne    100828 <irq_handler+0x28>
  100823:	e9 bf 02 00 00       	jmp    100ae7 <irq_handler+0x2e7>
  100828:	b8 60 00 00 00       	mov    $0x60,%eax

    scancode = inb(0x60);
  10082d:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100834:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100837:	e8 b4 02 00 00       	call   100af0 <inb>
  10083c:	88 45 f7             	mov    %al,-0x9(%ebp)

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
  10083f:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
  100843:	81 e1 80 00 00 00    	and    $0x80,%ecx
  100849:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  10084f:	0f 84 53 00 00 00    	je     1008a8 <irq_handler+0xa8>
  100855:	81 3d 1c a0 10 00 00 	cmpl   $0x0,0x10a01c
  10085c:	00 00 00 
  10085f:	0f 85 0f 00 00 00    	jne    100874 <irq_handler+0x74>
  100865:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100869:	3d e1 00 00 00       	cmp    $0xe1,%eax
  10086e:	0f 84 34 00 00 00    	je     1008a8 <irq_handler+0xa8>
  100874:	81 3d 18 a0 10 00 00 	cmpl   $0x0,0x10a018
  10087b:	00 00 00 
  10087e:	0f 85 0f 00 00 00    	jne    100893 <irq_handler+0x93>
  100884:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100888:	3d e0 00 00 00       	cmp    $0xe0,%eax
  10088d:	0f 84 15 00 00 00    	je     1008a8 <irq_handler+0xa8>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
  100893:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
        scancode &= ~0x80;
  10089a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  10089e:	25 7f ff ff ff       	and    $0xffffff7f,%eax
  1008a3:	88 c1                	mov    %al,%cl
  1008a5:	88 4d f7             	mov    %cl,-0x9(%ebp)
    }

    if (e0_code) {
  1008a8:	81 3d 18 a0 10 00 00 	cmpl   $0x0,0x10a018
  1008af:	00 00 00 
  1008b2:	0f 84 63 00 00 00    	je     10091b <irq_handler+0x11b>
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
  1008b8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1008bc:	3d 2a 00 00 00       	cmp    $0x2a,%eax
  1008c1:	0f 84 0f 00 00 00    	je     1008d6 <irq_handler+0xd6>
  1008c7:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1008cb:	3d 36 00 00 00       	cmp    $0x36,%eax
  1008d0:	0f 85 0f 00 00 00    	jne    1008e5 <irq_handler+0xe5>
            e0_code = 0;
  1008d6:	c7 05 18 a0 10 00 00 	movl   $0x0,0x10a018
  1008dd:	00 00 00 
            return;
  1008e0:	e9 02 02 00 00       	jmp    100ae7 <irq_handler+0x2e7>
  1008e5:	b8 01 00 00 00       	mov    $0x1,%eax
        }

        keycode = translate_scancode(1, scancode);
  1008ea:	8a 4d f7             	mov    -0x9(%ebp),%cl
  1008ed:	0f b6 d1             	movzbl %cl,%edx
  1008f0:	66 89 d6             	mov    %dx,%si
  1008f3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1008fa:	0f b7 d6             	movzwl %si,%edx
  1008fd:	89 54 24 04          	mov    %edx,0x4(%esp)
  100901:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100904:	e8 07 02 00 00       	call   100b10 <translate_scancode>
  100909:	88 45 f6             	mov    %al,-0xa(%ebp)
        e0_code = 0;
  10090c:	c7 05 18 a0 10 00 00 	movl   $0x0,0x10a018
  100913:	00 00 00 
    } else if (e1_code == 2) {
  100916:	e9 11 01 00 00       	jmp    100a2c <irq_handler+0x22c>
  10091b:	81 3d 1c a0 10 00 02 	cmpl   $0x2,0x10a01c
  100922:	00 00 00 
  100925:	0f 85 53 00 00 00    	jne    10097e <irq_handler+0x17e>
  10092b:	b8 02 00 00 00       	mov    $0x2,%eax
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
  100930:	8a 4d f7             	mov    -0x9(%ebp),%cl
  100933:	0f b6 d1             	movzbl %cl,%edx
  100936:	66 89 d6             	mov    %dx,%si
  100939:	0f b7 d6             	movzwl %si,%edx
  10093c:	c1 e2 08             	shl    $0x8,%edx
  10093f:	0f b7 3d 20 a0 10 00 	movzwl 0x10a020,%edi
  100946:	09 d7                	or     %edx,%edi
  100948:	66 89 fe             	mov    %di,%si
  10094b:	66 89 35 20 a0 10 00 	mov    %si,0x10a020
        keycode = translate_scancode(2, e1_prev);
  100952:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100959:	0f b7 15 20 a0 10 00 	movzwl 0x10a020,%edx
  100960:	89 54 24 04          	mov    %edx,0x4(%esp)
  100964:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100967:	e8 a4 01 00 00       	call   100b10 <translate_scancode>
  10096c:	88 45 f6             	mov    %al,-0xa(%ebp)
        e1_code = 0;
  10096f:	c7 05 1c a0 10 00 00 	movl   $0x0,0x10a01c
  100976:	00 00 00 
    } else if (e1_code == 1) {
  100979:	e9 a9 00 00 00       	jmp    100a27 <irq_handler+0x227>
  10097e:	81 3d 1c a0 10 00 01 	cmpl   $0x1,0x10a01c
  100985:	00 00 00 
  100988:	0f 85 27 00 00 00    	jne    1009b5 <irq_handler+0x1b5>
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
  10098e:	8a 45 f7             	mov    -0x9(%ebp),%al
  100991:	0f b6 c8             	movzbl %al,%ecx
  100994:	66 89 ca             	mov    %cx,%dx
  100997:	66 89 15 20 a0 10 00 	mov    %dx,0x10a020
        e1_code++;
  10099e:	8b 0d 1c a0 10 00    	mov    0x10a01c,%ecx
  1009a4:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1009aa:	89 0d 1c a0 10 00    	mov    %ecx,0x10a01c
    } else if (scancode == 0xE0) {
  1009b0:	e9 6d 00 00 00       	jmp    100a22 <irq_handler+0x222>
  1009b5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1009b9:	3d e0 00 00 00       	cmp    $0xe0,%eax
  1009be:	0f 85 0f 00 00 00    	jne    1009d3 <irq_handler+0x1d3>
        // Anfang eines e0-Codes
        e0_code = 1;
  1009c4:	c7 05 18 a0 10 00 01 	movl   $0x1,0x10a018
  1009cb:	00 00 00 
    } else if (scancode == 0xE1) {
  1009ce:	e9 4a 00 00 00       	jmp    100a1d <irq_handler+0x21d>
  1009d3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1009d7:	3d e1 00 00 00       	cmp    $0xe1,%eax
  1009dc:	0f 85 0f 00 00 00    	jne    1009f1 <irq_handler+0x1f1>
        // Anfang eines e1-Codes
        e1_code = 1;
  1009e2:	c7 05 1c a0 10 00 01 	movl   $0x1,0x10a01c
  1009e9:	00 00 00 
    } else {
  1009ec:	e9 27 00 00 00       	jmp    100a18 <irq_handler+0x218>
  1009f1:	b8 00 00 00 00       	mov    $0x0,%eax
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
  1009f6:	8a 4d f7             	mov    -0x9(%ebp),%cl
  1009f9:	0f b6 d1             	movzbl %cl,%edx
  1009fc:	66 89 d6             	mov    %dx,%si
  1009ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100a06:	0f b7 d6             	movzwl %si,%edx
  100a09:	89 54 24 04          	mov    %edx,0x4(%esp)
  100a0d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  100a10:	e8 fb 00 00 00       	call   100b10 <translate_scancode>
  100a15:	88 45 f6             	mov    %al,-0xa(%ebp)
  100a18:	e9 00 00 00 00       	jmp    100a1d <irq_handler+0x21d>
  100a1d:	e9 00 00 00 00       	jmp    100a22 <irq_handler+0x222>
  100a22:	e9 00 00 00 00       	jmp    100a27 <irq_handler+0x227>
  100a27:	e9 00 00 00 00       	jmp    100a2c <irq_handler+0x22c>
    }

    if(break_code) {
  100a2c:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  100a33:	0f 84 1d 00 00 00    	je     100a56 <irq_handler+0x256>
        key_flags[keycode] &= ~KF_PRESSED;
  100a39:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
  100a3d:	8b 0c 85 70 a5 12 00 	mov    0x12a570(,%eax,4),%ecx
  100a44:	81 e1 fe ff ff ff    	and    $0xfffffffe,%ecx
  100a4a:	89 0c 85 70 a5 12 00 	mov    %ecx,0x12a570(,%eax,4)
    }
  100a51:	e9 18 00 00 00       	jmp    100a6e <irq_handler+0x26e>
    else
    {
        key_flags[keycode] |= KF_PRESSED;
  100a56:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
  100a5a:	8b 0c 85 70 a5 12 00 	mov    0x12a570(,%eax,4),%ecx
  100a61:	81 c9 01 00 00 00    	or     $0x1,%ecx
  100a67:	89 0c 85 70 a5 12 00 	mov    %ecx,0x12a570(,%eax,4)
    }

    char chr = getchar(keycode);
  100a6e:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
  100a72:	89 04 24             	mov    %eax,(%esp)
  100a75:	e8 76 01 00 00       	call   100bf0 <getchar>
  100a7a:	88 45 ef             	mov    %al,-0x11(%ebp)

    if(!break_code && chr) {
  100a7d:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  100a84:	0f 85 5d 00 00 00    	jne    100ae7 <irq_handler+0x2e7>
  100a8a:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  100a8e:	3d 00 00 00 00       	cmp    $0x0,%eax
  100a93:	0f 84 4e 00 00 00    	je     100ae7 <irq_handler+0x2e7>
  100a99:	8d 45 ef             	lea    -0x11(%ebp),%eax
  100a9c:	b9 01 00 00 00       	mov    $0x1,%ecx
        if(vfs_write(charout, &chr, sizeof(char), 1)) {
  100aa1:	8b 15 14 a0 10 00    	mov    0x10a014,%edx
  100aa7:	89 14 24             	mov    %edx,(%esp)
  100aaa:	89 44 24 04          	mov    %eax,0x4(%esp)
  100aae:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100ab5:	00 
  100ab6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100abd:	00 
  100abe:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  100ac1:	e8 3a 56 00 00       	call   106100 <vfs_write>
  100ac6:	3d 00 00 00 00       	cmp    $0x0,%eax
  100acb:	0f 84 11 00 00 00    	je     100ae2 <irq_handler+0x2e2>
  100ad1:	8d 05 54 92 10 00    	lea    0x109254,%eax
            kprintf("[keyboard] BUFFER OVERFLOW! \n");
  100ad7:	89 04 24             	mov    %eax,(%esp)
  100ada:	e8 d1 f7 ff ff       	call   1002b0 <kprintf>
  100adf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        }
    }
  100ae2:	e9 00 00 00 00       	jmp    100ae7 <irq_handler+0x2e7>
}
  100ae7:	83 c4 40             	add    $0x40,%esp
  100aea:	5e                   	pop    %esi
  100aeb:	5f                   	pop    %edi
  100aec:	5d                   	pop    %ebp
  100aed:	c3                   	ret    
  100aee:	66 90                	xchg   %ax,%ax

00100af0 <inb>:
    uint16_t result;
    asm volatile ("inw %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline uint8_t inb(uint16_t _port) {
  100af0:	55                   	push   %ebp
  100af1:	89 e5                	mov    %esp,%ebp
  100af3:	50                   	push   %eax
  100af4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100af8:	66 89 c1             	mov    %ax,%cx
  100afb:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
    uint8_t result;
    asm volatile ("inb %1, %0" : "=a" (result) : "Nd" (_port));
  100aff:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  100b03:	ec                   	in     (%dx),%al
  100b04:	88 45 fd             	mov    %al,-0x3(%ebp)
    return result;
  100b07:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  100b0b:	83 c4 04             	add    $0x4,%esp
  100b0e:	5d                   	pop    %ebp
  100b0f:	c3                   	ret    

00100b10 <translate_scancode>:
uint32_t key_flags[256];

struct res_handle* charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
  100b10:	55                   	push   %ebp
  100b11:	89 e5                	mov    %esp,%ebp
  100b13:	83 ec 28             	sub    $0x28,%esp
  100b16:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  100b1a:	66 89 c1             	mov    %ax,%cx
  100b1d:	8b 45 08             	mov    0x8(%ebp),%eax
  100b20:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100b23:	66 89 4d fa          	mov    %cx,-0x6(%ebp)
    uint8_t keycode = 0;
  100b27:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)

    switch (set) {
  100b2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b2e:	89 c2                	mov    %eax,%edx
  100b30:	83 ea 02             	sub    $0x2,%edx
  100b33:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100b36:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100b39:	0f 84 4f 00 00 00    	je     100b8e <translate_scancode+0x7e>
  100b3f:	e9 00 00 00 00       	jmp    100b44 <translate_scancode+0x34>
  100b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b47:	83 e8 01             	sub    $0x1,%eax
  100b4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100b4d:	0f 84 28 00 00 00    	je     100b7b <translate_scancode+0x6b>
  100b53:	e9 00 00 00 00       	jmp    100b58 <translate_scancode+0x48>
  100b58:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b5b:	85 c0                	test   %eax,%eax
  100b5d:	0f 85 54 00 00 00    	jne    100bb7 <translate_scancode+0xa7>
  100b63:	e9 00 00 00 00       	jmp    100b68 <translate_scancode+0x58>
        // Normal scancodes
        case 0:
            keycode = sc_to_kc[0][scancode];
  100b68:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100b6c:	8a 0c 05 08 81 10 00 	mov    0x108108(,%eax,1),%cl
  100b73:	88 4d f9             	mov    %cl,-0x7(%ebp)
            break;
  100b76:	e9 3c 00 00 00       	jmp    100bb7 <translate_scancode+0xa7>

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
  100b7b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100b7f:	8a 0c 05 88 81 10 00 	mov    0x108188(,%eax,1),%cl
  100b86:	88 4d f9             	mov    %cl,-0x7(%ebp)
            break;
  100b89:	e9 29 00 00 00       	jmp    100bb7 <translate_scancode+0xa7>

        // e1-Scancodes
        case 2:
            switch (scancode) {
  100b8e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100b92:	2d 1d 45 00 00       	sub    $0x451d,%eax
  100b97:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100b9a:	0f 85 0e 00 00 00    	jne    100bae <translate_scancode+0x9e>
  100ba0:	e9 00 00 00 00       	jmp    100ba5 <translate_scancode+0x95>
                // Pause
                case 0x451D:
                    keycode = 119;
  100ba5:	c6 45 f9 77          	movb   $0x77,-0x7(%ebp)
                    break;
  100ba9:	e9 04 00 00 00       	jmp    100bb2 <translate_scancode+0xa2>

                default:
                    keycode = 0x0;
  100bae:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)
            };
            break;
  100bb2:	e9 00 00 00 00       	jmp    100bb7 <translate_scancode+0xa7>
    }

    if (keycode == 0) {
  100bb7:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  100bbb:	3d 00 00 00 00       	cmp    $0x0,%eax
  100bc0:	0f 85 20 00 00 00    	jne    100be6 <translate_scancode+0xd6>
  100bc6:	8d 05 80 92 10 00    	lea    0x109280,%eax
        kprintf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
  100bcc:	0f b7 4d fa          	movzwl -0x6(%ebp),%ecx
  100bd0:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100bd3:	89 04 24             	mov    %eax,(%esp)
  100bd6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100bda:	89 54 24 08          	mov    %edx,0x8(%esp)
  100bde:	e8 cd f6 ff ff       	call   1002b0 <kprintf>
  100be3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }

    return keycode;
  100be6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  100bea:	83 c4 28             	add    $0x28,%esp
  100bed:	5d                   	pop    %ebp
  100bee:	c3                   	ret    
  100bef:	90                   	nop

00100bf0 <getchar>:
}

static char getchar(uint8_t keycode) {
  100bf0:	55                   	push   %ebp
  100bf1:	89 e5                	mov    %esp,%ebp
  100bf3:	83 ec 08             	sub    $0x8,%esp
  100bf6:	8a 45 08             	mov    0x8(%ebp),%al
  100bf9:	88 45 ff             	mov    %al,-0x1(%ebp)
    uint32_t index = 0;
  100bfc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
  100c03:	8b 0d 18 a6 12 00    	mov    0x12a618,%ecx
  100c09:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100c0f:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100c15:	0f 84 07 00 00 00    	je     100c22 <getchar+0x32>
  100c1b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
  100c22:	a1 48 a6 12 00       	mov    0x12a648,%eax
  100c27:	25 01 00 00 00       	and    $0x1,%eax
  100c2c:	3d 00 00 00 00       	cmp    $0x0,%eax
  100c31:	0f 84 07 00 00 00    	je     100c3e <getchar+0x4e>
  100c37:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  100c3e:	8d 05 08 80 10 00    	lea    0x108008,%eax

    return kc_to_char[index][keycode];
  100c44:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  100c48:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100c4b:	c1 e2 07             	shl    $0x7,%edx
  100c4e:	01 d0                	add    %edx,%eax
  100c50:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  100c54:	83 c4 08             	add    $0x8,%esp
  100c57:	5d                   	pop    %ebp
  100c58:	c3                   	ret    
  100c59:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00100c60 <driver_keyboard_init>:
        }
    }
}

void driver_keyboard_init(void)
{
  100c60:	55                   	push   %ebp
  100c61:	89 e5                	mov    %esp,%ebp
  100c63:	56                   	push   %esi
  100c64:	83 ec 54             	sub    $0x54,%esp
  100c67:	b8 21 00 00 00       	mov    $0x21,%eax
  100c6c:	8d 0d 00 08 10 00    	lea    0x100800,%ecx
    register_intr_handler(0x21, &irq_handler);
  100c72:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100c79:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100c7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100c80:	e8 fb 11 00 00       	call   101e80 <register_intr_handler>
  100c85:	b8 64 00 00 00       	mov    $0x64,%eax

    while (inb(0x64) & 0x1) {
  100c8a:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100c91:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100c94:	e8 57 fe ff ff       	call   100af0 <inb>
  100c99:	0f b6 c8             	movzbl %al,%ecx
  100c9c:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100ca2:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100ca8:	0f 84 1c 00 00 00    	je     100cca <driver_keyboard_init+0x6a>
  100cae:	b8 60 00 00 00       	mov    $0x60,%eax
        inb(0x60);
  100cb3:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100cba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100cbd:	e8 2e fe ff ff       	call   100af0 <inb>
    }
  100cc2:	88 45 eb             	mov    %al,-0x15(%ebp)
  100cc5:	e9 bb ff ff ff       	jmp    100c85 <driver_keyboard_init+0x25>
  100cca:	b8 ed 00 00 00       	mov    $0xed,%eax
  100ccf:	8d 0d 70 a5 12 00    	lea    0x12a570,%ecx
  100cd5:	ba 00 00 00 00       	mov    $0x0,%edx
  100cda:	be 00 04 00 00       	mov    $0x400,%esi

    memset(key_flags, 0, 256 * sizeof(uint32_t));
  100cdf:	89 0c 24             	mov    %ecx,(%esp)
  100ce2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ce9:	00 
  100cea:	c7 44 24 08 00 04 00 	movl   $0x400,0x8(%esp)
  100cf1:	00 
  100cf2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100cf5:	89 75 e0             	mov    %esi,-0x20(%ebp)
  100cf8:	89 55 dc             	mov    %edx,-0x24(%ebp)
  100cfb:	e8 c0 49 00 00       	call   1056c0 <memset>

    // Leds alle ausloeschen
    send_command(0xED);
  100d00:	c7 04 24 ed 00 00 00 	movl   $0xed,(%esp)
  100d07:	e8 c4 00 00 00       	call   100dd0 <send_command>
  100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
    send_command(0);
  100d11:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100d18:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100d1b:	e8 b0 00 00 00       	call   100dd0 <send_command>
  100d20:	b8 f3 00 00 00       	mov    $0xf3,%eax

    // Schnellste Wiederholrate
    send_command(0xF3);
  100d25:	c7 04 24 f3 00 00 00 	movl   $0xf3,(%esp)
  100d2c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100d2f:	e8 9c 00 00 00       	call   100dd0 <send_command>
  100d34:	b8 00 00 00 00       	mov    $0x0,%eax
    send_command(0);
  100d39:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100d40:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100d43:	e8 88 00 00 00       	call   100dd0 <send_command>
  100d48:	b8 f4 00 00 00       	mov    $0xf4,%eax

    send_command(0xF4);
  100d4d:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp)
  100d54:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100d57:	e8 74 00 00 00       	call   100dd0 <send_command>
  100d5c:	8d 05 72 92 10 00    	lea    0x109272,%eax
  100d62:	8d 4d f8             	lea    -0x8(%ebp),%ecx

    vfs_create_kfile("/dev/keyboard", ramfs_fifo_driver_struct(), &(uint32_t){512});
  100d65:	89 45 c8             	mov    %eax,-0x38(%ebp)
  100d68:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  100d6b:	e8 70 30 00 00       	call   103de0 <ramfs_fifo_driver_struct>
  100d70:	c7 45 f8 00 02 00 00 	movl   $0x200,-0x8(%ebp)
  100d77:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  100d7a:	89 0c 24             	mov    %ecx,(%esp)
  100d7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d81:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  100d84:	89 44 24 08          	mov    %eax,0x8(%esp)
  100d88:	e8 c3 50 00 00       	call   105e50 <vfs_create_kfile>
  100d8d:	8d 0d 72 92 10 00    	lea    0x109272,%ecx
  100d93:	ba 02 00 00 00       	mov    $0x2,%edx
    charout = vfs_open("/dev/keyboard", FM_WRITE);
  100d98:	89 0c 24             	mov    %ecx,(%esp)
  100d9b:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  100da2:	00 
  100da3:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100da6:	89 55 bc             	mov    %edx,-0x44(%ebp)
  100da9:	e8 82 51 00 00       	call   105f30 <vfs_open>
  100dae:	a3 14 a0 10 00       	mov    %eax,0x10a014

    init_done = 1;
  100db3:	c7 05 10 a0 10 00 01 	movl   $0x1,0x10a010
  100dba:	00 00 00 
}
  100dbd:	83 c4 54             	add    $0x54,%esp
  100dc0:	5e                   	pop    %esi
  100dc1:	5d                   	pop    %ebp
  100dc2:	c3                   	ret    
  100dc3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  100dca:	84 00 00 00 00 00 

00100dd0 <send_command>:

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
  100dd0:	55                   	push   %ebp
  100dd1:	89 e5                	mov    %esp,%ebp
  100dd3:	83 ec 28             	sub    $0x28,%esp
  100dd6:	8a 45 08             	mov    0x8(%ebp),%al
  100dd9:	88 45 ff             	mov    %al,-0x1(%ebp)
    do {
        while (inb(0x64) & 0x2) {
  100ddc:	e9 00 00 00 00       	jmp    100de1 <send_command+0x11>
  100de1:	b8 64 00 00 00       	mov    $0x64,%eax
  100de6:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100ded:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100df0:	e8 fb fc ff ff       	call   100af0 <inb>
  100df5:	0f b6 c8             	movzbl %al,%ecx
  100df8:	81 e1 02 00 00 00    	and    $0x2,%ecx
  100dfe:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100e04:	0f 84 05 00 00 00    	je     100e0f <send_command+0x3f>
        }
  100e0a:	e9 d2 ff ff ff       	jmp    100de1 <send_command+0x11>
  100e0f:	b8 60 00 00 00       	mov    $0x60,%eax

        outb(0x60, command);
  100e14:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100e1b:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  100e1f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100e23:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100e26:	e8 65 00 00 00       	call   100e90 <outb>
  100e2b:	b8 64 00 00 00       	mov    $0x64,%eax

        while ((inb(0x64) & 0x1) == 0) {
  100e30:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100e37:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100e3a:	e8 b1 fc ff ff       	call   100af0 <inb>
  100e3f:	0f b6 c8             	movzbl %al,%ecx
  100e42:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100e48:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100e4e:	0f 85 05 00 00 00    	jne    100e59 <send_command+0x89>
        }
  100e54:	e9 d2 ff ff ff       	jmp    100e2b <send_command+0x5b>
    } while (inb(0x60) == 0xfe);
  100e59:	e9 00 00 00 00       	jmp    100e5e <send_command+0x8e>
  100e5e:	b8 60 00 00 00       	mov    $0x60,%eax
  100e63:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100e6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100e6d:	e8 7e fc ff ff       	call   100af0 <inb>
  100e72:	0f b6 c8             	movzbl %al,%ecx
  100e75:	81 f9 fe 00 00 00    	cmp    $0xfe,%ecx
  100e7b:	0f 84 5b ff ff ff    	je     100ddc <send_command+0xc>
}
  100e81:	83 c4 28             	add    $0x28,%esp
  100e84:	5d                   	pop    %ebp
  100e85:	c3                   	ret    
  100e86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  100e8d:	00 00 00 

00100e90 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  100e90:	55                   	push   %ebp
  100e91:	89 e5                	mov    %esp,%ebp
  100e93:	50                   	push   %eax
  100e94:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100e98:	66 89 c1             	mov    %ax,%cx
  100e9b:	8a 55 0c             	mov    0xc(%ebp),%dl
  100e9e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  100ea2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  100ea5:	8a 45 fd             	mov    -0x3(%ebp),%al
  100ea8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  100eac:	ee                   	out    %al,(%dx)
}
  100ead:	83 c4 04             	add    $0x4,%esp
  100eb0:	5d                   	pop    %ebp
  100eb1:	c3                   	ret    
  100eb2:	66 90                	xchg   %ax,%ax
  100eb4:	66 90                	xchg   %ax,%ax
  100eb6:	66 90                	xchg   %ax,%ax
  100eb8:	66 90                	xchg   %ax,%ax
  100eba:	66 90                	xchg   %ax,%ax
  100ebc:	66 90                	xchg   %ax,%ax
  100ebe:	66 90                	xchg   %ax,%ax

00100ec0 <load_gdt>:

#define GDT_ENTRIES 6

uint64_t gdt[GDT_ENTRIES];

void load_gdt() {
  100ec0:	55                   	push   %ebp
  100ec1:	89 e5                	mov    %esp,%ebp
	struct {
  100ec3:	83 ec 08             	sub    $0x8,%esp
  100ec6:	a1 24 90 10 00       	mov    0x109024,%eax
  100ecb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100ece:	66 8b 0d 28 90 10 00 	mov    0x109028,%cx
  100ed5:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
		uint16_t limit;
		void* pointer;
	}__attribute__((packed)) gdtp = { .limit = GDT_ENTRIES * 8 - 1, .pointer =
			gdt, };

	asm volatile("lgdt %0" : : "m" (gdtp));
  100ed9:	0f 01 55 f8          	lgdtl  -0x8(%ebp)

	asm ("mov $0x10, %ax");
  100edd:	66 b8 10 00          	mov    $0x10,%ax
	asm ("mov %ax, %ds");
  100ee1:	66 8e d8             	mov    %ax,%ds
	asm ("mov %ax, %es");
  100ee4:	66 8e c0             	mov    %ax,%es
	asm ("mov %ax, %fs");
  100ee7:	66 8e e0             	mov    %ax,%fs
	asm ("mov %ax, %gs");
  100eea:	66 8e e8             	mov    %ax,%gs
	asm ("mov %ax, %ss");
  100eed:	66 8e d0             	mov    %ax,%ss
	//asm ("ljmp $0x8, $.1");
	//asm (".1:");
}
  100ef0:	83 c4 08             	add    $0x8,%esp
  100ef3:	5d                   	pop    %ebp
  100ef4:	c3                   	ret    
  100ef5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  100efc:	00 00 00 00 

00100f00 <set_gdt_entry>:

void set_gdt_entry(int i, unsigned int base, unsigned int limit, int flags) {
  100f00:	55                   	push   %ebp
  100f01:	89 e5                	mov    %esp,%ebp
  100f03:	56                   	push   %esi
  100f04:	83 ec 10             	sub    $0x10,%esp
  100f07:	8b 45 14             	mov    0x14(%ebp),%eax
  100f0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100f0d:	8b 55 0c             	mov    0xc(%ebp),%edx
  100f10:	8b 75 08             	mov    0x8(%ebp),%esi
  100f13:	89 75 f8             	mov    %esi,-0x8(%ebp)
  100f16:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100f19:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gdt[i] = limit & 0xffffLL;
  100f1f:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  100f23:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100f26:	89 04 cd 70 a9 12 00 	mov    %eax,0x12a970(,%ecx,8)
  100f2d:	c7 04 cd 74 a9 12 00 	movl   $0x0,0x12a974(,%ecx,8)
  100f34:	00 00 00 00 
	gdt[i] |= (base & 0xffffffLL) << 16;
  100f38:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f3b:	25 ff ff ff 00       	and    $0xffffff,%eax
  100f40:	89 c1                	mov    %eax,%ecx
  100f42:	c1 e1 10             	shl    $0x10,%ecx
  100f45:	c1 e8 10             	shr    $0x10,%eax
  100f48:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100f4b:	8b 34 d5 74 a9 12 00 	mov    0x12a974(,%edx,8),%esi
  100f52:	09 f0                	or     %esi,%eax
  100f54:	8b 34 d5 70 a9 12 00 	mov    0x12a970(,%edx,8),%esi
  100f5b:	09 ce                	or     %ecx,%esi
  100f5d:	89 04 d5 74 a9 12 00 	mov    %eax,0x12a974(,%edx,8)
  100f64:	89 34 d5 70 a9 12 00 	mov    %esi,0x12a970(,%edx,8)
	gdt[i] |= (flags & 0xffLL) << 40;
  100f6b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100f6f:	c1 e0 08             	shl    $0x8,%eax
  100f72:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100f75:	8b 14 cd 70 a9 12 00 	mov    0x12a970(,%ecx,8),%edx
  100f7c:	8b 34 cd 74 a9 12 00 	mov    0x12a974(,%ecx,8),%esi
  100f83:	09 c6                	or     %eax,%esi
  100f85:	89 14 cd 70 a9 12 00 	mov    %edx,0x12a970(,%ecx,8)
  100f8c:	89 34 cd 74 a9 12 00 	mov    %esi,0x12a974(,%ecx,8)
	gdt[i] |= ((limit >> 16) & 0xfLL) << 48;
  100f93:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  100f97:	83 e0 0f             	and    $0xf,%eax
  100f9a:	c1 e0 10             	shl    $0x10,%eax
  100f9d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100fa0:	8b 14 cd 70 a9 12 00 	mov    0x12a970(,%ecx,8),%edx
  100fa7:	8b 34 cd 74 a9 12 00 	mov    0x12a974(,%ecx,8),%esi
  100fae:	09 c6                	or     %eax,%esi
  100fb0:	89 14 cd 70 a9 12 00 	mov    %edx,0x12a970(,%ecx,8)
  100fb7:	89 34 cd 74 a9 12 00 	mov    %esi,0x12a974(,%ecx,8)
	gdt[i] |= ((flags >> 8) & 0xffLL) << 52;
  100fbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100fc1:	c1 e0 0c             	shl    $0xc,%eax
  100fc4:	25 00 00 f0 0f       	and    $0xff00000,%eax
  100fc9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100fcc:	8b 14 cd 70 a9 12 00 	mov    0x12a970(,%ecx,8),%edx
  100fd3:	8b 34 cd 74 a9 12 00 	mov    0x12a974(,%ecx,8),%esi
  100fda:	09 c6                	or     %eax,%esi
  100fdc:	89 14 cd 70 a9 12 00 	mov    %edx,0x12a970(,%ecx,8)
  100fe3:	89 34 cd 74 a9 12 00 	mov    %esi,0x12a974(,%ecx,8)
	gdt[i] |= ((base >> 24) & 0xffLL) << 56;
  100fea:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100fee:	c1 e0 18             	shl    $0x18,%eax
  100ff1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100ff4:	8b 14 cd 70 a9 12 00 	mov    0x12a970(,%ecx,8),%edx
  100ffb:	8b 34 cd 74 a9 12 00 	mov    0x12a974(,%ecx,8),%esi
  101002:	09 c6                	or     %eax,%esi
  101004:	89 14 cd 70 a9 12 00 	mov    %edx,0x12a970(,%ecx,8)
  10100b:	89 34 cd 74 a9 12 00 	mov    %esi,0x12a974(,%ecx,8)
}
  101012:	83 c4 10             	add    $0x10,%esp
  101015:	5e                   	pop    %esi
  101016:	5d                   	pop    %ebp
  101017:	c3                   	ret    
  101018:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10101f:	00 

00101020 <init_gdt>:

void init_gdt(void) {
  101020:	55                   	push   %ebp
  101021:	89 e5                	mov    %esp,%ebp
  101023:	56                   	push   %esi
  101024:	83 ec 54             	sub    $0x54,%esp
  101027:	b8 00 00 00 00       	mov    $0x0,%eax
	set_gdt_entry(0, 0, 0, 0);
  10102c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  101033:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10103a:	00 
  10103b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101042:	00 
  101043:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10104a:	00 
  10104b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10104e:	e8 ad fe ff ff       	call   100f00 <set_gdt_entry>
  101053:	b8 01 00 00 00       	mov    $0x1,%eax
  101058:	b9 00 00 00 00       	mov    $0x0,%ecx
  10105d:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  101062:	be 9a 0c 00 00       	mov    $0xc9a,%esi
	set_gdt_entry(1, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  101067:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10106e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101075:	00 
  101076:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  10107d:	00 
  10107e:	c7 44 24 0c 9a 0c 00 	movl   $0xc9a,0xc(%esp)
  101085:	00 
  101086:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101089:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10108c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10108f:	89 75 e8             	mov    %esi,-0x18(%ebp)
  101092:	e8 69 fe ff ff       	call   100f00 <set_gdt_entry>
  101097:	b8 02 00 00 00       	mov    $0x2,%eax
  10109c:	b9 00 00 00 00       	mov    $0x0,%ecx
  1010a1:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  1010a6:	be 92 0c 00 00       	mov    $0xc92,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(2, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  1010ab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1010b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1010b9:	00 
  1010ba:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  1010c1:	00 
  1010c2:	c7 44 24 0c 92 0c 00 	movl   $0xc92,0xc(%esp)
  1010c9:	00 
  1010ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1010cd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1010d0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  1010d3:	89 75 d8             	mov    %esi,-0x28(%ebp)
  1010d6:	e8 25 fe ff ff       	call   100f00 <set_gdt_entry>
  1010db:	b8 03 00 00 00       	mov    $0x3,%eax
  1010e0:	b9 00 00 00 00       	mov    $0x0,%ecx
  1010e5:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  1010ea:	be fa 0c 00 00       	mov    $0xcfa,%esi
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(3, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  1010ef:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1010f6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1010fd:	00 
  1010fe:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  101105:	00 
  101106:	c7 44 24 0c fa 0c 00 	movl   $0xcfa,0xc(%esp)
  10110d:	00 
  10110e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  101111:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  101114:	89 55 cc             	mov    %edx,-0x34(%ebp)
  101117:	89 75 c8             	mov    %esi,-0x38(%ebp)
  10111a:	e8 e1 fd ff ff       	call   100f00 <set_gdt_entry>
  10111f:	b8 04 00 00 00       	mov    $0x4,%eax
  101124:	b9 00 00 00 00       	mov    $0x0,%ecx
  101129:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  10112e:	be f2 0c 00 00       	mov    $0xcf2,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);
	set_gdt_entry(4, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  101133:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10113a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101141:	00 
  101142:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  101149:	00 
  10114a:	c7 44 24 0c f2 0c 00 	movl   $0xcf2,0xc(%esp)
  101151:	00 
  101152:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  101155:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  101158:	89 55 bc             	mov    %edx,-0x44(%ebp)
  10115b:	89 75 b8             	mov    %esi,-0x48(%ebp)
  10115e:	e8 9d fd ff ff       	call   100f00 <set_gdt_entry>
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	load_gdt();
  101163:	e8 58 fd ff ff       	call   100ec0 <load_gdt>
}
  101168:	83 c4 54             	add    $0x54,%esp
  10116b:	5e                   	pop    %esi
  10116c:	5d                   	pop    %ebp
  10116d:	c3                   	ret    
  10116e:	66 90                	xchg   %ax,%ax

00101170 <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  101170:	55                   	push   %ebp
  101171:	89 e5                	mov    %esp,%ebp
  101173:	53                   	push   %ebx
  101174:	57                   	push   %edi
  101175:	56                   	push   %esi
  101176:	83 ec 10             	sub    $0x10,%esp
  101179:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  10117d:	66 89 c1             	mov    %ax,%cx
  101180:	8a 55 14             	mov    0x14(%ebp),%dl
  101183:	8b 45 0c             	mov    0xc(%ebp),%eax
  101186:	8b 75 08             	mov    0x8(%ebp),%esi
  101189:	89 75 f0             	mov    %esi,-0x10(%ebp)
  10118c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10118f:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  101193:	88 55 e9             	mov    %dl,-0x17(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  101196:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101199:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	idt[i] = handler & 0xffffLL;
  10119c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  1011a0:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1011a3:	89 04 f5 28 a0 10 00 	mov    %eax,0x10a028(,%esi,8)
  1011aa:	c7 04 f5 2c a0 10 00 	movl   $0x0,0x10a02c(,%esi,8)
  1011b1:	00 00 00 00 
	idt[i] |= (selector & 0xffffLL) << 16;
  1011b5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
  1011b9:	c1 e0 10             	shl    $0x10,%eax
  1011bc:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1011bf:	8b 3c f5 2c a0 10 00 	mov    0x10a02c(,%esi,8),%edi
  1011c6:	8b 1c f5 28 a0 10 00 	mov    0x10a028(,%esi,8),%ebx
  1011cd:	09 c3                	or     %eax,%ebx
  1011cf:	89 3c f5 2c a0 10 00 	mov    %edi,0x10a02c(,%esi,8)
  1011d6:	89 1c f5 28 a0 10 00 	mov    %ebx,0x10a028(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  1011dd:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  1011e1:	c1 e0 08             	shl    $0x8,%eax
  1011e4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1011e7:	8b 3c f5 28 a0 10 00 	mov    0x10a028(,%esi,8),%edi
  1011ee:	8b 1c f5 2c a0 10 00 	mov    0x10a02c(,%esi,8),%ebx
  1011f5:	09 c3                	or     %eax,%ebx
  1011f7:	89 3c f5 28 a0 10 00 	mov    %edi,0x10a028(,%esi,8)
  1011fe:	89 1c f5 2c a0 10 00 	mov    %ebx,0x10a02c(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  101205:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  101209:	c1 e0 10             	shl    $0x10,%eax
  10120c:	8b 75 f0             	mov    -0x10(%ebp),%esi
  10120f:	8b 3c f5 28 a0 10 00 	mov    0x10a028(,%esi,8),%edi
  101216:	8b 1c f5 2c a0 10 00 	mov    0x10a02c(,%esi,8),%ebx
  10121d:	09 c3                	or     %eax,%ebx
  10121f:	89 3c f5 28 a0 10 00 	mov    %edi,0x10a028(,%esi,8)
  101226:	89 1c f5 2c a0 10 00 	mov    %ebx,0x10a02c(,%esi,8)
}
  10122d:	83 c4 10             	add    $0x10,%esp
  101230:	5e                   	pop    %esi
  101231:	5f                   	pop    %edi
  101232:	5b                   	pop    %ebx
  101233:	5d                   	pop    %ebp
  101234:	c3                   	ret    
  101235:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10123c:	00 00 00 00 

00101240 <init_idt>:

void init_idt() {
  101240:	55                   	push   %ebp
  101241:	89 e5                	mov    %esp,%ebp
	struct {
  101243:	56                   	push   %esi
  101244:	81 ec 34 02 00 00    	sub    $0x234,%esp
  10124a:	a1 2a 90 10 00       	mov    0x10902a,%eax
  10124f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101252:	66 8b 0d 2e 90 10 00 	mov    0x10902e,%cx
  101259:	66 89 4d f4          	mov    %cx,-0xc(%ebp)
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;
  10125d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  101264:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10126b:	81 7d ec 40 00 00 00 	cmpl   $0x40,-0x14(%ebp)
  101272:	0f 8d 2c 00 00 00    	jge    1012a4 <init_idt+0x64>
		handler_set[i] = 0;
  101278:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10127b:	c7 04 85 28 a2 10 00 	movl   $0x0,0x10a228(,%eax,4)
  101282:	00 00 00 00 
		irq_rpcs[i] = 0;
  101286:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101289:	c7 04 85 28 a3 10 00 	movl   $0x0,0x10a328(,%eax,4)
  101290:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  101294:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101297:	05 01 00 00 00       	add    $0x1,%eax
  10129c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10129f:	e9 c7 ff ff ff       	jmp    10126b <init_idt+0x2b>
  1012a4:	b8 20 00 00 00       	mov    $0x20,%eax
  1012a9:	b9 11 00 00 00       	mov    $0x11,%ecx
		handler_set[i] = 0;
		irq_rpcs[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  1012ae:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1012b5:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  1012bc:	00 
  1012bd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1012c0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1012c3:	e8 88 0b 00 00       	call   101e50 <outb>
  1012c8:	b8 21 00 00 00       	mov    $0x21,%eax
  1012cd:	b9 20 00 00 00       	mov    $0x20,%ecx
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  1012d2:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1012d9:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  1012e0:	00 
  1012e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1012e4:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1012e7:	e8 64 0b 00 00       	call   101e50 <outb>
  1012ec:	b8 21 00 00 00       	mov    $0x21,%eax
  1012f1:	b9 04 00 00 00       	mov    $0x4,%ecx
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  1012f6:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1012fd:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  101304:	00 
  101305:	89 45 d8             	mov    %eax,-0x28(%ebp)
  101308:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  10130b:	e8 40 0b 00 00       	call   101e50 <outb>
  101310:	b8 21 00 00 00       	mov    $0x21,%eax
  101315:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0x21, 0x01); // ICW 4
  10131a:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101321:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  101328:	00 
  101329:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10132c:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  10132f:	e8 1c 0b 00 00       	call   101e50 <outb>
  101334:	b8 a0 00 00 00       	mov    $0xa0,%eax
  101339:	b9 11 00 00 00       	mov    $0x11,%ecx

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  10133e:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  101345:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  10134c:	00 
  10134d:	89 45 c8             	mov    %eax,-0x38(%ebp)
  101350:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  101353:	e8 f8 0a 00 00       	call   101e50 <outb>
  101358:	b8 a1 00 00 00       	mov    $0xa1,%eax
  10135d:	b9 28 00 00 00       	mov    $0x28,%ecx
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  101362:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  101369:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  101370:	00 
  101371:	89 45 c0             	mov    %eax,-0x40(%ebp)
  101374:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  101377:	e8 d4 0a 00 00       	call   101e50 <outb>
  10137c:	b8 a1 00 00 00       	mov    $0xa1,%eax
  101381:	b9 02 00 00 00       	mov    $0x2,%ecx
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  101386:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  10138d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  101394:	00 
  101395:	89 45 b8             	mov    %eax,-0x48(%ebp)
  101398:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  10139b:	e8 b0 0a 00 00       	call   101e50 <outb>
  1013a0:	b8 a1 00 00 00       	mov    $0xa1,%eax
  1013a5:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0xa1, 0x01); // ICW 4
  1013aa:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1013b1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1013b8:	00 
  1013b9:	89 45 b0             	mov    %eax,-0x50(%ebp)
  1013bc:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  1013bf:	e8 8c 0a 00 00       	call   101e50 <outb>
  1013c4:	b8 20 00 00 00       	mov    $0x20,%eax
  1013c9:	b9 00 00 00 00       	mov    $0x0,%ecx

	outb(0x20, 0x0);
  1013ce:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1013d5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1013dc:	00 
  1013dd:	89 45 a8             	mov    %eax,-0x58(%ebp)
  1013e0:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  1013e3:	e8 68 0a 00 00       	call   101e50 <outb>
  1013e8:	b8 a0 00 00 00       	mov    $0xa0,%eax
  1013ed:	b9 00 00 00 00       	mov    $0x0,%ecx
	outb(0xa0, 0x0);
  1013f2:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  1013f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101400:	00 
  101401:	89 45 a0             	mov    %eax,-0x60(%ebp)
  101404:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  101407:	e8 44 0a 00 00       	call   101e50 <outb>
  10140c:	b8 00 00 00 00       	mov    $0x0,%eax
  101411:	8d 0d a4 21 10 00    	lea    0x1021a4,%ecx
  101417:	ba 08 00 00 00       	mov    $0x8,%edx
  10141c:	be 8e 00 00 00       	mov    $0x8e,%esi

	idt_set_entry(0, intr_stub_0, 0x8,
  101421:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  101428:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10142c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101433:	00 
  101434:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10143b:	00 
  10143c:	89 45 98             	mov    %eax,-0x68(%ebp)
  10143f:	89 75 94             	mov    %esi,-0x6c(%ebp)
  101442:	89 55 90             	mov    %edx,-0x70(%ebp)
  101445:	e8 26 fd ff ff       	call   101170 <idt_set_entry>
  10144a:	b8 01 00 00 00       	mov    $0x1,%eax
  10144f:	8d 0d ad 21 10 00    	lea    0x1021ad,%ecx
  101455:	ba 08 00 00 00       	mov    $0x8,%edx
  10145a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  10145f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  101466:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10146a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101471:	00 
  101472:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101479:	00 
  10147a:	89 45 8c             	mov    %eax,-0x74(%ebp)
  10147d:	89 75 88             	mov    %esi,-0x78(%ebp)
  101480:	89 55 84             	mov    %edx,-0x7c(%ebp)
  101483:	e8 e8 fc ff ff       	call   101170 <idt_set_entry>
  101488:	b8 02 00 00 00       	mov    $0x2,%eax
  10148d:	8d 0d b6 21 10 00    	lea    0x1021b6,%ecx
  101493:	ba 08 00 00 00       	mov    $0x8,%edx
  101498:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  10149d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1014a4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014a8:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014af:	00 
  1014b0:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014b7:	00 
  1014b8:	89 45 80             	mov    %eax,-0x80(%ebp)
  1014bb:	89 b5 7c ff ff ff    	mov    %esi,-0x84(%ebp)
  1014c1:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
  1014c7:	e8 a4 fc ff ff       	call   101170 <idt_set_entry>
  1014cc:	b8 03 00 00 00       	mov    $0x3,%eax
  1014d1:	8d 0d bf 21 10 00    	lea    0x1021bf,%ecx
  1014d7:	ba 08 00 00 00       	mov    $0x8,%edx
  1014dc:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  1014e1:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1014e8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014ec:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014f3:	00 
  1014f4:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014fb:	00 
  1014fc:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  101502:	89 b5 70 ff ff ff    	mov    %esi,-0x90(%ebp)
  101508:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  10150e:	e8 5d fc ff ff       	call   101170 <idt_set_entry>
  101513:	b8 04 00 00 00       	mov    $0x4,%eax
  101518:	8d 0d c8 21 10 00    	lea    0x1021c8,%ecx
  10151e:	ba 08 00 00 00       	mov    $0x8,%edx
  101523:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  101528:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10152f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101533:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10153a:	00 
  10153b:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101542:	00 
  101543:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  101549:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
  10154f:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
  101555:	e8 16 fc ff ff       	call   101170 <idt_set_entry>
  10155a:	b8 05 00 00 00       	mov    $0x5,%eax
  10155f:	8d 0d d1 21 10 00    	lea    0x1021d1,%ecx
  101565:	ba 08 00 00 00       	mov    $0x8,%edx
  10156a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  10156f:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101576:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10157a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101581:	00 
  101582:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101589:	00 
  10158a:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  101590:	89 b5 58 ff ff ff    	mov    %esi,-0xa8(%ebp)
  101596:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
  10159c:	e8 cf fb ff ff       	call   101170 <idt_set_entry>
  1015a1:	b8 06 00 00 00       	mov    $0x6,%eax
  1015a6:	8d 0d da 21 10 00    	lea    0x1021da,%ecx
  1015ac:	ba 08 00 00 00       	mov    $0x8,%edx
  1015b1:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  1015b6:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1015bd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015c1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1015c8:	00 
  1015c9:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015d0:	00 
  1015d1:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  1015d7:	89 b5 4c ff ff ff    	mov    %esi,-0xb4(%ebp)
  1015dd:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
  1015e3:	e8 88 fb ff ff       	call   101170 <idt_set_entry>
  1015e8:	b8 07 00 00 00       	mov    $0x7,%eax
  1015ed:	8d 0d e3 21 10 00    	lea    0x1021e3,%ecx
  1015f3:	ba 08 00 00 00       	mov    $0x8,%edx
  1015f8:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  1015fd:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  101604:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101608:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10160f:	00 
  101610:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101617:	00 
  101618:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  10161e:	89 b5 40 ff ff ff    	mov    %esi,-0xc0(%ebp)
  101624:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
  10162a:	e8 41 fb ff ff       	call   101170 <idt_set_entry>
  10162f:	b8 08 00 00 00       	mov    $0x8,%eax
  101634:	8d 0d ec 21 10 00    	lea    0x1021ec,%ecx
  10163a:	ba 8e 00 00 00       	mov    $0x8e,%edx
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  10163f:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  101646:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10164a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101651:	00 
  101652:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101659:	00 
  10165a:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
  101660:	89 95 34 ff ff ff    	mov    %edx,-0xcc(%ebp)
  101666:	e8 05 fb ff ff       	call   101170 <idt_set_entry>
  10166b:	b8 09 00 00 00       	mov    $0x9,%eax
  101670:	8d 0d f3 21 10 00    	lea    0x1021f3,%ecx
  101676:	ba 08 00 00 00       	mov    $0x8,%edx
  10167b:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  101680:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  101687:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10168b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101692:	00 
  101693:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10169a:	00 
  10169b:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
  1016a1:	89 b5 2c ff ff ff    	mov    %esi,-0xd4(%ebp)
  1016a7:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%ebp)
  1016ad:	e8 be fa ff ff       	call   101170 <idt_set_entry>
  1016b2:	b8 0a 00 00 00       	mov    $0xa,%eax
  1016b7:	8d 0d fc 21 10 00    	lea    0x1021fc,%ecx
  1016bd:	ba 08 00 00 00       	mov    $0x8,%edx
  1016c2:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  1016c7:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1016ce:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016d2:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1016d9:	00 
  1016da:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1016e1:	00 
  1016e2:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  1016e8:	89 b5 20 ff ff ff    	mov    %esi,-0xe0(%ebp)
  1016ee:	89 95 1c ff ff ff    	mov    %edx,-0xe4(%ebp)
  1016f4:	e8 77 fa ff ff       	call   101170 <idt_set_entry>
  1016f9:	b8 0b 00 00 00       	mov    $0xb,%eax
  1016fe:	8d 0d 03 22 10 00    	lea    0x102203,%ecx
  101704:	ba 08 00 00 00       	mov    $0x8,%edx
  101709:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  10170e:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  101715:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101719:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101720:	00 
  101721:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101728:	00 
  101729:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  10172f:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%ebp)
  101735:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
  10173b:	e8 30 fa ff ff       	call   101170 <idt_set_entry>
  101740:	b8 0c 00 00 00       	mov    $0xc,%eax
  101745:	8d 0d 0a 22 10 00    	lea    0x10220a,%ecx
  10174b:	ba 08 00 00 00       	mov    $0x8,%edx
  101750:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  101755:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10175c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101760:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101767:	00 
  101768:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10176f:	00 
  101770:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  101776:	89 b5 08 ff ff ff    	mov    %esi,-0xf8(%ebp)
  10177c:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
  101782:	e8 e9 f9 ff ff       	call   101170 <idt_set_entry>
  101787:	b8 0d 00 00 00       	mov    $0xd,%eax
  10178c:	8d 0d 11 22 10 00    	lea    0x102211,%ecx
  101792:	ba 08 00 00 00       	mov    $0x8,%edx
  101797:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  10179c:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  1017a3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1017a7:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017ae:	00 
  1017af:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017b6:	00 
  1017b7:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
  1017bd:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
  1017c3:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
  1017c9:	e8 a2 f9 ff ff       	call   101170 <idt_set_entry>
  1017ce:	b8 0e 00 00 00       	mov    $0xe,%eax
  1017d3:	8d 0d 18 22 10 00    	lea    0x102218,%ecx
  1017d9:	ba 08 00 00 00       	mov    $0x8,%edx
  1017de:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  1017e3:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  1017ea:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1017ee:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017f5:	00 
  1017f6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017fd:	00 
  1017fe:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
  101804:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
  10180a:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
  101810:	e8 5b f9 ff ff       	call   101170 <idt_set_entry>
  101815:	b8 0f 00 00 00       	mov    $0xf,%eax
  10181a:	8d 0d 1c 22 10 00    	lea    0x10221c,%ecx
  101820:	ba 08 00 00 00       	mov    $0x8,%edx
  101825:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  10182a:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  101831:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101835:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10183c:	00 
  10183d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101844:	00 
  101845:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
  10184b:	89 b5 e4 fe ff ff    	mov    %esi,-0x11c(%ebp)
  101851:	89 95 e0 fe ff ff    	mov    %edx,-0x120(%ebp)
  101857:	e8 14 f9 ff ff       	call   101170 <idt_set_entry>
  10185c:	b8 10 00 00 00       	mov    $0x10,%eax
  101861:	8d 0d 22 22 10 00    	lea    0x102222,%ecx
  101867:	ba 08 00 00 00       	mov    $0x8,%edx
  10186c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  101871:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  101878:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10187c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101883:	00 
  101884:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10188b:	00 
  10188c:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
  101892:	89 b5 d8 fe ff ff    	mov    %esi,-0x128(%ebp)
  101898:	89 95 d4 fe ff ff    	mov    %edx,-0x12c(%ebp)
  10189e:	e8 cd f8 ff ff       	call   101170 <idt_set_entry>
  1018a3:	b8 11 00 00 00       	mov    $0x11,%eax
  1018a8:	8d 0d 28 22 10 00    	lea    0x102228,%ecx
  1018ae:	ba 08 00 00 00       	mov    $0x8,%edx
  1018b3:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  1018b8:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  1018bf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018c3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1018ca:	00 
  1018cb:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1018d2:	00 
  1018d3:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
  1018d9:	89 b5 cc fe ff ff    	mov    %esi,-0x134(%ebp)
  1018df:	89 95 c8 fe ff ff    	mov    %edx,-0x138(%ebp)
  1018e5:	e8 86 f8 ff ff       	call   101170 <idt_set_entry>
  1018ea:	b8 12 00 00 00       	mov    $0x12,%eax
  1018ef:	8d 0d 2c 22 10 00    	lea    0x10222c,%ecx
  1018f5:	ba 08 00 00 00       	mov    $0x8,%edx
  1018fa:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  1018ff:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  101906:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10190a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101911:	00 
  101912:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101919:	00 
  10191a:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  101920:	89 b5 c0 fe ff ff    	mov    %esi,-0x140(%ebp)
  101926:	89 95 bc fe ff ff    	mov    %edx,-0x144(%ebp)
  10192c:	e8 3f f8 ff ff       	call   101170 <idt_set_entry>
  101931:	b8 20 00 00 00       	mov    $0x20,%eax
  101936:	8d 0d 32 22 10 00    	lea    0x102232,%ecx
  10193c:	ba 08 00 00 00       	mov    $0x8,%edx
  101941:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  101946:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10194d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101951:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101958:	00 
  101959:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101960:	00 
  101961:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
  101967:	89 b5 b4 fe ff ff    	mov    %esi,-0x14c(%ebp)
  10196d:	89 95 b0 fe ff ff    	mov    %edx,-0x150(%ebp)
  101973:	e8 f8 f7 ff ff       	call   101170 <idt_set_entry>
  101978:	b8 21 00 00 00       	mov    $0x21,%eax
  10197d:	8d 0d 38 22 10 00    	lea    0x102238,%ecx
  101983:	ba 08 00 00 00       	mov    $0x8,%edx
  101988:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  10198d:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101994:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101998:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10199f:	00 
  1019a0:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1019a7:	00 
  1019a8:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
  1019ae:	89 b5 a8 fe ff ff    	mov    %esi,-0x158(%ebp)
  1019b4:	89 95 a4 fe ff ff    	mov    %edx,-0x15c(%ebp)
  1019ba:	e8 b1 f7 ff ff       	call   101170 <idt_set_entry>
  1019bf:	b8 22 00 00 00       	mov    $0x22,%eax
  1019c4:	8d 0d 3e 22 10 00    	lea    0x10223e,%ecx
  1019ca:	ba 08 00 00 00       	mov    $0x8,%edx
  1019cf:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  1019d4:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1019db:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1019df:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1019e6:	00 
  1019e7:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1019ee:	00 
  1019ef:	89 85 a0 fe ff ff    	mov    %eax,-0x160(%ebp)
  1019f5:	89 b5 9c fe ff ff    	mov    %esi,-0x164(%ebp)
  1019fb:	89 95 98 fe ff ff    	mov    %edx,-0x168(%ebp)
  101a01:	e8 6a f7 ff ff       	call   101170 <idt_set_entry>
  101a06:	b8 23 00 00 00       	mov    $0x23,%eax
  101a0b:	8d 0d 44 22 10 00    	lea    0x102244,%ecx
  101a11:	ba 08 00 00 00       	mov    $0x8,%edx
  101a16:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  101a1b:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  101a22:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101a26:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101a2d:	00 
  101a2e:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101a35:	00 
  101a36:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
  101a3c:	89 b5 90 fe ff ff    	mov    %esi,-0x170(%ebp)
  101a42:	89 95 8c fe ff ff    	mov    %edx,-0x174(%ebp)
  101a48:	e8 23 f7 ff ff       	call   101170 <idt_set_entry>
  101a4d:	b8 24 00 00 00       	mov    $0x24,%eax
  101a52:	8d 0d 4a 22 10 00    	lea    0x10224a,%ecx
  101a58:	ba 08 00 00 00       	mov    $0x8,%edx
  101a5d:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  101a62:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  101a69:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101a6d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101a74:	00 
  101a75:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101a7c:	00 
  101a7d:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
  101a83:	89 b5 84 fe ff ff    	mov    %esi,-0x17c(%ebp)
  101a89:	89 95 80 fe ff ff    	mov    %edx,-0x180(%ebp)
  101a8f:	e8 dc f6 ff ff       	call   101170 <idt_set_entry>
  101a94:	b8 25 00 00 00       	mov    $0x25,%eax
  101a99:	8d 0d 50 22 10 00    	lea    0x102250,%ecx
  101a9f:	ba 08 00 00 00       	mov    $0x8,%edx
  101aa4:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  101aa9:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  101ab0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101ab4:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101abb:	00 
  101abc:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101ac3:	00 
  101ac4:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
  101aca:	89 b5 78 fe ff ff    	mov    %esi,-0x188(%ebp)
  101ad0:	89 95 74 fe ff ff    	mov    %edx,-0x18c(%ebp)
  101ad6:	e8 95 f6 ff ff       	call   101170 <idt_set_entry>
  101adb:	b8 26 00 00 00       	mov    $0x26,%eax
  101ae0:	8d 0d 56 22 10 00    	lea    0x102256,%ecx
  101ae6:	ba 08 00 00 00       	mov    $0x8,%edx
  101aeb:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  101af0:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  101af7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101afb:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101b02:	00 
  101b03:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101b0a:	00 
  101b0b:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
  101b11:	89 b5 6c fe ff ff    	mov    %esi,-0x194(%ebp)
  101b17:	89 95 68 fe ff ff    	mov    %edx,-0x198(%ebp)
  101b1d:	e8 4e f6 ff ff       	call   101170 <idt_set_entry>
  101b22:	b8 27 00 00 00       	mov    $0x27,%eax
  101b27:	8d 0d 5c 22 10 00    	lea    0x10225c,%ecx
  101b2d:	ba 08 00 00 00       	mov    $0x8,%edx
  101b32:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  101b37:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
  101b3e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101b42:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101b49:	00 
  101b4a:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101b51:	00 
  101b52:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%ebp)
  101b58:	89 b5 60 fe ff ff    	mov    %esi,-0x1a0(%ebp)
  101b5e:	89 95 5c fe ff ff    	mov    %edx,-0x1a4(%ebp)
  101b64:	e8 07 f6 ff ff       	call   101170 <idt_set_entry>
  101b69:	b8 28 00 00 00       	mov    $0x28,%eax
  101b6e:	8d 0d 62 22 10 00    	lea    0x102262,%ecx
  101b74:	ba 08 00 00 00       	mov    $0x8,%edx
  101b79:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  101b7e:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  101b85:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101b89:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101b90:	00 
  101b91:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101b98:	00 
  101b99:	89 85 58 fe ff ff    	mov    %eax,-0x1a8(%ebp)
  101b9f:	89 b5 54 fe ff ff    	mov    %esi,-0x1ac(%ebp)
  101ba5:	89 95 50 fe ff ff    	mov    %edx,-0x1b0(%ebp)
  101bab:	e8 c0 f5 ff ff       	call   101170 <idt_set_entry>
  101bb0:	b8 29 00 00 00       	mov    $0x29,%eax
  101bb5:	8d 0d 68 22 10 00    	lea    0x102268,%ecx
  101bbb:	ba 08 00 00 00       	mov    $0x8,%edx
  101bc0:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  101bc5:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
  101bcc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101bd0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101bd7:	00 
  101bd8:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101bdf:	00 
  101be0:	89 85 4c fe ff ff    	mov    %eax,-0x1b4(%ebp)
  101be6:	89 b5 48 fe ff ff    	mov    %esi,-0x1b8(%ebp)
  101bec:	89 95 44 fe ff ff    	mov    %edx,-0x1bc(%ebp)
  101bf2:	e8 79 f5 ff ff       	call   101170 <idt_set_entry>
  101bf7:	b8 2a 00 00 00       	mov    $0x2a,%eax
  101bfc:	8d 0d 6e 22 10 00    	lea    0x10226e,%ecx
  101c02:	ba 08 00 00 00       	mov    $0x8,%edx
  101c07:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  101c0c:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
  101c13:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101c17:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101c1e:	00 
  101c1f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101c26:	00 
  101c27:	89 85 40 fe ff ff    	mov    %eax,-0x1c0(%ebp)
  101c2d:	89 b5 3c fe ff ff    	mov    %esi,-0x1c4(%ebp)
  101c33:	89 95 38 fe ff ff    	mov    %edx,-0x1c8(%ebp)
  101c39:	e8 32 f5 ff ff       	call   101170 <idt_set_entry>
  101c3e:	b8 2b 00 00 00       	mov    $0x2b,%eax
  101c43:	8d 0d 74 22 10 00    	lea    0x102274,%ecx
  101c49:	ba 08 00 00 00       	mov    $0x8,%edx
  101c4e:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  101c53:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  101c5a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101c5e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101c65:	00 
  101c66:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101c6d:	00 
  101c6e:	89 85 34 fe ff ff    	mov    %eax,-0x1cc(%ebp)
  101c74:	89 b5 30 fe ff ff    	mov    %esi,-0x1d0(%ebp)
  101c7a:	89 95 2c fe ff ff    	mov    %edx,-0x1d4(%ebp)
  101c80:	e8 eb f4 ff ff       	call   101170 <idt_set_entry>
  101c85:	b8 2c 00 00 00       	mov    $0x2c,%eax
  101c8a:	8d 0d 7a 22 10 00    	lea    0x10227a,%ecx
  101c90:	ba 08 00 00 00       	mov    $0x8,%edx
  101c95:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  101c9a:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  101ca1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101ca5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101cac:	00 
  101cad:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101cb4:	00 
  101cb5:	89 85 28 fe ff ff    	mov    %eax,-0x1d8(%ebp)
  101cbb:	89 b5 24 fe ff ff    	mov    %esi,-0x1dc(%ebp)
  101cc1:	89 95 20 fe ff ff    	mov    %edx,-0x1e0(%ebp)
  101cc7:	e8 a4 f4 ff ff       	call   101170 <idt_set_entry>
  101ccc:	b8 2d 00 00 00       	mov    $0x2d,%eax
  101cd1:	8d 0d 80 22 10 00    	lea    0x102280,%ecx
  101cd7:	ba 08 00 00 00       	mov    $0x8,%edx
  101cdc:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  101ce1:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  101ce8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101cec:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101cf3:	00 
  101cf4:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101cfb:	00 
  101cfc:	89 85 1c fe ff ff    	mov    %eax,-0x1e4(%ebp)
  101d02:	89 b5 18 fe ff ff    	mov    %esi,-0x1e8(%ebp)
  101d08:	89 95 14 fe ff ff    	mov    %edx,-0x1ec(%ebp)
  101d0e:	e8 5d f4 ff ff       	call   101170 <idt_set_entry>
  101d13:	b8 2e 00 00 00       	mov    $0x2e,%eax
  101d18:	8d 0d 86 22 10 00    	lea    0x102286,%ecx
  101d1e:	ba 08 00 00 00       	mov    $0x8,%edx
  101d23:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  101d28:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
  101d2f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d33:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101d3a:	00 
  101d3b:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101d42:	00 
  101d43:	89 85 10 fe ff ff    	mov    %eax,-0x1f0(%ebp)
  101d49:	89 b5 0c fe ff ff    	mov    %esi,-0x1f4(%ebp)
  101d4f:	89 95 08 fe ff ff    	mov    %edx,-0x1f8(%ebp)
  101d55:	e8 16 f4 ff ff       	call   101170 <idt_set_entry>
  101d5a:	b8 2f 00 00 00       	mov    $0x2f,%eax
  101d5f:	8d 0d 8c 22 10 00    	lea    0x10228c,%ecx
  101d65:	ba 08 00 00 00       	mov    $0x8,%edx
  101d6a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  101d6f:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
  101d76:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d7a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101d81:	00 
  101d82:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101d89:	00 
  101d8a:	89 85 04 fe ff ff    	mov    %eax,-0x1fc(%ebp)
  101d90:	89 b5 00 fe ff ff    	mov    %esi,-0x200(%ebp)
  101d96:	89 95 fc fd ff ff    	mov    %edx,-0x204(%ebp)
  101d9c:	e8 cf f3 ff ff       	call   101170 <idt_set_entry>
  101da1:	b8 30 00 00 00       	mov    $0x30,%eax
  101da6:	8d 0d 92 22 10 00    	lea    0x102292,%ecx
  101dac:	ba 08 00 00 00       	mov    $0x8,%edx
  101db1:	be ee 00 00 00       	mov    $0xee,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  101db6:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  101dbd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101dc1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101dc8:	00 
  101dc9:	c7 44 24 0c ee 00 00 	movl   $0xee,0xc(%esp)
  101dd0:	00 
  101dd1:	89 85 f8 fd ff ff    	mov    %eax,-0x208(%ebp)
  101dd7:	89 b5 f4 fd ff ff    	mov    %esi,-0x20c(%ebp)
  101ddd:	89 95 f0 fd ff ff    	mov    %edx,-0x210(%ebp)
  101de3:	e8 88 f3 ff ff       	call   101170 <idt_set_entry>
  101de8:	b8 05 00 00 00       	mov    $0x5,%eax
  101ded:	8d 0d 08 82 10 00    	lea    0x108208,%ecx
  101df3:	ba 80 00 00 00       	mov    $0x80,%edx
  101df8:	be e9 00 00 00       	mov    $0xe9,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  101dfd:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101e04:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101e08:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  101e0f:	00 
  101e10:	c7 44 24 0c e9 00 00 	movl   $0xe9,0xc(%esp)
  101e17:	00 
  101e18:	89 85 ec fd ff ff    	mov    %eax,-0x214(%ebp)
  101e1e:	89 b5 e8 fd ff ff    	mov    %esi,-0x218(%ebp)
  101e24:	89 95 e4 fd ff ff    	mov    %edx,-0x21c(%ebp)
  101e2a:	e8 d1 f0 ff ff       	call   100f00 <set_gdt_entry>
  101e2f:	b8 28 00 00 00       	mov    $0x28,%eax
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101e34:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  101e37:	0f 01 5d f0          	lidtl  -0x10(%ebp)
	asm volatile("sti");
  101e3b:	fb                   	sti    
}
  101e3c:	81 c4 34 02 00 00    	add    $0x234,%esp
  101e42:	5e                   	pop    %esi
  101e43:	5d                   	pop    %ebp
  101e44:	c3                   	ret    
  101e45:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  101e4c:	00 00 00 00 

00101e50 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  101e50:	55                   	push   %ebp
  101e51:	89 e5                	mov    %esp,%ebp
  101e53:	50                   	push   %eax
  101e54:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  101e58:	66 89 c1             	mov    %ax,%cx
  101e5b:	8a 55 0c             	mov    0xc(%ebp),%dl
  101e5e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  101e62:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  101e65:	8a 45 fd             	mov    -0x3(%ebp),%al
  101e68:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  101e6c:	ee                   	out    %al,(%dx)
}
  101e6d:	83 c4 04             	add    $0x4,%esp
  101e70:	5d                   	pop    %ebp
  101e71:	c3                   	ret    
  101e72:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101e79:	1f 84 00 00 00 00 00 

00101e80 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  101e80:	55                   	push   %ebp
  101e81:	89 e5                	mov    %esp,%ebp
  101e83:	83 ec 08             	sub    $0x8,%esp
  101e86:	8b 45 0c             	mov    0xc(%ebp),%eax
  101e89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101e8c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  101e8f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	handlers[i] = fn;
  101e92:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e95:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101e98:	89 04 8d 28 a4 10 00 	mov    %eax,0x10a428(,%ecx,4)
	handler_set[i] = 1;
  101e9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ea2:	c7 04 85 28 a2 10 00 	movl   $0x1,0x10a228(,%eax,4)
  101ea9:	01 00 00 00 
}
  101ead:	83 c4 08             	add    $0x8,%esp
  101eb0:	5d                   	pop    %ebp
  101eb1:	c3                   	ret    
  101eb2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101eb9:	1f 84 00 00 00 00 00 

00101ec0 <register_irq_rpc>:

uint32_t register_irq_rpc(uint32_t irq) {
  101ec0:	55                   	push   %ebp
  101ec1:	89 e5                	mov    %esp,%ebp
  101ec3:	83 ec 08             	sub    $0x8,%esp
  101ec6:	8b 45 08             	mov    0x8(%ebp),%eax
  101ec9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (irq >= 0x20 && irq <= 0x2f) {
  101ecc:	81 7d f8 20 00 00 00 	cmpl   $0x20,-0x8(%ebp)
  101ed3:	0f 82 2a 00 00 00    	jb     101f03 <register_irq_rpc+0x43>
  101ed9:	81 7d f8 2f 00 00 00 	cmpl   $0x2f,-0x8(%ebp)
  101ee0:	0f 87 1d 00 00 00    	ja     101f03 <register_irq_rpc+0x43>
        irq_rpcs[irq] = get_current_task()->PID;
  101ee6:	e8 a5 24 00 00       	call   104390 <get_current_task>
  101eeb:	8b 00                	mov    (%eax),%eax
  101eed:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101ef0:	89 04 8d 28 a3 10 00 	mov    %eax,0x10a328(,%ecx,4)
        return 1;
  101ef7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  101efe:	e9 07 00 00 00       	jmp    101f0a <register_irq_rpc+0x4a>
    }
    return 0;
  101f03:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  101f0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f0d:	83 c4 08             	add    $0x8,%esp
  101f10:	5d                   	pop    %ebp
  101f11:	c3                   	ret    
  101f12:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101f19:	1f 84 00 00 00 00 00 

00101f20 <disable_irq_rpc>:

void disable_irq_rpc(uint32_t irq) {
  101f20:	55                   	push   %ebp
  101f21:	89 e5                	mov    %esp,%ebp
  101f23:	50                   	push   %eax
  101f24:	8b 45 08             	mov    0x8(%ebp),%eax
  101f27:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (irq >= 0x20 && irq <= 0x2f) {
  101f2a:	81 7d fc 20 00 00 00 	cmpl   $0x20,-0x4(%ebp)
  101f31:	0f 82 3f 00 00 00    	jb     101f76 <disable_irq_rpc+0x56>
  101f37:	81 7d fc 2f 00 00 00 	cmpl   $0x2f,-0x4(%ebp)
  101f3e:	0f 87 32 00 00 00    	ja     101f76 <disable_irq_rpc+0x56>
        if(irq_rpcs[irq] > 0) {
  101f44:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f47:	81 3c 85 28 a3 10 00 	cmpl   $0x0,0x10a328(,%eax,4)
  101f4e:	00 00 00 00 
  101f52:	0f 8e 19 00 00 00    	jle    101f71 <disable_irq_rpc+0x51>
  101f58:	b8 00 00 00 00       	mov    $0x0,%eax
            irq_rpcs[irq] = -irq_rpcs[irq];
  101f5d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101f60:	2b 04 8d 28 a3 10 00 	sub    0x10a328(,%ecx,4),%eax
  101f67:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101f6a:	89 04 8d 28 a3 10 00 	mov    %eax,0x10a328(,%ecx,4)
        }
    }
  101f71:	e9 00 00 00 00       	jmp    101f76 <disable_irq_rpc+0x56>
}
  101f76:	83 c4 04             	add    $0x4,%esp
  101f79:	5d                   	pop    %ebp
  101f7a:	c3                   	ret    
  101f7b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00101f80 <enable_irq_rpc>:

void enable_irq_rpc(uint32_t irq) {
  101f80:	55                   	push   %ebp
  101f81:	89 e5                	mov    %esp,%ebp
  101f83:	50                   	push   %eax
  101f84:	8b 45 08             	mov    0x8(%ebp),%eax
  101f87:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (irq >= 0x20 && irq <= 0x2f) {
  101f8a:	81 7d fc 20 00 00 00 	cmpl   $0x20,-0x4(%ebp)
  101f91:	0f 82 3f 00 00 00    	jb     101fd6 <enable_irq_rpc+0x56>
  101f97:	81 7d fc 2f 00 00 00 	cmpl   $0x2f,-0x4(%ebp)
  101f9e:	0f 87 32 00 00 00    	ja     101fd6 <enable_irq_rpc+0x56>
        if(irq_rpcs[irq] < 0) {
  101fa4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101fa7:	81 3c 85 28 a3 10 00 	cmpl   $0x0,0x10a328(,%eax,4)
  101fae:	00 00 00 00 
  101fb2:	0f 8d 19 00 00 00    	jge    101fd1 <enable_irq_rpc+0x51>
  101fb8:	b8 00 00 00 00       	mov    $0x0,%eax
            irq_rpcs[irq] = -irq_rpcs[irq];
  101fbd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101fc0:	2b 04 8d 28 a3 10 00 	sub    0x10a328(,%ecx,4),%eax
  101fc7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101fca:	89 04 8d 28 a3 10 00 	mov    %eax,0x10a328(,%ecx,4)
        }
    }
  101fd1:	e9 00 00 00 00       	jmp    101fd6 <enable_irq_rpc+0x56>
}
  101fd6:	83 c4 04             	add    $0x4,%esp
  101fd9:	5d                   	pop    %ebp
  101fda:	c3                   	ret    
  101fdb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00101fe0 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  101fe0:	55                   	push   %ebp
  101fe1:	89 e5                	mov    %esp,%ebp
  101fe3:	83 ec 38             	sub    $0x38,%esp
  101fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  101fe9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	struct cpu_state* new_cpu = cpu;
  101fec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101fef:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (cpu->intr <= 0x1f) {
  101ff2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ff5:	81 78 1c 1f 00 00 00 	cmpl   $0x1f,0x1c(%eax)
  101ffc:	0f 87 3d 00 00 00    	ja     10203f <handle_interrupt+0x5f>
		if (!isSchedulingEnabled()) {
  102002:	e8 79 23 00 00       	call   104380 <isSchedulingEnabled>
  102007:	3d 00 00 00 00       	cmp    $0x0,%eax
  10200c:	0f 85 1a 00 00 00    	jne    10202c <handle_interrupt+0x4c>
  102012:	8d 05 a2 92 10 00    	lea    0x1092a2,%eax
			show_cod(cpu, "Kernel PANIC!");
  102018:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10201b:	89 0c 24             	mov    %ecx,(%esp)
  10201e:	89 44 24 04          	mov    %eax,0x4(%esp)
  102022:	e8 99 e0 ff ff       	call   1000c0 <show_cod>
		} else {
  102027:	e9 0e 00 00 00       	jmp    10203a <handle_interrupt+0x5a>
			new_cpu = schedule_exception(cpu);
  10202c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10202f:	89 04 24             	mov    %eax,(%esp)
  102032:	e8 19 25 00 00       	call   104550 <schedule_exception>
  102037:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  10203a:	e9 5c 01 00 00       	jmp    10219b <handle_interrupt+0x1bb>
  10203f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102042:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  102049:	0f 82 0a 01 00 00    	jb     102159 <handle_interrupt+0x179>
  10204f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102052:	81 78 1c 2f 00 00 00 	cmpl   $0x2f,0x1c(%eax)
  102059:	0f 87 fa 00 00 00    	ja     102159 <handle_interrupt+0x179>
		if (cpu->intr >= 0x28) {
  10205f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102062:	81 78 1c 28 00 00 00 	cmpl   $0x28,0x1c(%eax)
  102069:	0f 82 24 00 00 00    	jb     102093 <handle_interrupt+0xb3>
  10206f:	b8 a0 00 00 00       	mov    $0xa0,%eax
  102074:	b9 20 00 00 00       	mov    $0x20,%ecx
			outb(0xa0, 0x20);
  102079:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  102080:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  102087:	00 
  102088:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10208b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10208e:	e8 bd fd ff ff       	call   101e50 <outb>
		}

		if (cpu->intr == 0x20) {
  102093:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102096:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  10209d:	0f 85 13 00 00 00    	jne    1020b6 <handle_interrupt+0xd6>
			new_cpu = schedule(cpu);
  1020a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020a6:	89 04 24             	mov    %eax,(%esp)
  1020a9:	e8 e2 29 00 00       	call   104a90 <schedule>
  1020ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  1020b1:	e9 82 00 00 00       	jmp    102138 <handle_interrupt+0x158>
		else
		{
            if (handler_set[cpu->intr]) {
  1020b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020b9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1020bc:	81 3c 85 28 a2 10 00 	cmpl   $0x0,0x10a228(,%eax,4)
  1020c3:	00 00 00 00 
  1020c7:	0f 84 0d 00 00 00    	je     1020da <handle_interrupt+0xfa>
                handlers[cpu->intr]();
  1020cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020d0:	8b 40 1c             	mov    0x1c(%eax),%eax
  1020d3:	ff 14 85 28 a4 10 00 	call   *0x10a428(,%eax,4)
            }
            if(irq_rpcs[cpu->intr] > 0) {
  1020da:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020dd:	8b 40 1c             	mov    0x1c(%eax),%eax
  1020e0:	81 3c 85 28 a3 10 00 	cmpl   $0x0,0x10a328(,%eax,4)
  1020e7:	00 00 00 00 
  1020eb:	0f 8e 42 00 00 00    	jle    102133 <handle_interrupt+0x153>
  1020f1:	b8 00 00 00 00       	mov    $0x0,%eax
                create_rpc_call(irq_rpcs[cpu->intr], RPCT_IRQ, cpu->intr, 0, 0);
  1020f6:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1020f9:	8b 49 1c             	mov    0x1c(%ecx),%ecx
  1020fc:	8b 0c 8d 28 a3 10 00 	mov    0x10a328(,%ecx,4),%ecx
  102103:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102106:	8b 52 1c             	mov    0x1c(%edx),%edx
  102109:	89 0c 24             	mov    %ecx,(%esp)
  10210c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102113:	00 
  102114:	89 54 24 08          	mov    %edx,0x8(%esp)
  102118:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10211f:	00 
  102120:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  102127:	00 
  102128:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10212b:	e8 30 2b 00 00       	call   104c60 <create_rpc_call>
  102130:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102133:	e9 00 00 00 00       	jmp    102138 <handle_interrupt+0x158>
  102138:	b8 20 00 00 00       	mov    $0x20,%eax
                //disable_irq_rpc(cpu->intr); TODO find out if we need to block
            }
		}

        outb(0x20, 0x20);
  10213d:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  102144:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  10214b:	00 
  10214c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10214f:	e8 fc fc ff ff       	call   101e50 <outb>
	} else if (cpu->intr == 0x30) {
  102154:	e9 3d 00 00 00       	jmp    102196 <handle_interrupt+0x1b6>
  102159:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10215c:	81 78 1c 30 00 00 00 	cmpl   $0x30,0x1c(%eax)
  102163:	0f 85 13 00 00 00    	jne    10217c <handle_interrupt+0x19c>
		new_cpu = syscall(new_cpu);
  102169:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10216c:	89 04 24             	mov    %eax,(%esp)
  10216f:	e8 5c 01 00 00       	call   1022d0 <syscall>
  102174:	89 45 f8             	mov    %eax,-0x8(%ebp)
	} else {
  102177:	e9 15 00 00 00       	jmp    102191 <handle_interrupt+0x1b1>
  10217c:	8d 05 b0 92 10 00    	lea    0x1092b0,%eax
		show_cod(cpu, "Unknown Interrupt!");
  102182:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  102185:	89 0c 24             	mov    %ecx,(%esp)
  102188:	89 44 24 04          	mov    %eax,0x4(%esp)
  10218c:	e8 2f df ff ff       	call   1000c0 <show_cod>
  102191:	e9 00 00 00 00       	jmp    102196 <handle_interrupt+0x1b6>
  102196:	e9 00 00 00 00       	jmp    10219b <handle_interrupt+0x1bb>
	}

	return new_cpu;
  10219b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10219e:	83 c4 38             	add    $0x38,%esp
  1021a1:	5d                   	pop    %ebp
  1021a2:	c3                   	ret    
  1021a3:	90                   	nop

001021a4 <intr_stub_0>:
  1021a4:	6a 00                	push   $0x0
  1021a6:	6a 00                	push   $0x0
  1021a8:	e9 eb 00 00 00       	jmp    102298 <intr_common_handler>

001021ad <intr_stub_1>:
  1021ad:	6a 00                	push   $0x0
  1021af:	6a 01                	push   $0x1
  1021b1:	e9 e2 00 00 00       	jmp    102298 <intr_common_handler>

001021b6 <intr_stub_2>:
  1021b6:	6a 00                	push   $0x0
  1021b8:	6a 02                	push   $0x2
  1021ba:	e9 d9 00 00 00       	jmp    102298 <intr_common_handler>

001021bf <intr_stub_3>:
  1021bf:	6a 00                	push   $0x0
  1021c1:	6a 03                	push   $0x3
  1021c3:	e9 d0 00 00 00       	jmp    102298 <intr_common_handler>

001021c8 <intr_stub_4>:
  1021c8:	6a 00                	push   $0x0
  1021ca:	6a 04                	push   $0x4
  1021cc:	e9 c7 00 00 00       	jmp    102298 <intr_common_handler>

001021d1 <intr_stub_5>:
  1021d1:	6a 00                	push   $0x0
  1021d3:	6a 05                	push   $0x5
  1021d5:	e9 be 00 00 00       	jmp    102298 <intr_common_handler>

001021da <intr_stub_6>:
  1021da:	6a 00                	push   $0x0
  1021dc:	6a 06                	push   $0x6
  1021de:	e9 b5 00 00 00       	jmp    102298 <intr_common_handler>

001021e3 <intr_stub_7>:
  1021e3:	6a 00                	push   $0x0
  1021e5:	6a 07                	push   $0x7
  1021e7:	e9 ac 00 00 00       	jmp    102298 <intr_common_handler>

001021ec <intr_stub_8>:
  1021ec:	6a 08                	push   $0x8
  1021ee:	e9 a5 00 00 00       	jmp    102298 <intr_common_handler>

001021f3 <intr_stub_9>:
  1021f3:	6a 00                	push   $0x0
  1021f5:	6a 09                	push   $0x9
  1021f7:	e9 9c 00 00 00       	jmp    102298 <intr_common_handler>

001021fc <intr_stub_10>:
  1021fc:	6a 0a                	push   $0xa
  1021fe:	e9 95 00 00 00       	jmp    102298 <intr_common_handler>

00102203 <intr_stub_11>:
  102203:	6a 0b                	push   $0xb
  102205:	e9 8e 00 00 00       	jmp    102298 <intr_common_handler>

0010220a <intr_stub_12>:
  10220a:	6a 0c                	push   $0xc
  10220c:	e9 87 00 00 00       	jmp    102298 <intr_common_handler>

00102211 <intr_stub_13>:
  102211:	6a 0d                	push   $0xd
  102213:	e9 80 00 00 00       	jmp    102298 <intr_common_handler>

00102218 <intr_stub_14>:
  102218:	6a 0e                	push   $0xe
  10221a:	eb 7c                	jmp    102298 <intr_common_handler>

0010221c <intr_stub_15>:
  10221c:	6a 00                	push   $0x0
  10221e:	6a 0f                	push   $0xf
  102220:	eb 76                	jmp    102298 <intr_common_handler>

00102222 <intr_stub_16>:
  102222:	6a 00                	push   $0x0
  102224:	6a 10                	push   $0x10
  102226:	eb 70                	jmp    102298 <intr_common_handler>

00102228 <intr_stub_17>:
  102228:	6a 11                	push   $0x11
  10222a:	eb 6c                	jmp    102298 <intr_common_handler>

0010222c <intr_stub_18>:
  10222c:	6a 00                	push   $0x0
  10222e:	6a 12                	push   $0x12
  102230:	eb 66                	jmp    102298 <intr_common_handler>

00102232 <intr_stub_32>:
  102232:	6a 00                	push   $0x0
  102234:	6a 20                	push   $0x20
  102236:	eb 60                	jmp    102298 <intr_common_handler>

00102238 <intr_stub_33>:
  102238:	6a 00                	push   $0x0
  10223a:	6a 21                	push   $0x21
  10223c:	eb 5a                	jmp    102298 <intr_common_handler>

0010223e <intr_stub_34>:
  10223e:	6a 00                	push   $0x0
  102240:	6a 22                	push   $0x22
  102242:	eb 54                	jmp    102298 <intr_common_handler>

00102244 <intr_stub_35>:
  102244:	6a 00                	push   $0x0
  102246:	6a 23                	push   $0x23
  102248:	eb 4e                	jmp    102298 <intr_common_handler>

0010224a <intr_stub_36>:
  10224a:	6a 00                	push   $0x0
  10224c:	6a 24                	push   $0x24
  10224e:	eb 48                	jmp    102298 <intr_common_handler>

00102250 <intr_stub_37>:
  102250:	6a 00                	push   $0x0
  102252:	6a 25                	push   $0x25
  102254:	eb 42                	jmp    102298 <intr_common_handler>

00102256 <intr_stub_38>:
  102256:	6a 00                	push   $0x0
  102258:	6a 26                	push   $0x26
  10225a:	eb 3c                	jmp    102298 <intr_common_handler>

0010225c <intr_stub_39>:
  10225c:	6a 00                	push   $0x0
  10225e:	6a 27                	push   $0x27
  102260:	eb 36                	jmp    102298 <intr_common_handler>

00102262 <intr_stub_40>:
  102262:	6a 00                	push   $0x0
  102264:	6a 28                	push   $0x28
  102266:	eb 30                	jmp    102298 <intr_common_handler>

00102268 <intr_stub_41>:
  102268:	6a 00                	push   $0x0
  10226a:	6a 29                	push   $0x29
  10226c:	eb 2a                	jmp    102298 <intr_common_handler>

0010226e <intr_stub_42>:
  10226e:	6a 00                	push   $0x0
  102270:	6a 2a                	push   $0x2a
  102272:	eb 24                	jmp    102298 <intr_common_handler>

00102274 <intr_stub_43>:
  102274:	6a 00                	push   $0x0
  102276:	6a 2b                	push   $0x2b
  102278:	eb 1e                	jmp    102298 <intr_common_handler>

0010227a <intr_stub_44>:
  10227a:	6a 00                	push   $0x0
  10227c:	6a 2c                	push   $0x2c
  10227e:	eb 18                	jmp    102298 <intr_common_handler>

00102280 <intr_stub_45>:
  102280:	6a 00                	push   $0x0
  102282:	6a 2d                	push   $0x2d
  102284:	eb 12                	jmp    102298 <intr_common_handler>

00102286 <intr_stub_46>:
  102286:	6a 00                	push   $0x0
  102288:	6a 2e                	push   $0x2e
  10228a:	eb 0c                	jmp    102298 <intr_common_handler>

0010228c <intr_stub_47>:
  10228c:	6a 00                	push   $0x0
  10228e:	6a 2f                	push   $0x2f
  102290:	eb 06                	jmp    102298 <intr_common_handler>

00102292 <intr_stub_48>:
  102292:	6a 00                	push   $0x0
  102294:	6a 30                	push   $0x30
  102296:	eb 00                	jmp    102298 <intr_common_handler>

00102298 <intr_common_handler>:
  102298:	55                   	push   %ebp
  102299:	57                   	push   %edi
  10229a:	56                   	push   %esi
  10229b:	52                   	push   %edx
  10229c:	51                   	push   %ecx
  10229d:	53                   	push   %ebx
  10229e:	50                   	push   %eax
  10229f:	54                   	push   %esp
  1022a0:	66 b8 10 00          	mov    $0x10,%ax
  1022a4:	66 8e d8             	mov    %ax,%ds
  1022a7:	66 8e c0             	mov    %ax,%es
  1022aa:	e8 31 fd ff ff       	call   101fe0 <handle_interrupt>
  1022af:	89 c4                	mov    %eax,%esp
  1022b1:	66 b8 23 00          	mov    $0x23,%ax
  1022b5:	66 8e d8             	mov    %ax,%ds
  1022b8:	66 8e c0             	mov    %ax,%es
  1022bb:	58                   	pop    %eax
  1022bc:	5b                   	pop    %ebx
  1022bd:	59                   	pop    %ecx
  1022be:	5a                   	pop    %edx
  1022bf:	5e                   	pop    %esi
  1022c0:	5f                   	pop    %edi
  1022c1:	5d                   	pop    %ebp
  1022c2:	83 c4 08             	add    $0x8,%esp
  1022c5:	cf                   	iret   
  1022c6:	66 90                	xchg   %ax,%ax
  1022c8:	66 90                	xchg   %ax,%ax
  1022ca:	66 90                	xchg   %ax,%ax
  1022cc:	66 90                	xchg   %ax,%ax
  1022ce:	66 90                	xchg   %ax,%ax

001022d0 <syscall>:
    char* stdin;
    char* stdout;
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
  1022d0:	55                   	push   %ebp
  1022d1:	89 e5                	mov    %esp,%ebp
  1022d3:	53                   	push   %ebx
  1022d4:	57                   	push   %edi
  1022d5:	56                   	push   %esi
  1022d6:	81 ec 2c 01 00 00    	sub    $0x12c,%esp
  1022dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1022df:	89 45 ec             	mov    %eax,-0x14(%ebp)
    cpu = save_cpu_state(cpu);
  1022e2:	89 e1                	mov    %esp,%ecx
  1022e4:	89 01                	mov    %eax,(%ecx)
  1022e6:	e8 85 26 00 00       	call   104970 <save_cpu_state>
  1022eb:	89 45 ec             	mov    %eax,-0x14(%ebp)

	switch (cpu->eax) {
  1022ee:	8b 00                	mov    (%eax),%eax
  1022f0:	89 c1                	mov    %eax,%ecx
  1022f2:	81 e9 c8 00 00 00    	sub    $0xc8,%ecx
  1022f8:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  1022fe:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%ebp)
  102304:	0f 8f 32 00 00 00    	jg     10233c <syscall+0x6c>
  10230a:	e9 00 00 00 00       	jmp    10230f <syscall+0x3f>
  10230f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  102315:	48                   	dec    %eax
  102316:	89 c1                	mov    %eax,%ecx
  102318:	83 e9 27             	sub    $0x27,%ecx
  10231b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  102321:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%ebp)
  102327:	0f 87 b6 08 00 00    	ja     102be3 <syscall+0x913>
  10232d:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
  102333:	8b 0c 85 44 90 10 00 	mov    0x109044(,%eax,4),%ecx
  10233a:	ff e1                	jmp    *%ecx
  10233c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
  102342:	05 37 ff ff ff       	add    $0xffffff37,%eax
  102347:	89 c1                	mov    %eax,%ecx
  102349:	83 e9 04             	sub    $0x4,%ecx
  10234c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
  102352:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
  102358:	0f 87 85 08 00 00    	ja     102be3 <syscall+0x913>
  10235e:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  102364:	8b 0c 85 30 90 10 00 	mov    0x109030(,%eax,4),%ecx
  10236b:	ff e1                	jmp    *%ecx
	case 1: /* exit */
		return terminate_current(cpu);
  10236d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102370:	89 04 24             	mov    %eax,(%esp)
  102373:	e8 18 23 00 00       	call   104690 <terminate_current>
  102378:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10237b:	e9 86 08 00 00       	jmp    102c06 <syscall+0x936>

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  102380:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102383:	8b 40 04             	mov    0x4(%eax),%eax
  102386:	89 04 24             	mov    %eax,(%esp)
  102389:	e8 52 36 00 00       	call   1059e0 <strclone>
  10238e:	b9 00 00 00 00       	mov    $0x0,%ecx
  102393:	ba 10 00 00 00       	mov    $0x10,%edx
  102398:	8d 75 d0             	lea    -0x30(%ebp),%esi
  10239b:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct exec_info* einp = (void*) cpu->edx;
  10239e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1023a1:	8b 40 0c             	mov    0xc(%eax),%eax
  1023a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        struct exec_info ein = {
  1023a7:	89 34 24             	mov    %esi,(%esp)
  1023aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1023b1:	00 
  1023b2:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  1023b9:	00 
  1023ba:	89 95 64 ff ff ff    	mov    %edx,-0x9c(%ebp)
  1023c0:	89 8d 60 ff ff ff    	mov    %ecx,-0xa0(%ebp)
  1023c6:	e8 f5 32 00 00       	call   1056c0 <memset>
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };

        if(einp != 0) {
  1023cb:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  1023d2:	0f 84 43 00 00 00    	je     10241b <syscall+0x14b>
            ein.execPath = strclone(einp->execPath);
  1023d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1023db:	8b 00                	mov    (%eax),%eax
  1023dd:	89 04 24             	mov    %eax,(%esp)
  1023e0:	e8 fb 35 00 00       	call   1059e0 <strclone>
  1023e5:	89 45 d0             	mov    %eax,-0x30(%ebp)
            ein.stdin = strclone(einp->stdin);
  1023e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1023eb:	8b 40 04             	mov    0x4(%eax),%eax
  1023ee:	89 04 24             	mov    %eax,(%esp)
  1023f1:	e8 ea 35 00 00       	call   1059e0 <strclone>
  1023f6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            ein.stdout = strclone(einp->stdout);
  1023f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1023fc:	8b 40 08             	mov    0x8(%eax),%eax
  1023ff:	89 04 24             	mov    %eax,(%esp)
  102402:	e8 d9 35 00 00       	call   1059e0 <strclone>
  102407:	89 45 d8             	mov    %eax,-0x28(%ebp)
            ein.stderr = strclone(einp->stderr);
  10240a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10240d:	8b 40 0c             	mov    0xc(%eax),%eax
  102410:	89 04 24             	mov    %eax,(%esp)
  102413:	e8 c8 35 00 00       	call   1059e0 <strclone>
  102418:	89 45 dc             	mov    %eax,-0x24(%ebp)
        }

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  10241b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10241e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102421:	8b 49 08             	mov    0x8(%ecx),%ecx
  102424:	8b 55 d0             	mov    -0x30(%ebp),%edx
  102427:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  10242a:	8b 7d d8             	mov    -0x28(%ebp),%edi
  10242d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  102430:	89 04 24             	mov    %eax,(%esp)
  102433:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102437:	89 54 24 08          	mov    %edx,0x8(%esp)
  10243b:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10243f:	89 7c 24 10          	mov    %edi,0x10(%esp)
  102443:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  102447:	e8 b4 3e 00 00       	call   106300 <vfs_exec>
  10244c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10244f:	89 01                	mov    %eax,(%ecx)

        if(einp != 0) {
  102451:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  102458:	0f 84 2c 00 00 00    	je     10248a <syscall+0x1ba>
            free(ein.execPath);
  10245e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  102461:	89 04 24             	mov    %eax,(%esp)
  102464:	e8 87 2f 00 00       	call   1053f0 <free>
            free(ein.stdin);
  102469:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10246c:	89 04 24             	mov    %eax,(%esp)
  10246f:	e8 7c 2f 00 00       	call   1053f0 <free>
            free(ein.stdout);
  102474:	8b 45 d8             	mov    -0x28(%ebp),%eax
  102477:	89 04 24             	mov    %eax,(%esp)
  10247a:	e8 71 2f 00 00       	call   1053f0 <free>
            free(ein.stderr);
  10247f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102482:	89 04 24             	mov    %eax,(%esp)
  102485:	e8 66 2f 00 00       	call   1053f0 <free>
        }

        free(path);
  10248a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10248d:	89 04 24             	mov    %eax,(%esp)
  102490:	e8 5b 2f 00 00       	call   1053f0 <free>
    }
        break;
  102495:	e9 66 07 00 00       	jmp    102c00 <syscall+0x930>

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  10249a:	e8 f1 1e 00 00       	call   104390 <get_current_task>
  10249f:	8b 40 20             	mov    0x20(%eax),%eax
  1024a2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1024a5:	89 01                	mov    %eax,(%ecx)
    }
        break;
  1024a7:	e9 54 07 00 00       	jmp    102c00 <syscall+0x930>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
  1024ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1024af:	89 04 24             	mov    %eax,(%esp)
  1024b2:	e8 d9 25 00 00       	call   104a90 <schedule>
  1024b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
        break;
  1024ba:	e9 41 07 00 00       	jmp    102c00 <syscall+0x930>

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  1024bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1024c2:	8b 40 04             	mov    0x4(%eax),%eax
  1024c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  1024c8:	e8 c3 1e 00 00       	call   104390 <get_current_task>
  1024cd:	81 78 28 00 00 00 00 	cmpl   $0x0,0x28(%eax)
  1024d4:	0f 84 29 00 00 00    	je     102503 <syscall+0x233>
  1024da:	8b 45 cc             	mov    -0x34(%ebp),%eax
  1024dd:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  1024e3:	e8 a8 1e 00 00       	call   104390 <get_current_task>
  1024e8:	8b 40 28             	mov    0x28(%eax),%eax
  1024eb:	89 e1                	mov    %esp,%ecx
  1024ed:	89 41 04             	mov    %eax,0x4(%ecx)
  1024f0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
  1024f6:	89 01                	mov    %eax,(%ecx)
  1024f8:	e8 83 34 00 00       	call   105980 <strcpy>
  1024fd:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
    }
        break;
  102503:	e9 f8 06 00 00       	jmp    102c00 <syscall+0x930>

    case 7: /* changeExecPath */
    {
        vfs_reset_error();
  102508:	e8 73 37 00 00       	call   105c80 <vfs_reset_error>
        char* path = strclone((char*) cpu->ebx);
  10250d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102510:	8b 40 04             	mov    0x4(%eax),%eax
  102513:	89 04 24             	mov    %eax,(%esp)
  102516:	e8 c5 34 00 00       	call   1059e0 <strclone>
  10251b:	89 45 c8             	mov    %eax,-0x38(%ebp)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  10251e:	e8 6d 1e 00 00       	call   104390 <get_current_task>
  102523:	81 78 28 00 00 00 00 	cmpl   $0x0,0x28(%eax)
  10252a:	0f 84 10 00 00 00    	je     102540 <syscall+0x270>
  102530:	e8 5b 1e 00 00       	call   104390 <get_current_task>
  102535:	8b 40 28             	mov    0x28(%eax),%eax
  102538:	89 04 24             	mov    %eax,(%esp)
  10253b:	e8 b0 2e 00 00       	call   1053f0 <free>

        char* new = vfs_resolve_path(path);
  102540:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102543:	89 04 24             	mov    %eax,(%esp)
  102546:	e8 65 44 00 00       	call   1069b0 <vfs_resolve_path>
  10254b:	89 45 c4             	mov    %eax,-0x3c(%ebp)

        cpu->eax = 0;
  10254e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102551:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        if(new) {
  102557:	81 7d c4 00 00 00 00 	cmpl   $0x0,-0x3c(%ebp)
  10255e:	0f 84 20 00 00 00    	je     102584 <syscall+0x2b4>
            get_current_task()->execPath = new;
  102564:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  102567:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  10256d:	e8 1e 1e 00 00       	call   104390 <get_current_task>
  102572:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
  102578:	89 48 28             	mov    %ecx,0x28(%eax)
            cpu->eax = 1;
  10257b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10257e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        }

        free(path);
  102584:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102587:	89 04 24             	mov    %eax,(%esp)
  10258a:	e8 61 2e 00 00       	call   1053f0 <free>
    }
        break;
  10258f:	e9 6c 06 00 00       	jmp    102c00 <syscall+0x930>

	case 10: /* fopen */
	{
        vfs_reset_error();
  102594:	e8 e7 36 00 00       	call   105c80 <vfs_reset_error>
	    char* name = strclone((char*) cpu->ebx);
  102599:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10259c:	8b 40 04             	mov    0x4(%eax),%eax
  10259f:	89 04 24             	mov    %eax,(%esp)
  1025a2:	e8 39 34 00 00       	call   1059e0 <strclone>
  1025a7:	89 45 c0             	mov    %eax,-0x40(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  1025aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1025ad:	8b 40 08             	mov    0x8(%eax),%eax
  1025b0:	89 45 bc             	mov    %eax,-0x44(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  1025b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1025b6:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  1025b9:	89 04 24             	mov    %eax,(%esp)
  1025bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1025c0:	e8 6b 39 00 00       	call   105f30 <vfs_open>
  1025c5:	89 45 b8             	mov    %eax,-0x48(%ebp)
	    if(handle) {
  1025c8:	81 7d b8 00 00 00 00 	cmpl   $0x0,-0x48(%ebp)
  1025cf:	0f 84 1e 00 00 00    	je     1025f3 <syscall+0x323>
	        register_handle(handle);
  1025d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
  1025d8:	89 04 24             	mov    %eax,(%esp)
  1025db:	e8 20 1e 00 00       	call   104400 <register_handle>
	        cpu->eax = (uint32_t) handle;
  1025e0:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  1025e3:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1025e6:	89 0a                	mov    %ecx,(%edx)
	    }
  1025e8:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  1025ee:	e9 09 00 00 00       	jmp    1025fc <syscall+0x32c>
	    else
	    {
	        cpu->eax = 0;
  1025f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1025f6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }

	    free(name);
  1025fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1025ff:	89 04 24             	mov    %eax,(%esp)
  102602:	e8 e9 2d 00 00       	call   1053f0 <free>
	}
	    break;
  102607:	e9 f4 05 00 00       	jmp    102c00 <syscall+0x930>

	case 11: /* fclose */
	{
        vfs_reset_error();
  10260c:	e8 6f 36 00 00       	call   105c80 <vfs_reset_error>
	    struct res_handle* handle = (void*) cpu->ebx;
  102611:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102614:	8b 40 04             	mov    0x4(%eax),%eax
  102617:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	    if(!unregister_handle(handle)) {
  10261a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  10261d:	89 04 24             	mov    %eax,(%esp)
  102620:	e8 3b 1e 00 00       	call   104460 <unregister_handle>
  102625:	3d 00 00 00 00       	cmp    $0x0,%eax
  10262a:	0f 85 1f 00 00 00    	jne    10264f <syscall+0x37f>
	        vfs_close(handle);
  102630:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  102633:	89 04 24             	mov    %eax,(%esp)
  102636:	e8 75 39 00 00       	call   105fb0 <vfs_close>

	        cpu->eax = 0;
  10263b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10263e:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	    }
  102644:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
  10264a:	e9 09 00 00 00       	jmp    102658 <syscall+0x388>
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  10264f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102652:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  102658:	e9 a3 05 00 00       	jmp    102c00 <syscall+0x930>

	case 12: /* fwrite */
	{
        vfs_reset_error();
  10265d:	e8 1e 36 00 00       	call   105c80 <vfs_reset_error>
	    struct res_handle* handle = (void*) cpu->ebx;
  102662:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102665:	8b 40 04             	mov    0x4(%eax),%eax
  102668:	89 45 b0             	mov    %eax,-0x50(%ebp)
	    if(handle != 0) {
  10266b:	81 7d b0 00 00 00 00 	cmpl   $0x0,-0x50(%ebp)
  102672:	0f 84 3c 00 00 00    	je     1026b4 <syscall+0x3e4>
  102678:	b8 01 00 00 00       	mov    $0x1,%eax
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  10267d:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  102680:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102683:	8b 52 08             	mov    0x8(%edx),%edx
  102686:	8b 75 ec             	mov    -0x14(%ebp),%esi
  102689:	8b 76 0c             	mov    0xc(%esi),%esi
  10268c:	89 0c 24             	mov    %ecx,(%esp)
  10268f:	89 54 24 04          	mov    %edx,0x4(%esp)
  102693:	89 74 24 08          	mov    %esi,0x8(%esp)
  102697:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10269e:	00 
  10269f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
  1026a5:	e8 56 3a 00 00       	call   106100 <vfs_write>
  1026aa:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1026ad:	89 01                	mov    %eax,(%ecx)
	    }
  1026af:	e9 09 00 00 00       	jmp    1026bd <syscall+0x3ed>
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  1026b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1026b7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  1026bd:	e9 3e 05 00 00       	jmp    102c00 <syscall+0x930>

	case 13: /* fread */
	{
        vfs_reset_error();
  1026c2:	e8 b9 35 00 00       	call   105c80 <vfs_reset_error>
        struct res_handle* handle = (void*) cpu->ebx;
  1026c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1026ca:	8b 40 04             	mov    0x4(%eax),%eax
  1026cd:	89 45 ac             	mov    %eax,-0x54(%ebp)
        if(handle != 0) {
  1026d0:	81 7d ac 00 00 00 00 	cmpl   $0x0,-0x54(%ebp)
  1026d7:	0f 84 3c 00 00 00    	je     102719 <syscall+0x449>
  1026dd:	b8 01 00 00 00       	mov    $0x1,%eax
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  1026e2:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  1026e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1026e8:	8b 52 08             	mov    0x8(%edx),%edx
  1026eb:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1026ee:	8b 76 0c             	mov    0xc(%esi),%esi
  1026f1:	89 0c 24             	mov    %ecx,(%esp)
  1026f4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1026f8:	89 74 24 08          	mov    %esi,0x8(%esp)
  1026fc:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  102703:	00 
  102704:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  10270a:	e8 f1 38 00 00       	call   106000 <vfs_read>
  10270f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102712:	89 01                	mov    %eax,(%ecx)
        }
  102714:	e9 09 00 00 00       	jmp    102722 <syscall+0x452>
        else
        {
            cpu->eax = RW_ERR_VFS;
  102719:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10271c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  102722:	e9 d9 04 00 00       	jmp    102c00 <syscall+0x930>

	case 14: /* fmkfifo */
	{
        vfs_reset_error();
  102727:	e8 54 35 00 00       	call   105c80 <vfs_reset_error>
        char* name = strclone((char*) cpu->ebx);
  10272c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10272f:	8b 40 04             	mov    0x4(%eax),%eax
  102732:	89 04 24             	mov    %eax,(%esp)
  102735:	e8 a6 32 00 00       	call   1059e0 <strclone>
  10273a:	8d 4d a4             	lea    -0x5c(%ebp),%ecx
  10273d:	89 45 a8             	mov    %eax,-0x58(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  102740:	8b 45 a8             	mov    -0x58(%ebp),%eax
  102743:	89 8d 40 ff ff ff    	mov    %ecx,-0xc0(%ebp)
  102749:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
  10274f:	e8 8c 16 00 00       	call   103de0 <ramfs_fifo_driver_struct>
  102754:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
  10275b:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
  102761:	89 0c 24             	mov    %ecx,(%esp)
  102764:	89 44 24 04          	mov    %eax,0x4(%esp)
  102768:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
  10276e:	89 44 24 08          	mov    %eax,0x8(%esp)
  102772:	e8 d9 36 00 00       	call   105e50 <vfs_create_kfile>
  102777:	b9 03 00 00 00       	mov    $0x3,%ecx

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  10277c:	8b 55 a8             	mov    -0x58(%ebp),%edx
  10277f:	89 14 24             	mov    %edx,(%esp)
  102782:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  102789:	00 
  10278a:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
  102790:	89 8d 34 ff ff ff    	mov    %ecx,-0xcc(%ebp)
  102796:	e8 95 37 00 00       	call   105f30 <vfs_open>
  10279b:	89 45 a0             	mov    %eax,-0x60(%ebp)
        if(handle) {
  10279e:	81 7d a0 00 00 00 00 	cmpl   $0x0,-0x60(%ebp)
  1027a5:	0f 84 1e 00 00 00    	je     1027c9 <syscall+0x4f9>
            register_handle(handle);
  1027ab:	8b 45 a0             	mov    -0x60(%ebp),%eax
  1027ae:	89 04 24             	mov    %eax,(%esp)
  1027b1:	e8 4a 1c 00 00       	call   104400 <register_handle>
            cpu->eax = (uint32_t) handle;
  1027b6:	8b 4d a0             	mov    -0x60(%ebp),%ecx
  1027b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1027bc:	89 0a                	mov    %ecx,(%edx)
        }
  1027be:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
  1027c4:	e9 09 00 00 00       	jmp    1027d2 <syscall+0x502>
        else
        {
            cpu->eax = 0;
  1027c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        free(name);
  1027d2:	8b 45 a8             	mov    -0x58(%ebp),%eax
  1027d5:	89 04 24             	mov    %eax,(%esp)
  1027d8:	e8 13 2c 00 00       	call   1053f0 <free>
	}
	    break;
  1027dd:	e9 1e 04 00 00       	jmp    102c00 <syscall+0x930>

	case 15: /* getLastVFSErr */
	{
	    cpu->eax = get_current_task()->vfserr;
  1027e2:	e8 a9 1b 00 00       	call   104390 <get_current_task>
  1027e7:	8b 40 2c             	mov    0x2c(%eax),%eax
  1027ea:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1027ed:	89 01                	mov    %eax,(%ecx)
        vfs_reset_error();
  1027ef:	e8 8c 34 00 00       	call   105c80 <vfs_reset_error>
	}
	    break;
  1027f4:	e9 07 04 00 00       	jmp    102c00 <syscall+0x930>

	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  1027f9:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)

	    switch(cpu->ebx) {
  102800:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102803:	8b 40 04             	mov    0x4(%eax),%eax
  102806:	89 c1                	mov    %eax,%ecx
  102808:	83 e9 02             	sub    $0x2,%ecx
  10280b:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
  102811:	89 8d 28 ff ff ff    	mov    %ecx,-0xd8(%ebp)
  102817:	0f 84 52 00 00 00    	je     10286f <syscall+0x59f>
  10281d:	e9 00 00 00 00       	jmp    102822 <syscall+0x552>
  102822:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
  102828:	83 e8 01             	sub    $0x1,%eax
  10282b:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  102831:	0f 84 28 00 00 00    	je     10285f <syscall+0x58f>
  102837:	e9 00 00 00 00       	jmp    10283c <syscall+0x56c>
  10283c:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
  102842:	85 c0                	test   %eax,%eax
  102844:	0f 85 35 00 00 00    	jne    10287f <syscall+0x5af>
  10284a:	e9 00 00 00 00       	jmp    10284f <syscall+0x57f>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
  10284f:	e8 3c 1b 00 00       	call   104390 <get_current_task>
  102854:	8b 40 30             	mov    0x30(%eax),%eax
  102857:	89 45 9c             	mov    %eax,-0x64(%ebp)
	        break;
  10285a:	e9 2b 00 00 00       	jmp    10288a <syscall+0x5ba>
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  10285f:	e8 2c 1b 00 00       	call   104390 <get_current_task>
  102864:	8b 40 38             	mov    0x38(%eax),%eax
  102867:	89 45 9c             	mov    %eax,-0x64(%ebp)
            break;
  10286a:	e9 1b 00 00 00       	jmp    10288a <syscall+0x5ba>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  10286f:	e8 1c 1b 00 00       	call   104390 <get_current_task>
  102874:	8b 40 34             	mov    0x34(%eax),%eax
  102877:	89 45 9c             	mov    %eax,-0x64(%ebp)
            break;
  10287a:	e9 0b 00 00 00       	jmp    10288a <syscall+0x5ba>
        default:
            handle = get_current_task()->stdout;
  10287f:	e8 0c 1b 00 00       	call   104390 <get_current_task>
  102884:	8b 40 30             	mov    0x30(%eax),%eax
  102887:	89 45 9c             	mov    %eax,-0x64(%ebp)
            break;
	    }

	    cpu->eax = (uint32_t) handle;
  10288a:	8b 45 9c             	mov    -0x64(%ebp),%eax
  10288d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102890:	89 01                	mov    %eax,(%ecx)
	}
	    break;
  102892:	e9 69 03 00 00       	jmp    102c00 <syscall+0x930>

	case 21: /* fopenpmhandle */
	{
	    vfs_reset_error();
  102897:	e8 e4 33 00 00       	call   105c80 <vfs_reset_error>
	    char* path = strclone((char*)cpu->ecx);
  10289c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10289f:	8b 40 08             	mov    0x8(%eax),%eax
  1028a2:	89 04 24             	mov    %eax,(%esp)
  1028a5:	e8 36 31 00 00       	call   1059e0 <strclone>
  1028aa:	89 45 98             	mov    %eax,-0x68(%ebp)

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  1028ad:	c7 45 90 02 00 00 00 	movl   $0x2,-0x70(%ebp)

	    if(cpu->ebx == PMID_STDIN) {
  1028b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1028b7:	81 78 04 01 00 00 00 	cmpl   $0x1,0x4(%eax)
  1028be:	0f 85 07 00 00 00    	jne    1028cb <syscall+0x5fb>
	        fm = FM_READ;
  1028c4:	c7 45 90 01 00 00 00 	movl   $0x1,-0x70(%ebp)
	    }

	    open = vfs_open(path, fm);
  1028cb:	8b 45 98             	mov    -0x68(%ebp),%eax
  1028ce:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  1028d1:	89 04 24             	mov    %eax,(%esp)
  1028d4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1028d8:	e8 53 36 00 00       	call   105f30 <vfs_open>
  1028dd:	89 45 94             	mov    %eax,-0x6c(%ebp)

	    free(path);
  1028e0:	8b 45 98             	mov    -0x68(%ebp),%eax
  1028e3:	89 04 24             	mov    %eax,(%esp)
  1028e6:	e8 05 2b 00 00       	call   1053f0 <free>

	    if(!open) {
  1028eb:	81 7d 94 00 00 00 00 	cmpl   $0x0,-0x6c(%ebp)
  1028f2:	0f 85 0e 00 00 00    	jne    102906 <syscall+0x636>
	        cpu->eax = (uint32_t) -1;
  1028f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1028fb:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	        break;
  102901:	e9 fa 02 00 00       	jmp    102c00 <syscall+0x930>
	    }

	    struct res_handle* oldhandle = 0;
  102906:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%ebp)

        switch(cpu->ebx) {
  10290d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102910:	8b 40 04             	mov    0x4(%eax),%eax
  102913:	89 c1                	mov    %eax,%ecx
  102915:	83 e9 02             	sub    $0x2,%ecx
  102918:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
  10291e:	89 8d 1c ff ff ff    	mov    %ecx,-0xe4(%ebp)
  102924:	0f 84 80 00 00 00    	je     1029aa <syscall+0x6da>
  10292a:	e9 00 00 00 00       	jmp    10292f <syscall+0x65f>
  10292f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
  102935:	83 e8 01             	sub    $0x1,%eax
  102938:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  10293e:	0f 84 3f 00 00 00    	je     102983 <syscall+0x6b3>
  102944:	e9 00 00 00 00       	jmp    102949 <syscall+0x679>
  102949:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
  10294f:	85 c0                	test   %eax,%eax
  102951:	0f 85 7a 00 00 00    	jne    1029d1 <syscall+0x701>
  102957:	e9 00 00 00 00       	jmp    10295c <syscall+0x68c>
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  10295c:	e8 2f 1a 00 00       	call   104390 <get_current_task>
  102961:	8b 40 30             	mov    0x30(%eax),%eax
  102964:	89 45 8c             	mov    %eax,-0x74(%ebp)
            get_current_task()->stdout = open;
  102967:	8b 45 94             	mov    -0x6c(%ebp),%eax
  10296a:	89 85 14 ff ff ff    	mov    %eax,-0xec(%ebp)
  102970:	e8 1b 1a 00 00       	call   104390 <get_current_task>
  102975:	8b 8d 14 ff ff ff    	mov    -0xec(%ebp),%ecx
  10297b:	89 48 30             	mov    %ecx,0x30(%eax)
            break;
  10297e:	e9 70 00 00 00       	jmp    1029f3 <syscall+0x723>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  102983:	e8 08 1a 00 00       	call   104390 <get_current_task>
  102988:	8b 40 38             	mov    0x38(%eax),%eax
  10298b:	89 45 8c             	mov    %eax,-0x74(%ebp)
            get_current_task()->stdin = open;
  10298e:	8b 45 94             	mov    -0x6c(%ebp),%eax
  102991:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
  102997:	e8 f4 19 00 00       	call   104390 <get_current_task>
  10299c:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
  1029a2:	89 48 38             	mov    %ecx,0x38(%eax)
            break;
  1029a5:	e9 49 00 00 00       	jmp    1029f3 <syscall+0x723>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  1029aa:	e8 e1 19 00 00       	call   104390 <get_current_task>
  1029af:	8b 40 34             	mov    0x34(%eax),%eax
  1029b2:	89 45 8c             	mov    %eax,-0x74(%ebp)
            get_current_task()->stderr = open;
  1029b5:	8b 45 94             	mov    -0x6c(%ebp),%eax
  1029b8:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  1029be:	e8 cd 19 00 00       	call   104390 <get_current_task>
  1029c3:	8b 8d 0c ff ff ff    	mov    -0xf4(%ebp),%ecx
  1029c9:	89 48 34             	mov    %ecx,0x34(%eax)
            break;
  1029cc:	e9 22 00 00 00       	jmp    1029f3 <syscall+0x723>
        default:
            oldhandle = get_current_task()->stdout;
  1029d1:	e8 ba 19 00 00       	call   104390 <get_current_task>
  1029d6:	8b 40 30             	mov    0x30(%eax),%eax
  1029d9:	89 45 8c             	mov    %eax,-0x74(%ebp)
            get_current_task()->stdout = open;
  1029dc:	8b 45 94             	mov    -0x6c(%ebp),%eax
  1029df:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
  1029e5:	e8 a6 19 00 00       	call   104390 <get_current_task>
  1029ea:	8b 8d 08 ff ff ff    	mov    -0xf8(%ebp),%ecx
  1029f0:	89 48 30             	mov    %ecx,0x30(%eax)
            break;
        }

        if(oldhandle != 0) {
  1029f3:	81 7d 8c 00 00 00 00 	cmpl   $0x0,-0x74(%ebp)
  1029fa:	0f 84 11 00 00 00    	je     102a11 <syscall+0x741>
            vfs_close(oldhandle);
  102a00:	8b 45 8c             	mov    -0x74(%ebp),%eax
  102a03:	89 04 24             	mov    %eax,(%esp)
  102a06:	e8 a5 35 00 00       	call   105fb0 <vfs_close>
  102a0b:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
        }

        cpu->eax = 0;
  102a11:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	    break;
  102a1a:	e9 e1 01 00 00       	jmp    102c00 <syscall+0x930>

	case 30: /* return_rpc */
	{
	    cpu = return_rpc_call(cpu);
  102a1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a22:	89 04 24             	mov    %eax,(%esp)
  102a25:	e8 56 24 00 00       	call   104e80 <return_rpc_call>
  102a2a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}
	    break;
  102a2d:	e9 ce 01 00 00       	jmp    102c00 <syscall+0x930>

	case 31: /* call_rpc */
	{
	    int PID = cpu->ebx;
  102a32:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a35:	8b 40 04             	mov    0x4(%eax),%eax
  102a38:	89 45 88             	mov    %eax,-0x78(%ebp)

	    //TODO create RPC for U2U
	}
	    break;
  102a3b:	e9 c0 01 00 00       	jmp    102c00 <syscall+0x930>

	case 32: /* set_rpc_handler */
	{
	    uint32_t handlerAddr = cpu->ebx;
  102a40:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a43:	8b 40 04             	mov    0x4(%eax),%eax
  102a46:	89 45 84             	mov    %eax,-0x7c(%ebp)
	    if(get_current_task()->rpc_handler_addr == 0) {
  102a49:	e8 42 19 00 00       	call   104390 <get_current_task>
  102a4e:	81 78 1c 00 00 00 00 	cmpl   $0x0,0x1c(%eax)
  102a55:	0f 85 17 00 00 00    	jne    102a72 <syscall+0x7a2>
	        get_current_task()->rpc_handler_addr = handlerAddr;
  102a5b:	8b 45 84             	mov    -0x7c(%ebp),%eax
  102a5e:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
  102a64:	e8 27 19 00 00       	call   104390 <get_current_task>
  102a69:	8b 8d 00 ff ff ff    	mov    -0x100(%ebp),%ecx
  102a6f:	89 48 1c             	mov    %ecx,0x1c(%eax)
	    }
	}
	    break;
  102a72:	e9 89 01 00 00       	jmp    102c00 <syscall+0x930>

	case 33: /* fetch_rpc_data */
	{
	    cpu->eax = 0;
  102a77:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a7a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    void* dest = (void*) cpu->ebx;
  102a80:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a83:	8b 40 04             	mov    0x4(%eax),%eax
  102a86:	89 45 80             	mov    %eax,-0x80(%ebp)
	    if(get_current_task()->rpc != 0) {
  102a89:	e8 02 19 00 00       	call   104390 <get_current_task>
  102a8e:	81 78 18 00 00 00 00 	cmpl   $0x0,0x18(%eax)
  102a95:	0f 84 51 00 00 00    	je     102aec <syscall+0x81c>
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
  102a9b:	8b 45 80             	mov    -0x80(%ebp),%eax
  102a9e:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
  102aa4:	e8 e7 18 00 00       	call   104390 <get_current_task>
  102aa9:	8b 40 18             	mov    0x18(%eax),%eax
  102aac:	8b 40 0c             	mov    0xc(%eax),%eax
  102aaf:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
  102ab5:	e8 d6 18 00 00       	call   104390 <get_current_task>
  102aba:	8b 40 18             	mov    0x18(%eax),%eax
  102abd:	8b 40 10             	mov    0x10(%eax),%eax
  102ac0:	8b 8d fc fe ff ff    	mov    -0x104(%ebp),%ecx
  102ac6:	89 0c 24             	mov    %ecx,(%esp)
  102ac9:	8b 95 f8 fe ff ff    	mov    -0x108(%ebp),%edx
  102acf:	89 54 24 04          	mov    %edx,0x4(%esp)
  102ad3:	89 44 24 08          	mov    %eax,0x8(%esp)
  102ad7:	e8 44 2c 00 00       	call   105720 <memcpy>
	        cpu->eax = get_current_task()->rpc->dataSize;
  102adc:	e8 af 18 00 00       	call   104390 <get_current_task>
  102ae1:	8b 40 18             	mov    0x18(%eax),%eax
  102ae4:	8b 40 10             	mov    0x10(%eax),%eax
  102ae7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102aea:	89 01                	mov    %eax,(%ecx)
	    }
	}
	    break;
  102aec:	e9 0f 01 00 00       	jmp    102c00 <syscall+0x930>

	case 40:
	{
	    cpu->eax = register_irq_rpc(cpu->ebx);
  102af1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102af4:	8b 40 04             	mov    0x4(%eax),%eax
  102af7:	89 04 24             	mov    %eax,(%esp)
  102afa:	e8 c1 f3 ff ff       	call   101ec0 <register_irq_rpc>
  102aff:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b02:	89 01                	mov    %eax,(%ecx)
	}
	    break;
  102b04:	e9 f7 00 00 00       	jmp    102c00 <syscall+0x930>
  102b09:	8d 05 c3 92 10 00    	lea    0x1092c3,%eax

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  102b0f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b12:	8b 49 04             	mov    0x4(%ecx),%ecx
  102b15:	89 04 24             	mov    %eax,(%esp)
  102b18:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102b1c:	e8 8f d7 ff ff       	call   1002b0 <kprintf>
  102b21:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b24:	89 01                	mov    %eax,(%ecx)
		break;
  102b26:	e9 d5 00 00 00       	jmp    102c00 <syscall+0x930>
  102b2b:	8d 05 c6 92 10 00    	lea    0x1092c6,%eax

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  102b31:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b34:	8b 49 04             	mov    0x4(%ecx),%ecx
  102b37:	89 04 24             	mov    %eax,(%esp)
  102b3a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102b3e:	e8 6d d7 ff ff       	call   1002b0 <kprintf>
  102b43:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b46:	89 01                	mov    %eax,(%ecx)
		break;
  102b48:	e9 b3 00 00 00       	jmp    102c00 <syscall+0x930>

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  102b4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b50:	8b 40 04             	mov    0x4(%eax),%eax
  102b53:	89 04 24             	mov    %eax,(%esp)
  102b56:	e8 65 4d 00 00       	call   1078c0 <vmm_alloc_ucont>
  102b5b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b5e:	89 01                	mov    %eax,(%ecx)
		break;
  102b60:	e9 9b 00 00 00       	jmp    102c00 <syscall+0x930>

	case 204: /* vmm_free */
		cpu->eax = 0;
  102b65:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b68:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  102b6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b71:	81 78 04 00 10 40 01 	cmpl   $0x1401000,0x4(%eax)
  102b78:	0f 82 0e 00 00 00    	jb     102b8c <syscall+0x8bc>
			vmm_free((void*) cpu->ebx);
  102b7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b81:	8b 40 04             	mov    0x4(%eax),%eax
  102b84:	89 04 24             	mov    %eax,(%esp)
  102b87:	e8 b4 49 00 00       	call   107540 <vmm_free>
		}
		break;
  102b8c:	e9 6f 00 00 00       	jmp    102c00 <syscall+0x930>
  102b91:	b8 01 00 00 00       	mov    $0x1,%eax
  102b96:	b9 00 00 00 00       	mov    $0x0,%ecx

	case 205: /* pmm_print_stats */
		pmm_print_stats();
  102b9b:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
  102ba1:	89 8d f0 fe ff ff    	mov    %ecx,-0x110(%ebp)
  102ba7:	e8 34 04 00 00       	call   102fe0 <pmm_print_stats>
        create_rpc_call(1, RPCT_KERNEL, 1, 0, 0);
  102bac:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  102bb3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  102bba:	00 
  102bbb:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  102bc2:	00 
  102bc3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102bca:	00 
  102bcb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  102bd2:	00 
  102bd3:	e8 88 20 00 00       	call   104c60 <create_rpc_call>
		break;
  102bd8:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  102bde:	e9 1d 00 00 00       	jmp    102c00 <syscall+0x930>
  102be3:	8d 05 c9 92 10 00    	lea    0x1092c9,%eax

	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  102be9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102bec:	8b 09                	mov    (%ecx),%ecx
  102bee:	89 04 24             	mov    %eax,(%esp)
  102bf1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102bf5:	e8 b6 d6 ff ff       	call   1002b0 <kprintf>
  102bfa:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		break;
	}

	return cpu;
  102c00:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102c03:	89 45 f0             	mov    %eax,-0x10(%ebp)
}
  102c06:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c09:	81 c4 2c 01 00 00    	add    $0x12c,%esp
  102c0f:	5e                   	pop    %esi
  102c10:	5f                   	pop    %edi
  102c11:	5b                   	pop    %ebx
  102c12:	5d                   	pop    %ebp
  102c13:	c3                   	ret    
  102c14:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102c1b:	00 00 00 00 00 

00102c20 <kernel_main>:

void kernel_main(struct multiboot_info* mb_info) {
  102c20:	55                   	push   %ebp
  102c21:	89 e5                	mov    %esp,%ebp
  102c23:	57                   	push   %edi
  102c24:	56                   	push   %esi
  102c25:	83 ec 70             	sub    $0x70,%esp
  102c28:	8b 45 08             	mov    0x8(%ebp),%eax
  102c2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t kernel_init_pdir = vmm_init();
  102c2e:	e8 dd 4f 00 00       	call   107c10 <vmm_init>
  102c33:	8d 0d df 92 10 00    	lea    0x1092df,%ecx
  102c39:	89 45 f0             	mov    %eax,-0x10(%ebp)

	kprintf("Setting PIT interval...\n");
  102c3c:	89 0c 24             	mov    %ecx,(%esp)
  102c3f:	e8 6c d6 ff ff       	call   1002b0 <kprintf>
  102c44:	b9 43 00 00 00       	mov    $0x43,%ecx
  102c49:	ba 36 00 00 00       	mov    $0x36,%edx

	outb(0x43, 0x36);
  102c4e:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
  102c55:	c7 44 24 04 36 00 00 	movl   $0x36,0x4(%esp)
  102c5c:	00 
  102c5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102c60:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102c63:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  102c66:	e8 25 02 00 00       	call   102e90 <outb>
  102c6b:	b8 40 00 00 00       	mov    $0x40,%eax
  102c70:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
	outw(0x40, 1000);
  102c75:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  102c7c:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  102c83:	00 
  102c84:	89 45 e0             	mov    %eax,-0x20(%ebp)
  102c87:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  102c8a:	e8 31 02 00 00       	call   102ec0 <outw>
  102c8f:	8d 05 f8 92 10 00    	lea    0x1092f8,%eax

    kprintf("Initializing vfs...\n");
  102c95:	89 04 24             	mov    %eax,(%esp)
  102c98:	e8 13 d6 ff ff       	call   1002b0 <kprintf>

    vfs_init_root();
  102c9d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  102ca0:	e8 fb 3d 00 00       	call   106aa0 <vfs_init_root>
    ramfs_fifo_init();
  102ca5:	e8 c6 0b 00 00       	call   103870 <ramfs_fifo_init>
    ramfs_block_init();
  102caa:	e8 11 07 00 00       	call   1033c0 <ramfs_block_init>

    driver_keyboard_init();
  102caf:	e8 ac df ff ff       	call   100c60 <driver_keyboard_init>
  102cb4:	b8 00 00 00 00       	mov    $0x0,%eax


    map_address_active((uint32_t) mb_info,
  102cb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102cbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102cbf:	89 0c 24             	mov    %ecx,(%esp)
  102cc2:	89 54 24 04          	mov    %edx,0x4(%esp)
  102cc6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102ccd:	00 
  102cce:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102cd1:	e8 ea 48 00 00       	call   1075c0 <map_address_active>
  102cd6:	b8 00 00 00 00       	mov    $0x0,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  102cdb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102cde:	8b 49 18             	mov    0x18(%ecx),%ecx
  102ce1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102ce4:	8b 52 18             	mov    0x18(%edx),%edx
  102ce7:	89 0c 24             	mov    %ecx,(%esp)
  102cea:	89 54 24 04          	mov    %edx,0x4(%esp)
  102cee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102cf5:	00 
  102cf6:	89 45 d0             	mov    %eax,-0x30(%ebp)
  102cf9:	e8 c2 48 00 00       	call   1075c0 <map_address_active>
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  102cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d01:	8b 00                	mov    (%eax),%eax
  102d03:	25 08 00 00 00       	and    $0x8,%eax
  102d08:	3d 00 00 00 00       	cmp    $0x0,%eax
  102d0d:	0f 84 aa 00 00 00    	je     102dbd <kernel_main+0x19d>
  102d13:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  102d18:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102d1b:	8b 49 18             	mov    0x18(%ecx),%ecx
  102d1e:	8b 09                	mov    (%ecx),%ecx
  102d20:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102d23:	8b 52 18             	mov    0x18(%edx),%edx
  102d26:	8b 12                	mov    (%edx),%edx
  102d28:	8b 75 f4             	mov    -0xc(%ebp),%esi
  102d2b:	8b 76 18             	mov    0x18(%esi),%esi
  102d2e:	8b 76 04             	mov    0x4(%esi),%esi
  102d31:	8b 7d f4             	mov    -0xc(%ebp),%edi
  102d34:	8b 7f 18             	mov    0x18(%edi),%edi
  102d37:	8b 3f                	mov    (%edi),%edi
  102d39:	29 fe                	sub    %edi,%esi
  102d3b:	89 0c 24             	mov    %ecx,(%esp)
  102d3e:	89 54 24 04          	mov    %edx,0x4(%esp)
  102d42:	89 74 24 08          	mov    %esi,0x8(%esp)
  102d46:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102d4d:	00 
  102d4e:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102d51:	e8 ca 49 00 00       	call   107720 <vmm_map_range>
  102d56:	8d 05 0d 93 10 00    	lea    0x10930d,%eax
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  102d5c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102d5f:	8b 49 18             	mov    0x18(%ecx),%ecx
  102d62:	8b 49 04             	mov    0x4(%ecx),%ecx
  102d65:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102d68:	8b 52 18             	mov    0x18(%edx),%edx
  102d6b:	8b 12                	mov    (%edx),%edx
  102d6d:	29 d1                	sub    %edx,%ecx
  102d6f:	89 04 24             	mov    %eax,(%esp)
  102d72:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102d76:	e8 35 d5 ff ff       	call   1002b0 <kprintf>
  102d7b:	8d 0d 4d 93 10 00    	lea    0x10934d,%ecx
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);
  102d81:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102d84:	8b 52 18             	mov    0x18(%edx),%edx
  102d87:	8b 12                	mov    (%edx),%edx
  102d89:	8b 75 f4             	mov    -0xc(%ebp),%esi
  102d8c:	8b 76 18             	mov    0x18(%esi),%esi
  102d8f:	8b 76 04             	mov    0x4(%esi),%esi
  102d92:	89 0c 24             	mov    %ecx,(%esp)
  102d95:	89 54 24 04          	mov    %edx,0x4(%esp)
  102d99:	89 74 24 08          	mov    %esi,0x8(%esp)
  102d9d:	89 45 c8             	mov    %eax,-0x38(%ebp)
  102da0:	e8 0b d5 ff ff       	call   1002b0 <kprintf>

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  102da5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102da8:	8b 49 18             	mov    0x18(%ecx),%ecx
  102dab:	8b 09                	mov    (%ecx),%ecx
  102dad:	89 0c 24             	mov    %ecx,(%esp)
  102db0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  102db3:	e8 38 10 00 00       	call   103df0 <tar_load_ramfs>
    } else {
  102db8:	e9 11 00 00 00       	jmp    102dce <kernel_main+0x1ae>
  102dbd:	8d 05 67 93 10 00    	lea    0x109367,%eax
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  102dc3:	89 04 24             	mov    %eax,(%esp)
  102dc6:	e8 e5 d4 ff ff       	call   1002b0 <kprintf>
  102dcb:	89 45 c0             	mov    %eax,-0x40(%ebp)
  102dce:	8d 05 99 93 10 00    	lea    0x109399,%eax
    }

    kprintf("[kernel_res] Creating /dev/vga\n");
  102dd4:	89 04 24             	mov    %eax,(%esp)
  102dd7:	e8 d4 d4 ff ff       	call   1002b0 <kprintf>
  102ddc:	8d 0d b9 93 10 00    	lea    0x1093b9,%ecx
  102de2:	ba 00 00 00 00       	mov    $0x0,%edx
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  102de7:	89 45 bc             	mov    %eax,-0x44(%ebp)
  102dea:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  102ded:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  102df0:	e8 5b 15 00 00       	call   104350 <ramfs_vga_driver_struct>
  102df5:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  102df8:	89 0c 24             	mov    %ecx,(%esp)
  102dfb:	89 44 24 04          	mov    %eax,0x4(%esp)
  102dff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102e06:	00 
  102e07:	e8 44 30 00 00       	call   105e50 <vfs_create_kfile>
  102e0c:	8d 0d c2 93 10 00    	lea    0x1093c2,%ecx

    if(vfs_exists("/ibin/init")) {
  102e12:	89 0c 24             	mov    %ecx,(%esp)
  102e15:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102e18:	e8 53 34 00 00       	call   106270 <vfs_exists>
  102e1d:	3d 00 00 00 00       	cmp    $0x0,%eax
  102e22:	0f 84 57 00 00 00    	je     102e7f <kernel_main+0x25f>
  102e28:	8d 05 cd 93 10 00    	lea    0x1093cd,%eax
        kprintf("[init] /ibin/init found. Executing...\n");
  102e2e:	89 04 24             	mov    %eax,(%esp)
  102e31:	e8 7a d4 ff ff       	call   1002b0 <kprintf>
  102e36:	8d 0d c2 93 10 00    	lea    0x1093c2,%ecx
  102e3c:	ba 00 00 00 00       	mov    $0x0,%edx

        vfs_exec("/ibin/init", 0, 0, 0, 0, 0);
  102e41:	89 0c 24             	mov    %ecx,(%esp)
  102e44:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102e4b:	00 
  102e4c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102e53:	00 
  102e54:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102e5b:	00 
  102e5c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  102e63:	00 
  102e64:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  102e6b:	00 
  102e6c:	89 45 ac             	mov    %eax,-0x54(%ebp)
  102e6f:	89 55 a8             	mov    %edx,-0x58(%ebp)
  102e72:	e8 89 34 00 00       	call   106300 <vfs_exec>
        enableScheduling();
  102e77:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  102e7a:	e8 f1 14 00 00       	call   104370 <enableScheduling>
    }

	while(1);
  102e7f:	e9 00 00 00 00       	jmp    102e84 <kernel_main+0x264>
  102e84:	e9 fb ff ff ff       	jmp    102e84 <kernel_main+0x264>
  102e89:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102e90 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  102e90:	55                   	push   %ebp
  102e91:	89 e5                	mov    %esp,%ebp
  102e93:	50                   	push   %eax
  102e94:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  102e98:	66 89 c1             	mov    %ax,%cx
  102e9b:	8a 55 0c             	mov    0xc(%ebp),%dl
  102e9e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  102ea2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  102ea5:	8a 45 fd             	mov    -0x3(%ebp),%al
  102ea8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  102eac:	ee                   	out    %al,(%dx)
}
  102ead:	83 c4 04             	add    $0x4,%esp
  102eb0:	5d                   	pop    %ebp
  102eb1:	c3                   	ret    
  102eb2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102eb9:	1f 84 00 00 00 00 00 

00102ec0 <outw>:
    uint32_t result;
    asm volatile ("inl %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline void outw(uint16_t _port, uint16_t _data) {
  102ec0:	55                   	push   %ebp
  102ec1:	89 e5                	mov    %esp,%ebp
  102ec3:	50                   	push   %eax
  102ec4:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  102ec8:	66 89 c1             	mov    %ax,%cx
  102ecb:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  102ecf:	66 89 c2             	mov    %ax,%dx
  102ed2:	66 89 55 fe          	mov    %dx,-0x2(%ebp)
  102ed6:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
  102eda:	66 8b 45 fc          	mov    -0x4(%ebp),%ax
  102ede:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  102ee2:	66 ef                	out    %ax,(%dx)
}
  102ee4:	83 c4 04             	add    $0x4,%esp
  102ee7:	5d                   	pop    %ebp
  102ee8:	c3                   	ret    
  102ee9:	66 90                	xchg   %ax,%ax
  102eeb:	66 90                	xchg   %ax,%ax
  102eed:	66 90                	xchg   %ax,%ax
  102eef:	90                   	nop

00102ef0 <pmm_alloc>:
#define BITMAP_SIZE 32768

uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
  102ef0:	55                   	push   %ebp
  102ef1:	89 e5                	mov    %esp,%ebp
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102ef3:	56                   	push   %esi
  102ef4:	83 ec 10             	sub    $0x10,%esp
  102ef7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102efe:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102f05:	0f 8d b7 00 00 00    	jge    102fc2 <pmm_alloc+0xd2>
		if (allocatable[i]) {
  102f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f0e:	81 3c 85 a0 a9 12 00 	cmpl   $0x0,0x12a9a0(,%eax,4)
  102f15:	00 00 00 00 
  102f19:	0f 84 8e 00 00 00    	je     102fad <pmm_alloc+0xbd>
			int s;
			for (s = 0; s < 32; s++) {
  102f1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102f26:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  102f2d:	0f 8d 75 00 00 00    	jge    102fa8 <pmm_alloc+0xb8>
  102f33:	b8 01 00 00 00       	mov    $0x1,%eax
				if (allocatable[i] & (1 << s)) {
  102f38:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102f3b:	8b 0c 8d a0 a9 12 00 	mov    0x12a9a0(,%ecx,4),%ecx
  102f42:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102f45:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102f48:	89 d1                	mov    %edx,%ecx
  102f4a:	d3 e0                	shl    %cl,%eax
  102f4c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102f4f:	21 c2                	and    %eax,%edx
  102f51:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  102f57:	0f 84 36 00 00 00    	je     102f93 <pmm_alloc+0xa3>
  102f5d:	b8 01 00 00 00       	mov    $0x1,%eax
					allocatable[i] &= ~(1 << s);
  102f62:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102f65:	d3 e0                	shl    %cl,%eax
  102f67:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  102f6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102f6f:	8b 34 95 a0 a9 12 00 	mov    0x12a9a0(,%edx,4),%esi
  102f76:	21 c6                	and    %eax,%esi
  102f78:	89 34 95 a0 a9 12 00 	mov    %esi,0x12a9a0(,%edx,4)
					return (uint8_t*) ((i * 32 + s) * 4096);
  102f7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f82:	c1 e0 05             	shl    $0x5,%eax
  102f85:	03 45 f0             	add    -0x10(%ebp),%eax
  102f88:	c1 e0 0c             	shl    $0xc,%eax
  102f8b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102f8e:	e9 36 00 00 00       	jmp    102fc9 <pmm_alloc+0xd9>
				}
			}
  102f93:	e9 00 00 00 00       	jmp    102f98 <pmm_alloc+0xa8>
void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
		if (allocatable[i]) {
			int s;
			for (s = 0; s < 32; s++) {
  102f98:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f9b:	05 01 00 00 00       	add    $0x1,%eax
  102fa0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102fa3:	e9 7e ff ff ff       	jmp    102f26 <pmm_alloc+0x36>
				if (allocatable[i] & (1 << s)) {
					allocatable[i] &= ~(1 << s);
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
  102fa8:	e9 00 00 00 00       	jmp    102fad <pmm_alloc+0xbd>
	}
  102fad:	e9 00 00 00 00       	jmp    102fb2 <pmm_alloc+0xc2>
uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102fb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fb5:	05 01 00 00 00       	add    $0x1,%eax
  102fba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102fbd:	e9 3c ff ff ff       	jmp    102efe <pmm_alloc+0xe>
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
	}
	return NULL ;
  102fc2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  102fc9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102fcc:	83 c4 10             	add    $0x10,%esp
  102fcf:	5e                   	pop    %esi
  102fd0:	5d                   	pop    %ebp
  102fd1:	c3                   	ret    
  102fd2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102fd9:	1f 84 00 00 00 00 00 

00102fe0 <pmm_print_stats>:

void pmm_print_stats() {
  102fe0:	55                   	push   %ebp
  102fe1:	89 e5                	mov    %esp,%ebp
  102fe3:	56                   	push   %esi
  102fe4:	83 ec 34             	sub    $0x34,%esp
  102fe7:	b8 00 00 10 00       	mov    $0x100000,%eax
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
  102fec:	c7 04 24 00 00 10 00 	movl   $0x100000,(%esp)
  102ff3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102ff6:	e8 65 00 00 00       	call   103060 <pmm_get_free_space>
  102ffb:	b9 00 04 00 00       	mov    $0x400,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  103000:	8b 15 28 a5 10 00    	mov    0x10a528,%edx
  103006:	c1 ea 14             	shr    $0x14,%edx
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
  103009:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
  103010:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103013:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  103016:	89 55 ec             	mov    %edx,-0x14(%ebp)
  103019:	e8 42 00 00 00       	call   103060 <pmm_get_free_space>
  10301e:	8d 0d f4 93 10 00    	lea    0x1093f4,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  103024:	8b 15 28 a5 10 00    	mov    0x10a528,%edx
  10302a:	c1 ea 0a             	shr    $0xa,%edx
  10302d:	89 0c 24             	mov    %ecx,(%esp)
  103030:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103033:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103037:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10303a:	89 74 24 08          	mov    %esi,0x8(%esp)
  10303e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  103042:	89 54 24 10          	mov    %edx,0x10(%esp)
  103046:	e8 65 d2 ff ff       	call   1002b0 <kprintf>
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
}
  10304b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10304e:	83 c4 34             	add    $0x34,%esp
  103051:	5e                   	pop    %esi
  103052:	5d                   	pop    %ebp
  103053:	c3                   	ret    
  103054:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10305b:	00 00 00 00 00 

00103060 <pmm_get_free_space>:

uint32_t pmm_get_free_space(uint32_t div) {
  103060:	55                   	push   %ebp
  103061:	89 e5                	mov    %esp,%ebp
  103063:	83 ec 14             	sub    $0x14,%esp
  103066:	8b 45 08             	mov    0x8(%ebp),%eax
  103069:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t free = 0;
  10306c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  103073:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10307a:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  103081:	0f 83 73 00 00 00    	jae    1030fa <pmm_get_free_space+0x9a>
		for (uint32_t s = 0; s < 32; s++) {
  103087:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10308e:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  103095:	0f 83 4a 00 00 00    	jae    1030e5 <pmm_get_free_space+0x85>
  10309b:	b8 01 00 00 00       	mov    $0x1,%eax
			if (allocatable[i] & (1 << s))
  1030a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1030a3:	8b 0c 8d a0 a9 12 00 	mov    0x12a9a0(,%ecx,4),%ecx
  1030aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1030ad:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1030b0:	89 d1                	mov    %edx,%ecx
  1030b2:	d3 e0                	shl    %cl,%eax
  1030b4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1030b7:	21 c2                	and    %eax,%edx
  1030b9:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  1030bf:	0f 84 0b 00 00 00    	je     1030d0 <pmm_get_free_space+0x70>
				free += 0x1000;
  1030c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030c8:	05 00 10 00 00       	add    $0x1000,%eax
  1030cd:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  1030d0:	e9 00 00 00 00       	jmp    1030d5 <pmm_get_free_space+0x75>

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
		for (uint32_t s = 0; s < 32; s++) {
  1030d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1030d8:	05 01 00 00 00       	add    $0x1,%eax
  1030dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1030e0:	e9 a9 ff ff ff       	jmp    10308e <pmm_get_free_space+0x2e>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}
  1030e5:	e9 00 00 00 00       	jmp    1030ea <pmm_get_free_space+0x8a>
}

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  1030ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1030ed:	05 01 00 00 00       	add    $0x1,%eax
  1030f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1030f5:	e9 80 ff ff ff       	jmp    10307a <pmm_get_free_space+0x1a>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}

	return free / div;
  1030fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030fd:	31 d2                	xor    %edx,%edx
  1030ff:	f7 75 fc             	divl   -0x4(%ebp)
  103102:	83 c4 14             	add    $0x14,%esp
  103105:	5d                   	pop    %ebp
  103106:	c3                   	ret    
  103107:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10310e:	00 00 

00103110 <pmm_free>:
}

void pmm_free(void* addr) {
  103110:	55                   	push   %ebp
  103111:	89 e5                	mov    %esp,%ebp
  103113:	56                   	push   %esi
  103114:	83 ec 14             	sub    $0x14,%esp
  103117:	8b 45 08             	mov    0x8(%ebp),%eax
  10311a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10311f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  103122:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103125:	c1 e8 0c             	shr    $0xc,%eax
  103128:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  10312b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10312e:	25 1f 00 00 00       	and    $0x1f,%eax
  103133:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  103136:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103139:	c1 e8 05             	shr    $0x5,%eax
  10313c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] |= (1 << s);
  10313f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103142:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  103145:	89 c1                	mov    %eax,%ecx
  103147:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10314a:	d3 e0                	shl    %cl,%eax
  10314c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10314f:	8b 34 95 a0 a9 12 00 	mov    0x12a9a0(,%edx,4),%esi
  103156:	09 c6                	or     %eax,%esi
  103158:	89 34 95 a0 a9 12 00 	mov    %esi,0x12a9a0(,%edx,4)
}
  10315f:	83 c4 14             	add    $0x14,%esp
  103162:	5e                   	pop    %esi
  103163:	5d                   	pop    %ebp
  103164:	c3                   	ret    
  103165:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10316c:	00 00 00 00 

00103170 <pmm_mark_used>:

void pmm_mark_used(void* addr) {
  103170:	55                   	push   %ebp
  103171:	89 e5                	mov    %esp,%ebp
  103173:	56                   	push   %esi
  103174:	83 ec 14             	sub    $0x14,%esp
  103177:	8b 45 08             	mov    0x8(%ebp),%eax
  10317a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10317f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  103182:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103185:	c1 e8 0c             	shr    $0xc,%eax
  103188:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  10318b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10318e:	25 1f 00 00 00       	and    $0x1f,%eax
  103193:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  103196:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103199:	c1 e8 05             	shr    $0x5,%eax
  10319c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] &= ~(1 << s);
  10319f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1031a2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1031a5:	89 c1                	mov    %eax,%ecx
  1031a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1031aa:	d3 e0                	shl    %cl,%eax
  1031ac:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  1031b1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1031b4:	8b 34 95 a0 a9 12 00 	mov    0x12a9a0(,%edx,4),%esi
  1031bb:	21 c6                	and    %eax,%esi
  1031bd:	89 34 95 a0 a9 12 00 	mov    %esi,0x12a9a0(,%edx,4)
}
  1031c4:	83 c4 14             	add    $0x14,%esp
  1031c7:	5e                   	pop    %esi
  1031c8:	5d                   	pop    %ebp
  1031c9:	c3                   	ret    
  1031ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001031d0 <pmm_init>:

void pmm_init(struct multiboot_info* mb_info) {
  1031d0:	55                   	push   %ebp
  1031d1:	89 e5                	mov    %esp,%ebp
  1031d3:	53                   	push   %ebx
  1031d4:	57                   	push   %edi
  1031d5:	56                   	push   %esi
  1031d6:	83 ec 5c             	sub    $0x5c,%esp
  1031d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1031dc:	8d 0d 31 94 10 00    	lea    0x109431,%ecx
  1031e2:	8d 15 a0 a9 12 00    	lea    0x12a9a0,%edx
  1031e8:	89 d6                	mov    %edx,%esi
  1031ea:	81 c6 00 00 02 00    	add    $0x20000,%esi
  1031f0:	89 d7                	mov    %edx,%edi
  1031f2:	bb 00 00 00 00       	mov    $0x0,%ebx
  1031f7:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1031fa:	b8 00 00 02 00       	mov    $0x20000,%eax
  1031ff:	89 45 cc             	mov    %eax,-0x34(%ebp)
  103202:	8b 45 d0             	mov    -0x30(%ebp),%eax
  103205:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct multiboot_mmap* mmap = mb_info->mi_mmap_addr;
  103208:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10320b:	8b 40 30             	mov    0x30(%eax),%eax
  10320e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct multiboot_mmap* mmap_end = (void*) ((uintptr_t) mb_info->mi_mmap_addr
  103211:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103214:	8b 40 30             	mov    0x30(%eax),%eax
  103217:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10321a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10321d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  103220:	8b 45 c8             	mov    -0x38(%ebp),%eax
  103223:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  103226:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  103229:	03 41 2c             	add    0x2c(%ecx),%eax
  10322c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			+ mb_info->mi_mmap_length);

	memset(allocatable, 0, sizeof(allocatable));
  10322f:	89 3c 24             	mov    %edi,(%esp)
  103232:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103239:	00 
  10323a:	c7 44 24 08 00 00 02 	movl   $0x20000,0x8(%esp)
  103241:	00 
  103242:	89 5d bc             	mov    %ebx,-0x44(%ebp)
  103245:	89 55 b8             	mov    %edx,-0x48(%ebp)
  103248:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  10324b:	e8 70 24 00 00       	call   1056c0 <memset>

	kprintf("Mem-Bitmap: %x to %x\n", allocatable, &(allocatable[BITMAP_SIZE]));
  103250:	8b 45 c0             	mov    -0x40(%ebp),%eax
  103253:	89 04 24             	mov    %eax,(%esp)
  103256:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  103259:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10325d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  103260:	89 54 24 08          	mov    %edx,0x8(%esp)
  103264:	e8 47 d0 ff ff       	call   1002b0 <kprintf>
  103269:	89 45 b0             	mov    %eax,-0x50(%ebp)

	while (mmap < mmap_end) {
  10326c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10326f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  103272:	0f 83 77 00 00 00    	jae    1032ef <pmm_init+0x11f>
		if (mmap->mm_type == 1) {
  103278:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10327b:	81 78 14 01 00 00 00 	cmpl   $0x1,0x14(%eax)
  103282:	0f 85 57 00 00 00    	jne    1032df <pmm_init+0x10f>
			uintptr_t addr = mmap->mm_base_addr;
  103288:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10328b:	8b 40 04             	mov    0x4(%eax),%eax
  10328e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uintptr_t end_addr = addr + mmap->mm_length;
  103291:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103294:	8b 49 0c             	mov    0xc(%ecx),%ecx
  103297:	01 c8                	add    %ecx,%eax
  103299:	89 45 e0             	mov    %eax,-0x20(%ebp)

			while (addr < end_addr) {
  10329c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10329f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  1032a2:	0f 83 32 00 00 00    	jae    1032da <pmm_init+0x10a>
				pmm_free((void*) addr);
  1032a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032ab:	89 04 24             	mov    %eax,(%esp)
  1032ae:	e8 5d fe ff ff       	call   103110 <pmm_free>
				if (addr > upper_limit)
  1032b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032b6:	3b 05 28 a5 10 00    	cmp    0x10a528,%eax
  1032bc:	0f 86 08 00 00 00    	jbe    1032ca <pmm_init+0xfa>
					upper_limit = addr;
  1032c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032c5:	a3 28 a5 10 00       	mov    %eax,0x10a528
				addr += 0x1000;
  1032ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032cd:	05 00 10 00 00       	add    $0x1000,%eax
  1032d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			}
  1032d5:	e9 c2 ff ff ff       	jmp    10329c <pmm_init+0xcc>
		}
  1032da:	e9 00 00 00 00       	jmp    1032df <pmm_init+0x10f>
		mmap++;
  1032df:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032e2:	05 18 00 00 00       	add    $0x18,%eax
  1032e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}
  1032ea:	e9 7d ff ff ff       	jmp    10326c <pmm_init+0x9c>
  1032ef:	8d 05 00 00 10 00    	lea    0x100000,%eax

	extern const void kernel_start;
	extern const void kernel_end;

	uintptr_t addr = (uintptr_t) &kernel_start;
  1032f5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1032f8:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
	while (addr < (uintptr_t) &kernel_end) {
  1032fe:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  103301:	0f 83 1b 00 00 00    	jae    103322 <pmm_init+0x152>
		pmm_mark_used((void*) addr);
  103307:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10330a:	89 04 24             	mov    %eax,(%esp)
  10330d:	e8 5e fe ff ff       	call   103170 <pmm_mark_used>
		addr += 0x1000;
  103312:	8b 45 dc             	mov    -0x24(%ebp),%eax
  103315:	05 00 10 00 00       	add    $0x1000,%eax
  10331a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
  10331d:	e9 d6 ff ff ff       	jmp    1032f8 <pmm_init+0x128>

	struct multiboot_module* modules = mb_info->mi_mods_addr;
  103322:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103325:	8b 40 18             	mov    0x18(%eax),%eax
  103328:	89 45 d8             	mov    %eax,-0x28(%ebp)

	pmm_mark_used(mb_info);
  10332b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10332e:	89 04 24             	mov    %eax,(%esp)
  103331:	e8 3a fe ff ff       	call   103170 <pmm_mark_used>
	pmm_mark_used(modules);
  103336:	8b 45 d8             	mov    -0x28(%ebp),%eax
  103339:	89 04 24             	mov    %eax,(%esp)
  10333c:	e8 2f fe ff ff       	call   103170 <pmm_mark_used>

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  103341:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  103348:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10334b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10334e:	3b 41 14             	cmp    0x14(%ecx),%eax
  103351:	0f 83 59 00 00 00    	jae    1033b0 <pmm_init+0x1e0>
		addr = (uintptr_t) modules[i].start;
  103357:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10335a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10335d:	c1 e0 04             	shl    $0x4,%eax
  103360:	01 c1                	add    %eax,%ecx
  103362:	8b 01                	mov    (%ecx),%eax
  103364:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while (addr < (uintptr_t) modules[i].end) {
  103367:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10336a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  10336d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  103370:	c1 e1 04             	shl    $0x4,%ecx
  103373:	01 ca                	add    %ecx,%edx
  103375:	8b 4a 04             	mov    0x4(%edx),%ecx
  103378:	39 c8                	cmp    %ecx,%eax
  10337a:	0f 83 1b 00 00 00    	jae    10339b <pmm_init+0x1cb>
			pmm_mark_used((void*) addr);
  103380:	8b 45 dc             	mov    -0x24(%ebp),%eax
  103383:	89 04 24             	mov    %eax,(%esp)
  103386:	e8 e5 fd ff ff       	call   103170 <pmm_mark_used>
			addr += 0x1000;
  10338b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10338e:	05 00 10 00 00       	add    $0x1000,%eax
  103393:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
  103396:	e9 cc ff ff ff       	jmp    103367 <pmm_init+0x197>
	}
  10339b:	e9 00 00 00 00       	jmp    1033a0 <pmm_init+0x1d0>

	pmm_mark_used(mb_info);
	pmm_mark_used(modules);

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  1033a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1033a3:	05 01 00 00 00       	add    $0x1,%eax
  1033a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1033ab:	e9 98 ff ff ff       	jmp    103348 <pmm_init+0x178>
		while (addr < (uintptr_t) modules[i].end) {
			pmm_mark_used((void*) addr);
			addr += 0x1000;
		}
	}
}
  1033b0:	83 c4 5c             	add    $0x5c,%esp
  1033b3:	5e                   	pop    %esi
  1033b4:	5f                   	pop    %edi
  1033b5:	5b                   	pop    %ebx
  1033b6:	5d                   	pop    %ebp
  1033b7:	c3                   	ret    
  1033b8:	66 90                	xchg   %ax,%ax
  1033ba:	66 90                	xchg   %ax,%ax
  1033bc:	66 90                	xchg   %ax,%ax
  1033be:	66 90                	xchg   %ax,%ax

001033c0 <ramfs_block_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  1033c0:	55                   	push   %ebp
  1033c1:	89 e5                	mov    %esp,%ebp
  1033c3:	83 ec 18             	sub    $0x18,%esp
  1033c6:	8d 05 a0 a9 14 00    	lea    0x14a9a0,%eax
  1033cc:	b9 00 00 00 00       	mov    $0x0,%ecx
  1033d1:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  1033d6:	89 04 24             	mov    %eax,(%esp)
  1033d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1033e0:	00 
  1033e1:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  1033e8:	00 
  1033e9:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1033ec:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1033ef:	e8 cc 22 00 00       	call   1056c0 <memset>
}
  1033f4:	83 c4 18             	add    $0x18,%esp
  1033f7:	5d                   	pop    %ebp
  1033f8:	c3                   	ret    
  1033f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00103400 <ramfs_block_read>:
    }

    return 0;
}

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  103400:	55                   	push   %ebp
  103401:	89 e5                	mov    %esp,%ebp
  103403:	83 ec 28             	sub    $0x28,%esp
  103406:	8b 45 10             	mov    0x10(%ebp),%eax
  103409:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10340c:	8b 55 08             	mov    0x8(%ebp),%edx
  10340f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103412:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103415:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103418:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10341b:	8b 40 04             	mov    0x4(%eax),%eax
  10341e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  103421:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103424:	8b 00                	mov    (%eax),%eax
  103426:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  10342d:	00 00 00 00 
  103431:	0f 84 70 00 00 00    	je     1034a7 <ramfs_block_read+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't read that much biatch
  103437:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10343a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10343d:	8b 09                	mov    (%ecx),%ecx
  10343f:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103446:	8b 49 04             	mov    0x4(%ecx),%ecx
  103449:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10344c:	2b 4a 08             	sub    0x8(%edx),%ecx
  10344f:	39 c8                	cmp    %ecx,%eax
  103451:	0f 86 0c 00 00 00    	jbe    103463 <ramfs_block_read+0x63>
  103457:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  10345e:	e9 4b 00 00 00       	jmp    1034ae <ramfs_block_read+0xae>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  103463:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103466:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103469:	8b 09                	mov    (%ecx),%ecx
  10346b:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103472:	8b 09                	mov    (%ecx),%ecx
  103474:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103477:	03 4a 08             	add    0x8(%edx),%ecx
  10347a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10347d:	89 04 24             	mov    %eax,(%esp)
  103480:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103484:	89 54 24 08          	mov    %edx,0x8(%esp)
  103488:	e8 93 22 00 00       	call   105720 <memcpy>
        handle->position += length;
  10348d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103490:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103493:	8b 51 08             	mov    0x8(%ecx),%edx
  103496:	01 c2                	add    %eax,%edx
  103498:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  10349b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1034a2:	e9 07 00 00 00       	jmp    1034ae <ramfs_block_read+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  1034a7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1034ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034b1:	83 c4 28             	add    $0x28,%esp
  1034b4:	5d                   	pop    %ebp
  1034b5:	c3                   	ret    
  1034b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1034bd:	00 00 00 

001034c0 <ramfs_block_write>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  1034c0:	55                   	push   %ebp
  1034c1:	89 e5                	mov    %esp,%ebp
  1034c3:	83 ec 28             	sub    $0x28,%esp
  1034c6:	8b 45 10             	mov    0x10(%ebp),%eax
  1034c9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1034cc:	8b 55 08             	mov    0x8(%ebp),%edx
  1034cf:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1034d2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1034d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1034d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1034db:	8b 40 04             	mov    0x4(%eax),%eax
  1034de:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  1034e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1034e4:	8b 00                	mov    (%eax),%eax
  1034e6:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  1034ed:	00 00 00 00 
  1034f1:	0f 84 70 00 00 00    	je     103567 <ramfs_block_write+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't write  that much biatch TODO realloc so file may grow
  1034f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034fa:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1034fd:	8b 09                	mov    (%ecx),%ecx
  1034ff:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103506:	8b 49 04             	mov    0x4(%ecx),%ecx
  103509:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10350c:	2b 4a 08             	sub    0x8(%edx),%ecx
  10350f:	39 c8                	cmp    %ecx,%eax
  103511:	0f 86 0c 00 00 00    	jbe    103523 <ramfs_block_write+0x63>
  103517:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  10351e:	e9 4b 00 00 00       	jmp    10356e <ramfs_block_write+0xae>

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  103523:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103526:	8b 00                	mov    (%eax),%eax
  103528:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  10352f:	8b 00                	mov    (%eax),%eax
  103531:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103534:	03 41 08             	add    0x8(%ecx),%eax
  103537:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10353a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10353d:	89 04 24             	mov    %eax,(%esp)
  103540:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103544:	89 54 24 08          	mov    %edx,0x8(%esp)
  103548:	e8 d3 21 00 00       	call   105720 <memcpy>
        handle->position += length;
  10354d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103550:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103553:	8b 51 08             	mov    0x8(%ecx),%edx
  103556:	01 c2                	add    %eax,%edx
  103558:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  10355b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103562:	e9 07 00 00 00       	jmp    10356e <ramfs_block_write+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103567:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  10356e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103571:	83 c4 28             	add    $0x28,%esp
  103574:	5d                   	pop    %ebp
  103575:	c3                   	ret    
  103576:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10357d:	00 00 00 

00103580 <ramfs_block_open>:

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  103580:	55                   	push   %ebp
  103581:	89 e5                	mov    %esp,%ebp
  103583:	83 ec 18             	sub    $0x18,%esp
  103586:	8b 45 0c             	mov    0xc(%ebp),%eax
  103589:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10358c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10358f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  103592:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103595:	8b 00                	mov    (%eax),%eax
  103597:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  10359e:	00 00 00 00 
  1035a2:	0f 84 9d 00 00 00    	je     103645 <ramfs_block_open+0xc5>
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  1035a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1035ab:	25 01 00 00 00       	and    $0x1,%eax
  1035b0:	3d 00 00 00 00       	cmp    $0x0,%eax
  1035b5:	0f 84 18 00 00 00    	je     1035d3 <ramfs_block_open+0x53>
  1035bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1035be:	8b 00                	mov    (%eax),%eax
  1035c0:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  1035c7:	8b 48 08             	mov    0x8(%eax),%ecx
  1035ca:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1035d0:	89 48 08             	mov    %ecx,0x8(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  1035d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1035d6:	25 02 00 00 00       	and    $0x2,%eax
  1035db:	3d 00 00 00 00       	cmp    $0x0,%eax
  1035e0:	0f 84 18 00 00 00    	je     1035fe <ramfs_block_open+0x7e>
  1035e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1035e9:	8b 00                	mov    (%eax),%eax
  1035eb:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  1035f2:	8b 48 0c             	mov    0xc(%eax),%ecx
  1035f5:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1035fb:	89 48 0c             	mov    %ecx,0xc(%eax)
  1035fe:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103603:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10360a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10360d:	e8 de 19 00 00       	call   104ff0 <malloc>
  103612:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  103615:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103618:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10361b:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  10361e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103621:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  103628:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10362b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  103631:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103634:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103637:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  10363a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10363d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103640:	e9 08 00 00 00       	jmp    10364d <ramfs_block_open+0xcd>
  103645:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return (void*)1;
  10364a:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10364d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103650:	83 c4 18             	add    $0x18,%esp
  103653:	5d                   	pop    %ebp
  103654:	c3                   	ret    
  103655:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10365c:	00 00 00 00 

00103660 <ramfs_block_close>:

uint32_t ramfs_block_close(struct res_handle* handle) {
  103660:	55                   	push   %ebp
  103661:	89 e5                	mov    %esp,%ebp
  103663:	83 ec 18             	sub    $0x18,%esp
  103666:	8b 45 08             	mov    0x8(%ebp),%eax
  103669:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10366c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10366f:	8b 40 04             	mov    0x4(%eax),%eax
  103672:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  103675:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103678:	8b 00                	mov    (%eax),%eax
  10367a:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  103681:	00 00 00 00 
  103685:	0f 84 61 00 00 00    	je     1036ec <ramfs_block_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  10368b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10368e:	8b 40 0c             	mov    0xc(%eax),%eax
  103691:	25 01 00 00 00       	and    $0x1,%eax
  103696:	3d 00 00 00 00       	cmp    $0x0,%eax
  10369b:	0f 84 18 00 00 00    	je     1036b9 <ramfs_block_close+0x59>
  1036a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1036a4:	8b 00                	mov    (%eax),%eax
  1036a6:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  1036ad:	8b 48 08             	mov    0x8(%eax),%ecx
  1036b0:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1036b6:	89 48 08             	mov    %ecx,0x8(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  1036b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1036bc:	8b 40 0c             	mov    0xc(%eax),%eax
  1036bf:	25 02 00 00 00       	and    $0x2,%eax
  1036c4:	3d 00 00 00 00       	cmp    $0x0,%eax
  1036c9:	0f 84 18 00 00 00    	je     1036e7 <ramfs_block_close+0x87>
  1036cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1036d2:	8b 00                	mov    (%eax),%eax
  1036d4:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  1036db:	8b 48 0c             	mov    0xc(%eax),%ecx
  1036de:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1036e4:	89 48 0c             	mov    %ecx,0xc(%eax)
    }
  1036e7:	e9 00 00 00 00       	jmp    1036ec <ramfs_block_close+0x8c>

    free(handle);
  1036ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1036ef:	89 04 24             	mov    %eax,(%esp)
  1036f2:	e8 f9 1c 00 00       	call   1053f0 <free>
  1036f7:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  1036fc:	83 c4 18             	add    $0x18,%esp
  1036ff:	5d                   	pop    %ebp
  103700:	c3                   	ret    
  103701:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103708:	0f 1f 84 00 00 00 00 
  10370f:	00 

00103710 <ramfs_block_available>:

struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
}

uint32_t ramfs_block_available(struct res_handle* handle) {
  103710:	55                   	push   %ebp
  103711:	89 e5                	mov    %esp,%ebp
  103713:	83 ec 0c             	sub    $0xc,%esp
  103716:	8b 45 08             	mov    0x8(%ebp),%eax
  103719:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10371c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10371f:	8b 40 04             	mov    0x4(%eax),%eax
  103722:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  103725:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103728:	8b 00                	mov    (%eax),%eax
  10372a:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  103731:	00 00 00 00 
  103735:	0f 84 1d 00 00 00    	je     103758 <ramfs_block_available+0x48>
        return buffer[kf->id]->size - handle->position;
  10373b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10373e:	8b 00                	mov    (%eax),%eax
  103740:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103747:	8b 40 04             	mov    0x4(%eax),%eax
  10374a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10374d:	2b 41 08             	sub    0x8(%ecx),%eax
  103750:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103753:	e9 07 00 00 00       	jmp    10375f <ramfs_block_available+0x4f>
    }

    return 0;
  103758:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  10375f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103762:	83 c4 0c             	add    $0xc,%esp
  103765:	5d                   	pop    %ebp
  103766:	c3                   	ret    
  103767:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10376e:	00 00 

00103770 <ramfs_block_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  103770:	55                   	push   %ebp
  103771:	89 e5                	mov    %esp,%ebp
  103773:	83 ec 28             	sub    $0x28,%esp
  103776:	8b 45 08             	mov    0x8(%ebp),%eax
  103779:	b9 08 00 00 00       	mov    $0x8,%ecx
  10377e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  103781:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103788:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10378b:	e8 60 18 00 00       	call   104ff0 <malloc>
  103790:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  103793:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10379a:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  1037a1:	0f 8d a7 00 00 00    	jge    10384e <ramfs_block_create+0xde>
        if(buffer[i] == 0) {
  1037a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1037aa:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  1037b1:	00 00 00 00 
  1037b5:	0f 85 7e 00 00 00    	jne    103839 <ramfs_block_create+0xc9>
  1037bb:	b8 10 00 00 00       	mov    $0x10,%eax
            buffer[i] = malloc(sizeof(struct block_buffer));
  1037c0:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  1037c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1037ca:	e8 21 18 00 00       	call   104ff0 <malloc>
  1037cf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1037d2:	89 04 8d a0 a9 14 00 	mov    %eax,0x14a9a0(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  1037d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1037dc:	8b 00                	mov    (%eax),%eax
  1037de:	89 04 24             	mov    %eax,(%esp)
  1037e1:	e8 0a 18 00 00       	call   104ff0 <malloc>
  1037e6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1037e9:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  1037f0:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  1037f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1037f5:	8b 00                	mov    (%eax),%eax
  1037f7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1037fa:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103801:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->writers = 0;
  103804:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103807:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  10380e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            buffer[i]->readers = 0;
  103815:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103818:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  10381f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

            kfret->id = i;
  103826:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103829:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10382c:	89 01                	mov    %eax,(%ecx)

            return kfret;
  10382e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103831:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103834:	e9 1c 00 00 00       	jmp    103855 <ramfs_block_create+0xe5>
        }
    }
  103839:	e9 00 00 00 00       	jmp    10383e <ramfs_block_create+0xce>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  10383e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103841:	05 01 00 00 00       	add    $0x1,%eax
  103846:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103849:	e9 4c ff ff ff       	jmp    10379a <ramfs_block_create+0x2a>

            return kfret;
        }
    }

    return 0;
  10384e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103855:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103858:	83 c4 28             	add    $0x28,%esp
  10385b:	5d                   	pop    %ebp
  10385c:	c3                   	ret    
  10385d:	0f 1f 00             	nopl   (%eax)

00103860 <ramfs_block_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  103860:	55                   	push   %ebp
  103861:	89 e5                	mov    %esp,%ebp
  103863:	8d 05 88 82 10 00    	lea    0x108288,%eax
    return &block_driver;
  103869:	5d                   	pop    %ebp
  10386a:	c3                   	ret    
  10386b:	66 90                	xchg   %ax,%ax
  10386d:	66 90                	xchg   %ax,%ax
  10386f:	90                   	nop

00103870 <ramfs_fifo_init>:
#include "ramfs/fifo.h"

struct fifo_buffer* buffer[65536];

void ramfs_fifo_init() {
  103870:	55                   	push   %ebp
  103871:	89 e5                	mov    %esp,%ebp
  103873:	83 ec 18             	sub    $0x18,%esp
  103876:	8d 05 a0 a9 14 00    	lea    0x14a9a0,%eax
  10387c:	b9 00 00 00 00       	mov    $0x0,%ecx
  103881:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  103886:	89 04 24             	mov    %eax,(%esp)
  103889:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103890:	00 
  103891:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  103898:	00 
  103899:	89 55 fc             	mov    %edx,-0x4(%ebp)
  10389c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10389f:	e8 1c 1e 00 00       	call   1056c0 <memset>
}
  1038a4:	83 c4 18             	add    $0x18,%esp
  1038a7:	5d                   	pop    %ebp
  1038a8:	c3                   	ret    
  1038a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

001038b0 <ramfs_fifo_read>:
    }

    return 0;
}

uint32_t ramfs_fifo_read(struct res_handle* handle, void* dest, uint32_t length) {
  1038b0:	55                   	push   %ebp
  1038b1:	89 e5                	mov    %esp,%ebp
  1038b3:	83 ec 28             	sub    $0x28,%esp
  1038b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1038b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1038bc:	8b 55 08             	mov    0x8(%ebp),%edx
  1038bf:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1038c2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1038c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1038c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1038cb:	8b 40 04             	mov    0x4(%eax),%eax
  1038ce:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  1038d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1038d4:	8b 00                	mov    (%eax),%eax
  1038d6:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  1038dd:	00 00 00 00 
  1038e1:	0f 84 d0 00 00 00    	je     1039b7 <ramfs_fifo_read+0x107>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't read cause buffer too small
  1038e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038ea:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1038ed:	8b 09                	mov    (%ecx),%ecx
  1038ef:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  1038f6:	3b 41 04             	cmp    0x4(%ecx),%eax
  1038f9:	0f 86 0c 00 00 00    	jbe    10390b <ramfs_fifo_read+0x5b>
  1038ff:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103906:	e9 b3 00 00 00       	jmp    1039be <ramfs_fifo_read+0x10e>
        if(length > buffer[kf->id]->pos)  return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has writers
  10390b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10390e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103911:	8b 09                	mov    (%ecx),%ecx
  103913:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  10391a:	3b 41 08             	cmp    0x8(%ecx),%eax
  10391d:	0f 86 0c 00 00 00    	jbe    10392f <ramfs_fifo_read+0x7f>
  103923:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10392a:	e9 8f 00 00 00       	jmp    1039be <ramfs_fifo_read+0x10e>

        memcpy(dest, buffer[kf->id]->buffer, length);
  10392f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103932:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103935:	8b 09                	mov    (%ecx),%ecx
  103937:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  10393e:	8b 09                	mov    (%ecx),%ecx
  103940:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103943:	89 04 24             	mov    %eax,(%esp)
  103946:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10394a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10394e:	e8 cd 1d 00 00       	call   105720 <memcpy>
        memcpy(buffer[kf->id]->buffer, buffer[kf->id]->buffer + length, buffer[kf->id]->pos - length);
  103953:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103956:	8b 00                	mov    (%eax),%eax
  103958:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  10395f:	8b 00                	mov    (%eax),%eax
  103961:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103964:	8b 09                	mov    (%ecx),%ecx
  103966:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  10396d:	8b 09                	mov    (%ecx),%ecx
  10396f:	03 4d f0             	add    -0x10(%ebp),%ecx
  103972:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103975:	8b 12                	mov    (%edx),%edx
  103977:	8b 14 95 a0 a9 14 00 	mov    0x14a9a0(,%edx,4),%edx
  10397e:	8b 52 08             	mov    0x8(%edx),%edx
  103981:	2b 55 f0             	sub    -0x10(%ebp),%edx
  103984:	89 04 24             	mov    %eax,(%esp)
  103987:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10398b:	89 54 24 08          	mov    %edx,0x8(%esp)
  10398f:	e8 8c 1d 00 00       	call   105720 <memcpy>
        buffer[kf->id]->pos -= length;
  103994:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103997:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10399a:	8b 09                	mov    (%ecx),%ecx
  10399c:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  1039a3:	8b 51 08             	mov    0x8(%ecx),%edx
  1039a6:	29 c2                	sub    %eax,%edx
  1039a8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  1039ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1039b2:	e9 07 00 00 00       	jmp    1039be <ramfs_fifo_read+0x10e>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  1039b7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1039be:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039c1:	83 c4 28             	add    $0x28,%esp
  1039c4:	5d                   	pop    %ebp
  1039c5:	c3                   	ret    
  1039c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1039cd:	00 00 00 

001039d0 <ramfs_fifo_write>:

uint32_t ramfs_fifo_write(struct res_handle* handle, void* src, uint32_t length) {
  1039d0:	55                   	push   %ebp
  1039d1:	89 e5                	mov    %esp,%ebp
  1039d3:	83 ec 28             	sub    $0x28,%esp
  1039d6:	8b 45 10             	mov    0x10(%ebp),%eax
  1039d9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1039dc:	8b 55 08             	mov    0x8(%ebp),%edx
  1039df:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1039e2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1039e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1039e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1039eb:	8b 40 04             	mov    0x4(%eax),%eax
  1039ee:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  1039f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1039f4:	8b 00                	mov    (%eax),%eax
  1039f6:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  1039fd:	00 00 00 00 
  103a01:	0f 84 af 00 00 00    	je     103ab6 <ramfs_fifo_write+0xe6>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't write cause buffer too small
  103a07:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a0a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a0d:	8b 09                	mov    (%ecx),%ecx
  103a0f:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103a16:	3b 41 04             	cmp    0x4(%ecx),%eax
  103a19:	0f 86 0c 00 00 00    	jbe    103a2b <ramfs_fifo_write+0x5b>
  103a1f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103a26:	e9 92 00 00 00       	jmp    103abd <ramfs_fifo_write+0xed>
        if(length > (buffer[kf->id]->size - buffer[kf->id]->pos)) return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has readers
  103a2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a2e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a31:	8b 09                	mov    (%ecx),%ecx
  103a33:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103a3a:	8b 49 04             	mov    0x4(%ecx),%ecx
  103a3d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103a40:	8b 12                	mov    (%edx),%edx
  103a42:	8b 14 95 a0 a9 14 00 	mov    0x14a9a0(,%edx,4),%edx
  103a49:	2b 4a 08             	sub    0x8(%edx),%ecx
  103a4c:	39 c8                	cmp    %ecx,%eax
  103a4e:	0f 86 0c 00 00 00    	jbe    103a60 <ramfs_fifo_write+0x90>
  103a54:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  103a5b:	e9 5d 00 00 00       	jmp    103abd <ramfs_fifo_write+0xed>

        memcpy(buffer[kf->id]->buffer + buffer[kf->id]->pos, src, length);
  103a60:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103a63:	8b 00                	mov    (%eax),%eax
  103a65:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103a6c:	8b 00                	mov    (%eax),%eax
  103a6e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a71:	8b 09                	mov    (%ecx),%ecx
  103a73:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103a7a:	03 41 08             	add    0x8(%ecx),%eax
  103a7d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103a80:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103a83:	89 04 24             	mov    %eax,(%esp)
  103a86:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103a8a:	89 54 24 08          	mov    %edx,0x8(%esp)
  103a8e:	e8 8d 1c 00 00       	call   105720 <memcpy>
        buffer[kf->id]->pos += length;
  103a93:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a96:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a99:	8b 09                	mov    (%ecx),%ecx
  103a9b:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103aa2:	8b 51 08             	mov    0x8(%ecx),%edx
  103aa5:	01 c2                	add    %eax,%edx
  103aa7:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  103aaa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103ab1:	e9 07 00 00 00       	jmp    103abd <ramfs_fifo_write+0xed>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103ab6:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  103abd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103ac0:	83 c4 28             	add    $0x28,%esp
  103ac3:	5d                   	pop    %ebp
  103ac4:	c3                   	ret    
  103ac5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  103acc:	00 00 00 00 

00103ad0 <ramfs_fifo_open>:

struct res_handle* ramfs_fifo_open(struct res_kfile* kf, uint32_t filemode) {
  103ad0:	55                   	push   %ebp
  103ad1:	89 e5                	mov    %esp,%ebp
  103ad3:	83 ec 18             	sub    $0x18,%esp
  103ad6:	8b 45 0c             	mov    0xc(%ebp),%eax
  103ad9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103adc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103adf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  103ae2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ae5:	8b 00                	mov    (%eax),%eax
  103ae7:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  103aee:	00 00 00 00 
  103af2:	0f 84 bc 00 00 00    	je     103bb4 <ramfs_fifo_open+0xe4>
        if(filemode & FM_EXEC) return 0;
  103af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103afb:	25 04 00 00 00       	and    $0x4,%eax
  103b00:	3d 00 00 00 00       	cmp    $0x0,%eax
  103b05:	0f 84 0c 00 00 00    	je     103b17 <ramfs_fifo_open+0x47>
  103b0b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103b12:	e9 a4 00 00 00       	jmp    103bbb <ramfs_fifo_open+0xeb>

        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  103b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b1a:	25 01 00 00 00       	and    $0x1,%eax
  103b1f:	3d 00 00 00 00       	cmp    $0x0,%eax
  103b24:	0f 84 18 00 00 00    	je     103b42 <ramfs_fifo_open+0x72>
  103b2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103b2d:	8b 00                	mov    (%eax),%eax
  103b2f:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103b36:	8b 48 0c             	mov    0xc(%eax),%ecx
  103b39:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103b3f:	89 48 0c             	mov    %ecx,0xc(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  103b42:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b45:	25 02 00 00 00       	and    $0x2,%eax
  103b4a:	3d 00 00 00 00       	cmp    $0x0,%eax
  103b4f:	0f 84 18 00 00 00    	je     103b6d <ramfs_fifo_open+0x9d>
  103b55:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103b58:	8b 00                	mov    (%eax),%eax
  103b5a:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103b61:	8b 48 10             	mov    0x10(%eax),%ecx
  103b64:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103b6a:	89 48 10             	mov    %ecx,0x10(%eax)
  103b6d:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103b72:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  103b79:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103b7c:	e8 6f 14 00 00       	call   104ff0 <malloc>
  103b81:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  103b84:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b87:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103b8a:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  103b8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103b90:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  103b97:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103b9a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  103ba0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ba3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103ba6:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  103ba9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103bac:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103baf:	e9 07 00 00 00       	jmp    103bbb <ramfs_fifo_open+0xeb>
    }

    return 0;
  103bb4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103bbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bbe:	83 c4 18             	add    $0x18,%esp
  103bc1:	5d                   	pop    %ebp
  103bc2:	c3                   	ret    
  103bc3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103bca:	84 00 00 00 00 00 

00103bd0 <ramfs_fifo_close>:

uint32_t ramfs_fifo_close(struct res_handle* handle) {
  103bd0:	55                   	push   %ebp
  103bd1:	89 e5                	mov    %esp,%ebp
  103bd3:	83 ec 18             	sub    $0x18,%esp
  103bd6:	8b 45 08             	mov    0x8(%ebp),%eax
  103bd9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103bdc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bdf:	8b 40 04             	mov    0x4(%eax),%eax
  103be2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  103be5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103be8:	8b 00                	mov    (%eax),%eax
  103bea:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  103bf1:	00 00 00 00 
  103bf5:	0f 84 61 00 00 00    	je     103c5c <ramfs_fifo_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  103bfb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bfe:	8b 40 0c             	mov    0xc(%eax),%eax
  103c01:	25 01 00 00 00       	and    $0x1,%eax
  103c06:	3d 00 00 00 00       	cmp    $0x0,%eax
  103c0b:	0f 84 18 00 00 00    	je     103c29 <ramfs_fifo_close+0x59>
  103c11:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103c14:	8b 00                	mov    (%eax),%eax
  103c16:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103c1d:	8b 48 0c             	mov    0xc(%eax),%ecx
  103c20:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103c26:	89 48 0c             	mov    %ecx,0xc(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  103c29:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c2c:	8b 40 0c             	mov    0xc(%eax),%eax
  103c2f:	25 02 00 00 00       	and    $0x2,%eax
  103c34:	3d 00 00 00 00       	cmp    $0x0,%eax
  103c39:	0f 84 18 00 00 00    	je     103c57 <ramfs_fifo_close+0x87>
  103c3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103c42:	8b 00                	mov    (%eax),%eax
  103c44:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103c4b:	8b 48 10             	mov    0x10(%eax),%ecx
  103c4e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103c54:	89 48 10             	mov    %ecx,0x10(%eax)
    }
  103c57:	e9 00 00 00 00       	jmp    103c5c <ramfs_fifo_close+0x8c>

    free(handle);
  103c5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c5f:	89 04 24             	mov    %eax,(%esp)
  103c62:	e8 89 17 00 00       	call   1053f0 <free>
  103c67:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  103c6c:	83 c4 18             	add    $0x18,%esp
  103c6f:	5d                   	pop    %ebp
  103c70:	c3                   	ret    
  103c71:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103c78:	0f 1f 84 00 00 00 00 
  103c7f:	00 

00103c80 <ramfs_fifo_available>:

struct kfs_driver* ramfs_fifo_driver_struct() {
    return &fifo_driver;
}

uint32_t ramfs_fifo_available(struct res_handle* handle) {
  103c80:	55                   	push   %ebp
  103c81:	89 e5                	mov    %esp,%ebp
  103c83:	83 ec 0c             	sub    $0xc,%esp
  103c86:	8b 45 08             	mov    0x8(%ebp),%eax
  103c89:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103c8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103c8f:	8b 40 04             	mov    0x4(%eax),%eax
  103c92:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  103c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c98:	8b 00                	mov    (%eax),%eax
  103c9a:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  103ca1:	00 00 00 00 
  103ca5:	0f 84 17 00 00 00    	je     103cc2 <ramfs_fifo_available+0x42>
        return buffer[kf->id]->pos;
  103cab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103cae:	8b 00                	mov    (%eax),%eax
  103cb0:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103cb7:	8b 40 08             	mov    0x8(%eax),%eax
  103cba:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103cbd:	e9 07 00 00 00       	jmp    103cc9 <ramfs_fifo_available+0x49>
    }

    return 0;
  103cc2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103cc9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103ccc:	83 c4 0c             	add    $0xc,%esp
  103ccf:	5d                   	pop    %ebp
  103cd0:	c3                   	ret    
  103cd1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103cd8:	0f 1f 84 00 00 00 00 
  103cdf:	00 

00103ce0 <ramfs_fifo_create>:

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
  103ce0:	55                   	push   %ebp
  103ce1:	89 e5                	mov    %esp,%ebp
  103ce3:	83 ec 28             	sub    $0x28,%esp
  103ce6:	8b 45 08             	mov    0x8(%ebp),%eax
  103ce9:	b9 08 00 00 00       	mov    $0x8,%ecx
  103cee:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  103cf1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103cf8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103cfb:	e8 f0 12 00 00       	call   104ff0 <malloc>
  103d00:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  103d03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  103d0a:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  103d11:	0f 8d b8 00 00 00    	jge    103dcf <ramfs_fifo_create+0xef>
        if(buffer[i] == 0) {
  103d17:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d1a:	81 3c 85 a0 a9 14 00 	cmpl   $0x0,0x14a9a0(,%eax,4)
  103d21:	00 00 00 00 
  103d25:	0f 85 8f 00 00 00    	jne    103dba <ramfs_fifo_create+0xda>
  103d2b:	b8 14 00 00 00       	mov    $0x14,%eax
            buffer[i] = malloc(sizeof(struct fifo_buffer));
  103d30:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  103d37:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103d3a:	e8 b1 12 00 00       	call   104ff0 <malloc>
  103d3f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103d42:	89 04 8d a0 a9 14 00 	mov    %eax,0x14a9a0(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  103d49:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103d4c:	8b 00                	mov    (%eax),%eax
  103d4e:	89 04 24             	mov    %eax,(%esp)
  103d51:	e8 9a 12 00 00       	call   104ff0 <malloc>
  103d56:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103d59:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103d60:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  103d62:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103d65:	8b 00                	mov    (%eax),%eax
  103d67:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103d6a:	8b 0c 8d a0 a9 14 00 	mov    0x14a9a0(,%ecx,4),%ecx
  103d71:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->pos = 0;
  103d74:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d77:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103d7e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            buffer[i]->writers = 0;
  103d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d88:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103d8f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
            buffer[i]->readers = 0;
  103d96:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d99:	8b 04 85 a0 a9 14 00 	mov    0x14a9a0(,%eax,4),%eax
  103da0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

            kfret->id = i;
  103da7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103daa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103dad:	89 01                	mov    %eax,(%ecx)

            return kfret;
  103daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103db2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103db5:	e9 1c 00 00 00       	jmp    103dd6 <ramfs_fifo_create+0xf6>
        }
    }
  103dba:	e9 00 00 00 00       	jmp    103dbf <ramfs_fifo_create+0xdf>
}

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  103dbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103dc2:	05 01 00 00 00       	add    $0x1,%eax
  103dc7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103dca:	e9 3b ff ff ff       	jmp    103d0a <ramfs_fifo_create+0x2a>

            return kfret;
        }
    }

    return 0;
  103dcf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103dd6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103dd9:	83 c4 28             	add    $0x28,%esp
  103ddc:	5d                   	pop    %ebp
  103ddd:	c3                   	ret    
  103dde:	66 90                	xchg   %ax,%ax

00103de0 <ramfs_fifo_driver_struct>:
    .close     = ramfs_fifo_close,
    .available = ramfs_fifo_available,
    .drvname   = "FIFO"
};

struct kfs_driver* ramfs_fifo_driver_struct() {
  103de0:	55                   	push   %ebp
  103de1:	89 e5                	mov    %esp,%ebp
  103de3:	8d 05 a4 82 10 00    	lea    0x1082a4,%eax
    return &fifo_driver;
  103de9:	5d                   	pop    %ebp
  103dea:	c3                   	ret    
  103deb:	90                   	nop
  103dec:	66 90                	xchg   %ax,%ax
  103dee:	66 90                	xchg   %ax,%ax

00103df0 <tar_load_ramfs>:

    return size;

}

void tar_load_ramfs(void* tarball) {
  103df0:	55                   	push   %ebp
  103df1:	89 e5                	mov    %esp,%ebp
  103df3:	56                   	push   %esi
  103df4:	83 ec 64             	sub    $0x64,%esp
  103df7:	8b 45 08             	mov    0x8(%ebp),%eax
  103dfa:	8d 0d 54 94 10 00    	lea    0x109454,%ecx
  103e00:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* address = tarball;
  103e03:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103e06:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);
  103e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e0c:	89 0c 24             	mov    %ecx,(%esp)
  103e0f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103e13:	e8 98 c4 ff ff       	call   1002b0 <kprintf>

    for (i = 0; ; i++)
  103e18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  103e1f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    {

        struct tar_header *header = (struct tar_header*)address;
  103e22:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e25:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (header->name[0] == '\0')
  103e28:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103e2b:	0f be 00             	movsbl (%eax),%eax
  103e2e:	3d 00 00 00 00       	cmp    $0x0,%eax
  103e33:	0f 85 05 00 00 00    	jne    103e3e <tar_load_ramfs+0x4e>
            break;
  103e39:	e9 67 01 00 00       	jmp    103fa5 <tar_load_ramfs+0x1b5>

        uint32_t size = tar_parse_number(header->size);
  103e3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103e41:	05 7c 00 00 00       	add    $0x7c,%eax
  103e46:	89 04 24             	mov    %eax,(%esp)
  103e49:	e8 72 01 00 00       	call   103fc0 <tar_parse_number>
  103e4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        address += 512;
  103e51:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e54:	05 00 02 00 00       	add    $0x200,%eax
  103e59:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(size != 0) {
  103e5c:	81 7d e8 00 00 00 00 	cmpl   $0x0,-0x18(%ebp)
  103e63:	0f 84 cb 00 00 00    	je     103f34 <tar_load_ramfs+0x144>
  103e69:	8d 05 80 94 10 00    	lea    0x109480,%eax
            kprintf("[initrfs] Extracting %s (%d bytes)\n", header->name, size);
  103e6f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103e72:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103e75:	89 04 24             	mov    %eax,(%esp)
  103e78:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103e7c:	89 54 24 08          	mov    %edx,0x8(%esp)
  103e80:	e8 2b c4 ff ff       	call   1002b0 <kprintf>
  103e85:	8d 4d e8             	lea    -0x18(%ebp),%ecx

            vfs_create_kfile(header->name, ramfs_block_driver_struct(), &size);
  103e88:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103e8b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  103e8e:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  103e91:	89 55 d0             	mov    %edx,-0x30(%ebp)
  103e94:	e8 c7 f9 ff ff       	call   103860 <ramfs_block_driver_struct>
  103e99:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  103e9c:	89 0c 24             	mov    %ecx,(%esp)
  103e9f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103ea3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  103ea6:	89 44 24 08          	mov    %eax,0x8(%esp)
  103eaa:	e8 a1 1f 00 00       	call   105e50 <vfs_create_kfile>
  103eaf:	b9 02 00 00 00       	mov    $0x2,%ecx
            struct res_handle* h = vfs_open(header->name, FM_WRITE);
  103eb4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103eb7:	89 14 24             	mov    %edx,(%esp)
  103eba:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  103ec1:	00 
  103ec2:	89 45 cc             	mov    %eax,-0x34(%ebp)
  103ec5:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  103ec8:	e8 63 20 00 00       	call   105f30 <vfs_open>
  103ecd:	b9 01 00 00 00       	mov    $0x1,%ecx
  103ed2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            uint32_t err = vfs_write(h, address, size, 1);
  103ed5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103ed8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103edb:	8b 75 e8             	mov    -0x18(%ebp),%esi
  103ede:	89 04 24             	mov    %eax,(%esp)
  103ee1:	89 54 24 04          	mov    %edx,0x4(%esp)
  103ee5:	89 74 24 08          	mov    %esi,0x8(%esp)
  103ee9:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  103ef0:	00 
  103ef1:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  103ef4:	e8 07 22 00 00       	call   106100 <vfs_write>
  103ef9:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(err) {
  103efc:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  103f03:	0f 84 18 00 00 00    	je     103f21 <tar_load_ramfs+0x131>
  103f09:	8d 05 a4 94 10 00    	lea    0x1094a4,%eax
                kprintf("[initrfs] VFS ERROR: %d\n", err);
  103f0f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  103f12:	89 04 24             	mov    %eax,(%esp)
  103f15:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103f19:	e8 92 c3 ff ff       	call   1002b0 <kprintf>
  103f1e:	89 45 c0             	mov    %eax,-0x40(%ebp)
            }

            vfs_close(h);
  103f21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103f24:	89 04 24             	mov    %eax,(%esp)
  103f27:	e8 84 20 00 00       	call   105fb0 <vfs_close>
        }
  103f2c:	89 45 bc             	mov    %eax,-0x44(%ebp)
  103f2f:	e9 2d 00 00 00       	jmp    103f61 <tar_load_ramfs+0x171>
  103f34:	8d 05 bd 94 10 00    	lea    0x1094bd,%eax
        else
        {
            kprintf("[initrfs] Creating dir %s (%d bytes)\n", header->name, size);
  103f3a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103f3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103f40:	89 04 24             	mov    %eax,(%esp)
  103f43:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103f47:	89 54 24 08          	mov    %edx,0x8(%esp)
  103f4b:	e8 60 c3 ff ff       	call   1002b0 <kprintf>
            vfs_create_dir(header->name);
  103f50:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103f53:	89 0c 24             	mov    %ecx,(%esp)
  103f56:	89 45 b8             	mov    %eax,-0x48(%ebp)
  103f59:	e8 52 1d 00 00       	call   105cb0 <vfs_create_dir>
  103f5e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        }

        address += (size / 512) * 512;
  103f61:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103f64:	c1 e8 09             	shr    $0x9,%eax
  103f67:	c1 e0 09             	shl    $0x9,%eax
  103f6a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103f6d:	01 c1                	add    %eax,%ecx
  103f6f:	89 4d f4             	mov    %ecx,-0xc(%ebp)

        if (size % 512)
  103f72:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103f75:	25 ff 01 00 00       	and    $0x1ff,%eax
  103f7a:	3d 00 00 00 00       	cmp    $0x0,%eax
  103f7f:	0f 84 0b 00 00 00    	je     103f90 <tar_load_ramfs+0x1a0>
            address += 512;
  103f85:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f88:	05 00 02 00 00       	add    $0x200,%eax
  103f8d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    }
  103f90:	e9 00 00 00 00       	jmp    103f95 <tar_load_ramfs+0x1a5>

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);

    for (i = 0; ; i++)
  103f95:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103f98:	05 01 00 00 00       	add    $0x1,%eax
  103f9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103fa0:	e9 7d fe ff ff       	jmp    103e22 <tar_load_ramfs+0x32>
  103fa5:	8d 05 e3 94 10 00    	lea    0x1094e3,%eax
        if (size % 512)
            address += 512;

    }

    kprintf("[initrfs] Finished unpacking tarball\n");
  103fab:	89 04 24             	mov    %eax,(%esp)
  103fae:	e8 fd c2 ff ff       	call   1002b0 <kprintf>
}
  103fb3:	89 45 b0             	mov    %eax,-0x50(%ebp)
  103fb6:	83 c4 64             	add    $0x64,%esp
  103fb9:	5e                   	pop    %esi
  103fba:	5d                   	pop    %ebp
  103fbb:	c3                   	ret    
  103fbc:	0f 1f 40 00          	nopl   0x0(%eax)

00103fc0 <tar_parse_number>:
#include "ramfs/tar.h"
#include "ramfs/block.h"
#include "vfs.h"

static uint32_t tar_parse_number(const char *in)
{
  103fc0:	55                   	push   %ebp
  103fc1:	89 e5                	mov    %esp,%ebp
  103fc3:	83 ec 10             	sub    $0x10,%esp
  103fc6:	8b 45 08             	mov    0x8(%ebp),%eax
  103fc9:	89 45 fc             	mov    %eax,-0x4(%ebp)

    unsigned int size = 0;
  103fcc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    unsigned int j;
    unsigned int count = 1;
  103fd3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

    for (j = 11; j > 0; j--, count *= 8)
  103fda:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
  103fe1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103fe8:	0f 86 39 00 00 00    	jbe    104027 <tar_parse_number+0x67>
        size += ((in[j - 1] - '0') * count);
  103fee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ff1:	2d 01 00 00 00       	sub    $0x1,%eax
  103ff6:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103ff9:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  103ffd:	2d 30 00 00 00       	sub    $0x30,%eax
  104002:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  104006:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104009:	01 c1                	add    %eax,%ecx
  10400b:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    unsigned int size = 0;
    unsigned int j;
    unsigned int count = 1;

    for (j = 11; j > 0; j--, count *= 8)
  10400e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104011:	05 ff ff ff ff       	add    $0xffffffff,%eax
  104016:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104019:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10401c:	c1 e0 03             	shl    $0x3,%eax
  10401f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104022:	e9 ba ff ff ff       	jmp    103fe1 <tar_parse_number+0x21>
        size += ((in[j - 1] - '0') * count);

    return size;
  104027:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10402a:	83 c4 10             	add    $0x10,%esp
  10402d:	5d                   	pop    %ebp
  10402e:	c3                   	ret    
  10402f:	90                   	nop

00104030 <ramfs_vga_read>:

struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
}

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  104030:	55                   	push   %ebp
  104031:	89 e5                	mov    %esp,%ebp
  104033:	56                   	push   %esi
  104034:	83 ec 0c             	sub    $0xc,%esp
  104037:	8b 45 10             	mov    0x10(%ebp),%eax
  10403a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10403d:	8b 55 08             	mov    0x8(%ebp),%edx
  104040:	be 03 00 00 00       	mov    $0x3,%esi
  104045:	89 55 f8             	mov    %edx,-0x8(%ebp)
  104048:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10404b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  10404e:	89 f0                	mov    %esi,%eax
  104050:	83 c4 0c             	add    $0xc,%esp
  104053:	5e                   	pop    %esi
  104054:	5d                   	pop    %ebp
  104055:	c3                   	ret    
  104056:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10405d:	00 00 00 

00104060 <ramfs_vga_write>:
}

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  104060:	55                   	push   %ebp
  104061:	89 e5                	mov    %esp,%ebp
  104063:	83 ec 1c             	sub    $0x1c,%esp
  104066:	8b 45 10             	mov    0x10(%ebp),%eax
  104069:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10406c:	8b 55 08             	mov    0x8(%ebp),%edx
  10406f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  104072:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104075:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  104078:	81 7d f0 06 00 00 00 	cmpl   $0x6,-0x10(%ebp)
  10407f:	0f 84 0c 00 00 00    	je     104091 <ramfs_vga_write+0x31>
  104085:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  10408c:	e9 1f 01 00 00       	jmp    1041b0 <ramfs_vga_write+0x150>

    struct vga_command* vgac = src;
  104091:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104094:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(vgac->command == CMD_SET) {
  104097:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10409a:	0f b7 00             	movzwl (%eax),%eax
  10409d:	3d 00 00 00 00       	cmp    $0x0,%eax
  1040a2:	0f 85 2f 00 00 00    	jne    1040d7 <ramfs_vga_write+0x77>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  1040a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040ab:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1040af:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  1040b4:	0f 8d 18 00 00 00    	jge    1040d2 <ramfs_vga_write+0x72>
  1040ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040bd:	66 8b 48 04          	mov    0x4(%eax),%cx
  1040c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040c4:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1040c8:	8b 15 c0 82 10 00    	mov    0x1082c0,%edx
  1040ce:	66 89 0c 42          	mov    %cx,(%edx,%eax,2)
    }
  1040d2:	e9 00 00 00 00       	jmp    1040d7 <ramfs_vga_write+0x77>

    if(vgac->command == CMD_CLEAR) {
  1040d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040da:	0f b7 00             	movzwl (%eax),%eax
  1040dd:	3d 01 00 00 00       	cmp    $0x1,%eax
  1040e2:	0f 85 38 00 00 00    	jne    104120 <ramfs_vga_write+0xc0>
        for(int i = 0; i < (80 * 25); i++) {
  1040e8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1040ef:	81 7d e8 d0 07 00 00 	cmpl   $0x7d0,-0x18(%ebp)
  1040f6:	0f 8d 1f 00 00 00    	jge    10411b <ramfs_vga_write+0xbb>
            vga_buffer[i] = 0;
  1040fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1040ff:	8b 0d c0 82 10 00    	mov    0x1082c0,%ecx
  104105:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
    if(vgac->command == CMD_SET) {
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
  10410b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10410e:	05 01 00 00 00       	add    $0x1,%eax
  104113:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104116:	e9 d4 ff ff ff       	jmp    1040ef <ramfs_vga_write+0x8f>
            vga_buffer[i] = 0;
        }
    }
  10411b:	e9 00 00 00 00       	jmp    104120 <ramfs_vga_write+0xc0>

    if(vgac->command == CMD_SCROLL) {
  104120:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104123:	0f b7 00             	movzwl (%eax),%eax
  104126:	3d 02 00 00 00       	cmp    $0x2,%eax
  10412b:	0f 85 78 00 00 00    	jne    1041a9 <ramfs_vga_write+0x149>
        int i;
        for (i = 0; i < 24 * 80; i++) {
  104131:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104138:	81 7d e4 80 07 00 00 	cmpl   $0x780,-0x1c(%ebp)
  10413f:	0f 8d 2e 00 00 00    	jge    104173 <ramfs_vga_write+0x113>
            vga_buffer[i] = vga_buffer[i + 80];
  104145:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104148:	8b 0d c0 82 10 00    	mov    0x1082c0,%ecx
  10414e:	66 8b 94 41 a0 00 00 	mov    0xa0(%ecx,%eax,2),%dx
  104155:	00 
  104156:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104159:	8b 0d c0 82 10 00    	mov    0x1082c0,%ecx
  10415f:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  104163:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104166:	05 01 00 00 00       	add    $0x1,%eax
  10416b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10416e:	e9 c5 ff ff ff       	jmp    104138 <ramfs_vga_write+0xd8>
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  104173:	e9 00 00 00 00       	jmp    104178 <ramfs_vga_write+0x118>
  104178:	81 7d e4 d0 07 00 00 	cmpl   $0x7d0,-0x1c(%ebp)
  10417f:	0f 8d 1f 00 00 00    	jge    1041a4 <ramfs_vga_write+0x144>
            vga_buffer[i] = 0;
  104185:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104188:	8b 0d c0 82 10 00    	mov    0x1082c0,%ecx
  10418e:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  104194:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104197:	05 01 00 00 00       	add    $0x1,%eax
  10419c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10419f:	e9 d4 ff ff ff       	jmp    104178 <ramfs_vga_write+0x118>
            vga_buffer[i] = 0;
        }
    }
  1041a4:	e9 00 00 00 00       	jmp    1041a9 <ramfs_vga_write+0x149>

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  1041a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1041b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1041b3:	83 c4 1c             	add    $0x1c,%esp
  1041b6:	5d                   	pop    %ebp
  1041b7:	c3                   	ret    
  1041b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  1041bf:	00 

001041c0 <ramfs_vga_open>:

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
  1041c0:	55                   	push   %ebp
  1041c1:	89 e5                	mov    %esp,%ebp
  1041c3:	83 ec 18             	sub    $0x18,%esp
  1041c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1041c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1041cc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1041cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filemode & FM_EXEC) return 0;
  1041d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1041d5:	25 04 00 00 00       	and    $0x4,%eax
  1041da:	3d 00 00 00 00       	cmp    $0x0,%eax
  1041df:	0f 84 0c 00 00 00    	je     1041f1 <ramfs_vga_open+0x31>
  1041e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1041ec:	e9 b2 00 00 00       	jmp    1042a3 <ramfs_vga_open+0xe3>
    if(filemode & FM_READ) return 0;
  1041f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1041f4:	25 01 00 00 00       	and    $0x1,%eax
  1041f9:	3d 00 00 00 00       	cmp    $0x0,%eax
  1041fe:	0f 84 0c 00 00 00    	je     104210 <ramfs_vga_open+0x50>
  104204:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10420b:	e9 93 00 00 00       	jmp    1042a3 <ramfs_vga_open+0xe3>

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  104210:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104213:	25 02 00 00 00       	and    $0x2,%eax
  104218:	3d 00 00 00 00       	cmp    $0x0,%eax
  10421d:	0f 84 1c 00 00 00    	je     10423f <ramfs_vga_open+0x7f>
  104223:	81 3d 2c a5 10 00 00 	cmpl   $0x0,0x10a52c
  10422a:	00 00 00 
  10422d:	0f 84 0c 00 00 00    	je     10423f <ramfs_vga_open+0x7f>
  104233:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10423a:	e9 64 00 00 00       	jmp    1042a3 <ramfs_vga_open+0xe3>
    if((filemode & FM_WRITE)) vga_writers++;
  10423f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104242:	25 02 00 00 00       	and    $0x2,%eax
  104247:	3d 00 00 00 00       	cmp    $0x0,%eax
  10424c:	0f 84 0f 00 00 00    	je     104261 <ramfs_vga_open+0xa1>
  104252:	a1 2c a5 10 00       	mov    0x10a52c,%eax
  104257:	05 01 00 00 00       	add    $0x1,%eax
  10425c:	a3 2c a5 10 00       	mov    %eax,0x10a52c
  104261:	b8 10 00 00 00       	mov    $0x10,%eax

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  104266:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10426d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104270:	e8 7b 0d 00 00       	call   104ff0 <malloc>
  104275:	89 45 f0             	mov    %eax,-0x10(%ebp)

    rethandle->filemode = filemode;
  104278:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10427b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10427e:	89 41 0c             	mov    %eax,0xc(%ecx)
    rethandle->position = 0;
  104281:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104284:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    rethandle->res_type = RES_KERNDRV;
  10428b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10428e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    rethandle->res_ptr  = kf;
  104294:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104297:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10429a:	89 41 04             	mov    %eax,0x4(%ecx)

    return rethandle;
  10429d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1042a0:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1042a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1042a6:	83 c4 18             	add    $0x18,%esp
  1042a9:	5d                   	pop    %ebp
  1042aa:	c3                   	ret    
  1042ab:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001042b0 <ramfs_vga_close>:

uint32_t ramfs_vga_close(struct res_handle* handle) {
  1042b0:	55                   	push   %ebp
  1042b1:	89 e5                	mov    %esp,%ebp
  1042b3:	83 ec 08             	sub    $0x8,%esp
  1042b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1042b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(handle->filemode & FM_WRITE) vga_writers--;
  1042bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1042bf:	8b 40 0c             	mov    0xc(%eax),%eax
  1042c2:	25 02 00 00 00       	and    $0x2,%eax
  1042c7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1042cc:	0f 84 0f 00 00 00    	je     1042e1 <ramfs_vga_close+0x31>
  1042d2:	a1 2c a5 10 00       	mov    0x10a52c,%eax
  1042d7:	05 ff ff ff ff       	add    $0xffffffff,%eax
  1042dc:	a3 2c a5 10 00       	mov    %eax,0x10a52c

    free(handle);
  1042e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1042e4:	89 04 24             	mov    %eax,(%esp)
  1042e7:	e8 04 11 00 00       	call   1053f0 <free>
  1042ec:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  1042f1:	83 c4 08             	add    $0x8,%esp
  1042f4:	5d                   	pop    %ebp
  1042f5:	c3                   	ret    
  1042f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1042fd:	00 00 00 

00104300 <ramfs_vga_available>:

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

uint32_t ramfs_vga_available(struct res_handle* handle) {
  104300:	55                   	push   %ebp
  104301:	89 e5                	mov    %esp,%ebp
  104303:	50                   	push   %eax
  104304:	8b 45 08             	mov    0x8(%ebp),%eax
  104307:	b9 06 00 00 00       	mov    $0x6,%ecx
  10430c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return sizeof(struct vga_command);
  10430f:	89 c8                	mov    %ecx,%eax
  104311:	83 c4 04             	add    $0x4,%esp
  104314:	5d                   	pop    %ebp
  104315:	c3                   	ret    
  104316:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10431d:	00 00 00 

00104320 <ramfs_vga_create>:
}

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  104320:	55                   	push   %ebp
  104321:	89 e5                	mov    %esp,%ebp
  104323:	83 ec 18             	sub    $0x18,%esp
  104326:	8b 45 08             	mov    0x8(%ebp),%eax
  104329:	b9 08 00 00 00       	mov    $0x8,%ecx
  10432e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return malloc(sizeof(struct res_kfile));
  104331:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  104338:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10433b:	e8 b0 0c 00 00       	call   104ff0 <malloc>
  104340:	83 c4 18             	add    $0x18,%esp
  104343:	5d                   	pop    %ebp
  104344:	c3                   	ret    
  104345:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10434c:	00 00 00 00 

00104350 <ramfs_vga_driver_struct>:
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
  104350:	55                   	push   %ebp
  104351:	89 e5                	mov    %esp,%ebp
  104353:	8d 05 c4 82 10 00    	lea    0x1082c4,%eax
    return &vga_driver;
  104359:	5d                   	pop    %ebp
  10435a:	c3                   	ret    
  10435b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104360 <ramfs_vga_writers>:
}

uint32_t ramfs_vga_writers() {
  104360:	55                   	push   %ebp
  104361:	89 e5                	mov    %esp,%ebp
    return vga_writers;
  104363:	a1 2c a5 10 00       	mov    0x10a52c,%eax
  104368:	5d                   	pop    %ebp
  104369:	c3                   	ret    
  10436a:	66 90                	xchg   %ax,%ax
  10436c:	66 90                	xchg   %ax,%ax
  10436e:	66 90                	xchg   %ax,%ax

00104370 <enableScheduling>:
struct task* first_task = 0;
struct task* current_task = 0;

int nextPID = 1; //FIXME int.max_value overflow

void enableScheduling(void) {
  104370:	55                   	push   %ebp
  104371:	89 e5                	mov    %esp,%ebp
    schedulingEnabled = 1;
  104373:	c7 05 30 a5 10 00 01 	movl   $0x1,0x10a530
  10437a:	00 00 00 
}
  10437d:	5d                   	pop    %ebp
  10437e:	c3                   	ret    
  10437f:	90                   	nop

00104380 <isSchedulingEnabled>:

uint32_t isSchedulingEnabled(void) {
  104380:	55                   	push   %ebp
  104381:	89 e5                	mov    %esp,%ebp
    return schedulingEnabled;
  104383:	a1 30 a5 10 00       	mov    0x10a530,%eax
  104388:	5d                   	pop    %ebp
  104389:	c3                   	ret    
  10438a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104390 <get_current_task>:
}

struct task* get_current_task(void) {
  104390:	55                   	push   %ebp
  104391:	89 e5                	mov    %esp,%ebp
    return current_task;
  104393:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104398:	5d                   	pop    %ebp
  104399:	c3                   	ret    
  10439a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001043a0 <get_task_by_pid>:
}

struct task* get_task_by_pid(int pid) {
  1043a0:	55                   	push   %ebp
  1043a1:	89 e5                	mov    %esp,%ebp
  1043a3:	83 ec 0c             	sub    $0xc,%esp
  1043a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1043a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct task* cur = first_task;
  1043ac:	a1 34 a5 10 00       	mov    0x10a534,%eax
  1043b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1043b4:	b0 00                	mov    $0x0,%al

    while(cur != 0 && cur->PID != pid) {
  1043b6:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1043bd:	88 45 f7             	mov    %al,-0x9(%ebp)
  1043c0:	0f 84 0e 00 00 00    	je     1043d4 <get_task_by_pid+0x34>
  1043c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1043c9:	8b 00                	mov    (%eax),%eax
  1043cb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  1043ce:	0f 95 c1             	setne  %cl
  1043d1:	88 4d f7             	mov    %cl,-0x9(%ebp)
  1043d4:	8a 45 f7             	mov    -0x9(%ebp),%al
  1043d7:	a8 01                	test   $0x1,%al
  1043d9:	0f 85 05 00 00 00    	jne    1043e4 <get_task_by_pid+0x44>
  1043df:	e9 0e 00 00 00       	jmp    1043f2 <get_task_by_pid+0x52>
        cur = cur->next;
  1043e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1043e7:	8b 40 08             	mov    0x8(%eax),%eax
  1043ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  1043ed:	e9 c2 ff ff ff       	jmp    1043b4 <get_task_by_pid+0x14>

    return cur;
  1043f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1043f5:	83 c4 0c             	add    $0xc,%esp
  1043f8:	5d                   	pop    %ebp
  1043f9:	c3                   	ret    
  1043fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104400 <register_handle>:
}

uint32_t register_handle(struct res_handle* h) {
  104400:	55                   	push   %ebp
  104401:	89 e5                	mov    %esp,%ebp
  104403:	83 ec 18             	sub    $0x18,%esp
  104406:	8b 45 08             	mov    0x8(%ebp),%eax
  104409:	b9 08 00 00 00       	mov    $0x8,%ecx
  10440e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct hl_node* old = current_task->handle_list;
  104411:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104416:	8b 40 3c             	mov    0x3c(%eax),%eax
  104419:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task->handle_list = malloc(sizeof(struct hl_node));
  10441c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  104423:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104426:	e8 c5 0b 00 00       	call   104ff0 <malloc>
  10442b:	b9 00 00 00 00       	mov    $0x0,%ecx
  104430:	8b 15 38 a5 10 00    	mov    0x10a538,%edx
  104436:	89 42 3c             	mov    %eax,0x3c(%edx)
    current_task->handle_list->next = old;
  104439:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10443c:	8b 15 38 a5 10 00    	mov    0x10a538,%edx
  104442:	8b 52 3c             	mov    0x3c(%edx),%edx
  104445:	89 42 04             	mov    %eax,0x4(%edx)
    current_task->handle_list->handle = h;
  104448:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10444b:	8b 15 38 a5 10 00    	mov    0x10a538,%edx
  104451:	8b 52 3c             	mov    0x3c(%edx),%edx
  104454:	89 02                	mov    %eax,(%edx)

    return 0;
  104456:	89 c8                	mov    %ecx,%eax
  104458:	83 c4 18             	add    $0x18,%esp
  10445b:	5d                   	pop    %ebp
  10445c:	c3                   	ret    
  10445d:	0f 1f 00             	nopl   (%eax)

00104460 <unregister_handle>:
}

uint32_t unregister_handle(struct res_handle* h) {
  104460:	55                   	push   %ebp
  104461:	89 e5                	mov    %esp,%ebp
  104463:	83 ec 18             	sub    $0x18,%esp
  104466:	8b 45 08             	mov    0x8(%ebp),%eax
  104469:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct hl_node* cur = current_task->handle_list;
  10446c:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104471:	8b 40 3c             	mov    0x3c(%eax),%eax
  104474:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(h == 0) return 2;
  104477:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10447e:	0f 85 0c 00 00 00    	jne    104490 <unregister_handle+0x30>
  104484:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
  10448b:	e9 b4 00 00 00       	jmp    104544 <unregister_handle+0xe4>
    if(cur == 0) return 1;
  104490:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104497:	0f 85 0c 00 00 00    	jne    1044a9 <unregister_handle+0x49>
  10449d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1044a4:	e9 9b 00 00 00       	jmp    104544 <unregister_handle+0xe4>

    if(cur->handle == h) {
  1044a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044ac:	8b 00                	mov    (%eax),%eax
  1044ae:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1044b1:	0f 85 26 00 00 00    	jne    1044dd <unregister_handle+0x7d>
        current_task->handle_list = cur->next;
  1044b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044ba:	8b 40 04             	mov    0x4(%eax),%eax
  1044bd:	8b 0d 38 a5 10 00    	mov    0x10a538,%ecx
  1044c3:	89 41 3c             	mov    %eax,0x3c(%ecx)
        free(cur);
  1044c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044c9:	89 04 24             	mov    %eax,(%esp)
  1044cc:	e8 1f 0f 00 00       	call   1053f0 <free>

        return 0;
  1044d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1044d8:	e9 67 00 00 00       	jmp    104544 <unregister_handle+0xe4>
    }

    while(cur != 0) {
  1044dd:	e9 00 00 00 00       	jmp    1044e2 <unregister_handle+0x82>
  1044e2:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1044e9:	0f 84 4e 00 00 00    	je     10453d <unregister_handle+0xdd>
        if(cur->next->handle == h) {
  1044ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044f2:	8b 40 04             	mov    0x4(%eax),%eax
  1044f5:	8b 00                	mov    (%eax),%eax
  1044f7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1044fa:	0f 85 2f 00 00 00    	jne    10452f <unregister_handle+0xcf>
            void* next = cur->next;
  104500:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104503:	8b 40 04             	mov    0x4(%eax),%eax
  104506:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cur->next =  cur->next->next;
  104509:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10450c:	8b 40 04             	mov    0x4(%eax),%eax
  10450f:	8b 40 04             	mov    0x4(%eax),%eax
  104512:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104515:	89 41 04             	mov    %eax,0x4(%ecx)

            free(next);
  104518:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10451b:	89 04 24             	mov    %eax,(%esp)
  10451e:	e8 cd 0e 00 00       	call   1053f0 <free>

            return 0;
  104523:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10452a:	e9 15 00 00 00       	jmp    104544 <unregister_handle+0xe4>
        }

        cur = cur->next;
  10452f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104532:	8b 40 04             	mov    0x4(%eax),%eax
  104535:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  104538:	e9 a5 ff ff ff       	jmp    1044e2 <unregister_handle+0x82>

    return 3;
  10453d:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  104544:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104547:	83 c4 18             	add    $0x18,%esp
  10454a:	5d                   	pop    %ebp
  10454b:	c3                   	ret    
  10454c:	0f 1f 40 00          	nopl   0x0(%eax)

00104550 <schedule_exception>:

struct cpu_state* schedule_exception(struct cpu_state* cpu) {
  104550:	55                   	push   %ebp
  104551:	89 e5                	mov    %esp,%ebp
  104553:	57                   	push   %edi
  104554:	56                   	push   %esi
  104555:	83 ec 40             	sub    $0x40,%esp
  104558:	8b 45 08             	mov    0x8(%ebp),%eax
  10455b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (current_task == first_task && current_task->next == 0) {
  10455e:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104563:	3b 05 34 a5 10 00    	cmp    0x10a534,%eax
  104569:	0f 85 85 00 00 00    	jne    1045f4 <schedule_exception+0xa4>
  10456f:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104574:	81 78 08 00 00 00 00 	cmpl   $0x0,0x8(%eax)
  10457b:	0f 85 73 00 00 00    	jne    1045f4 <schedule_exception+0xa4>
  104581:	b8 04 00 00 00       	mov    $0x4,%eax
        //Only one process is running, which just crashed. Stop system.
        setclr(0x04);
  104586:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10458d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104590:	e8 fb bc ff ff       	call   100290 <setclr>
  104595:	8d 05 15 95 10 00    	lea    0x109515,%eax
        kprintf("\n~~~ Terminated task (PID=%d PATH=%s) due to exception %x:%x \n", current_task->PID, current_task->filePath, cpu->intr, cpu->error);
  10459b:	8b 0d 38 a5 10 00    	mov    0x10a538,%ecx
  1045a1:	8b 09                	mov    (%ecx),%ecx
  1045a3:	8b 15 38 a5 10 00    	mov    0x10a538,%edx
  1045a9:	8b 52 24             	mov    0x24(%edx),%edx
  1045ac:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1045af:	8b 76 1c             	mov    0x1c(%esi),%esi
  1045b2:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1045b5:	8b 7f 20             	mov    0x20(%edi),%edi
  1045b8:	89 04 24             	mov    %eax,(%esp)
  1045bb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1045bf:	89 54 24 08          	mov    %edx,0x8(%esp)
  1045c3:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1045c7:	89 7c 24 10          	mov    %edi,0x10(%esp)
  1045cb:	e8 e0 bc ff ff       	call   1002b0 <kprintf>
  1045d0:	8d 0d 54 95 10 00    	lea    0x109554,%ecx
        show_cod(cpu, "Last task crashed. Terminating kernel...");
  1045d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1045d9:	89 14 24             	mov    %edx,(%esp)
  1045dc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1045e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1045e3:	e8 d8 ba ff ff       	call   1000c0 <show_cod>

        //will never occur cause COD terminates execution
        return 0;
  1045e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1045ef:	e9 90 00 00 00       	jmp    104684 <schedule_exception+0x134>
  1045f4:	b8 04 00 00 00       	mov    $0x4,%eax
    } else {
        //Potential security leaks available in following code.
        setclr(0x04);
  1045f9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  104600:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104603:	e8 88 bc ff ff       	call   100290 <setclr>
  104608:	8d 05 15 95 10 00    	lea    0x109515,%eax
        kprintf("\n~~~ Terminated task (PID=%d PATH=%s) due to exception %x:%x \n", current_task->PID, current_task->filePath, cpu->intr, cpu->error);
  10460e:	8b 0d 38 a5 10 00    	mov    0x10a538,%ecx
  104614:	8b 09                	mov    (%ecx),%ecx
  104616:	8b 15 38 a5 10 00    	mov    0x10a538,%edx
  10461c:	8b 52 24             	mov    0x24(%edx),%edx
  10461f:	8b 75 f0             	mov    -0x10(%ebp),%esi
  104622:	8b 76 1c             	mov    0x1c(%esi),%esi
  104625:	8b 7d f0             	mov    -0x10(%ebp),%edi
  104628:	8b 7f 20             	mov    0x20(%edi),%edi
  10462b:	89 04 24             	mov    %eax,(%esp)
  10462e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104632:	89 54 24 08          	mov    %edx,0x8(%esp)
  104636:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10463a:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10463e:	e8 6d bc ff ff       	call   1002b0 <kprintf>
  104643:	8d 0d 70 92 10 00    	lea    0x109270,%ecx
        kprintf("\n");
  104649:	89 0c 24             	mov    %ecx,(%esp)
  10464c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10464f:	e8 5c bc ff ff       	call   1002b0 <kprintf>
        show_dump(cpu);
  104654:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104657:	89 0c 24             	mov    %ecx,(%esp)
  10465a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10465d:	e8 de ba ff ff       	call   100140 <show_dump>
  104662:	b8 07 00 00 00       	mov    $0x7,%eax
        setclr(0x07);
  104667:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  10466e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104671:	e8 1a bc ff ff       	call   100290 <setclr>

        return terminate_current(cpu);
  104676:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104679:	89 04 24             	mov    %eax,(%esp)
  10467c:	e8 0f 00 00 00       	call   104690 <terminate_current>
  104681:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
}
  104684:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104687:	83 c4 40             	add    $0x40,%esp
  10468a:	5e                   	pop    %esi
  10468b:	5f                   	pop    %edi
  10468c:	5d                   	pop    %ebp
  10468d:	c3                   	ret    
  10468e:	66 90                	xchg   %ax,%ax

00104690 <terminate_current>:

struct cpu_state* terminate_current(struct cpu_state* cpu) {
  104690:	55                   	push   %ebp
  104691:	89 e5                	mov    %esp,%ebp
  104693:	83 ec 18             	sub    $0x18,%esp
  104696:	8b 45 08             	mov    0x8(%ebp),%eax
  104699:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct task* next = current_task->next;
  10469c:	a1 38 a5 10 00       	mov    0x10a538,%eax
  1046a1:	8b 40 08             	mov    0x8(%eax),%eax
  1046a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* prev = current_task->prev;
  1046a7:	a1 38 a5 10 00       	mov    0x10a538,%eax
  1046ac:	8b 40 0c             	mov    0xc(%eax),%eax
  1046af:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct task* old = current_task;
  1046b2:	a1 38 a5 10 00       	mov    0x10a538,%eax
  1046b7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    vmm_free_current_pagetables();
  1046ba:	e8 c1 2c 00 00       	call   107380 <vmm_free_current_pagetables>

    if (current_task == first_task) {
  1046bf:	a1 38 a5 10 00       	mov    0x10a538,%eax
  1046c4:	3b 05 34 a5 10 00    	cmp    0x10a534,%eax
  1046ca:	0f 85 0d 00 00 00    	jne    1046dd <terminate_current+0x4d>
        first_task = current_task->next;
  1046d0:	a1 38 a5 10 00       	mov    0x10a538,%eax
  1046d5:	8b 40 08             	mov    0x8(%eax),%eax
  1046d8:	a3 34 a5 10 00       	mov    %eax,0x10a534
    }

    if (next != 0) {
  1046dd:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1046e4:	0f 84 09 00 00 00    	je     1046f3 <terminate_current+0x63>
        next->prev = prev;
  1046ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1046ed:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1046f0:	89 41 0c             	mov    %eax,0xc(%ecx)
    }

    if (prev != 0) {
  1046f3:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1046fa:	0f 84 09 00 00 00    	je     104709 <terminate_current+0x79>
        prev->next = next;
  104700:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104703:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104706:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if (next == 0)
  104709:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104710:	0f 85 08 00 00 00    	jne    10471e <terminate_current+0x8e>
        next = first_task;
  104716:	a1 34 a5 10 00       	mov    0x10a534,%eax
  10471b:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task = next;
  10471e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104721:	a3 38 a5 10 00       	mov    %eax,0x10a538

    free(old->cpuState);
  104726:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104729:	8b 40 04             	mov    0x4(%eax),%eax
  10472c:	89 04 24             	mov    %eax,(%esp)
  10472f:	e8 bc 0c 00 00       	call   1053f0 <free>
    free(old);
  104734:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104737:	89 04 24             	mov    %eax,(%esp)
  10473a:	e8 b1 0c 00 00       	call   1053f0 <free>

    if(current_task == 0) {
  10473f:	81 3d 38 a5 10 00 00 	cmpl   $0x0,0x10a538
  104746:	00 00 00 
  104749:	0f 85 15 00 00 00    	jne    104764 <terminate_current+0xd4>
  10474f:	8d 05 7d 95 10 00    	lea    0x10957d,%eax
        show_cod(cpu, "Last task terminated.");
  104755:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104758:	89 0c 24             	mov    %ecx,(%esp)
  10475b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10475f:	e8 5c b9 ff ff       	call   1000c0 <show_cod>
    }

    vmm_activate_pagedir(current_task->phys_pdir);
  104764:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104769:	8b 40 14             	mov    0x14(%eax),%eax
  10476c:	89 04 24             	mov    %eax,(%esp)
  10476f:	e8 7c 34 00 00       	call   107bf0 <vmm_activate_pagedir>
    return current_task->cpuState;
  104774:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104779:	8b 40 04             	mov    0x4(%eax),%eax
  10477c:	83 c4 18             	add    $0x18,%esp
  10477f:	5d                   	pop    %ebp
  104780:	c3                   	ret    
  104781:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104788:	0f 1f 84 00 00 00 00 
  10478f:	00 

00104790 <init_task>:
}

struct task* init_task(uint32_t task_pagedir, void* entry) {
  104790:	55                   	push   %ebp
  104791:	89 e5                	mov    %esp,%ebp
  104793:	56                   	push   %esi
  104794:	83 ec 74             	sub    $0x74,%esp
  104797:	8b 45 0c             	mov    0xc(%ebp),%eax
  10479a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10479d:	ba 01 00 00 00       	mov    $0x1,%edx
  1047a2:	be 40 00 00 00       	mov    $0x40,%esi
  1047a7:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1047aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct task* ntask = calloc(1, sizeof(struct task));
  1047ad:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1047b4:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
  1047bb:	00 
  1047bc:	89 55 ac             	mov    %edx,-0x54(%ebp)
  1047bf:	89 75 a8             	mov    %esi,-0x58(%ebp)
  1047c2:	e8 e9 0a 00 00       	call   1052b0 <calloc>
  1047c7:	b9 01 00 00 00       	mov    $0x1,%ecx
  1047cc:	ba 38 00 00 00       	mov    $0x38,%edx
  1047d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ntask->cpuState = calloc(1, sizeof(struct cpu_state));
  1047d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1047db:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
  1047e2:	00 
  1047e3:	89 55 a4             	mov    %edx,-0x5c(%ebp)
  1047e6:	89 4d a0             	mov    %ecx,-0x60(%ebp)
  1047e9:	e8 c2 0a 00 00       	call   1052b0 <calloc>
  1047ee:	b9 00 e0 ff ff       	mov    $0xffffe000,%ecx
  1047f3:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1047f6:	89 42 04             	mov    %eax,0x4(%edx)

    ntask->phys_pdir = task_pagedir;
  1047f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1047fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1047ff:	89 42 14             	mov    %eax,0x14(%edx)
    ntask->user_stack_bottom = (void*) 0xFFFFE000;
  104802:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104805:	89 48 10             	mov    %ecx,0x10(%eax)
    ntask->PID = nextPID++;
  104808:	a1 e0 82 10 00       	mov    0x1082e0,%eax
  10480d:	89 c1                	mov    %eax,%ecx
  10480f:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104815:	89 0d e0 82 10 00    	mov    %ecx,0x1082e0
  10481b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10481e:	89 01                	mov    %eax,(%ecx)

    ntask->stdin  = 0;
  104820:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104823:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    ntask->stdout = 0;
  10482a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10482d:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
    ntask->stderr = 0;
  104834:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104837:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

    ntask->next = (void*) 0;
  10483e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104841:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    ntask->prev = (void*) 0;
  104848:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10484b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

    if (first_task == 0) {
  104852:	81 3d 34 a5 10 00 00 	cmpl   $0x0,0x10a534
  104859:	00 00 00 
  10485c:	0f 85 0d 00 00 00    	jne    10486f <init_task+0xdf>
        first_task = ntask;
  104862:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104865:	a3 34 a5 10 00       	mov    %eax,0x10a534
    } else {
  10486a:	e9 1f 00 00 00       	jmp    10488e <init_task+0xfe>
        ntask->next = first_task;
  10486f:	a1 34 a5 10 00       	mov    0x10a534,%eax
  104874:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104877:	89 41 08             	mov    %eax,0x8(%ecx)
        first_task->prev = ntask;
  10487a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10487d:	8b 0d 34 a5 10 00    	mov    0x10a534,%ecx
  104883:	89 41 0c             	mov    %eax,0xc(%ecx)
        first_task = ntask;
  104886:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104889:	a3 34 a5 10 00       	mov    %eax,0x10a534
    }

    uint32_t rest_pdir = vmm_get_current_pagedir();
  10488e:	e8 8d 27 00 00       	call   107020 <vmm_get_current_pagedir>
  104893:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vmm_activate_pagedir(task_pagedir);
  104896:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104899:	89 04 24             	mov    %eax,(%esp)
  10489c:	e8 4f 33 00 00       	call   107bf0 <vmm_activate_pagedir>
  1048a1:	b8 00 00 00 00       	mov    $0x0,%eax

    vmm_alloc_addr(ntask->user_stack_bottom, 0);
  1048a6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1048a9:	8b 49 10             	mov    0x10(%ecx),%ecx
  1048ac:	89 0c 24             	mov    %ecx,(%esp)
  1048af:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1048b6:	00 
  1048b7:	89 45 9c             	mov    %eax,-0x64(%ebp)
  1048ba:	e8 31 32 00 00       	call   107af0 <vmm_alloc_addr>
  1048bf:	b9 38 00 00 00       	mov    $0x38,%ecx
  1048c4:	8d 55 b0             	lea    -0x50(%ebp),%edx

    struct cpu_state nstate = { .eax = 0, .ebx = 0, .ecx = 0, .edx = 0,
  1048c7:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
  1048ce:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
  1048d5:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  1048dc:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  1048e3:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  1048ea:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  1048f1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  1048f8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  1048ff:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  104906:	8b 75 f4             	mov    -0xc(%ebp),%esi
  104909:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  10490c:	c7 45 d8 1b 00 00 00 	movl   $0x1b,-0x28(%ebp)
  104913:	c7 45 dc 00 02 00 00 	movl   $0x200,-0x24(%ebp)
  10491a:	8b 75 f0             	mov    -0x10(%ebp),%esi
  10491d:	8b 76 10             	mov    0x10(%esi),%esi
  104920:	81 c6 00 10 00 00    	add    $0x1000,%esi
  104926:	89 75 e0             	mov    %esi,-0x20(%ebp)
  104929:	c7 45 e4 23 00 00 00 	movl   $0x23,-0x1c(%ebp)
            /* Ring-3-Segmentregister */
            .cs = 0x18 | 0x03, .ss = 0x20 | 0x03,

            .eflags = 0x200, };

    memcpy(ntask->cpuState, &nstate, sizeof(struct cpu_state));
  104930:	8b 75 f0             	mov    -0x10(%ebp),%esi
  104933:	8b 76 04             	mov    0x4(%esi),%esi
  104936:	89 34 24             	mov    %esi,(%esp)
  104939:	89 54 24 04          	mov    %edx,0x4(%esp)
  10493d:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  104944:	00 
  104945:	89 45 98             	mov    %eax,-0x68(%ebp)
  104948:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
  10494b:	e8 d0 0d 00 00       	call   105720 <memcpy>

    vmm_activate_pagedir(rest_pdir);
  104950:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104953:	89 04 24             	mov    %eax,(%esp)
  104956:	e8 95 32 00 00       	call   107bf0 <vmm_activate_pagedir>

    return ntask;
  10495b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10495e:	83 c4 74             	add    $0x74,%esp
  104961:	5e                   	pop    %esi
  104962:	5d                   	pop    %ebp
  104963:	c3                   	ret    
  104964:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10496b:	00 00 00 00 00 

00104970 <save_cpu_state>:
}

struct cpu_state* save_cpu_state(struct cpu_state* cpu) {
  104970:	55                   	push   %ebp
  104971:	89 e5                	mov    %esp,%ebp
  104973:	83 ec 28             	sub    $0x28,%esp
  104976:	8b 45 08             	mov    0x8(%ebp),%eax
  104979:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(current_task->rpc && current_task->rpc->executing) {
  10497c:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104981:	81 78 18 00 00 00 00 	cmpl   $0x0,0x18(%eax)
  104988:	0f 84 55 00 00 00    	je     1049e3 <save_cpu_state+0x73>
  10498e:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104993:	8b 40 18             	mov    0x18(%eax),%eax
  104996:	0f b6 40 14          	movzbl 0x14(%eax),%eax
  10499a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10499f:	0f 84 3e 00 00 00    	je     1049e3 <save_cpu_state+0x73>
  1049a5:	b8 38 00 00 00       	mov    $0x38,%eax
        memcpy(current_task->rpc->state, cpu, sizeof(struct cpu_state));
  1049aa:	8b 0d 38 a5 10 00    	mov    0x10a538,%ecx
  1049b0:	8b 49 18             	mov    0x18(%ecx),%ecx
  1049b3:	8b 49 18             	mov    0x18(%ecx),%ecx
  1049b6:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1049b9:	89 0c 24             	mov    %ecx,(%esp)
  1049bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1049c0:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  1049c7:	00 
  1049c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1049cb:	e8 50 0d 00 00       	call   105720 <memcpy>
        return current_task->rpc->state;
  1049d0:	a1 38 a5 10 00       	mov    0x10a538,%eax
  1049d5:	8b 40 18             	mov    0x18(%eax),%eax
  1049d8:	8b 40 18             	mov    0x18(%eax),%eax
  1049db:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1049de:	e9 33 00 00 00       	jmp    104a16 <save_cpu_state+0xa6>
  1049e3:	b8 38 00 00 00       	mov    $0x38,%eax
    }
    else
    {
        memcpy(current_task->cpuState, cpu, sizeof(struct cpu_state));
  1049e8:	8b 0d 38 a5 10 00    	mov    0x10a538,%ecx
  1049ee:	8b 49 04             	mov    0x4(%ecx),%ecx
  1049f1:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1049f4:	89 0c 24             	mov    %ecx,(%esp)
  1049f7:	89 54 24 04          	mov    %edx,0x4(%esp)
  1049fb:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  104a02:	00 
  104a03:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104a06:	e8 15 0d 00 00       	call   105720 <memcpy>
        return current_task->cpuState;
  104a0b:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104a10:	8b 40 04             	mov    0x4(%eax),%eax
  104a13:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  104a16:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104a19:	83 c4 28             	add    $0x28,%esp
  104a1c:	5d                   	pop    %ebp
  104a1d:	c3                   	ret    
  104a1e:	66 90                	xchg   %ax,%ax

00104a20 <schedule_to_task>:

struct cpu_state* schedule_to_task(struct task* dest) {
  104a20:	55                   	push   %ebp
  104a21:	89 e5                	mov    %esp,%ebp
  104a23:	83 ec 18             	sub    $0x18,%esp
  104a26:	8b 45 08             	mov    0x8(%ebp),%eax
  104a29:	89 45 f8             	mov    %eax,-0x8(%ebp)
    current_task = dest;
  104a2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a2f:	a3 38 a5 10 00       	mov    %eax,0x10a538

    vmm_activate_pagedir(dest->phys_pdir);
  104a34:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a37:	8b 40 14             	mov    0x14(%eax),%eax
  104a3a:	89 04 24             	mov    %eax,(%esp)
  104a3d:	e8 ae 31 00 00       	call   107bf0 <vmm_activate_pagedir>

    if(!dest->rpc) {
  104a42:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a45:	81 78 18 00 00 00 00 	cmpl   $0x0,0x18(%eax)
  104a4c:	0f 85 0e 00 00 00    	jne    104a60 <schedule_to_task+0x40>
        return dest->cpuState;
  104a52:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a55:	8b 40 04             	mov    0x4(%eax),%eax
  104a58:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104a5b:	e9 27 00 00 00       	jmp    104a87 <schedule_to_task+0x67>
    }
    else
    {
        if(!dest->rpc->executing) {
  104a60:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a63:	8b 40 18             	mov    0x18(%eax),%eax
  104a66:	80 78 14 00          	cmpb   $0x0,0x14(%eax)
  104a6a:	0f 85 0b 00 00 00    	jne    104a7b <schedule_to_task+0x5b>
            init_rpc_call(dest);
  104a70:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a73:	89 04 24             	mov    %eax,(%esp)
  104a76:	e8 d5 00 00 00       	call   104b50 <init_rpc_call>
        }
        return dest->rpc->state;
  104a7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a7e:	8b 40 18             	mov    0x18(%eax),%eax
  104a81:	8b 40 18             	mov    0x18(%eax),%eax
  104a84:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  104a87:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104a8a:	83 c4 18             	add    $0x18,%esp
  104a8d:	5d                   	pop    %ebp
  104a8e:	c3                   	ret    
  104a8f:	90                   	nop

00104a90 <schedule>:

struct cpu_state* schedule(struct cpu_state* cpu) {
  104a90:	55                   	push   %ebp
  104a91:	89 e5                	mov    %esp,%ebp
  104a93:	83 ec 18             	sub    $0x18,%esp
  104a96:	8b 45 08             	mov    0x8(%ebp),%eax
  104a99:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (first_task != 0 && schedulingEnabled) {
  104a9c:	81 3d 34 a5 10 00 00 	cmpl   $0x0,0x10a534
  104aa3:	00 00 00 
  104aa6:	0f 84 8b 00 00 00    	je     104b37 <schedule+0xa7>
  104aac:	81 3d 30 a5 10 00 00 	cmpl   $0x0,0x10a530
  104ab3:	00 00 00 
  104ab6:	0f 84 7b 00 00 00    	je     104b37 <schedule+0xa7>
        if (current_task == 0) {
  104abc:	81 3d 38 a5 10 00 00 	cmpl   $0x0,0x10a538
  104ac3:	00 00 00 
  104ac6:	0f 85 2a 00 00 00    	jne    104af6 <schedule+0x66>
            current_task = first_task;
  104acc:	a1 34 a5 10 00       	mov    0x10a534,%eax
  104ad1:	a3 38 a5 10 00       	mov    %eax,0x10a538
            vmm_activate_pagedir(current_task->phys_pdir);
  104ad6:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104adb:	8b 40 14             	mov    0x14(%eax),%eax
  104ade:	89 04 24             	mov    %eax,(%esp)
  104ae1:	e8 0a 31 00 00       	call   107bf0 <vmm_activate_pagedir>
            return current_task->cpuState;
  104ae6:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104aeb:	8b 40 04             	mov    0x4(%eax),%eax
  104aee:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104af1:	e9 47 00 00 00       	jmp    104b3d <schedule+0xad>
        }

        struct task* next = current_task->next;
  104af6:	a1 38 a5 10 00       	mov    0x10a538,%eax
  104afb:	8b 40 08             	mov    0x8(%eax),%eax
  104afe:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (next == 0)
  104b01:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104b08:	0f 85 08 00 00 00    	jne    104b16 <schedule+0x86>
            next = first_task;
  104b0e:	a1 34 a5 10 00       	mov    0x10a534,%eax
  104b13:	89 45 f4             	mov    %eax,-0xc(%ebp)

        save_cpu_state(cpu);
  104b16:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b19:	89 04 24             	mov    %eax,(%esp)
  104b1c:	e8 4f fe ff ff       	call   104970 <save_cpu_state>

        return schedule_to_task(next);
  104b21:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104b24:	89 0c 24             	mov    %ecx,(%esp)
  104b27:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104b2a:	e8 f1 fe ff ff       	call   104a20 <schedule_to_task>
  104b2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104b32:	e9 06 00 00 00       	jmp    104b3d <schedule+0xad>
    }
    return cpu;
  104b37:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b3a:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104b3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104b40:	83 c4 18             	add    $0x18,%esp
  104b43:	5d                   	pop    %ebp
  104b44:	c3                   	ret    
  104b45:	66 90                	xchg   %ax,%ax
  104b47:	66 90                	xchg   %ax,%ax
  104b49:	66 90                	xchg   %ax,%ax
  104b4b:	66 90                	xchg   %ax,%ax
  104b4d:	66 90                	xchg   %ax,%ax
  104b4f:	90                   	nop

00104b50 <init_rpc_call>:
#include "console.h"
#include "pmm.h"
#include "vmm.h"
#include "catofdeath.h"

void init_rpc_call(struct task* task) {
  104b50:	55                   	push   %ebp
  104b51:	89 e5                	mov    %esp,%ebp
  104b53:	56                   	push   %esi
  104b54:	83 ec 64             	sub    $0x64,%esp
  104b57:	8b 45 08             	mov    0x8(%ebp),%eax
  104b5a:	b9 01 00 00 00       	mov    $0x1,%ecx
  104b5f:	ba 38 00 00 00       	mov    $0x38,%edx
  104b64:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct rpc* rpc = task->rpc;
  104b67:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b6a:	8b 40 18             	mov    0x18(%eax),%eax
  104b6d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    rpc->state = calloc(1, sizeof(struct cpu_state));
  104b70:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  104b77:	c7 44 24 04 38 00 00 	movl   $0x38,0x4(%esp)
  104b7e:	00 
  104b7f:	89 55 b0             	mov    %edx,-0x50(%ebp)
  104b82:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  104b85:	e8 26 07 00 00       	call   1052b0 <calloc>
  104b8a:	b9 38 00 00 00       	mov    $0x38,%ecx
  104b8f:	8d 55 b8             	lea    -0x48(%ebp),%edx
  104b92:	8b 75 f4             	mov    -0xc(%ebp),%esi
  104b95:	89 46 18             	mov    %eax,0x18(%esi)

    struct cpu_state nstate = {
  104b98:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  104b9f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  104ba6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  104bad:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  104bb4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  104bbb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  104bc2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  104bc9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  104bd0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104bd7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104bda:	8b 40 1c             	mov    0x1c(%eax),%eax
  104bdd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  104be0:	c7 45 e0 1b 00 00 00 	movl   $0x1b,-0x20(%ebp)
  104be7:	c7 45 e4 00 02 00 00 	movl   $0x200,-0x1c(%ebp)
  104bee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104bf1:	8b 40 04             	mov    0x4(%eax),%eax
  104bf4:	8b 40 30             	mov    0x30(%eax),%eax
  104bf7:	2d 10 00 00 00       	sub    $0x10,%eax
  104bfc:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104bff:	c7 45 ec 23 00 00 00 	movl   $0x23,-0x14(%ebp)
            /* Ring-3-Segmentregister */
            .cs = 0x18 | 0x03, .ss = 0x20 | 0x03,

            .eflags = 0x200, };

    memcpy(rpc->state, &nstate, sizeof(struct cpu_state));
  104c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c09:	8b 40 18             	mov    0x18(%eax),%eax
  104c0c:	89 04 24             	mov    %eax,(%esp)
  104c0f:	89 54 24 04          	mov    %edx,0x4(%esp)
  104c13:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  104c1a:	00 
  104c1b:	89 4d a8             	mov    %ecx,-0x58(%ebp)
  104c1e:	e8 fd 0a 00 00       	call   105720 <memcpy>

    uint32_t* rpch_args = (void*) rpc->state->esp;
  104c23:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c26:	8b 40 18             	mov    0x18(%eax),%eax
  104c29:	8b 40 30             	mov    0x30(%eax),%eax
  104c2c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

    rpch_args[1] = rpc->type;
  104c2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c32:	8b 40 04             	mov    0x4(%eax),%eax
  104c35:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  104c38:	89 41 04             	mov    %eax,0x4(%ecx)
    rpch_args[2] = rpc->funcID;
  104c3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c3e:	8b 40 08             	mov    0x8(%eax),%eax
  104c41:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  104c44:	89 41 08             	mov    %eax,0x8(%ecx)
    rpch_args[3] = rpc->dataSize;
  104c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c4a:	8b 40 10             	mov    0x10(%eax),%eax
  104c4d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  104c50:	89 41 0c             	mov    %eax,0xc(%ecx)

    rpc->executing = 1;
  104c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c56:	c6 40 14 01          	movb   $0x1,0x14(%eax)
}
  104c5a:	83 c4 64             	add    $0x64,%esp
  104c5d:	5e                   	pop    %esi
  104c5e:	5d                   	pop    %ebp
  104c5f:	c3                   	ret    

00104c60 <create_rpc_call>:

uint32_t create_rpc_call(int dPID, uint32_t type, uint32_t funcID, uint32_t dsize, void* data) {
  104c60:	55                   	push   %ebp
  104c61:	89 e5                	mov    %esp,%ebp
  104c63:	53                   	push   %ebx
  104c64:	57                   	push   %edi
  104c65:	56                   	push   %esi
  104c66:	83 ec 5c             	sub    $0x5c,%esp
  104c69:	8b 45 18             	mov    0x18(%ebp),%eax
  104c6c:	8b 4d 14             	mov    0x14(%ebp),%ecx
  104c6f:	8b 55 10             	mov    0x10(%ebp),%edx
  104c72:	8b 75 0c             	mov    0xc(%ebp),%esi
  104c75:	8b 7d 08             	mov    0x8(%ebp),%edi
  104c78:	bb 01 00 00 00       	mov    $0x1,%ebx
  104c7d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  104c80:	b8 20 00 00 00       	mov    $0x20,%eax
  104c85:	89 7d ec             	mov    %edi,-0x14(%ebp)
  104c88:	89 75 e8             	mov    %esi,-0x18(%ebp)
  104c8b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  104c8e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  104c91:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  104c94:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    struct rpc* nrpc = calloc(1, sizeof(struct rpc));
  104c97:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  104c9e:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  104ca5:	00 
  104ca6:	89 45 c8             	mov    %eax,-0x38(%ebp)
  104ca9:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
  104cac:	e8 ff 05 00 00       	call   1052b0 <calloc>
  104cb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    struct task* destTask = get_task_by_pid(dPID);
  104cb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104cb7:	89 04 24             	mov    %eax,(%esp)
  104cba:	e8 e1 f6 ff ff       	call   1043a0 <get_task_by_pid>
  104cbf:	89 45 d4             	mov    %eax,-0x2c(%ebp)

    if(destTask == 0) {
  104cc2:	81 7d d4 00 00 00 00 	cmpl   $0x0,-0x2c(%ebp)
  104cc9:	0f 85 45 00 00 00    	jne    104d14 <create_rpc_call+0xb4>
  104ccf:	b8 0a 00 00 00       	mov    $0xa,%eax
        setclr(0x0A);
  104cd4:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  104cdb:	89 45 c0             	mov    %eax,-0x40(%ebp)
  104cde:	e8 ad b5 ff ff       	call   100290 <setclr>
  104ce3:	8d 05 93 95 10 00    	lea    0x109593,%eax
        kprintf("Tried to execute RPC in non-existing task.\n");
  104ce9:	89 04 24             	mov    %eax,(%esp)
  104cec:	e8 bf b5 ff ff       	call   1002b0 <kprintf>
  104cf1:	b9 07 00 00 00       	mov    $0x7,%ecx
        setclr(0x07);
  104cf6:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  104cfd:	89 45 bc             	mov    %eax,-0x44(%ebp)
  104d00:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  104d03:	e8 88 b5 ff ff       	call   100290 <setclr>
        return RPCE_NODEST;
  104d08:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
  104d0f:	e9 5c 01 00 00       	jmp    104e70 <create_rpc_call+0x210>
    }

    if(destTask->rpc_handler_addr == 0) {
  104d14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104d17:	81 78 1c 00 00 00 00 	cmpl   $0x0,0x1c(%eax)
  104d1e:	0f 85 45 00 00 00    	jne    104d69 <create_rpc_call+0x109>
  104d24:	b8 0a 00 00 00       	mov    $0xa,%eax
        setclr(0x0A);
  104d29:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  104d30:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  104d33:	e8 58 b5 ff ff       	call   100290 <setclr>
  104d38:	8d 05 bf 95 10 00    	lea    0x1095bf,%eax
        kprintf("Tried to execute RPC in non RPC enabled task.\n");
  104d3e:	89 04 24             	mov    %eax,(%esp)
  104d41:	e8 6a b5 ff ff       	call   1002b0 <kprintf>
  104d46:	b9 07 00 00 00       	mov    $0x7,%ecx
        setclr(0x07);
  104d4b:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  104d52:	89 45 b0             	mov    %eax,-0x50(%ebp)
  104d55:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  104d58:	e8 33 b5 ff ff       	call   100290 <setclr>
        return RPCE_NOFUNC;
  104d5d:	c7 45 f0 03 00 00 00 	movl   $0x3,-0x10(%ebp)
  104d64:	e9 07 01 00 00       	jmp    104e70 <create_rpc_call+0x210>
    }

    nrpc->type = type;
  104d69:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104d6c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104d6f:	89 41 04             	mov    %eax,0x4(%ecx)
    nrpc->funcID = funcID;
  104d72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104d75:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104d78:	89 41 08             	mov    %eax,0x8(%ecx)
    nrpc->returnPID = get_current_task() ? get_current_task()->PID : 0;
  104d7b:	e8 10 f6 ff ff       	call   104390 <get_current_task>
  104d80:	3d 00 00 00 00       	cmp    $0x0,%eax
  104d85:	0f 84 0f 00 00 00    	je     104d9a <create_rpc_call+0x13a>
  104d8b:	e8 00 f6 ff ff       	call   104390 <get_current_task>
  104d90:	8b 00                	mov    (%eax),%eax
  104d92:	89 45 a8             	mov    %eax,-0x58(%ebp)
  104d95:	e9 0d 00 00 00       	jmp    104da7 <create_rpc_call+0x147>
  104d9a:	b8 00 00 00 00       	mov    $0x0,%eax
  104d9f:	89 45 a8             	mov    %eax,-0x58(%ebp)
  104da2:	e9 00 00 00 00       	jmp    104da7 <create_rpc_call+0x147>
  104da7:	8b 45 a8             	mov    -0x58(%ebp),%eax
  104daa:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104dad:	89 01                	mov    %eax,(%ecx)

    nrpc->data = malloc(dsize);
  104daf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104db2:	89 04 24             	mov    %eax,(%esp)
  104db5:	e8 36 02 00 00       	call   104ff0 <malloc>
  104dba:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104dbd:	89 41 0c             	mov    %eax,0xc(%ecx)
    memcpy(nrpc->data, data, dsize);
  104dc0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104dc3:	8b 40 0c             	mov    0xc(%eax),%eax
  104dc6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  104dc9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  104dcc:	89 04 24             	mov    %eax,(%esp)
  104dcf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104dd3:	89 54 24 08          	mov    %edx,0x8(%esp)
  104dd7:	e8 44 09 00 00       	call   105720 <memcpy>
    nrpc->dataSize = dsize;
  104ddc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104ddf:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104de2:	89 41 10             	mov    %eax,0x10(%ecx)

    if(destTask->rpc == 0) {
  104de5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104de8:	81 78 18 00 00 00 00 	cmpl   $0x0,0x18(%eax)
  104def:	0f 85 15 00 00 00    	jne    104e0a <create_rpc_call+0x1aa>
        destTask->rpc = nrpc;
  104df5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104df8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  104dfb:	89 41 18             	mov    %eax,0x18(%ecx)
        return RPCE_OK;
  104dfe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104e05:	e9 66 00 00 00       	jmp    104e70 <create_rpc_call+0x210>
    }
    else
    {
        struct rpc* ptr = destTask->rpc;
  104e0a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104e0d:	8b 40 18             	mov    0x18(%eax),%eax
  104e10:	89 45 d0             	mov    %eax,-0x30(%ebp)

        while(ptr != 0) {
  104e13:	81 7d d0 00 00 00 00 	cmpl   $0x0,-0x30(%ebp)
  104e1a:	0f 84 44 00 00 00    	je     104e64 <create_rpc_call+0x204>
            if(ptr->next == 0) {
  104e20:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104e23:	81 78 1c 00 00 00 00 	cmpl   $0x0,0x1c(%eax)
  104e2a:	0f 85 26 00 00 00    	jne    104e56 <create_rpc_call+0x1f6>
  104e30:	8d 05 ee 95 10 00    	lea    0x1095ee,%eax
                kprintf("Chained RPC occured\n");
  104e36:	89 04 24             	mov    %eax,(%esp)
  104e39:	e8 72 b4 ff ff       	call   1002b0 <kprintf>

                ptr->next = nrpc;
  104e3e:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104e41:	8b 55 d0             	mov    -0x30(%ebp),%edx
  104e44:	89 4a 1c             	mov    %ecx,0x1c(%edx)
                return RPCE_OK;
  104e47:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104e4e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  104e51:	e9 1a 00 00 00       	jmp    104e70 <create_rpc_call+0x210>
            }
            ptr = ptr->next;
  104e56:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104e59:	8b 40 1c             	mov    0x1c(%eax),%eax
  104e5c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        }
  104e5f:	e9 af ff ff ff       	jmp    104e13 <create_rpc_call+0x1b3>
  104e64:	e9 00 00 00 00       	jmp    104e69 <create_rpc_call+0x209>
    }

    return RPCE_UNKNOWN;
  104e69:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
}
  104e70:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e73:	83 c4 5c             	add    $0x5c,%esp
  104e76:	5e                   	pop    %esi
  104e77:	5f                   	pop    %edi
  104e78:	5b                   	pop    %ebx
  104e79:	5d                   	pop    %ebp
  104e7a:	c3                   	ret    
  104e7b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104e80 <return_rpc_call>:

struct cpu_state* return_rpc_call(struct cpu_state* cpu) {
  104e80:	55                   	push   %ebp
  104e81:	89 e5                	mov    %esp,%ebp
  104e83:	83 ec 38             	sub    $0x38,%esp
  104e86:	8b 45 08             	mov    0x8(%ebp),%eax
  104e89:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* task = get_current_task();
  104e8c:	e8 ff f4 ff ff       	call   104390 <get_current_task>
  104e91:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!task->rpc) {
  104e94:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e97:	81 78 18 00 00 00 00 	cmpl   $0x0,0x18(%eax)
  104e9e:	0f 85 7b 00 00 00    	jne    104f1f <return_rpc_call+0x9f>
  104ea4:	b8 04 00 00 00       	mov    $0x4,%eax
        setclr(0x04);
  104ea9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  104eb0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104eb3:	e8 d8 b3 ff ff       	call   100290 <setclr>
  104eb8:	8d 05 03 96 10 00    	lea    0x109603,%eax
        kprintf("\n~~~ Terminated task (PID=%d PATH=%s). RPC_RET_WITHOUT_CALL \n", task->PID, task->filePath);
  104ebe:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104ec1:	8b 09                	mov    (%ecx),%ecx
  104ec3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104ec6:	8b 52 24             	mov    0x24(%edx),%edx
  104ec9:	89 04 24             	mov    %eax,(%esp)
  104ecc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104ed0:	89 54 24 08          	mov    %edx,0x8(%esp)
  104ed4:	e8 d7 b3 ff ff       	call   1002b0 <kprintf>
  104ed9:	8d 0d 70 92 10 00    	lea    0x109270,%ecx
        kprintf("\n");
  104edf:	89 0c 24             	mov    %ecx,(%esp)
  104ee2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104ee5:	e8 c6 b3 ff ff       	call   1002b0 <kprintf>
        show_dump(cpu);
  104eea:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104eed:	89 0c 24             	mov    %ecx,(%esp)
  104ef0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104ef3:	e8 48 b2 ff ff       	call   100140 <show_dump>
  104ef8:	b8 07 00 00 00       	mov    $0x7,%eax
        setclr(0x07);
  104efd:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  104f04:	89 45 dc             	mov    %eax,-0x24(%ebp)
  104f07:	e8 84 b3 ff ff       	call   100290 <setclr>

        return terminate_current(cpu);
  104f0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f0f:	89 04 24             	mov    %eax,(%esp)
  104f12:	e8 79 f7 ff ff       	call   104690 <terminate_current>
  104f17:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104f1a:	e9 bb 00 00 00       	jmp    104fda <return_rpc_call+0x15a>
    }

    struct rpc* rpc = task->rpc;
  104f1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104f22:	8b 40 18             	mov    0x18(%eax),%eax
  104f25:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task->rpc = task->rpc->next;
  104f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104f2b:	8b 40 18             	mov    0x18(%eax),%eax
  104f2e:	8b 40 1c             	mov    0x1c(%eax),%eax
  104f31:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104f34:	89 41 18             	mov    %eax,0x18(%ecx)

    if(rpc->returnPID) {
  104f37:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f3a:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
  104f40:	0f 84 86 00 00 00    	je     104fcc <return_rpc_call+0x14c>
        struct task* rTask = get_task_by_pid(rpc->returnPID);
  104f46:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f49:	8b 00                	mov    (%eax),%eax
  104f4b:	89 04 24             	mov    %eax,(%esp)
  104f4e:	e8 4d f4 ff ff       	call   1043a0 <get_task_by_pid>
  104f53:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if(rpc->type == RPCT_IRQ) {
  104f56:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f59:	81 78 04 00 00 00 00 	cmpl   $0x0,0x4(%eax)
  104f60:	0f 85 0e 00 00 00    	jne    104f74 <return_rpc_call+0xf4>
            enable_irq_rpc(rpc->funcID);
  104f66:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f69:	8b 40 08             	mov    0x8(%eax),%eax
  104f6c:	89 04 24             	mov    %eax,(%esp)
  104f6f:	e8 0c d0 ff ff       	call   101f80 <enable_irq_rpc>
        }

        free(rpc->state);
  104f74:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f77:	8b 40 18             	mov    0x18(%eax),%eax
  104f7a:	89 04 24             	mov    %eax,(%esp)
  104f7d:	e8 6e 04 00 00       	call   1053f0 <free>
        free(rpc);
  104f82:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f85:	89 04 24             	mov    %eax,(%esp)
  104f88:	e8 63 04 00 00       	call   1053f0 <free>

        if(rTask == 0) {
  104f8d:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104f94:	0f 85 13 00 00 00    	jne    104fad <return_rpc_call+0x12d>
            return schedule_to_task(task);
  104f9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104f9d:	89 04 24             	mov    %eax,(%esp)
  104fa0:	e8 7b fa ff ff       	call   104a20 <schedule_to_task>
  104fa5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104fa8:	e9 2d 00 00 00       	jmp    104fda <return_rpc_call+0x15a>
        }

        rTask->cpuState->eax = RPCE_OK;
  104fad:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104fb0:	8b 40 04             	mov    0x4(%eax),%eax
  104fb3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        return schedule_to_task(rTask);
  104fb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104fbc:	89 04 24             	mov    %eax,(%esp)
  104fbf:	e8 5c fa ff ff       	call   104a20 <schedule_to_task>
  104fc4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104fc7:	e9 0e 00 00 00       	jmp    104fda <return_rpc_call+0x15a>
    }
    else
    {
        return schedule_to_task(task);
  104fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104fcf:	89 04 24             	mov    %eax,(%esp)
  104fd2:	e8 49 fa ff ff       	call   104a20 <schedule_to_task>
  104fd7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  104fda:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104fdd:	83 c4 38             	add    $0x38,%esp
  104fe0:	5d                   	pop    %ebp
  104fe1:	c3                   	ret    
  104fe2:	66 90                	xchg   %ax,%ax
  104fe4:	66 90                	xchg   %ax,%ax
  104fe6:	66 90                	xchg   %ax,%ax
  104fe8:	66 90                	xchg   %ax,%ax
  104fea:	66 90                	xchg   %ax,%ax
  104fec:	66 90                	xchg   %ax,%ax
  104fee:	66 90                	xchg   %ax,%ax

00104ff0 <malloc>:
    append_to_list(&first_free, tf);
}

uint32_t malloced = 0;

void* malloc(size_t size) {
  104ff0:	55                   	push   %ebp
  104ff1:	89 e5                	mov    %esp,%ebp
  104ff3:	83 ec 38             	sub    $0x38,%esp
  104ff6:	8b 45 08             	mov    0x8(%ebp),%eax
  104ff9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(size == 0) return 0;
  104ffc:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105003:	0f 85 0c 00 00 00    	jne    105015 <malloc+0x25>
  105009:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105010:	e9 c9 01 00 00       	jmp    1051de <malloc+0x1ee>
  105015:	8d 05 41 96 10 00    	lea    0x109641,%eax

    malloced += size;
  10501b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10501e:	8b 15 48 a5 10 00    	mov    0x10a548,%edx
  105024:	01 ca                	add    %ecx,%edx
  105026:	89 15 48 a5 10 00    	mov    %edx,0x10a548
    kprintf("malloc %d (%d) bytes \n", size, malloced);
  10502c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10502f:	8b 15 48 a5 10 00    	mov    0x10a548,%edx
  105035:	89 04 24             	mov    %eax,(%esp)
  105038:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10503c:	89 54 24 08          	mov    %edx,0x8(%esp)
  105040:	e8 6b b2 ff ff       	call   1002b0 <kprintf>

    struct memory_node* last = 0;
  105045:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
  10504c:	8b 0d 44 a5 10 00    	mov    0x10a544,%ecx
  105052:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105055:	89 45 d4             	mov    %eax,-0x2c(%ebp)

    while (cur != 0) {
  105058:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10505f:	0f 84 27 00 00 00    	je     10508c <malloc+0x9c>
        if (cur->size >= size) {
  105065:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105068:	8b 00                	mov    (%eax),%eax
  10506a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10506d:	0f 82 05 00 00 00    	jb     105078 <malloc+0x88>
            break;
  105073:	e9 14 00 00 00       	jmp    10508c <malloc+0x9c>
        }
        last = cur;
  105078:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10507b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  10507e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105081:	8b 40 08             	mov    0x8(%eax),%eax
  105084:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  105087:	e9 cc ff ff ff       	jmp    105058 <malloc+0x68>

    if (cur == 0) {
  10508c:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105093:	0f 85 bc 00 00 00    	jne    105155 <malloc+0x165>
        uint32_t pgs = size / PAGESIZE;
  105099:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10509c:	c1 e8 0c             	shr    $0xc,%eax
  10509f:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
  1050a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1050a5:	25 ff 0f 00 00       	and    $0xfff,%eax
  1050aa:	3d 00 00 00 00       	cmp    $0x0,%eax
  1050af:	0f 84 0b 00 00 00    	je     1050c0 <malloc+0xd0>
            pgs++;
  1050b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1050b8:	05 01 00 00 00       	add    $0x1,%eax
  1050bd:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
  1050c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1050c3:	89 04 24             	mov    %eax,(%esp)
  1050c6:	e8 d5 29 00 00       	call   107aa0 <vmm_alloc_cont>
  1050cb:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
  1050ce:	e8 ad 04 00 00       	call   105580 <pop_unused_node>
  1050d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
  1050d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1050d9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1050dc:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
  1050df:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1050e2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1050e5:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
  1050e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1050ea:	c1 e0 0c             	shl    $0xc,%eax
  1050ed:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1050f0:	0f 86 3c 00 00 00    	jbe    105132 <malloc+0x142>
            struct memory_node* free = pop_unused_node();
  1050f6:	e8 85 04 00 00       	call   105580 <pop_unused_node>
  1050fb:	8d 0d 44 a5 10 00    	lea    0x10a544,%ecx
  105101:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
  105104:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105107:	8b 40 04             	mov    0x4(%eax),%eax
  10510a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10510d:	03 02                	add    (%edx),%eax
  10510f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  105112:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
  105115:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105118:	c1 e0 0c             	shl    $0xc,%eax
  10511b:	2b 45 f8             	sub    -0x8(%ebp),%eax
  10511e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  105121:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  105123:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105126:	89 0c 24             	mov    %ecx,(%esp)
  105129:	89 44 24 04          	mov    %eax,0x4(%esp)
  10512d:	e8 be 00 00 00       	call   1051f0 <append_to_list>
  105132:	8d 05 40 a5 10 00    	lea    0x10a540,%eax
        }

        append_to_list(&first_used, fill);
  105138:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10513b:	89 04 24             	mov    %eax,(%esp)
  10513e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105142:	e8 a9 00 00 00       	call   1051f0 <append_to_list>

        return (void*) fill->address;
  105147:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10514a:	8b 40 04             	mov    0x4(%eax),%eax
  10514d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105150:	e9 89 00 00 00       	jmp    1051de <malloc+0x1ee>
  105155:	8d 05 44 a5 10 00    	lea    0x10a544,%eax
    } else {
        uint32_t freesize = cur->size - size;
  10515b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10515e:	8b 09                	mov    (%ecx),%ecx
  105160:	2b 4d f8             	sub    -0x8(%ebp),%ecx
  105163:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
  105166:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105169:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10516c:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
  10516e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105171:	89 04 24             	mov    %eax,(%esp)
  105174:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105178:	e8 a3 00 00 00       	call   105220 <remove_from_list>
  10517d:	8d 05 40 a5 10 00    	lea    0x10a540,%eax
        append_to_list(&first_used, cur);
  105183:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105186:	89 04 24             	mov    %eax,(%esp)
  105189:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10518d:	e8 5e 00 00 00       	call   1051f0 <append_to_list>

        if (freesize > 0) {
  105192:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  105199:	0f 86 36 00 00 00    	jbe    1051d5 <malloc+0x1e5>
            struct memory_node* free = pop_unused_node();
  10519f:	e8 dc 03 00 00       	call   105580 <pop_unused_node>
  1051a4:	8d 0d 44 a5 10 00    	lea    0x10a544,%ecx
  1051aa:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
  1051ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1051b0:	8b 40 04             	mov    0x4(%eax),%eax
  1051b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1051b6:	03 02                	add    (%edx),%eax
  1051b8:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1051bb:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
  1051be:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1051c1:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1051c4:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  1051c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1051c9:	89 0c 24             	mov    %ecx,(%esp)
  1051cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  1051d0:	e8 1b 00 00 00       	call   1051f0 <append_to_list>
        }

        return (void*) cur->address;
  1051d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1051d8:	8b 40 04             	mov    0x4(%eax),%eax
  1051db:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  1051de:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1051e1:	83 c4 38             	add    $0x38,%esp
  1051e4:	5d                   	pop    %ebp
  1051e5:	c3                   	ret    
  1051e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1051ed:	00 00 00 

001051f0 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
  1051f0:	55                   	push   %ebp
  1051f1:	89 e5                	mov    %esp,%ebp
  1051f3:	83 ec 08             	sub    $0x8,%esp
  1051f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1051f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1051fc:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1051ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
  105202:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105205:	8b 00                	mov    (%eax),%eax
  105207:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10520a:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
  10520d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105210:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105213:	89 01                	mov    %eax,(%ecx)
}
  105215:	83 c4 08             	add    $0x8,%esp
  105218:	5d                   	pop    %ebp
  105219:	c3                   	ret    
  10521a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105220 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
  105220:	55                   	push   %ebp
  105221:	89 e5                	mov    %esp,%ebp
  105223:	83 ec 10             	sub    $0x10,%esp
  105226:	8b 45 0c             	mov    0xc(%ebp),%eax
  105229:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10522c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10522f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
  105232:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
  105239:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10523c:	8b 00                	mov    (%eax),%eax
  10523e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  105241:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105248:	0f 84 4e 00 00 00    	je     10529c <remove_from_list+0x7c>
        if (cur == element) {
  10524e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105251:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  105254:	0f 85 2e 00 00 00    	jne    105288 <remove_from_list+0x68>
            if (last == 0) {
  10525a:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105261:	0f 85 10 00 00 00    	jne    105277 <remove_from_list+0x57>
                *root = cur->next;
  105267:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10526a:	8b 40 08             	mov    0x8(%eax),%eax
  10526d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105270:	89 01                	mov    %eax,(%ecx)
                return;
  105272:	e9 25 00 00 00       	jmp    10529c <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
  105277:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10527a:	8b 40 08             	mov    0x8(%eax),%eax
  10527d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105280:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
  105283:	e9 14 00 00 00       	jmp    10529c <remove_from_list+0x7c>
            }
        }
        last = cur;
  105288:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10528b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  10528e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105291:	8b 40 08             	mov    0x8(%eax),%eax
  105294:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  105297:	e9 a5 ff ff ff       	jmp    105241 <remove_from_list+0x21>
}
  10529c:	83 c4 10             	add    $0x10,%esp
  10529f:	5d                   	pop    %ebp
  1052a0:	c3                   	ret    
  1052a1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1052a8:	0f 1f 84 00 00 00 00 
  1052af:	00 

001052b0 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
  1052b0:	55                   	push   %ebp
  1052b1:	89 e5                	mov    %esp,%ebp
  1052b3:	83 ec 28             	sub    $0x28,%esp
  1052b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1052b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1052bc:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1052bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
  1052c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1052c5:	0f af 45 f8          	imul   -0x8(%ebp),%eax
  1052c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
  1052cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1052cf:	89 04 24             	mov    %eax,(%esp)
  1052d2:	e8 19 fd ff ff       	call   104ff0 <malloc>
  1052d7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
  1052da:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1052e1:	0f 84 22 00 00 00    	je     105309 <calloc+0x59>
  1052e7:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
  1052ec:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1052ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1052f2:	89 0c 24             	mov    %ecx,(%esp)
  1052f5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1052fc:	00 
  1052fd:	89 54 24 08          	mov    %edx,0x8(%esp)
  105301:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105304:	e8 b7 03 00 00       	call   1056c0 <memset>
    }

    return p;
  105309:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10530c:	83 c4 28             	add    $0x28,%esp
  10530f:	5d                   	pop    %ebp
  105310:	c3                   	ret    
  105311:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105318:	0f 1f 84 00 00 00 00 
  10531f:	00 

00105320 <realloc>:
}

void* realloc(void* ptr, size_t size) {
  105320:	55                   	push   %ebp
  105321:	89 e5                	mov    %esp,%ebp
  105323:	83 ec 28             	sub    $0x28,%esp
  105326:	8b 45 0c             	mov    0xc(%ebp),%eax
  105329:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10532c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10532f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
  105332:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
  105339:	a1 40 a5 10 00       	mov    0x10a540,%eax
  10533e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
  105341:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  105348:	0f 84 8e 00 00 00    	je     1053dc <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
  10534e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105351:	8b 40 04             	mov    0x4(%eax),%eax
  105354:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105357:	39 c8                	cmp    %ecx,%eax
  105359:	0f 85 69 00 00 00    	jne    1053c8 <realloc+0xa8>
            if (size == 0) {
  10535f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105366:	0f 85 17 00 00 00    	jne    105383 <realloc+0x63>
                free(ptr);
  10536c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10536f:	89 04 24             	mov    %eax,(%esp)
  105372:	e8 79 00 00 00       	call   1053f0 <free>
                return 0;
  105377:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10537e:	e9 60 00 00 00       	jmp    1053e3 <realloc+0xc3>
            } else {
                void* new = malloc(size);
  105383:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105386:	89 04 24             	mov    %eax,(%esp)
  105389:	e8 62 fc ff ff       	call   104ff0 <malloc>
  10538e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
  105391:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105394:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105397:	8b 49 04             	mov    0x4(%ecx),%ecx
  10539a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10539d:	8b 12                	mov    (%edx),%edx
  10539f:	89 04 24             	mov    %eax,(%esp)
  1053a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1053a6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1053aa:	e8 71 03 00 00       	call   105720 <memcpy>
                free((void*) cur->address);
  1053af:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1053b2:	8b 40 04             	mov    0x4(%eax),%eax
  1053b5:	89 04 24             	mov    %eax,(%esp)
  1053b8:	e8 33 00 00 00       	call   1053f0 <free>

                return new;
  1053bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1053c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1053c3:	e9 1b 00 00 00       	jmp    1053e3 <realloc+0xc3>
            }
        }
        last = cur;
  1053c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1053cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
  1053ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1053d1:	8b 40 08             	mov    0x8(%eax),%eax
  1053d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
  1053d7:	e9 65 ff ff ff       	jmp    105341 <realloc+0x21>
    return 0;
  1053dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1053e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1053e6:	83 c4 28             	add    $0x28,%esp
  1053e9:	5d                   	pop    %ebp
  1053ea:	c3                   	ret    
  1053eb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001053f0 <free>:

void free(void* ptr) {
  1053f0:	55                   	push   %ebp
  1053f1:	89 e5                	mov    %esp,%ebp
  1053f3:	83 ec 28             	sub    $0x28,%esp
  1053f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1053f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
  1053fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
  105403:	a1 40 a5 10 00       	mov    0x10a540,%eax
  105408:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
  10540b:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105412:	0f 84 6c 00 00 00    	je     105484 <free+0x94>
        if (cur->address == (uint32_t) ptr) {
  105418:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10541b:	8b 40 04             	mov    0x4(%eax),%eax
  10541e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105421:	39 c8                	cmp    %ecx,%eax
  105423:	0f 85 47 00 00 00    	jne    105470 <free+0x80>
  105429:	8d 05 58 96 10 00    	lea    0x109658,%eax
            malloced -= cur->size;
  10542f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105432:	8b 09                	mov    (%ecx),%ecx
  105434:	8b 15 48 a5 10 00    	mov    0x10a548,%edx
  10543a:	29 ca                	sub    %ecx,%edx
  10543c:	89 15 48 a5 10 00    	mov    %edx,0x10a548
            kprintf("freed %d (%d) bytes \n", cur->size, malloced);
  105442:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105445:	8b 09                	mov    (%ecx),%ecx
  105447:	8b 15 48 a5 10 00    	mov    0x10a548,%edx
  10544d:	89 04 24             	mov    %eax,(%esp)
  105450:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105454:	89 54 24 08          	mov    %edx,0x8(%esp)
  105458:	e8 53 ae ff ff       	call   1002b0 <kprintf>

            merge_into_frees(cur);
  10545d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105460:	89 0c 24             	mov    %ecx,(%esp)
  105463:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105466:	e8 25 00 00 00       	call   105490 <merge_into_frees>
            break;
  10546b:	e9 14 00 00 00       	jmp    105484 <free+0x94>
        }
        last = cur;
  105470:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105473:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
  105476:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105479:	8b 40 08             	mov    0x8(%eax),%eax
  10547c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  10547f:	e9 87 ff ff ff       	jmp    10540b <free+0x1b>
}
  105484:	83 c4 28             	add    $0x28,%esp
  105487:	5d                   	pop    %ebp
  105488:	c3                   	ret    
  105489:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00105490 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
  105490:	55                   	push   %ebp
  105491:	89 e5                	mov    %esp,%ebp
  105493:	56                   	push   %esi
  105494:	83 ec 14             	sub    $0x14,%esp
  105497:	8b 45 08             	mov    0x8(%ebp),%eax
  10549a:	8d 0d 40 a5 10 00    	lea    0x10a540,%ecx
  1054a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
  1054a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1054a6:	89 0c 24             	mov    %ecx,(%esp)
  1054a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1054ad:	e8 6e fd ff ff       	call   105220 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
  1054b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
  1054b9:	a1 44 a5 10 00       	mov    0x10a544,%eax
  1054be:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  1054c1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1054c8:	0f 84 92 00 00 00    	je     105560 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
  1054ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1054d1:	8b 40 04             	mov    0x4(%eax),%eax
  1054d4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1054d7:	03 01                	add    (%ecx),%eax
  1054d9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1054dc:	3b 41 04             	cmp    0x4(%ecx),%eax
  1054df:	0f 85 26 00 00 00    	jne    10550b <merge_into_frees+0x7b>
  1054e5:	8d 05 44 a5 10 00    	lea    0x10a544,%eax
            tf->address = cur->address;
  1054eb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1054ee:	8b 49 04             	mov    0x4(%ecx),%ecx
  1054f1:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1054f4:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
  1054f7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1054fa:	89 04 24             	mov    %eax,(%esp)
  1054fd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105501:	e8 1a fd ff ff       	call   105220 <remove_from_list>
            goto editedList;
  105506:	e9 a7 ff ff ff       	jmp    1054b2 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
  10550b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10550e:	8b 40 04             	mov    0x4(%eax),%eax
  105511:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105514:	8b 49 04             	mov    0x4(%ecx),%ecx
  105517:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10551a:	03 0a                	add    (%edx),%ecx
  10551c:	39 c8                	cmp    %ecx,%eax
  10551e:	0f 85 28 00 00 00    	jne    10554c <merge_into_frees+0xbc>
  105524:	8d 05 44 a5 10 00    	lea    0x10a544,%eax
            tf->size += cur->size;
  10552a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10552d:	8b 09                	mov    (%ecx),%ecx
  10552f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  105532:	8b 32                	mov    (%edx),%esi
  105534:	01 ce                	add    %ecx,%esi
  105536:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
  105538:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10553b:	89 04 24             	mov    %eax,(%esp)
  10553e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105542:	e8 d9 fc ff ff       	call   105220 <remove_from_list>
            goto editedList;
  105547:	e9 66 ff ff ff       	jmp    1054b2 <merge_into_frees+0x22>
        }

        last = cur;
  10554c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10554f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  105552:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105555:	8b 40 08             	mov    0x8(%eax),%eax
  105558:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  10555b:	e9 61 ff ff ff       	jmp    1054c1 <merge_into_frees+0x31>
  105560:	8d 05 44 a5 10 00    	lea    0x10a544,%eax

    append_to_list(&first_free, tf);
  105566:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105569:	89 04 24             	mov    %eax,(%esp)
  10556c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105570:	e8 7b fc ff ff       	call   1051f0 <append_to_list>
}
  105575:	83 c4 14             	add    $0x14,%esp
  105578:	5e                   	pop    %esi
  105579:	5d                   	pop    %ebp
  10557a:	c3                   	ret    
  10557b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105580 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
  105580:	55                   	push   %ebp
  105581:	89 e5                	mov    %esp,%ebp
  105583:	83 ec 08             	sub    $0x8,%esp
  105586:	8d 05 3c a5 10 00    	lea    0x10a53c,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
  10558c:	89 04 24             	mov    %eax,(%esp)
  10558f:	e8 3c 00 00 00       	call   1055d0 <pop_from_list>
  105594:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
  105597:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
  10559e:	0f 85 1b 00 00 00    	jne    1055bf <pop_unused_node+0x3f>
        allocate_unused_nodes();
  1055a4:	e8 77 00 00 00       	call   105620 <allocate_unused_nodes>
  1055a9:	8d 05 3c a5 10 00    	lea    0x10a53c,%eax
        ret = pop_from_list(&first_unused);
  1055af:	89 04 24             	mov    %eax,(%esp)
  1055b2:	e8 19 00 00 00       	call   1055d0 <pop_from_list>
  1055b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  1055ba:	e9 d8 ff ff ff       	jmp    105597 <pop_unused_node+0x17>

    return ret;
  1055bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1055c2:	83 c4 08             	add    $0x8,%esp
  1055c5:	5d                   	pop    %ebp
  1055c6:	c3                   	ret    
  1055c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1055ce:	00 00 

001055d0 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
  1055d0:	55                   	push   %ebp
  1055d1:	89 e5                	mov    %esp,%ebp
  1055d3:	83 ec 18             	sub    $0x18,%esp
  1055d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1055d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
  1055dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1055df:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
  1055e5:	0f 85 0c 00 00 00    	jne    1055f7 <pop_from_list+0x27>
        return 0;
  1055eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1055f2:	e9 20 00 00 00       	jmp    105617 <pop_from_list+0x47>
    struct memory_node* pop = *root;
  1055f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1055fa:	8b 00                	mov    (%eax),%eax
  1055fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
  1055ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105602:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105605:	89 04 24             	mov    %eax,(%esp)
  105608:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10560c:	e8 0f fc ff ff       	call   105220 <remove_from_list>
    return pop;
  105611:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105614:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  105617:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10561a:	83 c4 18             	add    $0x18,%esp
  10561d:	5d                   	pop    %ebp
  10561e:	c3                   	ret    
  10561f:	90                   	nop

00105620 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
  105620:	55                   	push   %ebp
  105621:	89 e5                	mov    %esp,%ebp
  105623:	83 ec 28             	sub    $0x28,%esp
  105626:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
  10562b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  105632:	89 45 f4             	mov    %eax,-0xc(%ebp)
  105635:	e8 66 24 00 00       	call   107aa0 <vmm_alloc_cont>
  10563a:	b9 00 00 00 00       	mov    $0x0,%ecx
  10563f:	ba 00 10 00 00       	mov    $0x1000,%edx
  105644:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
  105647:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10564a:	89 04 24             	mov    %eax,(%esp)
  10564d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105654:	00 
  105655:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  10565c:	00 
  10565d:	89 55 f0             	mov    %edx,-0x10(%ebp)
  105660:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  105663:	e8 58 00 00 00       	call   1056c0 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  105668:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  10566f:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
  105676:	0f 83 30 00 00 00    	jae    1056ac <allocate_unused_nodes+0x8c>
  10567c:	8d 05 3c a5 10 00    	lea    0x10a53c,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
  105682:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105685:	8b 55 fc             	mov    -0x4(%ebp),%edx
  105688:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
  10568e:	01 ca                	add    %ecx,%edx
  105690:	89 04 24             	mov    %eax,(%esp)
  105693:	89 54 24 04          	mov    %edx,0x4(%esp)
  105697:	e8 54 fb ff ff       	call   1051f0 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  10569c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10569f:	05 01 00 00 00       	add    $0x1,%eax
  1056a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1056a7:	e9 c3 ff ff ff       	jmp    10566f <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
  1056ac:	83 c4 28             	add    $0x28,%esp
  1056af:	5d                   	pop    %ebp
  1056b0:	c3                   	ret    
  1056b1:	66 90                	xchg   %ax,%ax
  1056b3:	66 90                	xchg   %ax,%ax
  1056b5:	66 90                	xchg   %ax,%ax
  1056b7:	66 90                	xchg   %ax,%ax
  1056b9:	66 90                	xchg   %ax,%ax
  1056bb:	66 90                	xchg   %ax,%ax
  1056bd:	66 90                	xchg   %ax,%ax
  1056bf:	90                   	nop

001056c0 <memset>:
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
  1056c0:	55                   	push   %ebp
  1056c1:	89 e5                	mov    %esp,%ebp
  1056c3:	83 ec 10             	sub    $0x10,%esp
  1056c6:	8b 45 10             	mov    0x10(%ebp),%eax
  1056c9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1056cc:	8b 55 08             	mov    0x8(%ebp),%edx
  1056cf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1056d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1056d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* p = buf;
  1056d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1056db:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (n--) {
  1056de:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1056e1:	89 c1                	mov    %eax,%ecx
  1056e3:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1056e9:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1056ec:	3d 00 00 00 00       	cmp    $0x0,%eax
  1056f1:	0f 84 1a 00 00 00    	je     105711 <memset+0x51>
        *p++ = c;
  1056f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1056fa:	88 c1                	mov    %al,%cl
  1056fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1056ff:	89 c2                	mov    %eax,%edx
  105701:	81 c2 01 00 00 00    	add    $0x1,%edx
  105707:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10570a:	88 08                	mov    %cl,(%eax)
    }
  10570c:	e9 cd ff ff ff       	jmp    1056de <memset+0x1e>

    return buf;
  105711:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105714:	83 c4 10             	add    $0x10,%esp
  105717:	5d                   	pop    %ebp
  105718:	c3                   	ret    
  105719:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00105720 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
  105720:	55                   	push   %ebp
  105721:	89 e5                	mov    %esp,%ebp
  105723:	83 ec 18             	sub    $0x18,%esp
  105726:	8b 45 10             	mov    0x10(%ebp),%eax
  105729:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10572c:	8b 55 08             	mov    0x8(%ebp),%edx
  10572f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  105732:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  105735:	89 45 f0             	mov    %eax,-0x10(%ebp)
    unsigned char* d = dest;
  105738:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10573b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* s = src;
  10573e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105741:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(n == 0) return 0;
  105744:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10574b:	0f 85 0c 00 00 00    	jne    10575d <memcpy+0x3d>
  105751:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105758:	e9 49 00 00 00       	jmp    1057a6 <memcpy+0x86>

    while (n--) {
  10575d:	e9 00 00 00 00       	jmp    105762 <memcpy+0x42>
  105762:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105765:	89 c1                	mov    %eax,%ecx
  105767:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  10576d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105770:	3d 00 00 00 00       	cmp    $0x0,%eax
  105775:	0f 84 25 00 00 00    	je     1057a0 <memcpy+0x80>
        *(d++) = *(s++);
  10577b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10577e:	89 c1                	mov    %eax,%ecx
  105780:	81 c1 01 00 00 00    	add    $0x1,%ecx
  105786:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  105789:	8a 10                	mov    (%eax),%dl
  10578b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10578e:	89 c1                	mov    %eax,%ecx
  105790:	81 c1 01 00 00 00    	add    $0x1,%ecx
  105796:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  105799:	88 10                	mov    %dl,(%eax)
    }
  10579b:	e9 c2 ff ff ff       	jmp    105762 <memcpy+0x42>

    return dest;
  1057a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1057a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1057a9:	83 c4 18             	add    $0x18,%esp
  1057ac:	5d                   	pop    %ebp
  1057ad:	c3                   	ret    
  1057ae:	66 90                	xchg   %ax,%ax

001057b0 <memcmp>:

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  1057b0:	55                   	push   %ebp
  1057b1:	89 e5                	mov    %esp,%ebp
  1057b3:	83 ec 1c             	sub    $0x1c,%esp
  1057b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1057b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1057bc:	8b 55 08             	mov    0x8(%ebp),%edx
  1057bf:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1057c2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1057c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
  1057c8:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1057cf:	0f 85 0c 00 00 00    	jne    1057e1 <memcmp+0x31>
        return -1;
  1057d5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1057dc:	e9 a7 00 00 00       	jmp    105888 <memcmp+0xd8>
    if (ptr2 == 0)
  1057e1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1057e8:	0f 85 0c 00 00 00    	jne    1057fa <memcmp+0x4a>
        return 1;
  1057ee:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1057f5:	e9 8e 00 00 00       	jmp    105888 <memcmp+0xd8>
    if (num == 0)
  1057fa:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105801:	0f 85 0c 00 00 00    	jne    105813 <memcmp+0x63>
        return 0;
  105807:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10580e:	e9 75 00 00 00       	jmp    105888 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
  105813:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105816:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
  105819:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10581c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
  10581f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  105826:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105829:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10582c:	0f 83 4f 00 00 00    	jae    105881 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
  105832:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105835:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105838:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  10583c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10583f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105842:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  105846:	39 c8                	cmp    %ecx,%eax
  105848:	0f 84 1e 00 00 00    	je     10586c <memcmp+0xbc>
            return pa[i] - pb[i];
  10584e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105851:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105854:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  105858:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10585b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10585e:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  105862:	29 c8                	sub    %ecx,%eax
  105864:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105867:	e9 1c 00 00 00       	jmp    105888 <memcmp+0xd8>
        }
    }
  10586c:	e9 00 00 00 00       	jmp    105871 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
  105871:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105874:	05 01 00 00 00       	add    $0x1,%eax
  105879:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10587c:	e9 a5 ff ff ff       	jmp    105826 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
  105881:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105888:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10588b:	83 c4 1c             	add    $0x1c,%esp
  10588e:	5d                   	pop    %ebp
  10588f:	c3                   	ret    

00105890 <strcmp>:

int strcmp(const char* str1, const char* str2) {
  105890:	55                   	push   %ebp
  105891:	89 e5                	mov    %esp,%ebp
  105893:	56                   	push   %esi
  105894:	83 ec 24             	sub    $0x24,%esp
  105897:	8b 45 0c             	mov    0xc(%ebp),%eax
  10589a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10589d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1058a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
  1058a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1058a6:	89 e1                	mov    %esp,%ecx
  1058a8:	89 01                	mov    %eax,(%ecx)
  1058aa:	e8 61 00 00 00       	call   105910 <strlen>
  1058af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
  1058b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1058b5:	89 e1                	mov    %esp,%ecx
  1058b7:	89 01                	mov    %eax,(%ecx)
  1058b9:	e8 52 00 00 00       	call   105910 <strlen>
  1058be:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
  1058c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1058c4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1058c7:	0f 8d 0b 00 00 00    	jge    1058d8 <strcmp+0x48>
  1058cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1058d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1058d3:	e9 06 00 00 00       	jmp    1058de <strcmp+0x4e>
  1058d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1058db:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1058de:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1058e1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
  1058e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1058e7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1058ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1058ed:	81 c2 01 00 00 00    	add    $0x1,%edx
  1058f3:	c1 e2 00             	shl    $0x0,%edx
  1058f6:	89 e6                	mov    %esp,%esi
  1058f8:	89 56 08             	mov    %edx,0x8(%esi)
  1058fb:	89 4e 04             	mov    %ecx,0x4(%esi)
  1058fe:	89 06                	mov    %eax,(%esi)
  105900:	e8 ab fe ff ff       	call   1057b0 <memcmp>
  105905:	83 c4 24             	add    $0x24,%esp
  105908:	5e                   	pop    %esi
  105909:	5d                   	pop    %ebp
  10590a:	c3                   	ret    
  10590b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105910 <strlen>:
}

unsigned int strlen(const char* str) {
  105910:	55                   	push   %ebp
  105911:	89 e5                	mov    %esp,%ebp
  105913:	83 ec 0c             	sub    $0xc,%esp
  105916:	8b 45 08             	mov    0x8(%ebp),%eax
  105919:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
  10591c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105923:	0f 85 0c 00 00 00    	jne    105935 <strlen+0x25>
        return 0;
  105929:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105930:	e9 37 00 00 00       	jmp    10596c <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
  105935:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10593c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10593f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105942:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  105946:	3d 00 00 00 00       	cmp    $0x0,%eax
  10594b:	0f 84 15 00 00 00    	je     105966 <strlen+0x56>
  105951:	e9 00 00 00 00       	jmp    105956 <strlen+0x46>
  105956:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105959:	05 01 00 00 00       	add    $0x1,%eax
  10595e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  105961:	e9 d6 ff ff ff       	jmp    10593c <strlen+0x2c>
        ;
    return i;
  105966:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105969:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10596c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10596f:	83 c4 0c             	add    $0xc,%esp
  105972:	5d                   	pop    %ebp
  105973:	c3                   	ret    
  105974:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10597b:	00 00 00 00 00 

00105980 <strcpy>:

char* strcpy(char* dest, const char* src) {
  105980:	55                   	push   %ebp
  105981:	89 e5                	mov    %esp,%ebp
  105983:	56                   	push   %esi
  105984:	83 ec 24             	sub    $0x24,%esp
  105987:	8b 45 0c             	mov    0xc(%ebp),%eax
  10598a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10598d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105990:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
  105993:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105996:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105999:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10599c:	89 e6                	mov    %esp,%esi
  10599e:	89 16                	mov    %edx,(%esi)
  1059a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1059a3:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1059a6:	e8 65 ff ff ff       	call   105910 <strlen>
  1059ab:	c1 e0 00             	shl    $0x0,%eax
  1059ae:	05 01 00 00 00       	add    $0x1,%eax
  1059b3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1059b6:	89 0c 24             	mov    %ecx,(%esp)
  1059b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1059bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1059c0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1059c4:	e8 57 fd ff ff       	call   105720 <memcpy>
    return dest;
  1059c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1059cc:	83 c4 24             	add    $0x24,%esp
  1059cf:	5e                   	pop    %esi
  1059d0:	5d                   	pop    %ebp
  1059d1:	c3                   	ret    
  1059d2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1059d9:	1f 84 00 00 00 00 00 

001059e0 <strclone>:
}

char* strclone(char* str) {
  1059e0:	55                   	push   %ebp
  1059e1:	89 e5                	mov    %esp,%ebp
  1059e3:	83 ec 18             	sub    $0x18,%esp
  1059e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1059e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
  1059ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1059ef:	89 e1                	mov    %esp,%ecx
  1059f1:	89 01                	mov    %eax,(%ecx)
  1059f3:	e8 18 ff ff ff       	call   105910 <strlen>
  1059f8:	c1 e0 00             	shl    $0x0,%eax
  1059fb:	05 01 00 00 00       	add    $0x1,%eax
  105a00:	89 04 24             	mov    %eax,(%esp)
  105a03:	e8 e8 f5 ff ff       	call   104ff0 <malloc>
  105a08:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
  105a0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105a0e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105a11:	89 e2                	mov    %esp,%edx
  105a13:	89 4a 04             	mov    %ecx,0x4(%edx)
  105a16:	89 02                	mov    %eax,(%edx)
  105a18:	e8 63 ff ff ff       	call   105980 <strcpy>

    return ret;
  105a1d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105a20:	89 45 f4             	mov    %eax,-0xc(%ebp)
  105a23:	89 c8                	mov    %ecx,%eax
  105a25:	83 c4 18             	add    $0x18,%esp
  105a28:	5d                   	pop    %ebp
  105a29:	c3                   	ret    
  105a2a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105a30 <strtok>:
}

char* sp = NULL; /* the start position of the string */
void* fr = NULL;

char* strtok(char* str, const char* delimiters) {
  105a30:	55                   	push   %ebp
  105a31:	89 e5                	mov    %esp,%ebp
  105a33:	83 ec 18             	sub    $0x18,%esp
  105a36:	8b 45 0c             	mov    0xc(%ebp),%eax
  105a39:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105a3c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) { //TODO better but if you call strtok and after that strtoknc will still be a memory leak. -> Don't use strtoknc
  105a42:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105a49:	0f 84 49 00 00 00    	je     105a98 <strtok+0x68>
        if(fr != 0) {
  105a4f:	81 3d 50 a5 10 00 00 	cmpl   $0x0,0x10a550
  105a56:	00 00 00 
  105a59:	0f 84 0d 00 00 00    	je     105a6c <strtok+0x3c>
            free(fr);
  105a5f:	a1 50 a5 10 00       	mov    0x10a550,%eax
  105a64:	89 04 24             	mov    %eax,(%esp)
  105a67:	e8 84 f9 ff ff       	call   1053f0 <free>
        }
        fr = strclone(str);
  105a6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105a6f:	89 04 24             	mov    %eax,(%esp)
  105a72:	e8 69 ff ff ff       	call   1059e0 <strclone>
  105a77:	a3 50 a5 10 00       	mov    %eax,0x10a550
        return strtoknc(fr, delimiters);
  105a7c:	a1 50 a5 10 00       	mov    0x10a550,%eax
  105a81:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105a84:	89 04 24             	mov    %eax,(%esp)
  105a87:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105a8b:	e8 30 00 00 00       	call   105ac0 <strtoknc>
  105a90:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105a93:	e9 1e 00 00 00       	jmp    105ab6 <strtok+0x86>
  105a98:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
  105a9d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105aa0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105aa7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105aab:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105aae:	e8 0d 00 00 00       	call   105ac0 <strtoknc>
  105ab3:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  105ab6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105ab9:	83 c4 18             	add    $0x18,%esp
  105abc:	5d                   	pop    %ebp
  105abd:	c3                   	ret    
  105abe:	66 90                	xchg   %ax,%ax

00105ac0 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
  105ac0:	55                   	push   %ebp
  105ac1:	89 e5                	mov    %esp,%ebp
  105ac3:	83 ec 28             	sub    $0x28,%esp
  105ac6:	8b 45 0c             	mov    0xc(%ebp),%eax
  105ac9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105acc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105acf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
  105ad2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
  105ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105adc:	89 e1                	mov    %esp,%ecx
  105ade:	89 01                	mov    %eax,(%ecx)
  105ae0:	e8 2b fe ff ff       	call   105910 <strlen>
  105ae5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
  105ae8:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  105aef:	0f 85 0c 00 00 00    	jne    105b01 <strtoknc+0x41>
        return 0;
  105af5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105afc:	e9 70 01 00 00       	jmp    105c71 <strtoknc+0x1b1>

    /* if the original string has nothing left */
    if (!str && !sp)
  105b01:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105b08:	0f 85 1c 00 00 00    	jne    105b2a <strtoknc+0x6a>
  105b0e:	81 3d 4c a5 10 00 00 	cmpl   $0x0,0x10a54c
  105b15:	00 00 00 
  105b18:	0f 85 0c 00 00 00    	jne    105b2a <strtoknc+0x6a>
        return 0;
  105b1e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105b25:	e9 47 01 00 00       	jmp    105c71 <strtoknc+0x1b1>

    /* initialize the sp during the first call */
    if (str) {
  105b2a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105b31:	0f 84 08 00 00 00    	je     105b3f <strtoknc+0x7f>
        sp = str;
  105b37:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105b3a:	a3 4c a5 10 00       	mov    %eax,0x10a54c
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
  105b3f:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105b44:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
  105b47:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  105b4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105b51:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  105b54:	0f 8d 3d 00 00 00    	jge    105b97 <strtoknc+0xd7>
            if (*p_start == delimiters[i]) {
  105b5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105b5d:	0f be 00             	movsbl (%eax),%eax
  105b60:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105b63:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105b66:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  105b6a:	39 c8                	cmp    %ecx,%eax
  105b6c:	0f 85 10 00 00 00    	jne    105b82 <strtoknc+0xc2>
                p_start++;
  105b72:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105b75:	05 01 00 00 00       	add    $0x1,%eax
  105b7a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
  105b7d:	e9 15 00 00 00       	jmp    105b97 <strtoknc+0xd7>
            }
        }
  105b82:	e9 00 00 00 00       	jmp    105b87 <strtoknc+0xc7>
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
  105b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105b8a:	05 01 00 00 00       	add    $0x1,%eax
  105b8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105b92:	e9 b7 ff ff ff       	jmp    105b4e <strtoknc+0x8e>
                p_start++;
                break;
            }
        }

        if (i == len) {
  105b97:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105b9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  105b9d:	0f 85 0d 00 00 00    	jne    105bb0 <strtoknc+0xf0>
            sp = p_start;
  105ba3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105ba6:	a3 4c a5 10 00       	mov    %eax,0x10a54c
            break;
  105bab:	e9 05 00 00 00       	jmp    105bb5 <strtoknc+0xf5>
        }
    }
  105bb0:	e9 92 ff ff ff       	jmp    105b47 <strtoknc+0x87>

    /* return NULL if nothing left */
    if (*sp == '\0') {
  105bb5:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105bba:	0f be 00             	movsbl (%eax),%eax
  105bbd:	3d 00 00 00 00       	cmp    $0x0,%eax
  105bc2:	0f 85 17 00 00 00    	jne    105bdf <strtoknc+0x11f>
        sp = NULL;
  105bc8:	c7 05 4c a5 10 00 00 	movl   $0x0,0x10a54c
  105bcf:	00 00 00 
        return sp;
  105bd2:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105bd7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105bda:	e9 92 00 00 00       	jmp    105c71 <strtoknc+0x1b1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
  105bdf:	e9 00 00 00 00       	jmp    105be4 <strtoknc+0x124>
  105be4:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105be9:	0f be 00             	movsbl (%eax),%eax
  105bec:	3d 00 00 00 00       	cmp    $0x0,%eax
  105bf1:	0f 84 74 00 00 00    	je     105c6b <strtoknc+0x1ab>
        for (i = 0; i < len; i++) {
  105bf7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  105bfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105c01:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  105c04:	0f 8d 3c 00 00 00    	jge    105c46 <strtoknc+0x186>
            if (*sp == delimiters[i]) {
  105c0a:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105c0f:	0f be 00             	movsbl (%eax),%eax
  105c12:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105c15:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105c18:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  105c1c:	39 c8                	cmp    %ecx,%eax
  105c1e:	0f 85 0d 00 00 00    	jne    105c31 <strtoknc+0x171>
                *sp = '\0';
  105c24:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105c29:	c6 00 00             	movb   $0x0,(%eax)
                break;
  105c2c:	e9 15 00 00 00       	jmp    105c46 <strtoknc+0x186>
            }
        }
  105c31:	e9 00 00 00 00       	jmp    105c36 <strtoknc+0x176>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
  105c36:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105c39:	05 01 00 00 00       	add    $0x1,%eax
  105c3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105c41:	e9 b8 ff ff ff       	jmp    105bfe <strtoknc+0x13e>
                *sp = '\0';
                break;
            }
        }

        sp++;
  105c46:	a1 4c a5 10 00       	mov    0x10a54c,%eax
  105c4b:	05 01 00 00 00       	add    $0x1,%eax
  105c50:	a3 4c a5 10 00       	mov    %eax,0x10a54c
        if (i < len)
  105c55:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105c58:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  105c5b:	0f 8d 05 00 00 00    	jge    105c66 <strtoknc+0x1a6>
            break;
  105c61:	e9 05 00 00 00       	jmp    105c6b <strtoknc+0x1ab>
    }
  105c66:	e9 79 ff ff ff       	jmp    105be4 <strtoknc+0x124>

    return p_start;
  105c6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105c6e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  105c71:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105c74:	83 c4 28             	add    $0x28,%esp
  105c77:	5d                   	pop    %ebp
  105c78:	c3                   	ret    
  105c79:	66 90                	xchg   %ax,%ax
  105c7b:	66 90                	xchg   %ax,%ax
  105c7d:	66 90                	xchg   %ax,%ax
  105c7f:	90                   	nop

00105c80 <vfs_reset_error>:
            get_current_task()->vfserr = code;
        }
    }
}

void vfs_reset_error() {
  105c80:	55                   	push   %ebp
  105c81:	89 e5                	mov    %esp,%ebp
    if(get_current_task()) {
  105c83:	83 ec 08             	sub    $0x8,%esp
  105c86:	e8 05 e7 ff ff       	call   104390 <get_current_task>
  105c8b:	3d 00 00 00 00       	cmp    $0x0,%eax
  105c90:	0f 84 0c 00 00 00    	je     105ca2 <vfs_reset_error+0x22>
        get_current_task()->vfserr = PE_NO_ERROR;
  105c96:	e8 f5 e6 ff ff       	call   104390 <get_current_task>
  105c9b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
    }
}
  105ca2:	83 c4 08             	add    $0x8,%esp
  105ca5:	5d                   	pop    %ebp
  105ca6:	c3                   	ret    
  105ca7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  105cae:	00 00 

00105cb0 <vfs_create_dir>:
    }

    return created;
}

uint32_t vfs_create_dir(char* path) {
  105cb0:	55                   	push   %ebp
  105cb1:	89 e5                	mov    %esp,%ebp
  105cb3:	83 ec 08             	sub    $0x8,%esp
  105cb6:	8b 45 08             	mov    0x8(%ebp),%eax
  105cb9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return vfs_create_path(path);
  105cbc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105cbf:	89 04 24             	mov    %eax,(%esp)
  105cc2:	e8 09 00 00 00       	call   105cd0 <vfs_create_path>
  105cc7:	83 c4 08             	add    $0x8,%esp
  105cca:	5d                   	pop    %ebp
  105ccb:	c3                   	ret    
  105ccc:	0f 1f 40 00          	nopl   0x0(%eax)

00105cd0 <vfs_create_path>:

static struct res_node* vfs_get_node(char* path) {
    return vfs_get_relative_node(vfs_get_current_task_root_node_for_path(path), path);
}

static int vfs_create_path(char* path) {
  105cd0:	55                   	push   %ebp
  105cd1:	89 e5                	mov    %esp,%ebp
  105cd3:	83 ec 38             	sub    $0x38,%esp
  105cd6:	8b 45 08             	mov    0x8(%ebp),%eax
  105cd9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = vfs_get_current_task_root_node_for_path(path);
  105cdc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105cdf:	89 04 24             	mov    %eax,(%esp)
  105ce2:	e8 99 10 00 00       	call   106d80 <vfs_get_current_task_root_node_for_path>
  105ce7:	8d 0d 88 96 10 00    	lea    0x109688,%ecx
  105ced:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  105cf0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    int created = 0;
  105cf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    sub = strtok(path, "/");
  105cfe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105d01:	89 04 24             	mov    %eax,(%esp)
  105d04:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105d08:	e8 23 fd ff ff       	call   105a30 <strtok>
  105d0d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  105d10:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105d13:	0f be 00             	movsbl (%eax),%eax
  105d16:	3d 00 00 00 00       	cmp    $0x0,%eax
  105d1b:	0f 85 21 00 00 00    	jne    105d42 <vfs_create_path+0x72>
  105d21:	b8 00 00 00 00       	mov    $0x0,%eax
  105d26:	8d 0d 88 96 10 00    	lea    0x109688,%ecx
  105d2c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105d33:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105d37:	89 45 e8             	mov    %eax,-0x18(%ebp)
  105d3a:	e8 f1 fc ff ff       	call   105a30 <strtok>
  105d3f:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  105d42:	e9 00 00 00 00       	jmp    105d47 <vfs_create_path+0x77>
  105d47:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105d4e:	0f 84 e8 00 00 00    	je     105e3c <vfs_create_path+0x16c>
    {
        child = vfs_find_node(parent, sub);
  105d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105d57:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105d5a:	89 04 24             	mov    %eax,(%esp)
  105d5d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105d61:	e8 ea 10 00 00       	call   106e50 <vfs_find_node>
  105d66:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(child == 0) {
  105d69:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105d70:	0f 85 9a 00 00 00    	jne    105e10 <vfs_create_path+0x140>
  105d76:	b8 10 01 00 00       	mov    $0x110,%eax
            child = malloc(sizeof(struct res_node));
  105d7b:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  105d82:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  105d85:	e8 66 f2 ff ff       	call   104ff0 <malloc>
  105d8a:	89 45 f0             	mov    %eax,-0x10(%ebp)

            strcpy(child->name, sub);
  105d8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105d90:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105d93:	89 e2                	mov    %esp,%edx
  105d95:	89 4a 04             	mov    %ecx,0x4(%edx)
  105d98:	89 02                	mov    %eax,(%edx)
  105d9a:	e8 e1 fb ff ff       	call   105980 <strcpy>
            child->res_type = RES_SUBDIR;
  105d9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105da2:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  105da9:	00 00 00 
            child->res_ptr = 0;
  105dac:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105daf:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  105db6:	00 00 00 

            created++;
  105db9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105dbc:	81 c1 01 00 00 00    	add    $0x1,%ecx
  105dc2:	89 4d ec             	mov    %ecx,-0x14(%ebp)

            if(vfs_insert_node(parent, child)) {
  105dc5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105dc8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  105dcb:	89 0c 24             	mov    %ecx,(%esp)
  105dce:	89 54 24 04          	mov    %edx,0x4(%esp)
  105dd2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  105dd5:	e8 b6 11 00 00       	call   106f90 <vfs_insert_node>
  105dda:	3d 00 00 00 00       	cmp    $0x0,%eax
  105ddf:	0f 84 26 00 00 00    	je     105e0b <vfs_create_path+0x13b>
  105de5:	b8 38 00 00 00       	mov    $0x38,%eax
                show_cod(malloc(sizeof(struct cpu_state)), "Tried to insert VFS node in non RES_SUBDIR parent");
  105dea:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  105df1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  105df4:	e8 f7 f1 ff ff       	call   104ff0 <malloc>
  105df9:	8d 0d 8a 96 10 00    	lea    0x10968a,%ecx
  105dff:	89 04 24             	mov    %eax,(%esp)
  105e02:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105e06:	e8 b5 a2 ff ff       	call   1000c0 <show_cod>
            }
        }
  105e0b:	e9 00 00 00 00       	jmp    105e10 <vfs_create_path+0x140>
  105e10:	b8 00 00 00 00       	mov    $0x0,%eax
  105e15:	8d 0d 88 96 10 00    	lea    0x109688,%ecx

        parent = child;
  105e1b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  105e1e:	89 55 f4             	mov    %edx,-0xc(%ebp)

        sub = strtok(0, "/");
  105e21:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105e28:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105e2c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105e2f:	e8 fc fb ff ff       	call   105a30 <strtok>
  105e34:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  105e37:	e9 0b ff ff ff       	jmp    105d47 <vfs_create_path+0x77>

    return created;
  105e3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105e3f:	83 c4 38             	add    $0x38,%esp
  105e42:	5d                   	pop    %ebp
  105e43:	c3                   	ret    
  105e44:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105e4b:	00 00 00 00 00 

00105e50 <vfs_create_kfile>:

uint32_t vfs_create_dir(char* path) {
    return vfs_create_path(path);
}

uint32_t vfs_create_kfile(char* path, struct kfs_driver* driver, uint32_t* params) {
  105e50:	55                   	push   %ebp
  105e51:	89 e5                	mov    %esp,%ebp
  105e53:	83 ec 28             	sub    $0x28,%esp
  105e56:	8b 45 10             	mov    0x10(%ebp),%eax
  105e59:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105e5c:	8b 55 08             	mov    0x8(%ebp),%edx
  105e5f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  105e62:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105e65:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* pathc = malloc(strlen(path) + 1);
  105e68:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105e6b:	89 e1                	mov    %esp,%ecx
  105e6d:	89 01                	mov    %eax,(%ecx)
  105e6f:	e8 9c fa ff ff       	call   105910 <strlen>
  105e74:	05 01 00 00 00       	add    $0x1,%eax
  105e79:	89 04 24             	mov    %eax,(%esp)
  105e7c:	e8 6f f1 ff ff       	call   104ff0 <malloc>
  105e81:	89 45 f0             	mov    %eax,-0x10(%ebp)
    strcpy(pathc, path);
  105e84:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105e87:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105e8a:	89 e2                	mov    %esp,%edx
  105e8c:	89 4a 04             	mov    %ecx,0x4(%edx)
  105e8f:	89 02                	mov    %eax,(%edx)
  105e91:	e8 ea fa ff ff       	call   105980 <strcpy>

    uint32_t ret = vfs_create_path(pathc);
  105e96:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105e99:	89 0c 24             	mov    %ecx,(%esp)
  105e9c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  105e9f:	e8 2c fe ff ff       	call   105cd0 <vfs_create_path>
  105ea4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    static struct res_node* node;
    node = vfs_get_node(path);
  105ea7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105eaa:	89 04 24             	mov    %eax,(%esp)
  105ead:	e8 4e 00 00 00       	call   105f00 <vfs_get_node>
  105eb2:	a3 60 a5 10 00       	mov    %eax,0x10a560

    node->res_type = RES_KERNDRV;
  105eb7:	a1 60 a5 10 00       	mov    0x10a560,%eax
  105ebc:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  105ec3:	00 00 00 
    node->res_ptr = driver->create(params);
  105ec6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ec9:	8b 40 14             	mov    0x14(%eax),%eax
  105ecc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105ecf:	89 0c 24             	mov    %ecx,(%esp)
  105ed2:	ff d0                	call   *%eax
  105ed4:	8b 0d 60 a5 10 00    	mov    0x10a560,%ecx
  105eda:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)
    ((struct res_kfile*) node->res_ptr)->driver = driver;
  105ee0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ee3:	8b 0d 60 a5 10 00    	mov    0x10a560,%ecx
  105ee9:	8b 89 04 01 00 00    	mov    0x104(%ecx),%ecx
  105eef:	89 41 04             	mov    %eax,0x4(%ecx)

    return ret;
  105ef2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105ef5:	83 c4 28             	add    $0x28,%esp
  105ef8:	5d                   	pop    %ebp
  105ef9:	c3                   	ret    
  105efa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105f00 <vfs_get_node>:

    return vfs_get_relative_node(root, get_current_task()->execPath);

}

static struct res_node* vfs_get_node(char* path) {
  105f00:	55                   	push   %ebp
  105f01:	89 e5                	mov    %esp,%ebp
  105f03:	83 ec 18             	sub    $0x18,%esp
  105f06:	8b 45 08             	mov    0x8(%ebp),%eax
  105f09:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return vfs_get_relative_node(vfs_get_current_task_root_node_for_path(path), path);
  105f0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105f0f:	89 04 24             	mov    %eax,(%esp)
  105f12:	e8 69 0e 00 00       	call   106d80 <vfs_get_current_task_root_node_for_path>
  105f17:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105f1a:	89 04 24             	mov    %eax,(%esp)
  105f1d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105f21:	e8 ea 0c 00 00       	call   106c10 <vfs_get_relative_node>
  105f26:	83 c4 18             	add    $0x18,%esp
  105f29:	5d                   	pop    %ebp
  105f2a:	c3                   	ret    
  105f2b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105f30 <vfs_open>:
    ((struct res_kfile*) node->res_ptr)->driver = driver;

    return ret;
}

struct res_handle* vfs_open(char* path, uint32_t filemode) {
  105f30:	55                   	push   %ebp
  105f31:	89 e5                	mov    %esp,%ebp
  105f33:	83 ec 28             	sub    $0x28,%esp
  105f36:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f39:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105f3c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105f3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    static struct res_node* node;

    node = vfs_get_node(path);
  105f42:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f45:	89 04 24             	mov    %eax,(%esp)
  105f48:	e8 b3 ff ff ff       	call   105f00 <vfs_get_node>
  105f4d:	a3 64 a5 10 00       	mov    %eax,0x10a564

    if(node->res_type == RES_KERNDRV) {
  105f52:	a1 64 a5 10 00       	mov    0x10a564,%eax
  105f57:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  105f5e:	00 00 00 
  105f61:	0f 85 34 00 00 00    	jne    105f9b <vfs_open+0x6b>
        struct res_kfile* kf = (struct res_kfile*)node->res_ptr;
  105f67:	a1 64 a5 10 00       	mov    0x10a564,%eax
  105f6c:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105f72:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct res_handle* handle = kf->driver->open(kf, filemode);
  105f75:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105f78:	8b 40 04             	mov    0x4(%eax),%eax
  105f7b:	8b 40 08             	mov    0x8(%eax),%eax
  105f7e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105f81:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105f84:	89 0c 24             	mov    %ecx,(%esp)
  105f87:	89 54 24 04          	mov    %edx,0x4(%esp)
  105f8b:	ff d0                	call   *%eax
  105f8d:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return handle;
  105f90:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105f93:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105f96:	e9 07 00 00 00       	jmp    105fa2 <vfs_open+0x72>
    }

    return 0;
  105f9b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105fa2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105fa5:	83 c4 28             	add    $0x28,%esp
  105fa8:	5d                   	pop    %ebp
  105fa9:	c3                   	ret    
  105faa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105fb0 <vfs_close>:

uint32_t vfs_close(struct res_handle* handle) {
  105fb0:	55                   	push   %ebp
  105fb1:	89 e5                	mov    %esp,%ebp
  105fb3:	83 ec 18             	sub    $0x18,%esp
  105fb6:	8b 45 08             	mov    0x8(%ebp),%eax
  105fb9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle->res_type == RES_KERNDRV) {
  105fbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105fbf:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105fc5:	0f 85 22 00 00 00    	jne    105fed <vfs_close+0x3d>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  105fcb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105fce:	8b 40 04             	mov    0x4(%eax),%eax
  105fd1:	89 45 f4             	mov    %eax,-0xc(%ebp)

       return kf->driver->close(handle);
  105fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105fd7:	8b 40 04             	mov    0x4(%eax),%eax
  105fda:	8b 40 0c             	mov    0xc(%eax),%eax
  105fdd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105fe0:	89 0c 24             	mov    %ecx,(%esp)
  105fe3:	ff d0                	call   *%eax
  105fe5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105fe8:	e9 07 00 00 00       	jmp    105ff4 <vfs_close+0x44>
    }

    return 0;
  105fed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105ff4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105ff7:	83 c4 18             	add    $0x18,%esp
  105ffa:	5d                   	pop    %ebp
  105ffb:	c3                   	ret    
  105ffc:	0f 1f 40 00          	nopl   0x0(%eax)

00106000 <vfs_read>:

uint32_t vfs_read(struct res_handle* handle, void* dest, uint32_t size, uint32_t count) {
  106000:	55                   	push   %ebp
  106001:	89 e5                	mov    %esp,%ebp
  106003:	56                   	push   %esi
  106004:	83 ec 34             	sub    $0x34,%esp
  106007:	8b 45 14             	mov    0x14(%ebp),%eax
  10600a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10600d:	8b 55 0c             	mov    0xc(%ebp),%edx
  106010:	8b 75 08             	mov    0x8(%ebp),%esi
  106013:	89 75 f4             	mov    %esi,-0xc(%ebp)
  106016:	89 55 f0             	mov    %edx,-0x10(%ebp)
  106019:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10601c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10601f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  106026:	0f 85 0c 00 00 00    	jne    106038 <vfs_read+0x38>
  10602c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  106033:	e9 b6 00 00 00       	jmp    1060ee <vfs_read+0xee>

    if(!(handle->filemode & FM_READ)) return RW_NOFM_READ;
  106038:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10603b:	8b 40 0c             	mov    0xc(%eax),%eax
  10603e:	25 01 00 00 00       	and    $0x1,%eax
  106043:	3d 00 00 00 00       	cmp    $0x0,%eax
  106048:	0f 85 0c 00 00 00    	jne    10605a <vfs_read+0x5a>
  10604e:	c7 45 f8 04 00 00 00 	movl   $0x4,-0x8(%ebp)
  106055:	e9 94 00 00 00       	jmp    1060ee <vfs_read+0xee>

    if(handle->res_type == RES_KERNDRV) {
  10605a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10605d:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  106063:	0f 85 7e 00 00 00    	jne    1060e7 <vfs_read+0xe7>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  106069:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10606c:	8b 40 04             	mov    0x4(%eax),%eax
  10606f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rread(handle, dest, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  106072:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106075:	8b 40 04             	mov    0x4(%eax),%eax
  106078:	8b 00                	mov    (%eax),%eax
  10607a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10607d:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106080:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106083:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  106087:	89 0c 24             	mov    %ecx,(%esp)
  10608a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10608e:	89 74 24 08          	mov    %esi,0x8(%esp)
  106092:	ff d0                	call   *%eax
  106094:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  106097:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10609e:	0f 85 1e 00 00 00    	jne    1060c2 <vfs_read+0xc2>
           handle->position += size * count;
  1060a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1060a7:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1060ab:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1060ae:	8b 51 08             	mov    0x8(%ecx),%edx
  1060b1:	01 c2                	add    %eax,%edx
  1060b3:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1060b6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1060bd:	e9 2c 00 00 00       	jmp    1060ee <vfs_read+0xee>
       }

       if(res == RW_BLOCK) {
  1060c2:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  1060c9:	0f 85 0c 00 00 00    	jne    1060db <vfs_read+0xdb>
           return RW_BLOCK;
  1060cf:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1060d6:	e9 13 00 00 00       	jmp    1060ee <vfs_read+0xee>
       }

       return RW_ERR_DRIVER;
  1060db:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  1060e2:	e9 07 00 00 00       	jmp    1060ee <vfs_read+0xee>
    }

    return RW_ERR_VFS;
  1060e7:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  1060ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1060f1:	83 c4 34             	add    $0x34,%esp
  1060f4:	5e                   	pop    %esi
  1060f5:	5d                   	pop    %ebp
  1060f6:	c3                   	ret    
  1060f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1060fe:	00 00 

00106100 <vfs_write>:

uint32_t vfs_write(struct res_handle* handle, void* src,  uint32_t size, uint32_t count) {
  106100:	55                   	push   %ebp
  106101:	89 e5                	mov    %esp,%ebp
  106103:	56                   	push   %esi
  106104:	83 ec 34             	sub    $0x34,%esp
  106107:	8b 45 14             	mov    0x14(%ebp),%eax
  10610a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10610d:	8b 55 0c             	mov    0xc(%ebp),%edx
  106110:	8b 75 08             	mov    0x8(%ebp),%esi
  106113:	89 75 f4             	mov    %esi,-0xc(%ebp)
  106116:	89 55 f0             	mov    %edx,-0x10(%ebp)
  106119:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10611c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10611f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  106126:	0f 85 0c 00 00 00    	jne    106138 <vfs_write+0x38>
  10612c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  106133:	e9 b7 00 00 00       	jmp    1061ef <vfs_write+0xef>

    if(!(handle->filemode & FM_WRITE)) return RW_NOFM_WRITE;
  106138:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10613b:	8b 40 0c             	mov    0xc(%eax),%eax
  10613e:	25 02 00 00 00       	and    $0x2,%eax
  106143:	3d 00 00 00 00       	cmp    $0x0,%eax
  106148:	0f 85 0c 00 00 00    	jne    10615a <vfs_write+0x5a>
  10614e:	c7 45 f8 05 00 00 00 	movl   $0x5,-0x8(%ebp)
  106155:	e9 95 00 00 00       	jmp    1061ef <vfs_write+0xef>

    if(handle->res_type == RES_KERNDRV) {
  10615a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10615d:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  106163:	0f 85 7f 00 00 00    	jne    1061e8 <vfs_write+0xe8>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  106169:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10616c:	8b 40 04             	mov    0x4(%eax),%eax
  10616f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rwrite(handle, src, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  106172:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106175:	8b 40 04             	mov    0x4(%eax),%eax
  106178:	8b 40 04             	mov    0x4(%eax),%eax
  10617b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10617e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106181:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106184:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  106188:	89 0c 24             	mov    %ecx,(%esp)
  10618b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10618f:	89 74 24 08          	mov    %esi,0x8(%esp)
  106193:	ff d0                	call   *%eax
  106195:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  106198:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10619f:	0f 85 1e 00 00 00    	jne    1061c3 <vfs_write+0xc3>
           handle->position += size * count;
  1061a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1061a8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1061ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1061af:	8b 51 08             	mov    0x8(%ecx),%edx
  1061b2:	01 c2                	add    %eax,%edx
  1061b4:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1061b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1061be:	e9 2c 00 00 00       	jmp    1061ef <vfs_write+0xef>
       }

       if(res == RW_BLOCK) {
  1061c3:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  1061ca:	0f 85 0c 00 00 00    	jne    1061dc <vfs_write+0xdc>
           return RW_BLOCK;
  1061d0:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1061d7:	e9 13 00 00 00       	jmp    1061ef <vfs_write+0xef>
       }

       return RW_ERR_DRIVER;
  1061dc:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  1061e3:	e9 07 00 00 00       	jmp    1061ef <vfs_write+0xef>
    }

    return RW_ERR_VFS;
  1061e8:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  1061ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1061f2:	83 c4 34             	add    $0x34,%esp
  1061f5:	5e                   	pop    %esi
  1061f6:	5d                   	pop    %ebp
  1061f7:	c3                   	ret    
  1061f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  1061ff:	00 

00106200 <vfs_available>:

uint32_t vfs_available(struct res_handle* handle) {
  106200:	55                   	push   %ebp
  106201:	89 e5                	mov    %esp,%ebp
  106203:	83 ec 18             	sub    $0x18,%esp
  106206:	8b 45 08             	mov    0x8(%ebp),%eax
  106209:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle == 0) return 0;
  10620c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  106213:	0f 85 0c 00 00 00    	jne    106225 <vfs_available+0x25>
  106219:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106220:	e9 38 00 00 00       	jmp    10625d <vfs_available+0x5d>

    if(handle->res_type == RES_KERNDRV) {
  106225:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106228:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  10622e:	0f 85 22 00 00 00    	jne    106256 <vfs_available+0x56>
        struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  106234:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106237:	8b 40 04             	mov    0x4(%eax),%eax
  10623a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        return kf->driver->available(handle);
  10623d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106240:	8b 40 04             	mov    0x4(%eax),%eax
  106243:	8b 40 10             	mov    0x10(%eax),%eax
  106246:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106249:	89 0c 24             	mov    %ecx,(%esp)
  10624c:	ff d0                	call   *%eax
  10624e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106251:	e9 07 00 00 00       	jmp    10625d <vfs_available+0x5d>
    }

    return 0;
  106256:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  10625d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106260:	83 c4 18             	add    $0x18,%esp
  106263:	5d                   	pop    %ebp
  106264:	c3                   	ret    
  106265:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10626c:	00 00 00 00 

00106270 <vfs_exists>:

uint32_t vfs_exists(char* path) {
  106270:	55                   	push   %ebp
  106271:	89 e5                	mov    %esp,%ebp
  106273:	83 ec 18             	sub    $0x18,%esp
  106276:	8b 45 08             	mov    0x8(%ebp),%eax
  106279:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(vfs_get_node(path) != 0) return 1;
  10627c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10627f:	89 04 24             	mov    %eax,(%esp)
  106282:	e8 79 fc ff ff       	call   105f00 <vfs_get_node>
  106287:	3d 00 00 00 00       	cmp    $0x0,%eax
  10628c:	0f 84 0c 00 00 00    	je     10629e <vfs_exists+0x2e>
  106292:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  106299:	e9 07 00 00 00       	jmp    1062a5 <vfs_exists+0x35>
    return 0;
  10629e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1062a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1062a8:	83 c4 18             	add    $0x18,%esp
  1062ab:	5d                   	pop    %ebp
  1062ac:	c3                   	ret    
  1062ad:	0f 1f 00             	nopl   (%eax)

001062b0 <vfs_seek>:

void vfs_seek(struct res_handle* handle, uint32_t offset, uint32_t origin) {
  1062b0:	55                   	push   %ebp
  1062b1:	89 e5                	mov    %esp,%ebp
  1062b3:	83 ec 0c             	sub    $0xc,%esp
  1062b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1062b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1062bc:	8b 55 08             	mov    0x8(%ebp),%edx
  1062bf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1062c2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1062c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(origin == SEEK_SET) {
  1062c8:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1062cf:	0f 85 09 00 00 00    	jne    1062de <vfs_seek+0x2e>
        handle->position = offset;
  1062d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1062d8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1062db:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if(origin == SEEK_CUR) {
  1062de:	81 7d f4 01 00 00 00 	cmpl   $0x1,-0xc(%ebp)
  1062e5:	0f 85 0e 00 00 00    	jne    1062f9 <vfs_seek+0x49>
        handle->position += offset;
  1062eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1062ee:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1062f1:	8b 51 08             	mov    0x8(%ecx),%edx
  1062f4:	01 c2                	add    %eax,%edx
  1062f6:	89 51 08             	mov    %edx,0x8(%ecx)
    }
}
  1062f9:	83 c4 0c             	add    $0xc,%esp
  1062fc:	5d                   	pop    %ebp
  1062fd:	c3                   	ret    
  1062fe:	66 90                	xchg   %ax,%ax

00106300 <vfs_exec>:

uint32_t vfs_exec(char* path, char* args[], char* execPath, char* stdin, char* stdout, char* stderr) {
  106300:	55                   	push   %ebp
  106301:	89 e5                	mov    %esp,%ebp
  106303:	53                   	push   %ebx
  106304:	57                   	push   %edi
  106305:	56                   	push   %esi
  106306:	81 ec cc 00 00 00    	sub    $0xcc,%esp
  10630c:	8b 45 1c             	mov    0x1c(%ebp),%eax
  10630f:	8b 4d 18             	mov    0x18(%ebp),%ecx
  106312:	8b 55 14             	mov    0x14(%ebp),%edx
  106315:	8b 75 10             	mov    0x10(%ebp),%esi
  106318:	8b 7d 0c             	mov    0xc(%ebp),%edi
  10631b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10631e:	89 5d ec             	mov    %ebx,-0x14(%ebp)
  106321:	89 7d e8             	mov    %edi,-0x18(%ebp)
  106324:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  106327:	89 55 e0             	mov    %edx,-0x20(%ebp)
  10632a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  10632d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    path = strclone(path);
  106330:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106333:	89 04 24             	mov    %eax,(%esp)
  106336:	e8 a5 f6 ff ff       	call   1059e0 <strclone>
  10633b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!vfs_exists(path)) {
  10633e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106341:	89 04 24             	mov    %eax,(%esp)
  106344:	e8 27 ff ff ff       	call   106270 <vfs_exists>
  106349:	3d 00 00 00 00       	cmp    $0x0,%eax
  10634e:	0f 85 2e 00 00 00    	jne    106382 <vfs_exec+0x82>
        free(path);
  106354:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106357:	89 04 24             	mov    %eax,(%esp)
  10635a:	e8 91 f0 ff ff       	call   1053f0 <free>
  10635f:	b8 01 00 00 00       	mov    $0x1,%eax
        vfs_set_error(PE_FILE_NOT_FOUND);
  106364:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10636b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  106371:	e8 ea 05 00 00       	call   106960 <vfs_set_error>
        return 0;
  106376:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10637d:	e9 c6 05 00 00       	jmp    106948 <vfs_exec+0x648>
    }

    uint32_t elf_mod_pdir;

    elf_mod_pdir = vmm_create_pagedir();
  106382:	e8 a9 0c 00 00       	call   107030 <vmm_create_pagedir>
  106387:	89 45 d4             	mov    %eax,-0x2c(%ebp)

    //Copy args into kernel memory
    uint32_t argc = 0;
  10638a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

    if(args != 0) {
  106391:	81 7d e8 00 00 00 00 	cmpl   $0x0,-0x18(%ebp)
  106398:	0f 84 2d 00 00 00    	je     1063cb <vfs_exec+0xcb>
        while(args[argc] != 0) {
  10639e:	e9 00 00 00 00       	jmp    1063a3 <vfs_exec+0xa3>
  1063a3:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1063a6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1063a9:	81 3c 81 00 00 00 00 	cmpl   $0x0,(%ecx,%eax,4)
  1063b0:	0f 84 10 00 00 00    	je     1063c6 <vfs_exec+0xc6>
            argc++;
  1063b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1063b9:	05 01 00 00 00       	add    $0x1,%eax
  1063be:	89 45 d0             	mov    %eax,-0x30(%ebp)
        }
  1063c1:	e9 dd ff ff ff       	jmp    1063a3 <vfs_exec+0xa3>
    }
  1063c6:	e9 00 00 00 00       	jmp    1063cb <vfs_exec+0xcb>

    char** kargs = malloc((sizeof(char*)) * (argc + 1));
  1063cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1063ce:	05 01 00 00 00       	add    $0x1,%eax
  1063d3:	c1 e0 02             	shl    $0x2,%eax
  1063d6:	89 04 24             	mov    %eax,(%esp)
  1063d9:	e8 12 ec ff ff       	call   104ff0 <malloc>
  1063de:	89 45 cc             	mov    %eax,-0x34(%ebp)

    for(uint32_t i = 0; i < argc; i++) {
  1063e1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  1063e8:	8b 45 c8             	mov    -0x38(%ebp),%eax
  1063eb:	3b 45 d0             	cmp    -0x30(%ebp),%eax
  1063ee:	0f 83 5c 00 00 00    	jae    106450 <vfs_exec+0x150>
        kargs[i] = malloc(strlen(args[i]) + 1);
  1063f4:	8b 45 c8             	mov    -0x38(%ebp),%eax
  1063f7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1063fa:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1063fd:	89 e1                	mov    %esp,%ecx
  1063ff:	89 01                	mov    %eax,(%ecx)
  106401:	e8 0a f5 ff ff       	call   105910 <strlen>
  106406:	05 01 00 00 00       	add    $0x1,%eax
  10640b:	89 04 24             	mov    %eax,(%esp)
  10640e:	e8 dd eb ff ff       	call   104ff0 <malloc>
  106413:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  106416:	8b 55 cc             	mov    -0x34(%ebp),%edx
  106419:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
        strcpy(kargs[i], args[i]);
  10641c:	8b 45 c8             	mov    -0x38(%ebp),%eax
  10641f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  106422:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106425:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  106428:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10642b:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  10642e:	89 e2                	mov    %esp,%edx
  106430:	89 4a 04             	mov    %ecx,0x4(%edx)
  106433:	89 02                	mov    %eax,(%edx)
  106435:	e8 46 f5 ff ff       	call   105980 <strcpy>
  10643a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
        }
    }

    char** kargs = malloc((sizeof(char*)) * (argc + 1));

    for(uint32_t i = 0; i < argc; i++) {
  106440:	8b 45 c8             	mov    -0x38(%ebp),%eax
  106443:	05 01 00 00 00       	add    $0x1,%eax
  106448:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10644b:	e9 98 ff ff ff       	jmp    1063e8 <vfs_exec+0xe8>
  106450:	b8 05 00 00 00       	mov    $0x5,%eax
        kargs[i] = malloc(strlen(args[i]) + 1);
        strcpy(kargs[i], args[i]);
    }

    kargs[argc] = 0;
  106455:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  106458:	8b 55 cc             	mov    -0x34(%ebp),%edx
  10645b:	c7 04 8a 00 00 00 00 	movl   $0x0,(%edx,%ecx,4)

    //Execute file
    struct res_handle* handle = vfs_open(path, FM_EXEC | FM_READ);
  106462:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106465:	89 0c 24             	mov    %ecx,(%esp)
  106468:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  10646f:	00 
  106470:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  106476:	e8 b5 fa ff ff       	call   105f30 <vfs_open>
  10647b:	89 45 c4             	mov    %eax,-0x3c(%ebp)

    if(!handle) {
  10647e:	81 7d c4 00 00 00 00 	cmpl   $0x0,-0x3c(%ebp)
  106485:	0f 85 2e 00 00 00    	jne    1064b9 <vfs_exec+0x1b9>
  10648b:	b8 02 00 00 00       	mov    $0x2,%eax
        vfs_set_error(PE_PERM_DENIED);
  106490:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  106497:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
  10649d:	e8 be 04 00 00       	call   106960 <vfs_set_error>
        free(path);
  1064a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1064a5:	89 04 24             	mov    %eax,(%esp)
  1064a8:	e8 43 ef ff ff       	call   1053f0 <free>
        return 0;
  1064ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1064b4:	e9 8f 04 00 00       	jmp    106948 <vfs_exec+0x648>
    }

    uint32_t size = vfs_available(handle);
  1064b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  1064bc:	89 04 24             	mov    %eax,(%esp)
  1064bf:	e8 3c fd ff ff       	call   106200 <vfs_available>
  1064c4:	89 45 c0             	mov    %eax,-0x40(%ebp)
    if(size == 0) {
  1064c7:	81 7d c0 00 00 00 00 	cmpl   $0x0,-0x40(%ebp)
  1064ce:	0f 85 2e 00 00 00    	jne    106502 <vfs_exec+0x202>
  1064d4:	b8 03 00 00 00       	mov    $0x3,%eax
        vfs_set_error(PE_CORRUPT_FILE);
  1064d9:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1064e0:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
  1064e6:	e8 75 04 00 00       	call   106960 <vfs_set_error>
        free(path);
  1064eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1064ee:	89 04 24             	mov    %eax,(%esp)
  1064f1:	e8 fa ee ff ff       	call   1053f0 <free>
        return 0;
  1064f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1064fd:	e9 46 04 00 00       	jmp    106948 <vfs_exec+0x648>
    }

    void* modsrc = malloc(size);
  106502:	8b 45 c0             	mov    -0x40(%ebp),%eax
  106505:	89 04 24             	mov    %eax,(%esp)
  106508:	e8 e3 ea ff ff       	call   104ff0 <malloc>
  10650d:	b9 01 00 00 00       	mov    $0x1,%ecx
  106512:	89 45 bc             	mov    %eax,-0x44(%ebp)

    uint32_t res = vfs_read(handle, modsrc, size, 1);
  106515:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  106518:	8b 55 bc             	mov    -0x44(%ebp),%edx
  10651b:	8b 75 c0             	mov    -0x40(%ebp),%esi
  10651e:	89 04 24             	mov    %eax,(%esp)
  106521:	89 54 24 04          	mov    %edx,0x4(%esp)
  106525:	89 74 24 08          	mov    %esi,0x8(%esp)
  106529:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  106530:	00 
  106531:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
  106537:	e8 c4 fa ff ff       	call   106000 <vfs_read>
  10653c:	89 45 b8             	mov    %eax,-0x48(%ebp)

    if(res != RW_OK) {
  10653f:	81 7d b8 00 00 00 00 	cmpl   $0x0,-0x48(%ebp)
  106546:	0f 84 39 00 00 00    	je     106585 <vfs_exec+0x285>
        free(path);
  10654c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10654f:	89 04 24             	mov    %eax,(%esp)
  106552:	e8 99 ee ff ff       	call   1053f0 <free>
        free(modsrc);
  106557:	8b 45 bc             	mov    -0x44(%ebp),%eax
  10655a:	89 04 24             	mov    %eax,(%esp)
  10655d:	e8 8e ee ff ff       	call   1053f0 <free>
  106562:	b8 04 00 00 00       	mov    $0x4,%eax
        vfs_set_error(PE_FILESYSTEM);
  106567:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10656e:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  106574:	e8 e7 03 00 00       	call   106960 <vfs_set_error>
        return 0;
  106579:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  106580:	e9 c3 03 00 00       	jmp    106948 <vfs_exec+0x648>
    }

    uint32_t old_pdir = vmm_get_current_pagedir();
  106585:	e8 96 0a 00 00       	call   107020 <vmm_get_current_pagedir>
  10658a:	89 45 b4             	mov    %eax,-0x4c(%ebp)

    //**********************************************************************************************************
    vmm_activate_pagedir(elf_mod_pdir);
  10658d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  106590:	89 04 24             	mov    %eax,(%esp)
  106593:	e8 58 16 00 00       	call   107bf0 <vmm_activate_pagedir>

    struct elf_header* header = modsrc;
  106598:	8b 45 bc             	mov    -0x44(%ebp),%eax
  10659b:	89 45 b0             	mov    %eax,-0x50(%ebp)
    struct elf_program_header* ph;

    /* Ist es ueberhaupt eine ELF-Datei? */
    if (header->magic != ELF_MAGIC) {
  10659e:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1065a1:	81 38 7f 45 4c 46    	cmpl   $0x464c457f,(%eax)
  1065a7:	0f 84 39 00 00 00    	je     1065e6 <vfs_exec+0x2e6>
        free(modsrc);
  1065ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
  1065b0:	89 04 24             	mov    %eax,(%esp)
  1065b3:	e8 38 ee ff ff       	call   1053f0 <free>
        free(path);
  1065b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1065bb:	89 04 24             	mov    %eax,(%esp)
  1065be:	e8 2d ee ff ff       	call   1053f0 <free>
  1065c3:	b8 03 00 00 00       	mov    $0x3,%eax
        vfs_set_error(PE_CORRUPT_FILE);
  1065c8:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1065cf:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
  1065d5:	e8 86 03 00 00       	call   106960 <vfs_set_error>
        return 0;
  1065da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1065e1:	e9 62 03 00 00       	jmp    106948 <vfs_exec+0x648>
    }

    void* elf_mod_entry = (void*) (header->entry);
  1065e6:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1065e9:	8b 40 18             	mov    0x18(%eax),%eax
  1065ec:	89 45 a8             	mov    %eax,-0x58(%ebp)

    ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);
  1065ef:	8b 45 b0             	mov    -0x50(%ebp),%eax
  1065f2:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  1065f5:	03 41 1c             	add    0x1c(%ecx),%eax
  1065f8:	89 45 ac             	mov    %eax,-0x54(%ebp)

    for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  1065fb:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  106602:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  106605:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  106608:	0f b7 49 2c          	movzwl 0x2c(%ecx),%ecx
  10660c:	39 c8                	cmp    %ecx,%eax
  10660e:	0f 83 bb 00 00 00    	jae    1066cf <vfs_exec+0x3cf>
        void* dest = (void*) ph->virt_addr;
  106614:	8b 45 ac             	mov    -0x54(%ebp),%eax
  106617:	8b 40 08             	mov    0x8(%eax),%eax
  10661a:	89 45 a0             	mov    %eax,-0x60(%ebp)
        void* src = ((char*) header) + ph->offset;
  10661d:	8b 45 b0             	mov    -0x50(%ebp),%eax
  106620:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  106623:	03 41 04             	add    0x4(%ecx),%eax
  106626:	89 45 9c             	mov    %eax,-0x64(%ebp)

        /* Nur Program Header vom Typ LOAD laden */
        if (ph->type != 1) {
  106629:	8b 45 ac             	mov    -0x54(%ebp),%eax
  10662c:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  106632:	0f 84 05 00 00 00    	je     10663d <vfs_exec+0x33d>
            continue;
  106638:	e9 77 00 00 00       	jmp    1066b4 <vfs_exec+0x3b4>
        }

        for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  10663d:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
  106644:	8b 45 98             	mov    -0x68(%ebp),%eax
  106647:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  10664a:	3b 41 14             	cmp    0x14(%ecx),%eax
  10664d:	0f 83 45 00 00 00    	jae    106698 <vfs_exec+0x398>
            vmm_free(dest + offset);
  106653:	8b 45 a0             	mov    -0x60(%ebp),%eax
  106656:	03 45 98             	add    -0x68(%ebp),%eax
  106659:	89 04 24             	mov    %eax,(%esp)
  10665c:	e8 df 0e 00 00       	call   107540 <vmm_free>
  106661:	b8 00 00 00 00       	mov    $0x0,%eax
            vmm_alloc_addr(dest + offset, 0);
  106666:	8b 4d a0             	mov    -0x60(%ebp),%ecx
  106669:	03 4d 98             	add    -0x68(%ebp),%ecx
  10666c:	89 0c 24             	mov    %ecx,(%esp)
  10666f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  106676:	00 
  106677:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  10667d:	e8 6e 14 00 00       	call   107af0 <vmm_alloc_addr>
  106682:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
        /* Nur Program Header vom Typ LOAD laden */
        if (ph->type != 1) {
            continue;
        }

        for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  106688:	8b 45 98             	mov    -0x68(%ebp),%eax
  10668b:	05 00 10 00 00       	add    $0x1000,%eax
  106690:	89 45 98             	mov    %eax,-0x68(%ebp)
  106693:	e9 ac ff ff ff       	jmp    106644 <vfs_exec+0x344>
            vmm_free(dest + offset);
            vmm_alloc_addr(dest + offset, 0);
        }

        memcpy(dest, src, ph->file_size);
  106698:	8b 45 a0             	mov    -0x60(%ebp),%eax
  10669b:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
  10669e:	8b 55 ac             	mov    -0x54(%ebp),%edx
  1066a1:	8b 52 10             	mov    0x10(%edx),%edx
  1066a4:	89 04 24             	mov    %eax,(%esp)
  1066a7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1066ab:	89 54 24 08          	mov    %edx,0x8(%esp)
  1066af:	e8 6c f0 ff ff       	call   105720 <memcpy>

    void* elf_mod_entry = (void*) (header->entry);

    ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);

    for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  1066b4:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1066b7:	05 01 00 00 00       	add    $0x1,%eax
  1066bc:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  1066bf:	8b 45 ac             	mov    -0x54(%ebp),%eax
  1066c2:	05 20 00 00 00       	add    $0x20,%eax
  1066c7:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1066ca:	e9 33 ff ff ff       	jmp    106602 <vfs_exec+0x302>
  1066cf:	b8 01 00 00 00       	mov    $0x1,%eax

        memcpy(dest, src, ph->file_size);
    }

    //Copy args into new task
    char** usargs = vmm_alloc_ucont(1);
  1066d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1066db:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  1066e1:	e8 da 11 00 00       	call   1078c0 <vmm_alloc_ucont>
  1066e6:	89 45 94             	mov    %eax,-0x6c(%ebp)

    for(uint32_t i = 0; i < argc; i++) {
  1066e9:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
  1066f0:	8b 45 90             	mov    -0x70(%ebp),%eax
  1066f3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
  1066f6:	0f 83 65 00 00 00    	jae    106761 <vfs_exec+0x461>
  1066fc:	b8 01 00 00 00       	mov    $0x1,%eax
        usargs[i] = vmm_alloc_ucont(1); //FIXME will fail on strings > 4095 chars or more than 1023 arguments
  106701:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  106708:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  10670e:	e8 ad 11 00 00       	call   1078c0 <vmm_alloc_ucont>
  106713:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  106716:	8b 55 94             	mov    -0x6c(%ebp),%edx
  106719:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
        strcpy(usargs[i], kargs[i]);
  10671c:	8b 45 90             	mov    -0x70(%ebp),%eax
  10671f:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
  106722:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106725:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  106728:	8b 55 cc             	mov    -0x34(%ebp),%edx
  10672b:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  10672e:	89 e2                	mov    %esp,%edx
  106730:	89 4a 04             	mov    %ecx,0x4(%edx)
  106733:	89 02                	mov    %eax,(%edx)
  106735:	e8 46 f2 ff ff       	call   105980 <strcpy>
        free(kargs[i]);
  10673a:	8b 4d 90             	mov    -0x70(%ebp),%ecx
  10673d:	8b 55 cc             	mov    -0x34(%ebp),%edx
  106740:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106743:	89 0c 24             	mov    %ecx,(%esp)
  106746:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
  10674c:	e8 9f ec ff ff       	call   1053f0 <free>
    }

    //Copy args into new task
    char** usargs = vmm_alloc_ucont(1);

    for(uint32_t i = 0; i < argc; i++) {
  106751:	8b 45 90             	mov    -0x70(%ebp),%eax
  106754:	05 01 00 00 00       	add    $0x1,%eax
  106759:	89 45 90             	mov    %eax,-0x70(%ebp)
  10675c:	e9 8f ff ff ff       	jmp    1066f0 <vfs_exec+0x3f0>
        usargs[i] = vmm_alloc_ucont(1); //FIXME will fail on strings > 4095 chars or more than 1023 arguments
        strcpy(usargs[i], kargs[i]);
        free(kargs[i]);
    }

    usargs[argc] = 0;
  106761:	8b 45 d0             	mov    -0x30(%ebp),%eax
  106764:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
  106767:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)
    free(kargs);
  10676e:	8b 45 cc             	mov    -0x34(%ebp),%eax
  106771:	89 04 24             	mov    %eax,(%esp)
  106774:	e8 77 ec ff ff       	call   1053f0 <free>

    struct task* task = init_task(elf_mod_pdir, elf_mod_entry);
  106779:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10677c:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  10677f:	89 04 24             	mov    %eax,(%esp)
  106782:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106786:	e8 05 e0 ff ff       	call   104790 <init_task>
  10678b:	89 45 8c             	mov    %eax,-0x74(%ebp)
    if(get_current_task() != 0) {
  10678e:	e8 fd db ff ff       	call   104390 <get_current_task>
  106793:	3d 00 00 00 00       	cmp    $0x0,%eax
  106798:	0f 84 38 00 00 00    	je     1067d6 <vfs_exec+0x4d6>
        task->stdin = get_current_task()->stdin;
  10679e:	e8 ed db ff ff       	call   104390 <get_current_task>
  1067a3:	8b 40 38             	mov    0x38(%eax),%eax
  1067a6:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1067a9:	89 41 38             	mov    %eax,0x38(%ecx)
        task->stdout = get_current_task()->stdout;
  1067ac:	e8 df db ff ff       	call   104390 <get_current_task>
  1067b1:	8b 40 30             	mov    0x30(%eax),%eax
  1067b4:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1067b7:	89 41 30             	mov    %eax,0x30(%ecx)
        task->stderr = get_current_task()->stderr;
  1067ba:	e8 d1 db ff ff       	call   104390 <get_current_task>
  1067bf:	8b 40 34             	mov    0x34(%eax),%eax
  1067c2:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1067c5:	89 41 34             	mov    %eax,0x34(%ecx)
        task->execPath = get_current_task()->execPath;
  1067c8:	e8 c3 db ff ff       	call   104390 <get_current_task>
  1067cd:	8b 40 28             	mov    0x28(%eax),%eax
  1067d0:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1067d3:	89 41 28             	mov    %eax,0x28(%ecx)
    }

    if(execPath != 0) {
  1067d6:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  1067dd:	0f 84 09 00 00 00    	je     1067ec <vfs_exec+0x4ec>
        task->execPath = execPath;
  1067e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1067e6:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1067e9:	89 41 28             	mov    %eax,0x28(%ecx)
    }

    if(stdin != 0) {
  1067ec:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1067f3:	0f 84 57 00 00 00    	je     106850 <vfs_exec+0x550>
        if(vfs_exists(stdin)) {
  1067f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1067fc:	89 04 24             	mov    %eax,(%esp)
  1067ff:	e8 6c fa ff ff       	call   106270 <vfs_exists>
  106804:	3d 00 00 00 00       	cmp    $0x0,%eax
  106809:	0f 84 3c 00 00 00    	je     10684b <vfs_exec+0x54b>
  10680f:	b8 01 00 00 00       	mov    $0x1,%eax
            struct res_handle* f = vfs_open(stdin, FM_READ);
  106814:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  106817:	89 0c 24             	mov    %ecx,(%esp)
  10681a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  106821:	00 
  106822:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
  106828:	e8 03 f7 ff ff       	call   105f30 <vfs_open>
  10682d:	89 45 88             	mov    %eax,-0x78(%ebp)
            if(f) task->stdin = f;
  106830:	81 7d 88 00 00 00 00 	cmpl   $0x0,-0x78(%ebp)
  106837:	0f 84 09 00 00 00    	je     106846 <vfs_exec+0x546>
  10683d:	8b 45 88             	mov    -0x78(%ebp),%eax
  106840:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  106843:	89 41 38             	mov    %eax,0x38(%ecx)
        }
  106846:	e9 00 00 00 00       	jmp    10684b <vfs_exec+0x54b>
    }
  10684b:	e9 00 00 00 00       	jmp    106850 <vfs_exec+0x550>

    if(stdout != 0) {
  106850:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  106857:	0f 84 57 00 00 00    	je     1068b4 <vfs_exec+0x5b4>
        if(vfs_exists(stdout)) {
  10685d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  106860:	89 04 24             	mov    %eax,(%esp)
  106863:	e8 08 fa ff ff       	call   106270 <vfs_exists>
  106868:	3d 00 00 00 00       	cmp    $0x0,%eax
  10686d:	0f 84 3c 00 00 00    	je     1068af <vfs_exec+0x5af>
  106873:	b8 01 00 00 00       	mov    $0x1,%eax
            struct res_handle* f = vfs_open(stdout, FM_READ);
  106878:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  10687b:	89 0c 24             	mov    %ecx,(%esp)
  10687e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  106885:	00 
  106886:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  10688c:	e8 9f f6 ff ff       	call   105f30 <vfs_open>
  106891:	89 45 84             	mov    %eax,-0x7c(%ebp)
            if(f) task->stdout = f;
  106894:	81 7d 84 00 00 00 00 	cmpl   $0x0,-0x7c(%ebp)
  10689b:	0f 84 09 00 00 00    	je     1068aa <vfs_exec+0x5aa>
  1068a1:	8b 45 84             	mov    -0x7c(%ebp),%eax
  1068a4:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1068a7:	89 41 30             	mov    %eax,0x30(%ecx)
        }
  1068aa:	e9 00 00 00 00       	jmp    1068af <vfs_exec+0x5af>
    }
  1068af:	e9 00 00 00 00       	jmp    1068b4 <vfs_exec+0x5b4>

    if(stderr != 0) {
  1068b4:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  1068bb:	0f 84 57 00 00 00    	je     106918 <vfs_exec+0x618>
        if(vfs_exists(stderr)) {
  1068c1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1068c4:	89 04 24             	mov    %eax,(%esp)
  1068c7:	e8 a4 f9 ff ff       	call   106270 <vfs_exists>
  1068cc:	3d 00 00 00 00       	cmp    $0x0,%eax
  1068d1:	0f 84 3c 00 00 00    	je     106913 <vfs_exec+0x613>
  1068d7:	b8 01 00 00 00       	mov    $0x1,%eax
            struct res_handle* f = vfs_open(stderr, FM_READ);
  1068dc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1068df:	89 0c 24             	mov    %ecx,(%esp)
  1068e2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1068e9:	00 
  1068ea:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
  1068f0:	e8 3b f6 ff ff       	call   105f30 <vfs_open>
  1068f5:	89 45 80             	mov    %eax,-0x80(%ebp)
            if(f) task->stderr = f;
  1068f8:	81 7d 80 00 00 00 00 	cmpl   $0x0,-0x80(%ebp)
  1068ff:	0f 84 09 00 00 00    	je     10690e <vfs_exec+0x60e>
  106905:	8b 45 80             	mov    -0x80(%ebp),%eax
  106908:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  10690b:	89 41 34             	mov    %eax,0x34(%ecx)
        }
  10690e:	e9 00 00 00 00       	jmp    106913 <vfs_exec+0x613>
    }
  106913:	e9 00 00 00 00       	jmp    106918 <vfs_exec+0x618>


    //TODO change stdio if requested and free kargs

    task->args = usargs;
  106918:	8b 45 94             	mov    -0x6c(%ebp),%eax
  10691b:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  10691e:	89 41 20             	mov    %eax,0x20(%ecx)
    task->filePath = path;
  106921:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106924:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  106927:	89 41 24             	mov    %eax,0x24(%ecx)

    vmm_activate_pagedir(old_pdir);
  10692a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  10692d:	89 04 24             	mov    %eax,(%esp)
  106930:	e8 bb 12 00 00       	call   107bf0 <vmm_activate_pagedir>

    free(modsrc);
  106935:	8b 45 bc             	mov    -0x44(%ebp),%eax
  106938:	89 04 24             	mov    %eax,(%esp)
  10693b:	e8 b0 ea ff ff       	call   1053f0 <free>

    return task->PID;
  106940:	8b 45 8c             	mov    -0x74(%ebp),%eax
  106943:	8b 00                	mov    (%eax),%eax
  106945:	89 45 f0             	mov    %eax,-0x10(%ebp)
}
  106948:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10694b:	81 c4 cc 00 00 00    	add    $0xcc,%esp
  106951:	5e                   	pop    %esi
  106952:	5f                   	pop    %edi
  106953:	5b                   	pop    %ebx
  106954:	5d                   	pop    %ebp
  106955:	c3                   	ret    
  106956:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10695d:	00 00 00 

00106960 <vfs_set_error>:

struct res_node* root = 0;
struct res_node* current = 0;
struct res_node* temp = 0;

static void vfs_set_error(uint32_t code) {
  106960:	55                   	push   %ebp
  106961:	89 e5                	mov    %esp,%ebp
  106963:	83 ec 08             	sub    $0x8,%esp
  106966:	8b 45 08             	mov    0x8(%ebp),%eax
  106969:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(get_current_task()) {
  10696c:	e8 1f da ff ff       	call   104390 <get_current_task>
  106971:	3d 00 00 00 00       	cmp    $0x0,%eax
  106976:	0f 84 28 00 00 00    	je     1069a4 <vfs_set_error+0x44>
        if(get_current_task()->vfserr == PE_NO_ERROR) {
  10697c:	e8 0f da ff ff       	call   104390 <get_current_task>
  106981:	81 78 2c 00 00 00 00 	cmpl   $0x0,0x2c(%eax)
  106988:	0f 85 11 00 00 00    	jne    10699f <vfs_set_error+0x3f>
            get_current_task()->vfserr = code;
  10698e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106991:	89 45 f8             	mov    %eax,-0x8(%ebp)
  106994:	e8 f7 d9 ff ff       	call   104390 <get_current_task>
  106999:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10699c:	89 48 2c             	mov    %ecx,0x2c(%eax)
        }
    }
  10699f:	e9 00 00 00 00       	jmp    1069a4 <vfs_set_error+0x44>
}
  1069a4:	83 c4 08             	add    $0x8,%esp
  1069a7:	5d                   	pop    %ebp
  1069a8:	c3                   	ret    
  1069a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

001069b0 <vfs_resolve_path>:
    free(modsrc);

    return task->PID;
}

char* vfs_resolve_path(char* path) {
  1069b0:	55                   	push   %ebp
  1069b1:	89 e5                	mov    %esp,%ebp
  1069b3:	83 ec 18             	sub    $0x18,%esp
  1069b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1069b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_node* node = vfs_get_node(path);
  1069bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1069bf:	89 04 24             	mov    %eax,(%esp)
  1069c2:	e8 39 f5 ff ff       	call   105f00 <vfs_get_node>
  1069c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(node == 0) return 0;
  1069ca:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1069d1:	0f 85 0c 00 00 00    	jne    1069e3 <vfs_resolve_path+0x33>
  1069d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1069de:	e9 0e 00 00 00       	jmp    1069f1 <vfs_resolve_path+0x41>
    return vfs_construct_absolute_path_for_node(node);
  1069e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1069e6:	89 04 24             	mov    %eax,(%esp)
  1069e9:	e8 12 00 00 00       	call   106a00 <vfs_construct_absolute_path_for_node>
  1069ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1069f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1069f4:	83 c4 18             	add    $0x18,%esp
  1069f7:	5d                   	pop    %ebp
  1069f8:	c3                   	ret    
  1069f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00106a00 <vfs_construct_absolute_path_for_node>:
    }
}

char capfn_buf[513];

static char* vfs_construct_absolute_path_for_node(struct res_node* node) {
  106a00:	55                   	push   %ebp
  106a01:	89 e5                	mov    %esp,%ebp
  106a03:	83 ec 18             	sub    $0x18,%esp
  106a06:	8b 45 08             	mov    0x8(%ebp),%eax
  106a09:	8d 0d a0 a9 18 00    	lea    0x18a9a0,%ecx
  106a0f:	81 c1 ff 01 00 00    	add    $0x1ff,%ecx
  106a15:	89 45 fc             	mov    %eax,-0x4(%ebp)
    capfn_buf[512] = '\0';
  106a18:	c6 05 a0 ab 18 00 00 	movb   $0x0,0x18aba0
    char* out =  &(capfn_buf[511]);
  106a1f:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    *out = '/';
  106a22:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106a25:	c6 00 2f             	movb   $0x2f,(%eax)

    while(node != root) {
  106a28:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106a2b:	3b 05 54 a5 10 00    	cmp    0x10a554,%eax
  106a31:	0f 84 59 00 00 00    	je     106a90 <vfs_construct_absolute_path_for_node+0x90>
  106a37:	b8 00 00 00 00       	mov    $0x0,%eax
        out -= strlen(node->name);
  106a3c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  106a3f:	89 e2                	mov    %esp,%edx
  106a41:	89 0a                	mov    %ecx,(%edx)
  106a43:	89 45 f4             	mov    %eax,-0xc(%ebp)
  106a46:	e8 c5 ee ff ff       	call   105910 <strlen>
  106a4b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106a4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
  106a51:	29 c2                	sub    %eax,%edx
  106a53:	01 d1                	add    %edx,%ecx
  106a55:	89 4d f8             	mov    %ecx,-0x8(%ebp)
        strcpy(out, node->name);
  106a58:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106a5b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  106a5e:	89 e2                	mov    %esp,%edx
  106a60:	89 4a 04             	mov    %ecx,0x4(%edx)
  106a63:	89 02                	mov    %eax,(%edx)
  106a65:	e8 16 ef ff ff       	call   105980 <strcpy>
        *--out = '/';
  106a6a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106a6d:	89 ca                	mov    %ecx,%edx
  106a6f:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
  106a75:	89 55 f8             	mov    %edx,-0x8(%ebp)
  106a78:	c6 41 ff 2f          	movb   $0x2f,-0x1(%ecx)

        node = node->parent;
  106a7c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  106a7f:	8b 89 0c 01 00 00    	mov    0x10c(%ecx),%ecx
  106a85:	89 4d fc             	mov    %ecx,-0x4(%ebp)
    }
  106a88:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106a8b:	e9 98 ff ff ff       	jmp    106a28 <vfs_construct_absolute_path_for_node+0x28>

    return strclone(out);
  106a90:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106a93:	89 04 24             	mov    %eax,(%esp)
  106a96:	e8 45 ef ff ff       	call   1059e0 <strclone>
  106a9b:	83 c4 18             	add    $0x18,%esp
  106a9e:	5d                   	pop    %ebp
  106a9f:	c3                   	ret    

00106aa0 <vfs_init_root>:
    struct res_node* node = vfs_get_node(path);
    if(node == 0) return 0;
    return vfs_construct_absolute_path_for_node(node);
}

void vfs_init_root() {
  106aa0:	55                   	push   %ebp
  106aa1:	89 e5                	mov    %esp,%ebp
    if(root == 0) {
  106aa3:	83 ec 18             	sub    $0x18,%esp
  106aa6:	81 3d 54 a5 10 00 00 	cmpl   $0x0,0x10a554
  106aad:	00 00 00 
  106ab0:	0f 85 6f 00 00 00    	jne    106b25 <vfs_init_root+0x85>
  106ab6:	b8 10 01 00 00       	mov    $0x110,%eax
        root = malloc(sizeof(struct res_node));
  106abb:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  106ac2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106ac5:	e8 26 e5 ff ff       	call   104ff0 <malloc>
  106aca:	a3 54 a5 10 00       	mov    %eax,0x10a554
        root->next = 0;
  106acf:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106ad4:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  106adb:	00 00 00 
        root->parent = 0;
  106ade:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106ae3:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  106aea:	00 00 00 
        strcpy(root->name, "$");
  106aed:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106af2:	89 e1                	mov    %esp,%ecx
  106af4:	89 01                	mov    %eax,(%ecx)
  106af6:	c7 41 04 6e 96 10 00 	movl   $0x10966e,0x4(%ecx)
  106afd:	e8 7e ee ff ff       	call   105980 <strcpy>
        root->res_ptr = 0;
  106b02:	8b 0d 54 a5 10 00    	mov    0x10a554,%ecx
  106b08:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  106b0f:	00 00 00 
        root->res_type = RES_SUBDIR;
  106b12:	8b 0d 54 a5 10 00    	mov    0x10a554,%ecx
  106b18:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  106b1f:	00 00 00 
  106b22:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  106b25:	83 c4 18             	add    $0x18,%esp
  106b28:	5d                   	pop    %ebp
  106b29:	c3                   	ret    
  106b2a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00106b30 <vfs_debug_ls>:

void vfs_debug_ls(char* path) {
  106b30:	55                   	push   %ebp
  106b31:	89 e5                	mov    %esp,%ebp
  106b33:	56                   	push   %esi
  106b34:	83 ec 24             	sub    $0x24,%esp
  106b37:	8b 45 08             	mov    0x8(%ebp),%eax
  106b3a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    static struct res_node* node;
    node = vfs_get_node(path);
  106b3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106b40:	89 04 24             	mov    %eax,(%esp)
  106b43:	e8 b8 f3 ff ff       	call   105f00 <vfs_get_node>
  106b48:	a3 68 a5 10 00       	mov    %eax,0x10a568
    node = node->res_ptr;
  106b4d:	a1 68 a5 10 00       	mov    0x10a568,%eax
  106b52:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  106b58:	a3 68 a5 10 00       	mov    %eax,0x10a568

    while(node != 0) {
  106b5d:	81 3d 68 a5 10 00 00 	cmpl   $0x0,0x10a568
  106b64:	00 00 00 
  106b67:	0f 84 90 00 00 00    	je     106bfd <vfs_debug_ls+0xcd>
  106b6d:	8d 05 70 96 10 00    	lea    0x109670,%eax
        char* type = "N/A";
  106b73:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(node->res_type == RES_SUBDIR) {
  106b76:	a1 68 a5 10 00       	mov    0x10a568,%eax
  106b7b:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  106b82:	00 00 00 
  106b85:	0f 85 09 00 00 00    	jne    106b94 <vfs_debug_ls+0x64>
  106b8b:	8d 05 74 96 10 00    	lea    0x109674,%eax
            type = "DIR";
  106b91:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        if(node->res_type == RES_KERNDRV) {
  106b94:	a1 68 a5 10 00       	mov    0x10a568,%eax
  106b99:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  106ba0:	00 00 00 
  106ba3:	0f 85 14 00 00 00    	jne    106bbd <vfs_debug_ls+0x8d>
            type = ((struct res_kfile*)node->res_ptr)->driver->drvname;
  106ba9:	a1 68 a5 10 00       	mov    0x10a568,%eax
  106bae:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  106bb4:	8b 40 04             	mov    0x4(%eax),%eax
  106bb7:	8b 40 18             	mov    0x18(%eax),%eax
  106bba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  106bbd:	8d 05 78 96 10 00    	lea    0x109678,%eax
        }

        kprintf("LS %s: %s [%s]\n", path, node->name, type);
  106bc3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106bc6:	8b 15 68 a5 10 00    	mov    0x10a568,%edx
  106bcc:	8b 75 f4             	mov    -0xc(%ebp),%esi
  106bcf:	89 04 24             	mov    %eax,(%esp)
  106bd2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106bd6:	89 54 24 08          	mov    %edx,0x8(%esp)
  106bda:	89 74 24 0c          	mov    %esi,0xc(%esp)
  106bde:	e8 cd 96 ff ff       	call   1002b0 <kprintf>

        node = node->next;
  106be3:	8b 0d 68 a5 10 00    	mov    0x10a568,%ecx
  106be9:	8b 89 08 01 00 00    	mov    0x108(%ecx),%ecx
  106bef:	89 0d 68 a5 10 00    	mov    %ecx,0x10a568
    }
  106bf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106bf8:	e9 60 ff ff ff       	jmp    106b5d <vfs_debug_ls+0x2d>
}
  106bfd:	83 c4 24             	add    $0x24,%esp
  106c00:	5e                   	pop    %esi
  106c01:	5d                   	pop    %ebp
  106c02:	c3                   	ret    
  106c03:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  106c0a:	84 00 00 00 00 00 

00106c10 <vfs_get_relative_node>:

    return 1;
}


static struct res_node* vfs_get_relative_node(struct res_node* parent, char* path) {
  106c10:	55                   	push   %ebp
  106c11:	89 e5                	mov    %esp,%ebp
  106c13:	83 ec 38             	sub    $0x38,%esp
  106c16:	8b 45 0c             	mov    0xc(%ebp),%eax
  106c19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106c1c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  106c1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* sub;
    struct res_node* child = 0;
  106c22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    if(path == 0) {
  106c29:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  106c30:	0f 85 20 00 00 00    	jne    106c56 <vfs_get_relative_node+0x46>
  106c36:	b8 05 00 00 00       	mov    $0x5,%eax
        vfs_set_error(PE_INVALID);
  106c3b:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  106c42:	89 45 e8             	mov    %eax,-0x18(%ebp)
  106c45:	e8 16 fd ff ff       	call   106960 <vfs_set_error>
        return 0;
  106c4a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106c51:	e9 1d 01 00 00       	jmp    106d73 <vfs_get_relative_node+0x163>
    }

    if(path[0] == 0) {
  106c56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106c59:	0f be 00             	movsbl (%eax),%eax
  106c5c:	3d 00 00 00 00       	cmp    $0x0,%eax
  106c61:	0f 85 20 00 00 00    	jne    106c87 <vfs_get_relative_node+0x77>
  106c67:	b8 05 00 00 00       	mov    $0x5,%eax
        vfs_set_error(PE_INVALID);
  106c6c:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  106c73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106c76:	e8 e5 fc ff ff       	call   106960 <vfs_set_error>
        return 0;
  106c7b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106c82:	e9 ec 00 00 00       	jmp    106d73 <vfs_get_relative_node+0x163>
  106c87:	8d 05 88 96 10 00    	lea    0x109688,%eax
    }

    sub = strtok(path, "/");
  106c8d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106c90:	89 0c 24             	mov    %ecx,(%esp)
  106c93:	89 44 24 04          	mov    %eax,0x4(%esp)
  106c97:	e8 94 ed ff ff       	call   105a30 <strtok>
  106c9c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(sub == NULL) {
  106c9f:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  106ca6:	0f 85 0b 00 00 00    	jne    106cb7 <vfs_get_relative_node+0xa7>
        return parent;
  106cac:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106caf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106cb2:	e9 bc 00 00 00       	jmp    106d73 <vfs_get_relative_node+0x163>
    }

    if(sub[0] == 0) sub = strtok(0, "/");
  106cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106cba:	0f be 00             	movsbl (%eax),%eax
  106cbd:	3d 00 00 00 00       	cmp    $0x0,%eax
  106cc2:	0f 85 21 00 00 00    	jne    106ce9 <vfs_get_relative_node+0xd9>
  106cc8:	b8 00 00 00 00       	mov    $0x0,%eax
  106ccd:	8d 0d 88 96 10 00    	lea    0x109688,%ecx
  106cd3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106cda:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106cde:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106ce1:	e8 4a ed ff ff       	call   105a30 <strtok>
  106ce6:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(sub == NULL) {
  106ce9:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  106cf0:	0f 85 0b 00 00 00    	jne    106d01 <vfs_get_relative_node+0xf1>
        return parent;
  106cf6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106cf9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106cfc:	e9 72 00 00 00       	jmp    106d73 <vfs_get_relative_node+0x163>
    }

    while (sub != NULL)
  106d01:	e9 00 00 00 00       	jmp    106d06 <vfs_get_relative_node+0xf6>
  106d06:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  106d0d:	0f 84 5a 00 00 00    	je     106d6d <vfs_get_relative_node+0x15d>
    {
        if(parent == 0) return 0;
  106d13:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  106d1a:	0f 85 0c 00 00 00    	jne    106d2c <vfs_get_relative_node+0x11c>
  106d20:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106d27:	e9 47 00 00 00       	jmp    106d73 <vfs_get_relative_node+0x163>

        child = vfs_find_node(parent, sub);
  106d2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106d2f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106d32:	89 04 24             	mov    %eax,(%esp)
  106d35:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106d39:	e8 12 01 00 00       	call   106e50 <vfs_find_node>
  106d3e:	b9 00 00 00 00       	mov    $0x0,%ecx
  106d43:	8d 15 88 96 10 00    	lea    0x109688,%edx
  106d49:	89 45 ec             	mov    %eax,-0x14(%ebp)
        parent = child;
  106d4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106d4f:	89 45 f8             	mov    %eax,-0x8(%ebp)

        sub = strtok(0, "/");
  106d52:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  106d59:	89 54 24 04          	mov    %edx,0x4(%esp)
  106d5d:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  106d60:	e8 cb ec ff ff       	call   105a30 <strtok>
  106d65:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  106d68:	e9 99 ff ff ff       	jmp    106d06 <vfs_get_relative_node+0xf6>

    return child;
  106d6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106d70:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  106d73:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106d76:	83 c4 38             	add    $0x38,%esp
  106d79:	5d                   	pop    %ebp
  106d7a:	c3                   	ret    
  106d7b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00106d80 <vfs_get_current_task_root_node_for_path>:

static struct res_node* vfs_get_current_task_root_node_for_path(char* path) {
  106d80:	55                   	push   %ebp
  106d81:	89 e5                	mov    %esp,%ebp
  106d83:	83 ec 18             	sub    $0x18,%esp
  106d86:	8b 45 08             	mov    0x8(%ebp),%eax
  106d89:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(path == 0 || path[0] == '\0') {
  106d8c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  106d93:	0f 84 11 00 00 00    	je     106daa <vfs_get_current_task_root_node_for_path+0x2a>
  106d99:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106d9c:	0f be 00             	movsbl (%eax),%eax
  106d9f:	3d 00 00 00 00       	cmp    $0x0,%eax
  106da4:	0f 85 20 00 00 00    	jne    106dca <vfs_get_current_task_root_node_for_path+0x4a>
  106daa:	b8 05 00 00 00       	mov    $0x5,%eax
        vfs_set_error(PE_INVALID);
  106daf:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  106db6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  106db9:	e8 a2 fb ff ff       	call   106960 <vfs_set_error>
        return 0;
  106dbe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  106dc5:	e9 7c 00 00 00       	jmp    106e46 <vfs_get_current_task_root_node_for_path+0xc6>
    }

    if(path[0] == '/') return root;
  106dca:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106dcd:	0f be 00             	movsbl (%eax),%eax
  106dd0:	3d 2f 00 00 00       	cmp    $0x2f,%eax
  106dd5:	0f 85 0d 00 00 00    	jne    106de8 <vfs_get_current_task_root_node_for_path+0x68>
  106ddb:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106de0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106de3:	e9 5e 00 00 00       	jmp    106e46 <vfs_get_current_task_root_node_for_path+0xc6>
    if(get_current_task() == 0) return root;
  106de8:	e8 a3 d5 ff ff       	call   104390 <get_current_task>
  106ded:	3d 00 00 00 00       	cmp    $0x0,%eax
  106df2:	0f 85 0d 00 00 00    	jne    106e05 <vfs_get_current_task_root_node_for_path+0x85>
  106df8:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106dfd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106e00:	e9 41 00 00 00       	jmp    106e46 <vfs_get_current_task_root_node_for_path+0xc6>
    if(get_current_task()->execPath == 0) return root;
  106e05:	e8 86 d5 ff ff       	call   104390 <get_current_task>
  106e0a:	81 78 28 00 00 00 00 	cmpl   $0x0,0x28(%eax)
  106e11:	0f 85 0d 00 00 00    	jne    106e24 <vfs_get_current_task_root_node_for_path+0xa4>
  106e17:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106e1c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106e1f:	e9 22 00 00 00       	jmp    106e46 <vfs_get_current_task_root_node_for_path+0xc6>

    return vfs_get_relative_node(root, get_current_task()->execPath);
  106e24:	a1 54 a5 10 00       	mov    0x10a554,%eax
  106e29:	89 45 f0             	mov    %eax,-0x10(%ebp)
  106e2c:	e8 5f d5 ff ff       	call   104390 <get_current_task>
  106e31:	8b 40 28             	mov    0x28(%eax),%eax
  106e34:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106e37:	89 0c 24             	mov    %ecx,(%esp)
  106e3a:	89 44 24 04          	mov    %eax,0x4(%esp)
  106e3e:	e8 cd fd ff ff       	call   106c10 <vfs_get_relative_node>
  106e43:	89 45 fc             	mov    %eax,-0x4(%ebp)

}
  106e46:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106e49:	83 c4 18             	add    $0x18,%esp
  106e4c:	5d                   	pop    %ebp
  106e4d:	c3                   	ret    
  106e4e:	66 90                	xchg   %ax,%ax

00106e50 <vfs_find_node>:
    }

    return strclone(out);
}

static struct res_node* vfs_find_node(struct res_node* parent, char* name) {
  106e50:	55                   	push   %ebp
  106e51:	89 e5                	mov    %esp,%ebp
  106e53:	83 ec 18             	sub    $0x18,%esp
  106e56:	8b 45 0c             	mov    0xc(%ebp),%eax
  106e59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106e5c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  106e5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(name == 0) return parent;
  106e62:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  106e69:	0f 85 0b 00 00 00    	jne    106e7a <vfs_find_node+0x2a>
  106e6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106e72:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106e75:	e9 ff 00 00 00       	jmp    106f79 <vfs_find_node+0x129>
    if(name[0] == '\0') return parent;
  106e7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106e7d:	0f be 00             	movsbl (%eax),%eax
  106e80:	3d 00 00 00 00       	cmp    $0x0,%eax
  106e85:	0f 85 0b 00 00 00    	jne    106e96 <vfs_find_node+0x46>
  106e8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106e8e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106e91:	e9 e3 00 00 00       	jmp    106f79 <vfs_find_node+0x129>

    if(!strcmp(name, ".")) return parent;
  106e96:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106e99:	89 e1                	mov    %esp,%ecx
  106e9b:	89 01                	mov    %eax,(%ecx)
  106e9d:	c7 41 04 dd 92 10 00 	movl   $0x1092dd,0x4(%ecx)
  106ea4:	e8 e7 e9 ff ff       	call   105890 <strcmp>
  106ea9:	3d 00 00 00 00       	cmp    $0x0,%eax
  106eae:	0f 85 0b 00 00 00    	jne    106ebf <vfs_find_node+0x6f>
  106eb4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106eb7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106eba:	e9 ba 00 00 00       	jmp    106f79 <vfs_find_node+0x129>
    if(!strcmp(name, "..")) {
  106ebf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106ec2:	89 e1                	mov    %esp,%ecx
  106ec4:	89 01                	mov    %eax,(%ecx)
  106ec6:	c7 41 04 dc 92 10 00 	movl   $0x1092dc,0x4(%ecx)
  106ecd:	e8 be e9 ff ff       	call   105890 <strcmp>
  106ed2:	3d 00 00 00 00       	cmp    $0x0,%eax
  106ed7:	0f 85 2b 00 00 00    	jne    106f08 <vfs_find_node+0xb8>
        if(parent == root) return parent;
  106edd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106ee0:	3b 05 54 a5 10 00    	cmp    0x10a554,%eax
  106ee6:	0f 85 0b 00 00 00    	jne    106ef7 <vfs_find_node+0xa7>
  106eec:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106eef:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106ef2:	e9 82 00 00 00       	jmp    106f79 <vfs_find_node+0x129>
        return parent->parent;
  106ef7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106efa:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  106f00:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106f03:	e9 71 00 00 00       	jmp    106f79 <vfs_find_node+0x129>
    }

    if(parent->res_type == RES_SUBDIR) {
  106f08:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106f0b:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  106f12:	00 00 00 
  106f15:	0f 85 57 00 00 00    	jne    106f72 <vfs_find_node+0x122>
        struct res_node* ptr = parent->res_ptr;
  106f1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106f1e:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  106f24:	89 45 f0             	mov    %eax,-0x10(%ebp)

        while(ptr != 0) {
  106f27:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  106f2e:	0f 84 39 00 00 00    	je     106f6d <vfs_find_node+0x11d>
            if(strcmp(name, ptr->name) == 0) {
  106f34:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106f37:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106f3a:	89 e2                	mov    %esp,%edx
  106f3c:	89 4a 04             	mov    %ecx,0x4(%edx)
  106f3f:	89 02                	mov    %eax,(%edx)
  106f41:	e8 4a e9 ff ff       	call   105890 <strcmp>
  106f46:	3d 00 00 00 00       	cmp    $0x0,%eax
  106f4b:	0f 85 0b 00 00 00    	jne    106f5c <vfs_find_node+0x10c>
                return ptr;
  106f51:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106f54:	89 45 fc             	mov    %eax,-0x4(%ebp)
  106f57:	e9 1d 00 00 00       	jmp    106f79 <vfs_find_node+0x129>
            }

            ptr = ptr->next;
  106f5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106f5f:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  106f65:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
  106f68:	e9 ba ff ff ff       	jmp    106f27 <vfs_find_node+0xd7>
    }
  106f6d:	e9 00 00 00 00       	jmp    106f72 <vfs_find_node+0x122>

    return 0;
  106f72:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  106f79:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106f7c:	83 c4 18             	add    $0x18,%esp
  106f7f:	5d                   	pop    %ebp
  106f80:	c3                   	ret    
  106f81:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  106f88:	0f 1f 84 00 00 00 00 
  106f8f:	00 

00106f90 <vfs_insert_node>:

static int vfs_insert_node(struct res_node* parent, struct res_node* child) {
  106f90:	55                   	push   %ebp
  106f91:	89 e5                	mov    %esp,%ebp
  106f93:	83 ec 0c             	sub    $0xc,%esp
  106f96:	8b 45 0c             	mov    0xc(%ebp),%eax
  106f99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106f9c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  106f9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_ptr == 0) {
  106fa2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106fa5:	81 b8 04 01 00 00 00 	cmpl   $0x0,0x104(%eax)
  106fac:	00 00 00 
  106faf:	0f 85 0d 00 00 00    	jne    106fc2 <vfs_insert_node+0x32>
        parent->res_type = RES_SUBDIR;
  106fb5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106fb8:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  106fbf:	00 00 00 
    }

    if(parent->res_type == RES_SUBDIR) {
  106fc2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106fc5:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  106fcc:	00 00 00 
  106fcf:	0f 85 36 00 00 00    	jne    10700b <vfs_insert_node+0x7b>
        child->next = parent->res_ptr;
  106fd5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106fd8:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  106fde:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106fe1:	89 81 08 01 00 00    	mov    %eax,0x108(%ecx)
        child->parent = parent;
  106fe7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106fea:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106fed:	89 81 0c 01 00 00    	mov    %eax,0x10c(%ecx)
        parent->res_ptr = child;
  106ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106ff6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106ff9:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)

        return 0;
  106fff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  107006:	e9 07 00 00 00       	jmp    107012 <vfs_insert_node+0x82>
    }

    return 1;
  10700b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
}
  107012:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107015:	83 c4 0c             	add    $0xc,%esp
  107018:	5d                   	pop    %ebp
  107019:	c3                   	ret    
  10701a:	66 90                	xchg   %ax,%ax
  10701c:	66 90                	xchg   %ax,%ax
  10701e:	66 90                	xchg   %ax,%ax

00107020 <vmm_get_current_pagedir>:
	}

	vmm_unmap(pagedir_ptr);
}

uint32_t vmm_get_current_pagedir(void) {
  107020:	55                   	push   %ebp
  107021:	89 e5                	mov    %esp,%ebp
	return active_pagedir;
  107023:	a1 6c a5 10 00       	mov    0x10a56c,%eax
  107028:	5d                   	pop    %ebp
  107029:	c3                   	ret    
  10702a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00107030 <vmm_create_pagedir>:
}

uint32_t vmm_create_pagedir() {
  107030:	55                   	push   %ebp
  107031:	89 e5                	mov    %esp,%ebp
  107033:	83 ec 18             	sub    $0x18,%esp
  107036:	8d 45 fc             	lea    -0x4(%ebp),%eax
	uint32_t phys_pagedir;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  107039:	89 04 24             	mov    %eax,(%esp)
  10703c:	e8 1f 00 00 00       	call   107060 <vmm_create_vpdraw>
  107041:	89 45 f8             	mov    %eax,-0x8(%ebp)
	vmm_free_pdptr(pdptr);
  107044:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107047:	89 04 24             	mov    %eax,(%esp)
  10704a:	e8 d1 02 00 00       	call   107320 <vmm_free_pdptr>

	return phys_pagedir;
  10704f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107052:	83 c4 18             	add    $0x18,%esp
  107055:	5d                   	pop    %ebp
  107056:	c3                   	ret    
  107057:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10705e:	00 00 

00107060 <vmm_create_vpdraw>:
uint32_t* active_pagetables = (uint32_t*) (ACTIVE_PAGETBL_VADDR);
struct vmm_context* active_context = (void*) (ACTIVE_CONTEXT_VADDR);

uint32_t active_pagedir = 0;

static uint32_t* vmm_create_vpdraw(uint32_t* pagedir) {
  107060:	55                   	push   %ebp
  107061:	89 e5                	mov    %esp,%ebp
  107063:	53                   	push   %ebx
  107064:	57                   	push   %edi
  107065:	56                   	push   %esi
  107066:	83 ec 4c             	sub    $0x4c,%esp
  107069:	8b 45 08             	mov    0x8(%ebp),%eax
  10706c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  10706f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t phys_context = 0;
  107072:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct vmm_context* context = vmm_alloc(&phys_context);
  107079:	89 0c 24             	mov    %ecx,(%esp)
  10707c:	e8 6f 04 00 00       	call   1074f0 <vmm_alloc>
  107081:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  107084:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32_t phys_pagedir = 0;
  107087:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	context->pagedir = vmm_alloc(&phys_pagedir);
  10708e:	89 0c 24             	mov    %ecx,(%esp)
  107091:	e8 5a 04 00 00       	call   1074f0 <vmm_alloc>
  107096:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  107099:	89 01                	mov    %eax,(%ecx)
	if (pagedir != 0)
  10709b:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1070a2:	0f 84 08 00 00 00    	je     1070b0 <vmm_create_vpdraw+0x50>
		*pagedir = phys_pagedir;
  1070a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1070ab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1070ae:	89 01                	mov    %eax,(%ecx)
  1070b0:	b8 00 00 00 00       	mov    $0x0,%eax

	uint32_t* pagedir_ptr = vmm_alloc(0);
  1070b5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1070bc:	89 45 c8             	mov    %eax,-0x38(%ebp)
  1070bf:	e8 2c 04 00 00       	call   1074f0 <vmm_alloc>
  1070c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  1070c7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  1070ce:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  1070d5:	0f 83 25 01 00 00    	jae    107200 <vmm_create_vpdraw+0x1a0>
  1070db:	8d 45 dc             	lea    -0x24(%ebp),%eax
		pagedir_ptr[i] = (uint32_t) vmm_alloc(&paddr);
  1070de:	89 04 24             	mov    %eax,(%esp)
  1070e1:	e8 0a 04 00 00       	call   1074f0 <vmm_alloc>
  1070e6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1070e9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1070ec:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i < PMEM_TABLES) {
  1070ef:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  1070f6:	0f 83 4d 00 00 00    	jae    107149 <vmm_create_vpdraw+0xe9>
			vmm_free((void*) (pagedir_ptr[i]));
  1070fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1070ff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  107102:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107105:	89 04 24             	mov    %eax,(%esp)
  107108:	e8 33 04 00 00       	call   107540 <vmm_free>
  10710d:	b8 00 00 00 00       	mov    $0x0,%eax
			map_address_active(pagedir_ptr[i], kernel_pagetables[i], 0); //Can reuse pagedir_ptr[i] cause of vmm_free
  107112:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  107115:	8b 55 e0             	mov    -0x20(%ebp),%edx
  107118:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  10711b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10711e:	8b 14 95 a4 ab 18 00 	mov    0x18aba4(,%edx,4),%edx
  107125:	89 0c 24             	mov    %ecx,(%esp)
  107128:	89 54 24 04          	mov    %edx,0x4(%esp)
  10712c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107133:	00 
  107134:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  107137:	e8 84 04 00 00       	call   1075c0 <map_address_active>
			paddr = kernel_pagetables[i];
  10713c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10713f:	8b 04 85 a4 ab 18 00 	mov    0x18aba4(,%eax,4),%eax
  107146:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;
  107149:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10714c:	0d 01 00 00 00       	or     $0x1,%eax
  107151:	0d 02 00 00 00       	or     $0x2,%eax
  107156:	0d 04 00 00 00       	or     $0x4,%eax
  10715b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10715e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  107161:	8b 12                	mov    (%edx),%edx
  107163:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
  107166:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  10716d:	0f 82 78 00 00 00    	jb     1071eb <vmm_create_vpdraw+0x18b>
			for (i2 = 0; i2 < 1024; i2++) {
  107173:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  10717a:	81 7d d4 00 04 00 00 	cmpl   $0x400,-0x2c(%ebp)
  107181:	0f 83 5f 00 00 00    	jae    1071e6 <vmm_create_vpdraw+0x186>
  107187:	b8 04 00 00 00       	mov    $0x4,%eax
  10718c:	b9 00 00 00 00       	mov    $0x0,%ecx
  107191:	ba 00 02 00 00       	mov    $0x200,%edx
				uint32_t vaddr = (i << 22) + (i2 << 12);
  107196:	8b 75 d8             	mov    -0x28(%ebp),%esi
  107199:	c1 e6 16             	shl    $0x16,%esi
  10719c:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  10719f:	c1 e7 0c             	shl    $0xc,%edi
  1071a2:	01 fe                	add    %edi,%esi
  1071a4:	89 75 d0             	mov    %esi,-0x30(%ebp)

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
  1071a7:	81 7d d0 00 10 40 01 	cmpl   $0x1401000,-0x30(%ebp)
  1071ae:	0f 97 c3             	seta   %bl
  1071b1:	84 db                	test   %bl,%bl
  1071b3:	0f 44 d1             	cmove  %ecx,%edx
  1071b6:	81 7d d0 00 10 40 01 	cmpl   $0x1401000,-0x30(%ebp)
  1071bd:	0f 97 c3             	seta   %bl
  1071c0:	84 db                	test   %bl,%bl
  1071c2:	0f 44 c1             	cmove  %ecx,%eax
  1071c5:	09 c2                	or     %eax,%edx
  1071c7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1071ca:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1071cd:	8b 75 e0             	mov    -0x20(%ebp),%esi
  1071d0:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  1071d3:	89 14 81             	mov    %edx,(%ecx,%eax,4)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
			for (i2 = 0; i2 < 1024; i2++) {
  1071d6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1071d9:	05 01 00 00 00       	add    $0x1,%eax
  1071de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1071e1:	e9 94 ff ff ff       	jmp    10717a <vmm_create_vpdraw+0x11a>

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
						(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
  1071e6:	e9 00 00 00 00       	jmp    1071eb <vmm_create_vpdraw+0x18b>
	}
  1071eb:	e9 00 00 00 00       	jmp    1071f0 <vmm_create_vpdraw+0x190>
		*pagedir = phys_pagedir;

	uint32_t* pagedir_ptr = vmm_alloc(0);
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  1071f0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1071f3:	05 01 00 00 00       	add    $0x1,%eax
  1071f8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1071fb:	e9 ce fe ff ff       	jmp    1070ce <vmm_create_vpdraw+0x6e>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  107200:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  107207:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  10720e:	0f 83 58 00 00 00    	jae    10726c <vmm_create_vpdraw+0x20c>
  107214:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
  107219:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10721c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10721f:	8b 12                	mov    (%edx),%edx
  107221:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  107224:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  10722a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		map_address_context(pagedir_ptr,
  10722d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  107230:	8b 15 e4 82 10 00    	mov    0x1082e4,%edx
  107236:	8b 75 d8             	mov    -0x28(%ebp),%esi
  107239:	c1 e6 0c             	shl    $0xc,%esi
  10723c:	01 f2                	add    %esi,%edx
  10723e:	8b 75 dc             	mov    -0x24(%ebp),%esi
  107241:	89 0c 24             	mov    %ecx,(%esp)
  107244:	89 54 24 04          	mov    %edx,0x4(%esp)
  107248:	89 74 24 08          	mov    %esi,0x8(%esp)
  10724c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107253:	00 
  107254:	89 45 c0             	mov    %eax,-0x40(%ebp)
  107257:	e8 64 05 00 00       	call   1077c0 <map_address_context>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  10725c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10725f:	05 01 00 00 00       	add    $0x1,%eax
  107264:	89 45 d8             	mov    %eax,-0x28(%ebp)
  107267:	e9 9b ff ff ff       	jmp    107207 <vmm_create_vpdraw+0x1a7>
  10726c:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(pagedir_ptr,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
  107271:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  107274:	8b 15 e8 82 10 00    	mov    0x1082e8,%edx
  10727a:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10727d:	89 0c 24             	mov    %ecx,(%esp)
  107280:	89 54 24 04          	mov    %edx,0x4(%esp)
  107284:	89 74 24 08          	mov    %esi,0x8(%esp)
  107288:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10728f:	00 
  107290:	89 45 bc             	mov    %eax,-0x44(%ebp)
  107293:	e8 28 05 00 00       	call   1077c0 <map_address_context>
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  107298:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
  10729f:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
  1072a5:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  1072a8:	0f 83 39 00 00 00    	jae    1072e7 <vmm_create_vpdraw+0x287>
  1072ae:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(pagedir_ptr, i, i, 0);
  1072b3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1072b6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1072b9:	8b 75 d8             	mov    -0x28(%ebp),%esi
  1072bc:	89 0c 24             	mov    %ecx,(%esp)
  1072bf:	89 54 24 04          	mov    %edx,0x4(%esp)
  1072c3:	89 74 24 08          	mov    %esi,0x8(%esp)
  1072c7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1072ce:	00 
  1072cf:	89 45 b8             	mov    %eax,-0x48(%ebp)
  1072d2:	e8 e9 04 00 00       	call   1077c0 <map_address_context>
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  1072d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1072da:	05 00 10 00 00       	add    $0x1000,%eax
  1072df:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1072e2:	e9 b8 ff ff ff       	jmp    10729f <vmm_create_vpdraw+0x23f>
		map_address_context(pagedir_ptr, i, i, 0);
	}

	uint32_t* pd_ptr = context->pagedir;
  1072e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1072ea:	8b 00                	mov    (%eax),%eax
  1072ec:	89 45 cc             	mov    %eax,-0x34(%ebp)
	context->pagedir = (uint32_t*) phys_pagedir;
  1072ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1072f2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1072f5:	89 01                	mov    %eax,(%ecx)

	vmm_unmap(pd_ptr);
  1072f7:	8b 45 cc             	mov    -0x34(%ebp),%eax
  1072fa:	89 04 24             	mov    %eax,(%esp)
  1072fd:	e8 4e 05 00 00       	call   107850 <vmm_unmap>
	vmm_unmap(context);
  107302:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107305:	89 04 24             	mov    %eax,(%esp)
  107308:	e8 43 05 00 00       	call   107850 <vmm_unmap>

	return pagedir_ptr;
  10730d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  107310:	83 c4 4c             	add    $0x4c,%esp
  107313:	5e                   	pop    %esi
  107314:	5f                   	pop    %edi
  107315:	5b                   	pop    %ebx
  107316:	5d                   	pop    %ebp
  107317:	c3                   	ret    
  107318:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10731f:	00 

00107320 <vmm_free_pdptr>:
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
  107320:	55                   	push   %ebp
  107321:	89 e5                	mov    %esp,%ebp
  107323:	83 ec 18             	sub    $0x18,%esp
  107326:	8b 45 08             	mov    0x8(%ebp),%eax
  107329:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (uint32_t i = 0; i < 1024; i++) {
  10732c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  107333:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
  10733a:	0f 83 21 00 00 00    	jae    107361 <vmm_free_pdptr+0x41>
		vmm_unmap((void*) pagedir_ptr[i]);
  107340:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107343:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  107346:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107349:	89 04 24             	mov    %eax,(%esp)
  10734c:	e8 ff 04 00 00       	call   107850 <vmm_unmap>

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
	for (uint32_t i = 0; i < 1024; i++) {
  107351:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107354:	05 01 00 00 00       	add    $0x1,%eax
  107359:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10735c:	e9 d2 ff ff ff       	jmp    107333 <vmm_free_pdptr+0x13>
		vmm_unmap((void*) pagedir_ptr[i]);
	}

	vmm_unmap(pagedir_ptr);
  107361:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107364:	89 04 24             	mov    %eax,(%esp)
  107367:	e8 e4 04 00 00       	call   107850 <vmm_unmap>
}
  10736c:	83 c4 18             	add    $0x18,%esp
  10736f:	5d                   	pop    %ebp
  107370:	c3                   	ret    
  107371:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  107378:	0f 1f 84 00 00 00 00 
  10737f:	00 

00107380 <vmm_free_current_pagetables>:
	vmm_free_pdptr(pdptr);

	return phys_pagedir;
}

void vmm_free_current_pagetables() {
  107380:	55                   	push   %ebp
  107381:	89 e5                	mov    %esp,%ebp
  107383:	56                   	push   %esi
  107384:	83 ec 34             	sub    $0x34,%esp
  107387:	b8 00 00 00 00       	mov    $0x0,%eax
    uint32_t* ppd = vmm_alloc(0);
  10738c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107393:	89 45 e8             	mov    %eax,-0x18(%ebp)
  107396:	e8 55 01 00 00       	call   1074f0 <vmm_alloc>
  10739b:	b9 00 00 00 00       	mov    $0x0,%ecx
  1073a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t* ppt = vmm_alloc(0);
  1073a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1073aa:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1073ad:	e8 3e 01 00 00       	call   1074f0 <vmm_alloc>
  1073b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    vmm_free(ppd);
  1073b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1073b8:	89 04 24             	mov    %eax,(%esp)
  1073bb:	e8 80 01 00 00       	call   107540 <vmm_free>
    vmm_free(ppt);
  1073c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1073c3:	89 04 24             	mov    %eax,(%esp)
  1073c6:	e8 75 01 00 00       	call   107540 <vmm_free>

    map_address_active((uint32_t)ppd, get_current_task()->phys_pdir, 0);
  1073cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1073ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1073d1:	e8 ba cf ff ff       	call   104390 <get_current_task>
  1073d6:	b9 00 00 00 00       	mov    $0x0,%ecx
  1073db:	8b 40 14             	mov    0x14(%eax),%eax
  1073de:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1073e1:	89 14 24             	mov    %edx,(%esp)
  1073e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  1073e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1073ef:	00 
  1073f0:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1073f3:	e8 c8 01 00 00       	call   1075c0 <map_address_active>

    for(uint32_t i = PMEM_TABLES; i < 1024; i++) {
  1073f8:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
  1073ff:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
  107406:	0f 83 ca 00 00 00    	jae    1074d6 <vmm_free_current_pagetables+0x156>
  10740c:	b8 00 00 00 00       	mov    $0x0,%eax
        map_address_active((uint32_t)ppt, ppd[i] & 0xFFFFF000, 0);
  107411:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  107414:	8b 55 f0             	mov    -0x10(%ebp),%edx
  107417:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10741a:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10741d:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  107423:	89 0c 24             	mov    %ecx,(%esp)
  107426:	89 54 24 04          	mov    %edx,0x4(%esp)
  10742a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107431:	00 
  107432:	89 45 d8             	mov    %eax,-0x28(%ebp)
  107435:	e8 86 01 00 00       	call   1075c0 <map_address_active>

        for(uint32_t n = 0; n < 1024; n++) {
  10743a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107441:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  107448:	0f 83 44 00 00 00    	jae    107492 <vmm_free_current_pagetables+0x112>
            if(ppt[n] & PT_PRESENT) {
  10744e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107451:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  107454:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107457:	25 01 00 00 00       	and    $0x1,%eax
  10745c:	3d 00 00 00 00       	cmp    $0x0,%eax
  107461:	0f 84 16 00 00 00    	je     10747d <vmm_free_current_pagetables+0xfd>

                //kprintf("[exit] should free %x:%d->%x:%d->%x\n", vmm_resolve(ppd), i, ppd[i], n, ppt[n]);

                pmm_free((void*)(ppt[n] & 0xFFFF000));
  107467:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10746a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10746d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107470:	25 00 f0 ff 0f       	and    $0xffff000,%eax
  107475:	89 04 24             	mov    %eax,(%esp)
  107478:	e8 93 bc ff ff       	call   103110 <pmm_free>
            }
        }
  10747d:	e9 00 00 00 00       	jmp    107482 <vmm_free_current_pagetables+0x102>
    map_address_active((uint32_t)ppd, get_current_task()->phys_pdir, 0);

    for(uint32_t i = PMEM_TABLES; i < 1024; i++) {
        map_address_active((uint32_t)ppt, ppd[i] & 0xFFFFF000, 0);

        for(uint32_t n = 0; n < 1024; n++) {
  107482:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107485:	05 01 00 00 00       	add    $0x1,%eax
  10748a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10748d:	e9 af ff ff ff       	jmp    107441 <vmm_free_current_pagetables+0xc1>

                pmm_free((void*)(ppt[n] & 0xFFFF000));
            }
        }

        if(ppd[i] & PD_PRESENT) {
  107492:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107495:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  107498:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10749b:	25 01 00 00 00       	and    $0x1,%eax
  1074a0:	3d 00 00 00 00       	cmp    $0x0,%eax
  1074a5:	0f 84 16 00 00 00    	je     1074c1 <vmm_free_current_pagetables+0x141>
            pmm_free((void*)(ppd[i] & (~0xFFF)));
  1074ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1074ae:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1074b1:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1074b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1074b9:	89 04 24             	mov    %eax,(%esp)
  1074bc:	e8 4f bc ff ff       	call   103110 <pmm_free>
        }
    }
  1074c1:	e9 00 00 00 00       	jmp    1074c6 <vmm_free_current_pagetables+0x146>
    vmm_free(ppd);
    vmm_free(ppt);

    map_address_active((uint32_t)ppd, get_current_task()->phys_pdir, 0);

    for(uint32_t i = PMEM_TABLES; i < 1024; i++) {
  1074c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1074c9:	05 01 00 00 00       	add    $0x1,%eax
  1074ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1074d1:	e9 29 ff ff ff       	jmp    1073ff <vmm_free_current_pagetables+0x7f>

        if(ppd[i] & PD_PRESENT) {
            pmm_free((void*)(ppd[i] & (~0xFFF)));
        }
    }
    pmm_free((void*)(get_current_task()->phys_pdir));
  1074d6:	e8 b5 ce ff ff       	call   104390 <get_current_task>
  1074db:	8b 40 14             	mov    0x14(%eax),%eax
  1074de:	89 04 24             	mov    %eax,(%esp)
  1074e1:	e8 2a bc ff ff       	call   103110 <pmm_free>
}
  1074e6:	83 c4 34             	add    $0x34,%esp
  1074e9:	5e                   	pop    %esi
  1074ea:	5d                   	pop    %ebp
  1074eb:	c3                   	ret    
  1074ec:	0f 1f 40 00          	nopl   0x0(%eax)

001074f0 <vmm_alloc>:

void* vmm_alloc_cont(uint32_t cont) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
}

void* vmm_alloc(uint32_t* retpaddr) {
  1074f0:	55                   	push   %ebp
  1074f1:	89 e5                	mov    %esp,%ebp
  1074f3:	56                   	push   %esi
  1074f4:	83 ec 24             	sub    $0x24,%esp
  1074f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1074fa:	b9 00 10 40 01       	mov    $0x1401000,%ecx
  1074ff:	ba 00 00 00 20       	mov    $0x20000000,%edx
  107504:	be 01 00 00 00       	mov    $0x1,%esi
  107509:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
  10750c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10750f:	c7 04 24 00 10 40 01 	movl   $0x1401000,(%esp)
  107516:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  10751d:	20 
  10751e:	89 44 24 08          	mov    %eax,0x8(%esp)
  107522:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  107529:	00 
  10752a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10752d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107530:	89 55 ec             	mov    %edx,-0x14(%ebp)
  107533:	e8 d8 03 00 00       	call   107910 <vmm_alloc_in_range>
  107538:	83 c4 24             	add    $0x24,%esp
  10753b:	5e                   	pop    %esi
  10753c:	5d                   	pop    %ebp
  10753d:	c3                   	ret    
  10753e:	66 90                	xchg   %ax,%ax

00107540 <vmm_free>:
	                                 (flags & 0xFFF) |
	                                 (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
}

void vmm_free(void* p_vaddr) {
  107540:	55                   	push   %ebp
  107541:	89 e5                	mov    %esp,%ebp
  107543:	83 ec 18             	sub    $0x18,%esp
  107546:	8b 45 08             	mov    0x8(%ebp),%eax
  107549:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  10754c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10754f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  107552:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107555:	c1 e8 0c             	shr    $0xc,%eax
  107558:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  10755e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107561:	25 01 02 00 00       	and    $0x201,%eax
  107566:	3d 01 02 00 00       	cmp    $0x201,%eax
  10756b:	0f 85 4a 00 00 00    	jne    1075bb <vmm_free+0x7b>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		pmm_free((void*) (active_pagetables[vaddr >> 12] & 0xFFFFF000));
  107571:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107574:	c1 e8 0c             	shr    $0xc,%eax
  107577:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  10757d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107580:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  107585:	89 04 24             	mov    %eax,(%esp)
  107588:	e8 83 bb ff ff       	call   103110 <pmm_free>

		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  10758d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107590:	c1 e8 0c             	shr    $0xc,%eax
  107593:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  107599:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10759c:	25 04 00 00 00       	and    $0x4,%eax
  1075a1:	0d 00 02 00 00       	or     $0x200,%eax
  1075a6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1075a9:	c1 e9 0c             	shr    $0xc,%ecx
  1075ac:	8b 15 e4 82 10 00    	mov    0x1082e4,%edx
  1075b2:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  1075b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1075b8:	0f 01 38             	invlpg (%eax)
	}
}
  1075bb:	83 c4 18             	add    $0x18,%esp
  1075be:	5d                   	pop    %ebp
  1075bf:	c3                   	ret    

001075c0 <map_address_active>:
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}

void map_address_active(uint32_t vaddr, uint32_t paddr, uint32_t flags) {
  1075c0:	55                   	push   %ebp
  1075c1:	89 e5                	mov    %esp,%ebp
  1075c3:	83 ec 0c             	sub    $0xc,%esp
  1075c6:	8b 45 10             	mov    0x10(%ebp),%eax
  1075c9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1075cc:	8b 55 08             	mov    0x8(%ebp),%edx
  1075cf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1075d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1075d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	active_pagetables[vaddr >> 12] = (paddr & 0xFFFFF000) | PT_PRESENT | PT_WRITE |
  1075d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1075db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1075e0:	0d 01 00 00 00       	or     $0x1,%eax
  1075e5:	0d 02 00 00 00       	or     $0x2,%eax
  1075ea:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1075ed:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  1075f3:	09 c8                	or     %ecx,%eax
  1075f5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1075f8:	c1 e9 0c             	shr    $0xc,%ecx
  1075fb:	8b 15 e4 82 10 00    	mov    0x1082e4,%edx
  107601:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  107604:	81 e1 04 02 00 00    	and    $0x204,%ecx
  10760a:	09 c8                	or     %ecx,%eax
  10760c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10760f:	c1 e9 0c             	shr    $0xc,%ecx
  107612:	8b 15 e4 82 10 00    	mov    0x1082e4,%edx
  107618:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
	                                 (flags & 0xFFF) |
	                                 (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  10761b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10761e:	0f 01 38             	invlpg (%eax)
}
  107621:	83 c4 0c             	add    $0xc,%esp
  107624:	5d                   	pop    %ebp
  107625:	c3                   	ret    
  107626:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10762d:	00 00 00 

00107630 <vmm_resolve>:
        }
    }
    pmm_free((void*)(get_current_task()->phys_pdir));
}

uint32_t vmm_resolve(void* vaddr) {
  107630:	55                   	push   %ebp
  107631:	89 e5                	mov    %esp,%ebp
  107633:	50                   	push   %eax
  107634:	8b 45 08             	mov    0x8(%ebp),%eax
  107637:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return active_pagetables[(uint32_t) vaddr >> 12] & 0xFFFFF000;
  10763a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10763d:	c1 e8 0c             	shr    $0xc,%eax
  107640:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  107646:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107649:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10764e:	83 c4 04             	add    $0x4,%esp
  107651:	5d                   	pop    %ebp
  107652:	c3                   	ret    
  107653:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10765a:	84 00 00 00 00 00 

00107660 <vmm_resolve_ppd>:
}

uint32_t vmm_resolve_ppd(uint32_t pdir, void* vaddr) {
  107660:	55                   	push   %ebp
  107661:	89 e5                	mov    %esp,%ebp
  107663:	83 ec 38             	sub    $0x38,%esp
  107666:	8b 45 0c             	mov    0xc(%ebp),%eax
  107669:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10766c:	ba 00 00 00 00       	mov    $0x0,%edx
  107671:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  107674:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32_t pd_entry = (uint32_t) vaddr >> 22;
  107677:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10767a:	c1 e8 16             	shr    $0x16,%eax
  10767d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t pt_entry = ((uint32_t) vaddr >> 12) % 1024;
  107680:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107683:	c1 e8 0c             	shr    $0xc,%eax
  107686:	25 ff 03 00 00       	and    $0x3ff,%eax
  10768b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	uint32_t* vpd = vmm_alloc(0);
  10768e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  107695:	89 55 e0             	mov    %edx,-0x20(%ebp)
  107698:	e8 53 fe ff ff       	call   1074f0 <vmm_alloc>
  10769d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	vmm_free(vpd);
  1076a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1076a3:	89 04 24             	mov    %eax,(%esp)
  1076a6:	e8 95 fe ff ff       	call   107540 <vmm_free>
  1076ab:	b8 00 00 00 00       	mov    $0x0,%eax

	map_address_active((uint32_t) vpd, pdir, 0);
  1076b0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1076b3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1076b6:	89 0c 24             	mov    %ecx,(%esp)
  1076b9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1076bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1076c4:	00 
  1076c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1076c8:	e8 f3 fe ff ff       	call   1075c0 <map_address_active>
  1076cd:	b8 00 00 00 00       	mov    $0x0,%eax
	uint32_t table = vpd[pd_entry] & 0xFFFFF000;
  1076d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1076d5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1076d8:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  1076db:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  1076e1:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	map_address_active((uint32_t) vpd, table, 0);
  1076e4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1076e7:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1076ea:	89 0c 24             	mov    %ecx,(%esp)
  1076ed:	89 54 24 04          	mov    %edx,0x4(%esp)
  1076f1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1076f8:	00 
  1076f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1076fc:	e8 bf fe ff ff       	call   1075c0 <map_address_active>
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;
  107701:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107704:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  107707:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10770a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10770f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	return addr & 0xFFFFF000;
  107712:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  107715:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10771a:	83 c4 38             	add    $0x38,%esp
  10771d:	5d                   	pop    %ebp
  10771e:	c3                   	ret    
  10771f:	90                   	nop

00107720 <vmm_map_range>:
}

void vmm_map_range(void* vaddr, void* paddr, uint32_t length, uint32_t flags) {
  107720:	55                   	push   %ebp
  107721:	89 e5                	mov    %esp,%ebp
  107723:	56                   	push   %esi
  107724:	83 ec 24             	sub    $0x24,%esp
  107727:	8b 45 14             	mov    0x14(%ebp),%eax
  10772a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10772d:	8b 55 0c             	mov    0xc(%ebp),%edx
  107730:	8b 75 08             	mov    0x8(%ebp),%esi
  107733:	89 75 f8             	mov    %esi,-0x8(%ebp)
  107736:	89 55 f4             	mov    %edx,-0xc(%ebp)
  107739:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10773c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((uint32_t) vaddr & 0xFFF)
  10773f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107742:	25 ff 0f 00 00       	and    $0xfff,%eax
  107747:	3d 00 00 00 00       	cmp    $0x0,%eax
  10774c:	0f 84 05 00 00 00    	je     107757 <vmm_map_range+0x37>
		return;
  107752:	e9 5a 00 00 00       	jmp    1077b1 <vmm_map_range+0x91>
	if ((uint32_t) paddr & 0xFFF)
  107757:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10775a:	25 ff 0f 00 00       	and    $0xfff,%eax
  10775f:	3d 00 00 00 00       	cmp    $0x0,%eax
  107764:	0f 84 05 00 00 00    	je     10776f <vmm_map_range+0x4f>
		return;
  10776a:	e9 42 00 00 00       	jmp    1077b1 <vmm_map_range+0x91>

	for (uint32_t i = 0; i < length; i += 0x1000) {
  10776f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  107776:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107779:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10777c:	0f 83 2f 00 00 00    	jae    1077b1 <vmm_map_range+0x91>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
  107782:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107785:	03 45 e8             	add    -0x18(%ebp),%eax
  107788:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10778b:	03 4d e8             	add    -0x18(%ebp),%ecx
  10778e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  107791:	89 04 24             	mov    %eax,(%esp)
  107794:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107798:	89 54 24 08          	mov    %edx,0x8(%esp)
  10779c:	e8 1f fe ff ff       	call   1075c0 <map_address_active>
	if ((uint32_t) vaddr & 0xFFF)
		return;
	if ((uint32_t) paddr & 0xFFF)
		return;

	for (uint32_t i = 0; i < length; i += 0x1000) {
  1077a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1077a4:	05 00 10 00 00       	add    $0x1000,%eax
  1077a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1077ac:	e9 c5 ff ff ff       	jmp    107776 <vmm_map_range+0x56>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}
  1077b1:	83 c4 24             	add    $0x24,%esp
  1077b4:	5e                   	pop    %esi
  1077b5:	5d                   	pop    %ebp
  1077b6:	c3                   	ret    
  1077b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1077be:	00 00 

001077c0 <map_address_context>:

void map_address_context(uint32_t* pagedir, uint32_t vaddr, uint32_t paddr,
		uint32_t flags) {
  1077c0:	55                   	push   %ebp
  1077c1:	89 e5                	mov    %esp,%ebp
  1077c3:	56                   	push   %esi
  1077c4:	83 ec 18             	sub    $0x18,%esp
  1077c7:	8b 45 14             	mov    0x14(%ebp),%eax
  1077ca:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1077cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  1077d0:	8b 75 08             	mov    0x8(%ebp),%esi
  1077d3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  1077d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  1077d9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1077dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32_t pd_entry = vaddr >> 22;
  1077df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1077e2:	c1 e8 16             	shr    $0x16,%eax
  1077e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pt_entry = (vaddr >> 12) % 1024;
  1077e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1077eb:	c1 e8 0c             	shr    $0xc,%eax
  1077ee:	25 ff 03 00 00       	and    $0x3ff,%eax
  1077f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry] = (paddr
  1077f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1077f9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1077fe:	0d 01 00 00 00       	or     $0x1,%eax
  107803:	0d 02 00 00 00       	or     $0x2,%eax
  107808:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10780b:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  107811:	09 c8                	or     %ecx,%eax
  107813:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  107816:	8b 55 e8             	mov    -0x18(%ebp),%edx
  107819:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10781c:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10781f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  107825:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  107828:	81 e1 04 02 00 00    	and    $0x204,%ecx
  10782e:	09 c8                	or     %ecx,%eax
  107830:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  107833:	8b 55 e8             	mov    -0x18(%ebp),%edx
  107836:	8b 75 f8             	mov    -0x8(%ebp),%esi
  107839:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10783c:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  107842:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}
  107845:	83 c4 18             	add    $0x18,%esp
  107848:	5e                   	pop    %esi
  107849:	5d                   	pop    %ebp
  10784a:	c3                   	ret    
  10784b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00107850 <vmm_unmap>:
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

void vmm_unmap(void* p_vaddr) { //USE ONLY IF YOU KNOW WHAT YOU DO. POTENTIAL MEMORY LEAK!
  107850:	55                   	push   %ebp
  107851:	89 e5                	mov    %esp,%ebp
  107853:	83 ec 08             	sub    $0x8,%esp
  107856:	8b 45 08             	mov    0x8(%ebp),%eax
  107859:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  10785c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10785f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  107862:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107865:	c1 e8 0c             	shr    $0xc,%eax
  107868:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  10786e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107871:	25 01 02 00 00       	and    $0x201,%eax
  107876:	3d 01 02 00 00       	cmp    $0x201,%eax
  10787b:	0f 85 2e 00 00 00    	jne    1078af <vmm_unmap+0x5f>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  107881:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107884:	c1 e8 0c             	shr    $0xc,%eax
  107887:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  10788d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107890:	25 04 00 00 00       	and    $0x4,%eax
  107895:	0d 00 02 00 00       	or     $0x200,%eax
  10789a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10789d:	c1 e9 0c             	shr    $0xc,%ecx
  1078a0:	8b 15 e4 82 10 00    	mov    0x1082e4,%edx
  1078a6:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  1078a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1078ac:	0f 01 38             	invlpg (%eax)
	}
}
  1078af:	83 c4 08             	add    $0x8,%esp
  1078b2:	5d                   	pop    %ebp
  1078b3:	c3                   	ret    
  1078b4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1078bb:	00 00 00 00 00 

001078c0 <vmm_alloc_ucont>:
	}

	return vaddr;
}

void* vmm_alloc_ucont(uint32_t cont) {
  1078c0:	55                   	push   %ebp
  1078c1:	89 e5                	mov    %esp,%ebp
  1078c3:	56                   	push   %esi
  1078c4:	83 ec 24             	sub    $0x24,%esp
  1078c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1078ca:	b9 00 10 40 01       	mov    $0x1401000,%ecx
  1078cf:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  1078d4:	be 00 00 00 00       	mov    $0x0,%esi
  1078d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
  1078dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1078df:	c7 04 24 00 10 40 01 	movl   $0x1401000,(%esp)
  1078e6:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  1078ed:	ff 
  1078ee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1078f5:	00 
  1078f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1078fa:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1078fd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107900:	89 55 ec             	mov    %edx,-0x14(%ebp)
  107903:	e8 08 00 00 00       	call   107910 <vmm_alloc_in_range>
  107908:	83 c4 24             	add    $0x24,%esp
  10790b:	5e                   	pop    %esi
  10790c:	5d                   	pop    %ebp
  10790d:	c3                   	ret    
  10790e:	66 90                	xchg   %ax,%ax

00107910 <vmm_alloc_in_range>:
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

static void* vmm_alloc_in_range(uint32_t low, uint32_t high, uint32_t* retpaddr,
		uint32_t cont) {
  107910:	55                   	push   %ebp
  107911:	89 e5                	mov    %esp,%ebp
  107913:	56                   	push   %esi
  107914:	83 ec 34             	sub    $0x34,%esp
  107917:	8b 45 14             	mov    0x14(%ebp),%eax
  10791a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10791d:	8b 55 0c             	mov    0xc(%ebp),%edx
  107920:	8b 75 08             	mov    0x8(%ebp),%esi
  107923:	89 75 f8             	mov    %esi,-0x8(%ebp)
  107926:	89 55 f4             	mov    %edx,-0xc(%ebp)
  107929:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10792c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	void* vaddr = 0;
  10792f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32_t i = 0;
  107936:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32_t c = 0;
  10793d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  107944:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107947:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10794c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10794f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  107952:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  107955:	0f 83 6f 00 00 00    	jae    1079ca <vmm_alloc_in_range+0xba>
		if ((active_pagetables[i >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  10795b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10795e:	c1 e8 0c             	shr    $0xc,%eax
  107961:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  107967:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10796a:	25 01 02 00 00       	and    $0x201,%eax
  10796f:	3d 00 02 00 00       	cmp    $0x200,%eax
  107974:	0f 85 34 00 00 00    	jne    1079ae <vmm_alloc_in_range+0x9e>
				== PT_ALLOCATABLE) {
			if (c == 0)
  10797a:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  107981:	0f 85 06 00 00 00    	jne    10798d <vmm_alloc_in_range+0x7d>
				vaddr = (void*) i;
  107987:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10798a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			c++;
  10798d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  107990:	05 01 00 00 00       	add    $0x1,%eax
  107995:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (c >= cont)
  107998:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10799b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10799e:	0f 82 05 00 00 00    	jb     1079a9 <vmm_alloc_in_range+0x99>
				break;
  1079a4:	e9 21 00 00 00       	jmp    1079ca <vmm_alloc_in_range+0xba>
		} else {
  1079a9:	e9 07 00 00 00       	jmp    1079b5 <vmm_alloc_in_range+0xa5>
			c = 0;
  1079ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
	}
  1079b5:	e9 00 00 00 00       	jmp    1079ba <vmm_alloc_in_range+0xaa>
		uint32_t cont) {
	void* vaddr = 0;
	uint32_t i = 0;
	uint32_t c = 0;

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  1079ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1079bd:	05 00 10 00 00       	add    $0x1000,%eax
  1079c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1079c5:	e9 85 ff ff ff       	jmp    10794f <vmm_alloc_in_range+0x3f>
		} else {
			c = 0;
		}
	}

	uint32_t off = 0;
  1079ca:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	while (c--) {
  1079d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1079d4:	89 c1                	mov    %eax,%ecx
  1079d6:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1079dc:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1079df:	3d 00 00 00 00       	cmp    $0x0,%eax
  1079e4:	0f 84 59 00 00 00    	je     107a43 <vmm_alloc_in_range+0x133>
		vmm_alloc_addr(vaddr + off * 0x1000, off == 0 ? retpaddr : 0);
  1079ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1079ed:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1079f0:	c1 e1 0c             	shl    $0xc,%ecx
  1079f3:	01 c8                	add    %ecx,%eax
  1079f5:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  1079fc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1079ff:	0f 85 0b 00 00 00    	jne    107a10 <vmm_alloc_in_range+0x100>
  107a05:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107a08:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  107a0b:	e9 0d 00 00 00       	jmp    107a1d <vmm_alloc_in_range+0x10d>
  107a10:	b8 00 00 00 00       	mov    $0x0,%eax
  107a15:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  107a18:	e9 00 00 00 00       	jmp    107a1d <vmm_alloc_in_range+0x10d>
  107a1d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  107a20:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  107a23:	89 0c 24             	mov    %ecx,(%esp)
  107a26:	89 44 24 04          	mov    %eax,0x4(%esp)
  107a2a:	e8 c1 00 00 00       	call   107af0 <vmm_alloc_addr>
		off++;
  107a2f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  107a32:	81 c1 01 00 00 00    	add    $0x1,%ecx
  107a38:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	}
  107a3b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  107a3e:	e9 8e ff ff ff       	jmp    1079d1 <vmm_alloc_in_range+0xc1>

	return vaddr;
  107a43:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107a46:	83 c4 34             	add    $0x34,%esp
  107a49:	5e                   	pop    %esi
  107a4a:	5d                   	pop    %ebp
  107a4b:	c3                   	ret    
  107a4c:	0f 1f 40 00          	nopl   0x0(%eax)

00107a50 <vmm_alloc_user>:

void* vmm_alloc_ucont(uint32_t cont) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
}

void* vmm_alloc_user(uint32_t* retpaddr) {
  107a50:	55                   	push   %ebp
  107a51:	89 e5                	mov    %esp,%ebp
  107a53:	56                   	push   %esi
  107a54:	83 ec 24             	sub    $0x24,%esp
  107a57:	8b 45 08             	mov    0x8(%ebp),%eax
  107a5a:	b9 00 10 40 01       	mov    $0x1401000,%ecx
  107a5f:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  107a64:	be 01 00 00 00       	mov    $0x1,%esi
  107a69:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
  107a6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107a6f:	c7 04 24 00 10 40 01 	movl   $0x1401000,(%esp)
  107a76:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  107a7d:	ff 
  107a7e:	89 44 24 08          	mov    %eax,0x8(%esp)
  107a82:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  107a89:	00 
  107a8a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  107a8d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107a90:	89 55 ec             	mov    %edx,-0x14(%ebp)
  107a93:	e8 78 fe ff ff       	call   107910 <vmm_alloc_in_range>
  107a98:	83 c4 24             	add    $0x24,%esp
  107a9b:	5e                   	pop    %esi
  107a9c:	5d                   	pop    %ebp
  107a9d:	c3                   	ret    
  107a9e:	66 90                	xchg   %ax,%ax

00107aa0 <vmm_alloc_cont>:
}

void* vmm_alloc_cont(uint32_t cont) {
  107aa0:	55                   	push   %ebp
  107aa1:	89 e5                	mov    %esp,%ebp
  107aa3:	56                   	push   %esi
  107aa4:	83 ec 24             	sub    $0x24,%esp
  107aa7:	8b 45 08             	mov    0x8(%ebp),%eax
  107aaa:	b9 00 10 40 01       	mov    $0x1401000,%ecx
  107aaf:	ba 00 00 00 20       	mov    $0x20000000,%edx
  107ab4:	be 00 00 00 00       	mov    $0x0,%esi
  107ab9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
  107abc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107abf:	c7 04 24 00 10 40 01 	movl   $0x1401000,(%esp)
  107ac6:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  107acd:	20 
  107ace:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107ad5:	00 
  107ad6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  107ada:	89 75 f4             	mov    %esi,-0xc(%ebp)
  107add:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  107ae0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  107ae3:	e8 28 fe ff ff       	call   107910 <vmm_alloc_in_range>
  107ae8:	83 c4 24             	add    $0x24,%esp
  107aeb:	5e                   	pop    %esi
  107aec:	5d                   	pop    %ebp
  107aed:	c3                   	ret    
  107aee:	66 90                	xchg   %ax,%ax

00107af0 <vmm_alloc_addr>:

void* vmm_alloc(uint32_t* retpaddr) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
}

void* vmm_alloc_addr(void* reqvaddr, uint32_t* retpaddr) {
  107af0:	55                   	push   %ebp
  107af1:	89 e5                	mov    %esp,%ebp
  107af3:	56                   	push   %esi
  107af4:	83 ec 34             	sub    $0x34,%esp
  107af7:	8b 45 0c             	mov    0xc(%ebp),%eax
  107afa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  107afd:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  107b00:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (reqvaddr == 0) {
  107b03:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  107b0a:	0f 85 34 00 00 00    	jne    107b44 <vmm_alloc_addr+0x54>
  107b10:	8d 05 bc 96 10 00    	lea    0x1096bc,%eax
  107b16:	b9 00 00 00 00       	mov    $0x0,%ecx
		kprintf(
  107b1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  107b1e:	89 04 24             	mov    %eax,(%esp)
  107b21:	89 54 24 04          	mov    %edx,0x4(%esp)
  107b25:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  107b2c:	00 
  107b2d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  107b30:	e8 7b 87 ff ff       	call   1002b0 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, 0);
		return 0;
  107b35:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  107b3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  107b3f:	e9 9b 00 00 00       	jmp    107bdf <vmm_alloc_addr+0xef>
	}

	if ((active_pagetables[(uint32_t) reqvaddr >> 12]
  107b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107b47:	c1 e8 0c             	shr    $0xc,%eax
  107b4a:	8b 0d e4 82 10 00    	mov    0x1082e4,%ecx
  107b50:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107b53:	25 01 02 00 00       	and    $0x201,%eax
  107b58:	3d 00 02 00 00       	cmp    $0x200,%eax
  107b5d:	0f 84 37 00 00 00    	je     107b9a <vmm_alloc_addr+0xaa>
  107b63:	8d 05 bc 96 10 00    	lea    0x1096bc,%eax
			& (PT_ALLOCATABLE | PT_PRESENT)) != PT_ALLOCATABLE) {
		kprintf(
  107b69:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  107b6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  107b6f:	c1 ea 0c             	shr    $0xc,%edx
  107b72:	8b 35 e4 82 10 00    	mov    0x1082e4,%esi
  107b78:	8b 14 96             	mov    (%esi,%edx,4),%edx
  107b7b:	89 04 24             	mov    %eax,(%esp)
  107b7e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107b82:	89 54 24 08          	mov    %edx,0x8(%esp)
  107b86:	e8 25 87 ff ff       	call   1002b0 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, active_pagetables[(uint32_t) reqvaddr >> 12]);
		return 0;
  107b8b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  107b92:	89 45 e0             	mov    %eax,-0x20(%ebp)
  107b95:	e9 45 00 00 00       	jmp    107bdf <vmm_alloc_addr+0xef>
  107b9a:	b8 04 02 00 00       	mov    $0x204,%eax
	}

	uint32_t paddr = (uint32_t) pmm_alloc();
  107b9f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  107ba2:	e8 49 b3 ff ff       	call   102ef0 <pmm_alloc>
  107ba7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	map_address_active((uint32_t) reqvaddr, paddr, PT_PUBLIC | PT_ALLOCATABLE);
  107baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107bad:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  107bb0:	89 04 24             	mov    %eax,(%esp)
  107bb3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  107bb7:	c7 44 24 08 04 02 00 	movl   $0x204,0x8(%esp)
  107bbe:	00 
  107bbf:	e8 fc f9 ff ff       	call   1075c0 <map_address_active>

	if (retpaddr != 0)
  107bc4:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  107bcb:	0f 84 08 00 00 00    	je     107bd9 <vmm_alloc_addr+0xe9>
		*retpaddr = paddr;
  107bd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107bd4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107bd7:	89 01                	mov    %eax,(%ecx)

	return reqvaddr;
  107bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  107bdc:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  107bdf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  107be2:	83 c4 34             	add    $0x34,%esp
  107be5:	5e                   	pop    %esi
  107be6:	5d                   	pop    %ebp
  107be7:	c3                   	ret    
  107be8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  107bef:	00 

00107bf0 <vmm_activate_pagedir>:

void vmm_activate_pagedir(uint32_t pdpaddr) {
  107bf0:	55                   	push   %ebp
  107bf1:	89 e5                	mov    %esp,%ebp
  107bf3:	50                   	push   %eax
  107bf4:	8b 45 08             	mov    0x8(%ebp),%eax
  107bf7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	active_pagedir = pdpaddr;
  107bfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107bfd:	a3 6c a5 10 00       	mov    %eax,0x10a56c
	asm volatile("mov %0, %%cr3" : : "r" (pdpaddr));
  107c02:	8b 45 fc             	mov    -0x4(%ebp),%eax
  107c05:	0f 22 d8             	mov    %eax,%cr3
}
  107c08:	83 c4 04             	add    $0x4,%esp
  107c0b:	5d                   	pop    %ebp
  107c0c:	c3                   	ret    
  107c0d:	0f 1f 00             	nopl   (%eax)

00107c10 <vmm_init>:

uint32_t vmm_init(void) {
  107c10:	55                   	push   %ebp
  107c11:	89 e5                	mov    %esp,%ebp
	//CREATE CONTEXT ************************************************************

	struct vmm_context* context = pmm_alloc();
  107c13:	53                   	push   %ebx
  107c14:	57                   	push   %edi
  107c15:	56                   	push   %esi
  107c16:	83 ec 3c             	sub    $0x3c,%esp
  107c19:	e8 d2 b2 ff ff       	call   102ef0 <pmm_alloc>
  107c1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t i, i2;

	context->pagedir = pmm_alloc();
  107c21:	e8 ca b2 ff ff       	call   102ef0 <pmm_alloc>
  107c26:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107c29:	89 01                	mov    %eax,(%ecx)

	for (i = 0; i < 1024; i++) {
  107c2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107c32:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  107c39:	0f 83 d6 00 00 00    	jae    107d15 <vmm_init+0x105>
		context->pagedir[i] = ((uint32_t) pmm_alloc());
  107c3f:	e8 ac b2 ff ff       	call   102ef0 <pmm_alloc>
  107c44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  107c47:	8b 55 f0             	mov    -0x10(%ebp),%edx
  107c4a:	8b 12                	mov    (%edx),%edx
  107c4c:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		if (i < PMEM_TABLES) {
  107c4f:	81 7d ec 80 00 00 00 	cmpl   $0x80,-0x14(%ebp)
  107c56:	0f 83 15 00 00 00    	jae    107c71 <vmm_init+0x61>
			kernel_pagetables[i] = context->pagedir[i];
  107c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107c5f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107c62:	8b 09                	mov    (%ecx),%ecx
  107c64:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  107c67:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  107c6a:	89 04 8d a4 ab 18 00 	mov    %eax,0x18aba4(,%ecx,4)
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;
  107c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107c74:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107c77:	8b 09                	mov    (%ecx),%ecx
  107c79:	8b 14 81             	mov    (%ecx,%eax,4),%edx
  107c7c:	81 ca 07 00 00 00    	or     $0x7,%edx
  107c82:	89 14 81             	mov    %edx,(%ecx,%eax,4)

		for (i2 = 0; i2 < 1024; i2++) {
  107c85:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  107c8c:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
  107c93:	0f 83 67 00 00 00    	jae    107d00 <vmm_init+0xf0>
  107c99:	b8 04 00 00 00       	mov    $0x4,%eax
  107c9e:	b9 00 00 00 00       	mov    $0x0,%ecx
  107ca3:	ba 00 02 00 00       	mov    $0x200,%edx
			uint32_t vaddr = (i << 22) + (i2 << 12);
  107ca8:	8b 75 ec             	mov    -0x14(%ebp),%esi
  107cab:	c1 e6 16             	shl    $0x16,%esi
  107cae:	8b 7d e8             	mov    -0x18(%ebp),%edi
  107cb1:	c1 e7 0c             	shl    $0xc,%edi
  107cb4:	01 fe                	add    %edi,%esi
  107cb6:	89 75 e4             	mov    %esi,-0x1c(%ebp)

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
  107cb9:	81 7d e4 00 10 40 01 	cmpl   $0x1401000,-0x1c(%ebp)
  107cc0:	0f 97 c3             	seta   %bl
  107cc3:	84 db                	test   %bl,%bl
  107cc5:	0f 44 d1             	cmove  %ecx,%edx
  107cc8:	81 7d e4 00 10 40 01 	cmpl   $0x1401000,-0x1c(%ebp)
  107ccf:	0f 97 c3             	seta   %bl
  107cd2:	84 db                	test   %bl,%bl
  107cd4:	0f 44 c1             	cmove  %ecx,%eax
  107cd7:	09 c2                	or     %eax,%edx
  107cd9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107cdc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  107cdf:	8b 75 f0             	mov    -0x10(%ebp),%esi
  107ce2:	8b 36                	mov    (%esi),%esi
  107ce4:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  107ce7:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  107ced:	89 14 81             	mov    %edx,(%ecx,%eax,4)
			kernel_pagetables[i] = context->pagedir[i];
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;

		for (i2 = 0; i2 < 1024; i2++) {
  107cf0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  107cf3:	05 01 00 00 00       	add    $0x1,%eax
  107cf8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  107cfb:	e9 8c ff ff ff       	jmp    107c8c <vmm_init+0x7c>

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}
  107d00:	e9 00 00 00 00       	jmp    107d05 <vmm_init+0xf5>
	struct vmm_context* context = pmm_alloc();
	uint32_t i, i2;

	context->pagedir = pmm_alloc();

	for (i = 0; i < 1024; i++) {
  107d05:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107d08:	05 01 00 00 00       	add    $0x1,%eax
  107d0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107d10:	e9 1d ff ff ff       	jmp    107c32 <vmm_init+0x22>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  107d15:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  107d1c:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  107d23:	0f 83 5a 00 00 00    	jae    107d83 <vmm_init+0x173>
  107d29:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
  107d2e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  107d31:	8b 55 f0             	mov    -0x10(%ebp),%edx
  107d34:	8b 12                	mov    (%edx),%edx
  107d36:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  107d39:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  107d3f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		map_address_context(context->pagedir,
  107d42:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107d45:	8b 09                	mov    (%ecx),%ecx
  107d47:	8b 15 e4 82 10 00    	mov    0x1082e4,%edx
  107d4d:	8b 75 ec             	mov    -0x14(%ebp),%esi
  107d50:	c1 e6 0c             	shl    $0xc,%esi
  107d53:	01 f2                	add    %esi,%edx
  107d55:	8b 75 e0             	mov    -0x20(%ebp),%esi
  107d58:	89 0c 24             	mov    %ecx,(%esp)
  107d5b:	89 54 24 04          	mov    %edx,0x4(%esp)
  107d5f:	89 74 24 08          	mov    %esi,0x8(%esp)
  107d63:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107d6a:	00 
  107d6b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  107d6e:	e8 4d fa ff ff       	call   1077c0 <map_address_context>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  107d73:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107d76:	05 01 00 00 00       	add    $0x1,%eax
  107d7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107d7e:	e9 99 ff ff ff       	jmp    107d1c <vmm_init+0x10c>
  107d83:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(context->pagedir,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
  107d88:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107d8b:	8b 09                	mov    (%ecx),%ecx
  107d8d:	8b 15 e8 82 10 00    	mov    0x1082e8,%edx
  107d93:	8b 75 f0             	mov    -0x10(%ebp),%esi
  107d96:	89 0c 24             	mov    %ecx,(%esp)
  107d99:	89 54 24 04          	mov    %edx,0x4(%esp)
  107d9d:	89 74 24 08          	mov    %esi,0x8(%esp)
  107da1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107da8:	00 
  107da9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  107dac:	e8 0f fa ff ff       	call   1077c0 <map_address_context>
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  107db1:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
  107db8:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
  107dbe:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  107dc1:	0f 83 3b 00 00 00    	jae    107e02 <vmm_init+0x1f2>
  107dc7:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(context->pagedir, i, i, 0);
  107dcc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  107dcf:	8b 09                	mov    (%ecx),%ecx
  107dd1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  107dd4:	8b 75 ec             	mov    -0x14(%ebp),%esi
  107dd7:	89 0c 24             	mov    %ecx,(%esp)
  107dda:	89 54 24 04          	mov    %edx,0x4(%esp)
  107dde:	89 74 24 08          	mov    %esi,0x8(%esp)
  107de2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  107de9:	00 
  107dea:	89 45 d0             	mov    %eax,-0x30(%ebp)
  107ded:	e8 ce f9 ff ff       	call   1077c0 <map_address_context>
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  107df2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  107df5:	05 00 10 00 00       	add    $0x1000,%eax
  107dfa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  107dfd:	e9 b6 ff ff ff       	jmp    107db8 <vmm_init+0x1a8>
		map_address_context(context->pagedir, i, i, 0);
	}

	//END CREATE CONTEXT ********************************************************

	vmm_activate_pagedir((uint32_t) context->pagedir);
  107e02:	8b 45 f0             	mov    -0x10(%ebp),%eax
  107e05:	8b 00                	mov    (%eax),%eax
  107e07:	89 04 24             	mov    %eax,(%esp)
  107e0a:	e8 e1 fd ff ff       	call   107bf0 <vmm_activate_pagedir>

	uint32_t cr0;

	asm volatile("mov %%cr0, %0" : "=r" (cr0));
  107e0f:	0f 20 c0             	mov    %cr0,%eax
  107e12:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= (1 << 31);
  107e15:	8b 45 dc             	mov    -0x24(%ebp),%eax
  107e18:	0d 00 00 00 80       	or     $0x80000000,%eax
  107e1d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	asm volatile("mov %0, %%cr0" : : "r" (cr0));
  107e20:	8b 45 dc             	mov    -0x24(%ebp),%eax
  107e23:	0f 22 c0             	mov    %eax,%cr0

	return (uint32_t) active_context->pagedir;
  107e26:	a1 e8 82 10 00       	mov    0x1082e8,%eax
  107e2b:	8b 00                	mov    (%eax),%eax
  107e2d:	83 c4 3c             	add    $0x3c,%esp
  107e30:	5e                   	pop    %esi
  107e31:	5f                   	pop    %edi
  107e32:	5b                   	pop    %ebx
  107e33:	5d                   	pop    %ebp
  107e34:	c3                   	ret    
  107e35:	66 90                	xchg   %ax,%ax
  107e37:	90                   	nop

00107e38 <_start>:
  107e38:	bc 70 a5 11 00       	mov    $0x11a570,%esp
  107e3d:	53                   	push   %ebx
  107e3e:	e8 cd 81 ff ff       	call   100010 <init>

00107e43 <_stop>:
  107e43:	fa                   	cli    
  107e44:	f4                   	hlt    
  107e45:	eb fc                	jmp    107e43 <_stop>
