
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <intr_stub_0-0xc>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 6a                	in     $0x6a,%al

0010000c <intr_stub_0>:
  10000c:	6a 00                	push   $0x0
  10000e:	6a 00                	push   $0x0
  100010:	e9 eb 00 00 00       	jmp    100100 <intr_common_handler>

00100015 <intr_stub_1>:
  100015:	6a 00                	push   $0x0
  100017:	6a 01                	push   $0x1
  100019:	e9 e2 00 00 00       	jmp    100100 <intr_common_handler>

0010001e <intr_stub_2>:
  10001e:	6a 00                	push   $0x0
  100020:	6a 02                	push   $0x2
  100022:	e9 d9 00 00 00       	jmp    100100 <intr_common_handler>

00100027 <intr_stub_3>:
  100027:	6a 00                	push   $0x0
  100029:	6a 03                	push   $0x3
  10002b:	e9 d0 00 00 00       	jmp    100100 <intr_common_handler>

00100030 <intr_stub_4>:
  100030:	6a 00                	push   $0x0
  100032:	6a 04                	push   $0x4
  100034:	e9 c7 00 00 00       	jmp    100100 <intr_common_handler>

00100039 <intr_stub_5>:
  100039:	6a 00                	push   $0x0
  10003b:	6a 05                	push   $0x5
  10003d:	e9 be 00 00 00       	jmp    100100 <intr_common_handler>

00100042 <intr_stub_6>:
  100042:	6a 00                	push   $0x0
  100044:	6a 06                	push   $0x6
  100046:	e9 b5 00 00 00       	jmp    100100 <intr_common_handler>

0010004b <intr_stub_7>:
  10004b:	6a 00                	push   $0x0
  10004d:	6a 07                	push   $0x7
  10004f:	e9 ac 00 00 00       	jmp    100100 <intr_common_handler>

00100054 <intr_stub_8>:
  100054:	6a 08                	push   $0x8
  100056:	e9 a5 00 00 00       	jmp    100100 <intr_common_handler>

0010005b <intr_stub_9>:
  10005b:	6a 00                	push   $0x0
  10005d:	6a 09                	push   $0x9
  10005f:	e9 9c 00 00 00       	jmp    100100 <intr_common_handler>

00100064 <intr_stub_10>:
  100064:	6a 0a                	push   $0xa
  100066:	e9 95 00 00 00       	jmp    100100 <intr_common_handler>

0010006b <intr_stub_11>:
  10006b:	6a 0b                	push   $0xb
  10006d:	e9 8e 00 00 00       	jmp    100100 <intr_common_handler>

00100072 <intr_stub_12>:
  100072:	6a 0c                	push   $0xc
  100074:	e9 87 00 00 00       	jmp    100100 <intr_common_handler>

00100079 <intr_stub_13>:
  100079:	6a 0d                	push   $0xd
  10007b:	e9 80 00 00 00       	jmp    100100 <intr_common_handler>

00100080 <intr_stub_14>:
  100080:	6a 0e                	push   $0xe
  100082:	eb 7c                	jmp    100100 <intr_common_handler>

00100084 <intr_stub_15>:
  100084:	6a 00                	push   $0x0
  100086:	6a 0f                	push   $0xf
  100088:	eb 76                	jmp    100100 <intr_common_handler>

0010008a <intr_stub_16>:
  10008a:	6a 00                	push   $0x0
  10008c:	6a 10                	push   $0x10
  10008e:	eb 70                	jmp    100100 <intr_common_handler>

00100090 <intr_stub_17>:
  100090:	6a 11                	push   $0x11
  100092:	eb 6c                	jmp    100100 <intr_common_handler>

00100094 <intr_stub_18>:
  100094:	6a 00                	push   $0x0
  100096:	6a 12                	push   $0x12
  100098:	eb 66                	jmp    100100 <intr_common_handler>

0010009a <intr_stub_32>:
  10009a:	6a 00                	push   $0x0
  10009c:	6a 20                	push   $0x20
  10009e:	eb 60                	jmp    100100 <intr_common_handler>

001000a0 <intr_stub_33>:
  1000a0:	6a 00                	push   $0x0
  1000a2:	6a 21                	push   $0x21
  1000a4:	eb 5a                	jmp    100100 <intr_common_handler>

001000a6 <intr_stub_34>:
  1000a6:	6a 00                	push   $0x0
  1000a8:	6a 22                	push   $0x22
  1000aa:	eb 54                	jmp    100100 <intr_common_handler>

001000ac <intr_stub_35>:
  1000ac:	6a 00                	push   $0x0
  1000ae:	6a 23                	push   $0x23
  1000b0:	eb 4e                	jmp    100100 <intr_common_handler>

001000b2 <intr_stub_36>:
  1000b2:	6a 00                	push   $0x0
  1000b4:	6a 24                	push   $0x24
  1000b6:	eb 48                	jmp    100100 <intr_common_handler>

001000b8 <intr_stub_37>:
  1000b8:	6a 00                	push   $0x0
  1000ba:	6a 25                	push   $0x25
  1000bc:	eb 42                	jmp    100100 <intr_common_handler>

001000be <intr_stub_38>:
  1000be:	6a 00                	push   $0x0
  1000c0:	6a 26                	push   $0x26
  1000c2:	eb 3c                	jmp    100100 <intr_common_handler>

001000c4 <intr_stub_39>:
  1000c4:	6a 00                	push   $0x0
  1000c6:	6a 27                	push   $0x27
  1000c8:	eb 36                	jmp    100100 <intr_common_handler>

001000ca <intr_stub_40>:
  1000ca:	6a 00                	push   $0x0
  1000cc:	6a 28                	push   $0x28
  1000ce:	eb 30                	jmp    100100 <intr_common_handler>

001000d0 <intr_stub_41>:
  1000d0:	6a 00                	push   $0x0
  1000d2:	6a 29                	push   $0x29
  1000d4:	eb 2a                	jmp    100100 <intr_common_handler>

001000d6 <intr_stub_42>:
  1000d6:	6a 00                	push   $0x0
  1000d8:	6a 2a                	push   $0x2a
  1000da:	eb 24                	jmp    100100 <intr_common_handler>

001000dc <intr_stub_43>:
  1000dc:	6a 00                	push   $0x0
  1000de:	6a 2b                	push   $0x2b
  1000e0:	eb 1e                	jmp    100100 <intr_common_handler>

001000e2 <intr_stub_44>:
  1000e2:	6a 00                	push   $0x0
  1000e4:	6a 2c                	push   $0x2c
  1000e6:	eb 18                	jmp    100100 <intr_common_handler>

001000e8 <intr_stub_45>:
  1000e8:	6a 00                	push   $0x0
  1000ea:	6a 2d                	push   $0x2d
  1000ec:	eb 12                	jmp    100100 <intr_common_handler>

001000ee <intr_stub_46>:
  1000ee:	6a 00                	push   $0x0
  1000f0:	6a 2e                	push   $0x2e
  1000f2:	eb 0c                	jmp    100100 <intr_common_handler>

001000f4 <intr_stub_47>:
  1000f4:	6a 00                	push   $0x0
  1000f6:	6a 2f                	push   $0x2f
  1000f8:	eb 06                	jmp    100100 <intr_common_handler>

001000fa <intr_stub_48>:
  1000fa:	6a 00                	push   $0x0
  1000fc:	6a 30                	push   $0x30
  1000fe:	eb 00                	jmp    100100 <intr_common_handler>

00100100 <intr_common_handler>:
  100100:	55                   	push   %ebp
  100101:	57                   	push   %edi
  100102:	56                   	push   %esi
  100103:	52                   	push   %edx
  100104:	51                   	push   %ecx
  100105:	53                   	push   %ebx
  100106:	50                   	push   %eax
  100107:	54                   	push   %esp
  100108:	66 b8 10 00          	mov    $0x10,%ax
  10010c:	8e d8                	mov    %eax,%ds
  10010e:	8e c0                	mov    %eax,%es
  100110:	e8 d2 12 00 00       	call   1013e7 <handle_interrupt>
  100115:	89 c4                	mov    %eax,%esp
  100117:	66 b8 23 00          	mov    $0x23,%ax
  10011b:	8e d8                	mov    %eax,%ds
  10011d:	8e c0                	mov    %eax,%es
  10011f:	58                   	pop    %eax
  100120:	5b                   	pop    %ebx
  100121:	59                   	pop    %ecx
  100122:	5a                   	pop    %edx
  100123:	5e                   	pop    %esi
  100124:	5f                   	pop    %edi
  100125:	5d                   	pop    %ebp
  100126:	83 c4 08             	add    $0x8,%esp
  100129:	cf                   	iret   
	...

0010012c <_start>:
  10012c:	bc 00 80 11 00       	mov    $0x118000,%esp
  100131:	53                   	push   %ebx
  100132:	e8 05 00 00 00       	call   10013c <init>

00100137 <_stop>:
  100137:	fa                   	cli    
  100138:	f4                   	hlt    
  100139:	eb fc                	jmp    100137 <_stop>
	...

0010013c <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
  10013c:	55                   	push   %ebp
  10013d:	89 e5                	mov    %esp,%ebp
  10013f:	83 ec 08             	sub    $0x8,%esp
	clrscr();
  100142:	e8 c9 03 00 00       	call   100510 <clrscr>
	pmm_init(mb_info);
  100147:	83 ec 0c             	sub    $0xc,%esp
  10014a:	ff 75 08             	pushl  0x8(%ebp)
  10014d:	e8 06 1f 00 00       	call   102058 <pmm_init>
  100152:	83 c4 10             	add    $0x10,%esp

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100155:	83 ec 08             	sub    $0x8,%esp
  100158:	68 00 70 10 00       	push   $0x107000
  10015d:	68 14 70 10 00       	push   $0x107014
  100162:	e8 06 04 00 00       	call   10056d <kprintf>
  100167:	83 c4 10             	add    $0x10,%esp
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10016a:	83 ec 0c             	sub    $0xc,%esp
  10016d:	68 38 70 10 00       	push   $0x107038
  100172:	e8 f6 03 00 00       	call   10056d <kprintf>
  100177:	83 c4 10             	add    $0x10,%esp

	kprintf("Initializing GDT...\n");
  10017a:	83 ec 0c             	sub    $0xc,%esp
  10017d:	68 77 70 10 00       	push   $0x107077
  100182:	e8 e6 03 00 00       	call   10056d <kprintf>
  100187:	83 c4 10             	add    $0x10,%esp

	init_gdt();
  10018a:	e8 af 0b 00 00       	call   100d3e <init_gdt>

	kprintf("Initializing IDT...\n");
  10018f:	83 ec 0c             	sub    $0xc,%esp
  100192:	68 8c 70 10 00       	push   $0x10708c
  100197:	e8 d1 03 00 00       	call   10056d <kprintf>
  10019c:	83 c4 10             	add    $0x10,%esp

	init_idt();
  10019f:	e8 4f 0d 00 00       	call   100ef3 <init_idt>

	kprintf("Initializing Kernel...\n");
  1001a4:	83 ec 0c             	sub    $0xc,%esp
  1001a7:	68 a1 70 10 00       	push   $0x1070a1
  1001ac:	e8 bc 03 00 00       	call   10056d <kprintf>
  1001b1:	83 c4 10             	add    $0x10,%esp

	pmm_print_stats();
  1001b4:	e8 2c 1d 00 00       	call   101ee5 <pmm_print_stats>

	kernel_main(mb_info);
  1001b9:	83 ec 0c             	sub    $0xc,%esp
  1001bc:	ff 75 08             	pushl  0x8(%ebp)
  1001bf:	e8 bf 1a 00 00       	call   101c83 <kernel_main>
  1001c4:	83 c4 10             	add    $0x10,%esp

	return;
}
  1001c7:	c9                   	leave  
  1001c8:	c3                   	ret    
  1001c9:	00 00                	add    %al,(%eax)
	...

001001cc <in_cod>:
#include "catofdeath.h"

static uint32_t icod = 0;

uint32_t in_cod() {
  1001cc:	55                   	push   %ebp
  1001cd:	89 e5                	mov    %esp,%ebp
    return icod;
  1001cf:	a1 00 80 12 00       	mov    0x128000,%eax
}
  1001d4:	5d                   	pop    %ebp
  1001d5:	c3                   	ret    

001001d6 <show_cod>:

void show_cod(struct cpu_state* cpu, char* fstr) {
  1001d6:	55                   	push   %ebp
  1001d7:	89 e5                	mov    %esp,%ebp
  1001d9:	83 ec 08             	sub    $0x8,%esp
    icod = 1;
  1001dc:	c7 05 00 80 12 00 01 	movl   $0x1,0x128000
  1001e3:	00 00 00 
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
  1001e6:	83 ec 0c             	sub    $0xc,%esp
  1001e9:	6a 04                	push   $0x4
  1001eb:	e8 67 03 00 00       	call   100557 <setclr>
  1001f0:	83 c4 10             	add    $0x10,%esp
    kprintf(fstr);
  1001f3:	83 ec 0c             	sub    $0xc,%esp
  1001f6:	ff 75 0c             	pushl  0xc(%ebp)
  1001f9:	e8 6f 03 00 00       	call   10056d <kprintf>
  1001fe:	83 c4 10             	add    $0x10,%esp
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  100201:	8b 45 08             	mov    0x8(%ebp),%eax
  100204:	8b 50 20             	mov    0x20(%eax),%edx
  100207:	8b 45 08             	mov    0x8(%ebp),%eax
  10020a:	8b 40 1c             	mov    0x1c(%eax),%eax
  10020d:	83 ec 04             	sub    $0x4,%esp
  100210:	52                   	push   %edx
  100211:	50                   	push   %eax
  100212:	68 bc 70 10 00       	push   $0x1070bc
  100217:	e8 51 03 00 00       	call   10056d <kprintf>
  10021c:	83 c4 10             	add    $0x10,%esp
    show_dump(cpu);
  10021f:	83 ec 0c             	sub    $0xc,%esp
  100222:	ff 75 08             	pushl  0x8(%ebp)
  100225:	e8 07 00 00 00       	call   100231 <show_dump>
  10022a:	83 c4 10             	add    $0x10,%esp

    while (1) {
        asm volatile("cli; hlt");
  10022d:	fa                   	cli    
  10022e:	f4                   	hlt    
    }
  10022f:	eb fc                	jmp    10022d <show_cod+0x57>

00100231 <show_dump>:
}

void show_dump(struct cpu_state* cpu) {
  100231:	55                   	push   %ebp
  100232:	89 e5                	mov    %esp,%ebp
  100234:	53                   	push   %ebx
  100235:	83 ec 14             	sub    $0x14,%esp
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  100238:	8b 45 08             	mov    0x8(%ebp),%eax
  10023b:	8b 58 0c             	mov    0xc(%eax),%ebx
  10023e:	8b 45 08             	mov    0x8(%ebp),%eax
  100241:	8b 48 08             	mov    0x8(%eax),%ecx
  100244:	8b 45 08             	mov    0x8(%ebp),%eax
  100247:	8b 50 04             	mov    0x4(%eax),%edx
  10024a:	8b 45 08             	mov    0x8(%ebp),%eax
  10024d:	8b 00                	mov    (%eax),%eax
  10024f:	83 ec 0c             	sub    $0xc,%esp
  100252:	53                   	push   %ebx
  100253:	51                   	push   %ecx
  100254:	52                   	push   %edx
  100255:	50                   	push   %eax
  100256:	68 e4 70 10 00       	push   $0x1070e4
  10025b:	e8 0d 03 00 00       	call   10056d <kprintf>
  100260:	83 c4 20             	add    $0x20,%esp
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  100263:	8b 45 08             	mov    0x8(%ebp),%eax
  100266:	8b 58 24             	mov    0x24(%eax),%ebx
  100269:	8b 45 08             	mov    0x8(%ebp),%eax
  10026c:	8b 48 18             	mov    0x18(%eax),%ecx
  10026f:	8b 45 08             	mov    0x8(%ebp),%eax
  100272:	8b 50 14             	mov    0x14(%eax),%edx
  100275:	8b 45 08             	mov    0x8(%ebp),%eax
  100278:	8b 40 10             	mov    0x10(%eax),%eax
  10027b:	83 ec 0c             	sub    $0xc,%esp
  10027e:	53                   	push   %ebx
  10027f:	51                   	push   %ecx
  100280:	52                   	push   %edx
  100281:	50                   	push   %eax
  100282:	68 08 71 10 00       	push   $0x107108
  100287:	e8 e1 02 00 00       	call   10056d <kprintf>
  10028c:	83 c4 20             	add    $0x20,%esp
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
  10028f:	8b 45 08             	mov    0x8(%ebp),%eax
  100292:	8b 58 34             	mov    0x34(%eax),%ebx
  100295:	8b 45 08             	mov    0x8(%ebp),%eax
  100298:	8b 48 30             	mov    0x30(%eax),%ecx
  10029b:	8b 45 08             	mov    0x8(%ebp),%eax
  10029e:	8b 50 2c             	mov    0x2c(%eax),%edx
  1002a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002a4:	8b 40 28             	mov    0x28(%eax),%eax
  1002a7:	83 ec 0c             	sub    $0xc,%esp
  1002aa:	53                   	push   %ebx
  1002ab:	51                   	push   %ecx
  1002ac:	52                   	push   %edx
  1002ad:	50                   	push   %eax
  1002ae:	68 2c 71 10 00       	push   $0x10712c
  1002b3:	e8 b5 02 00 00       	call   10056d <kprintf>
  1002b8:	83 c4 20             	add    $0x20,%esp
            cpu->esp, cpu->ss);

    uint32_t cr2 = 0;
  1002bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  1002c2:	0f 20 d0             	mov    %cr2,%eax
  1002c5:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kprintf("CR2: %x \n", cr2);
  1002c8:	83 ec 08             	sub    $0x8,%esp
  1002cb:	ff 75 f4             	pushl  -0xc(%ebp)
  1002ce:	68 4e 71 10 00       	push   $0x10714e
  1002d3:	e8 95 02 00 00       	call   10056d <kprintf>
  1002d8:	83 c4 10             	add    $0x10,%esp
}
  1002db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1002de:	c9                   	leave  
  1002df:	c3                   	ret    

001002e0 <kputc>:
}

void show_cod(struct cpu_state* cpu, char* fstr) {
    icod = 1;
#ifdef SCREEN_COD
    clrscr();
  1002e0:	55                   	push   %ebp
  1002e1:	89 e5                	mov    %esp,%ebp
  1002e3:	83 ec 28             	sub    $0x28,%esp
  1002e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002e9:	88 45 e4             	mov    %al,-0x1c(%ebp)

  1002ec:	e8 db fe ff ff       	call   1001cc <in_cod>
  1002f1:	85 c0                	test   %eax,%eax
  1002f3:	75 79                	jne    10036e <kputc+0x8e>
    kprintf ("        (`. \n");
    kprintf ("         ) ) \n");
    kprintf ("        ( ( \n");
    kprintf ("         \\ \\ \n");
  1002f5:	e8 af 29 00 00       	call   102ca9 <get_current_task>
  1002fa:	85 c0                	test   %eax,%eax
  1002fc:	74 61                	je     10035f <kputc+0x7f>
    kprintf ("          \\ \\ \n");
  1002fe:	e8 a6 29 00 00       	call   102ca9 <get_current_task>
  100303:	8b 40 30             	mov    0x30(%eax),%eax
  100306:	85 c0                	test   %eax,%eax
  100308:	74 55                	je     10035f <kputc+0x7f>
    kprintf ("        .-'  `-. \n");
  10030a:	c6 45 f3 11          	movb   $0x11,-0xd(%ebp)
  10030e:	e8 96 29 00 00       	call   102ca9 <get_current_task>
  100313:	8b 40 30             	mov    0x30(%eax),%eax
  100316:	6a 01                	push   $0x1
  100318:	6a 01                	push   $0x1
  10031a:	8d 55 f3             	lea    -0xd(%ebp),%edx
  10031d:	52                   	push   %edx
  10031e:	50                   	push   %eax
  10031f:	e8 c5 40 00 00       	call   1043e9 <vfs_write>
  100324:	83 c4 10             	add    $0x10,%esp
    kprintf ("       /        `. \n");
  100327:	e8 7d 29 00 00       	call   102ca9 <get_current_task>
  10032c:	8b 40 30             	mov    0x30(%eax),%eax
  10032f:	6a 01                	push   $0x1
  100331:	6a 01                	push   $0x1
  100333:	68 00 60 10 00       	push   $0x106000
  100338:	50                   	push   %eax
  100339:	e8 ab 40 00 00       	call   1043e9 <vfs_write>
  10033e:	83 c4 10             	add    $0x10,%esp
    kprintf ("      (      )    `-._ ,    _ \n");
  100341:	e8 63 29 00 00       	call   102ca9 <get_current_task>
  100346:	8b 40 30             	mov    0x30(%eax),%eax
  100349:	6a 01                	push   $0x1
  10034b:	6a 01                	push   $0x1
  10034d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  100350:	52                   	push   %edx
  100351:	50                   	push   %eax
  100352:	e8 92 40 00 00       	call   1043e9 <vfs_write>
  100357:	83 c4 10             	add    $0x10,%esp
    kprintf ("       )   ,'         (.\\--'( \n");
    kprintf ("       \\  (         ) /      \\ \n");
  10035a:	e9 1a 01 00 00       	jmp    100479 <kputc+0x199>
    kprintf ("        \\  \\_(     / (    <6 (6 \n");
    kprintf ("         \\_)))\\   (   `._  .:Y)__ \n");
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
  10035f:	e8 46 27 00 00       	call   102aaa <ramfs_vga_writers>
  100364:	85 c0                	test   %eax,%eax
  100366:	0f 85 09 01 00 00    	jne    100475 <kputc+0x195>
  10036c:	eb 01                	jmp    10036f <kputc+0x8f>
void show_cod(struct cpu_state* cpu, char* fstr) {
    icod = 1;
#ifdef SCREEN_COD
    clrscr();

    kprintf ("        (`. \n");
  10036e:	90                   	nop    
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
    kprintf(fstr);
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  10036f:	8a 45 e4             	mov    -0x1c(%ebp),%al
  100372:	3c 0a                	cmp    $0xa,%al
  100374:	74 0a                	je     100380 <kputc+0xa0>
  100376:	a1 04 80 12 00       	mov    0x128004,%eax
  10037b:	83 f8 4f             	cmp    $0x4f,%eax
  10037e:	7e 15                	jle    100395 <kputc+0xb5>
    show_dump(cpu);
  100380:	c7 05 04 80 12 00 00 	movl   $0x0,0x128004
  100387:	00 00 00 

  10038a:	a1 08 80 12 00       	mov    0x128008,%eax
  10038f:	40                   	inc    %eax
  100390:	a3 08 80 12 00       	mov    %eax,0x128008
    while (1) {
        asm volatile("cli; hlt");
    }
  100395:	8a 45 e4             	mov    -0x1c(%ebp),%al
  100398:	3c 0a                	cmp    $0xa,%al
  10039a:	0f 84 d8 00 00 00    	je     100478 <kputc+0x198>
}

void show_dump(struct cpu_state* cpu) {
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  1003a0:	a1 08 80 12 00       	mov    0x128008,%eax
  1003a5:	83 f8 18             	cmp    $0x18,%eax
  1003a8:	7e 5c                	jle    100406 <kputc+0x126>
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  1003aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1003b1:	eb 22                	jmp    1003d5 <kputc+0xf5>
            cpu->eip);
  1003b3:	8b 15 04 60 10 00    	mov    0x106004,%edx
  1003b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003bc:	01 c2                	add    %eax,%edx
  1003be:	a1 04 60 10 00       	mov    0x106004,%eax
  1003c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1003c6:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
  1003cc:	01 c8                	add    %ecx,%eax
  1003ce:	8a 00                	mov    (%eax),%al
  1003d0:	88 02                	mov    %al,(%edx)
}

void show_dump(struct cpu_state* cpu) {
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  1003d2:	ff 45 f4             	incl   -0xc(%ebp)
  1003d5:	81 7d f4 ff 0e 00 00 	cmpl   $0xeff,-0xc(%ebp)
  1003dc:	7e d5                	jle    1003b3 <kputc+0xd3>
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
            cpu->esp, cpu->ss);

  1003de:	eb 12                	jmp    1003f2 <kputc+0x112>
    uint32_t cr2 = 0;
  1003e0:	8b 15 04 60 10 00    	mov    0x106004,%edx
  1003e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003e9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1003ec:	c6 00 00             	movb   $0x0,(%eax)
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
            cpu->esp, cpu->ss);

  1003ef:	ff 45 f4             	incl   -0xc(%ebp)
  1003f2:	81 7d f4 9f 0f 00 00 	cmpl   $0xf9f,-0xc(%ebp)
  1003f9:	7e e5                	jle    1003e0 <kputc+0x100>
    uint32_t cr2 = 0;

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  1003fb:	a1 08 80 12 00       	mov    0x128008,%eax
  100400:	48                   	dec    %eax
  100401:	a3 08 80 12 00       	mov    %eax,0x128008

    kprintf("CR2: %x \n", cr2);
}
  100406:	8b 0d 04 60 10 00    	mov    0x106004,%ecx
  10040c:	8b 15 08 80 12 00    	mov    0x128008,%edx
  100412:	89 d0                	mov    %edx,%eax
  100414:	c1 e0 02             	shl    $0x2,%eax
  100417:	01 d0                	add    %edx,%eax
  100419:	c1 e0 04             	shl    $0x4,%eax
  10041c:	89 c2                	mov    %eax,%edx
  10041e:	a1 04 80 12 00       	mov    0x128004,%eax
  100423:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100426:	01 c0                	add    %eax,%eax
  100428:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  10042b:	8a 45 e4             	mov    -0x1c(%ebp),%al
  10042e:	88 02                	mov    %al,(%edx)
  100430:	8b 0d 04 60 10 00    	mov    0x106004,%ecx
  100436:	8b 15 08 80 12 00    	mov    0x128008,%edx
  10043c:	89 d0                	mov    %edx,%eax
  10043e:	c1 e0 02             	shl    $0x2,%eax
  100441:	01 d0                	add    %edx,%eax
  100443:	c1 e0 04             	shl    $0x4,%eax
  100446:	89 c2                	mov    %eax,%edx
  100448:	a1 04 80 12 00       	mov    0x128004,%eax
  10044d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100450:	01 c0                	add    %eax,%eax
  100452:	40                   	inc    %eax
  100453:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  100456:	a0 00 60 10 00       	mov    0x106000,%al
  10045b:	88 02                	mov    %al,(%edx)
  10045d:	a1 04 80 12 00       	mov    0x128004,%eax
  100462:	40                   	inc    %eax
  100463:	a3 04 80 12 00       	mov    %eax,0x128004
  100468:	a1 0c 80 12 00       	mov    0x12800c,%eax
  10046d:	40                   	inc    %eax
  10046e:	a3 0c 80 12 00       	mov    %eax,0x12800c
  100473:	eb 04                	jmp    100479 <kputc+0x199>
    kprintf ("       \\  (         ) /      \\ \n");
    kprintf ("        \\  \\_(     / (    <6 (6 \n");
    kprintf ("         \\_)))\\   (   `._  .:Y)__ \n");
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
  100475:	90                   	nop    
  100476:	eb 01                	jmp    100479 <kputc+0x199>
    show_dump(cpu);

    while (1) {
        asm volatile("cli; hlt");
    }
}
  100478:	90                   	nop    
}
  100479:	c9                   	leave  
  10047a:	c3                   	ret    

0010047b <kputs>:
  10047b:	55                   	push   %ebp
  10047c:	89 e5                	mov    %esp,%ebp
  10047e:	83 ec 08             	sub    $0x8,%esp
  100481:	eb 17                	jmp    10049a <kputs+0x1f>
  100483:	8b 45 08             	mov    0x8(%ebp),%eax
  100486:	8a 00                	mov    (%eax),%al
  100488:	0f be c0             	movsbl %al,%eax
  10048b:	ff 45 08             	incl   0x8(%ebp)
  10048e:	83 ec 0c             	sub    $0xc,%esp
  100491:	50                   	push   %eax
  100492:	e8 49 fe ff ff       	call   1002e0 <kputc>
  100497:	83 c4 10             	add    $0x10,%esp
  10049a:	8b 45 08             	mov    0x8(%ebp),%eax
  10049d:	8a 00                	mov    (%eax),%al
  10049f:	84 c0                	test   %al,%al
  1004a1:	75 e0                	jne    100483 <kputs+0x8>
  1004a3:	c9                   	leave  
  1004a4:	c3                   	ret    

001004a5 <kputn>:
  1004a5:	55                   	push   %ebp
  1004a6:	89 e5                	mov    %esp,%ebp
  1004a8:	83 ec 58             	sub    $0x58,%esp
  1004ab:	c7 45 f0 58 71 10 00 	movl   $0x107158,-0x10(%ebp)
  1004b2:	83 7d 0c 24          	cmpl   $0x24,0xc(%ebp)
  1004b6:	7f 55                	jg     10050d <kputn+0x68>
  1004b8:	8d 45 af             	lea    -0x51(%ebp),%eax
  1004bb:	83 c0 40             	add    $0x40,%eax
  1004be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1004c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1004c4:	c6 00 00             	movb   $0x0,(%eax)
  1004c7:	ff 4d f4             	decl   -0xc(%ebp)
  1004ca:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1004d0:	89 d1                	mov    %edx,%ecx
  1004d2:	ba 00 00 00 00       	mov    $0x0,%edx
  1004d7:	f7 f1                	div    %ecx
  1004d9:	89 d0                	mov    %edx,%eax
  1004db:	03 45 f0             	add    -0x10(%ebp),%eax
  1004de:	8a 10                	mov    (%eax),%dl
  1004e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1004e3:	88 10                	mov    %dl,(%eax)
  1004e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1004eb:	89 d1                	mov    %edx,%ecx
  1004ed:	ba 00 00 00 00       	mov    $0x0,%edx
  1004f2:	f7 f1                	div    %ecx
  1004f4:	89 45 08             	mov    %eax,0x8(%ebp)
  1004f7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1004fb:	75 ca                	jne    1004c7 <kputn+0x22>
  1004fd:	83 ec 0c             	sub    $0xc,%esp
  100500:	ff 75 f4             	pushl  -0xc(%ebp)
  100503:	e8 73 ff ff ff       	call   10047b <kputs>
  100508:	83 c4 10             	add    $0x10,%esp
  10050b:	eb 01                	jmp    10050e <kputn+0x69>
  10050d:	90                   	nop    
  10050e:	c9                   	leave  
  10050f:	c3                   	ret    

00100510 <clrscr>:
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	83 ec 10             	sub    $0x10,%esp
  100516:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10051d:	eb 12                	jmp    100531 <clrscr+0x21>
  10051f:	8b 15 04 60 10 00    	mov    0x106004,%edx
  100525:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100528:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10052b:	c6 00 00             	movb   $0x0,(%eax)
  10052e:	ff 45 fc             	incl   -0x4(%ebp)
  100531:	81 7d fc 9f 0f 00 00 	cmpl   $0xf9f,-0x4(%ebp)
  100538:	7e e5                	jle    10051f <clrscr+0xf>
  10053a:	c6 05 00 60 10 00 07 	movb   $0x7,0x106000
  100541:	c7 05 08 80 12 00 00 	movl   $0x0,0x128008
  100548:	00 00 00 
  10054b:	a1 08 80 12 00       	mov    0x128008,%eax
  100550:	a3 04 80 12 00       	mov    %eax,0x128004
  100555:	c9                   	leave  
  100556:	c3                   	ret    

00100557 <setclr>:
  100557:	55                   	push   %ebp
  100558:	89 e5                	mov    %esp,%ebp
  10055a:	83 ec 04             	sub    $0x4,%esp
  10055d:	8b 45 08             	mov    0x8(%ebp),%eax
  100560:	88 45 fc             	mov    %al,-0x4(%ebp)
  100563:	8a 45 fc             	mov    -0x4(%ebp),%al
  100566:	a2 00 60 10 00       	mov    %al,0x106000
  10056b:	c9                   	leave  
  10056c:	c3                   	ret    

0010056d <kprintf>:
  10056d:	55                   	push   %ebp
  10056e:	89 e5                	mov    %esp,%ebp
  100570:	83 ec 18             	sub    $0x18,%esp
  100573:	8d 45 0c             	lea    0xc(%ebp),%eax
  100576:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100579:	c7 05 0c 80 12 00 00 	movl   $0x0,0x12800c
  100580:	00 00 00 
  100583:	e9 35 01 00 00       	jmp    1006bd <kprintf+0x150>
  100588:	8b 45 08             	mov    0x8(%ebp),%eax
  10058b:	8a 00                	mov    (%eax),%al
  10058d:	3c 25                	cmp    $0x25,%al
  10058f:	0f 85 11 01 00 00    	jne    1006a6 <kprintf+0x139>
  100595:	ff 45 08             	incl   0x8(%ebp)
  100598:	8b 45 08             	mov    0x8(%ebp),%eax
  10059b:	8a 00                	mov    (%eax),%al
  10059d:	0f be c0             	movsbl %al,%eax
  1005a0:	83 f8 70             	cmp    $0x70,%eax
  1005a3:	0f 84 8a 00 00 00    	je     100633 <kprintf+0xc6>
  1005a9:	83 f8 70             	cmp    $0x70,%eax
  1005ac:	7f 2e                	jg     1005dc <kprintf+0x6f>
  1005ae:	83 f8 63             	cmp    $0x63,%eax
  1005b1:	0f 84 9c 00 00 00    	je     100653 <kprintf+0xe6>
  1005b7:	83 f8 63             	cmp    $0x63,%eax
  1005ba:	7f 16                	jg     1005d2 <kprintf+0x65>
  1005bc:	85 c0                	test   %eax,%eax
  1005be:	0f 84 08 01 00 00    	je     1006cc <kprintf+0x15f>
  1005c4:	83 f8 25             	cmp    $0x25,%eax
  1005c7:	0f 84 a6 00 00 00    	je     100673 <kprintf+0x106>
  1005cd:	e9 b1 00 00 00       	jmp    100683 <kprintf+0x116>
  1005d2:	83 f8 64             	cmp    $0x64,%eax
  1005d5:	74 39                	je     100610 <kprintf+0xa3>
  1005d7:	e9 a7 00 00 00       	jmp    100683 <kprintf+0x116>
  1005dc:	83 f8 75             	cmp    $0x75,%eax
  1005df:	74 2f                	je     100610 <kprintf+0xa3>
  1005e1:	83 f8 78             	cmp    $0x78,%eax
  1005e4:	74 4d                	je     100633 <kprintf+0xc6>
  1005e6:	83 f8 73             	cmp    $0x73,%eax
  1005e9:	0f 85 94 00 00 00    	jne    100683 <kprintf+0x116>
  1005ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005f2:	8d 50 04             	lea    0x4(%eax),%edx
  1005f5:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1005f8:	8b 00                	mov    (%eax),%eax
  1005fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1005fd:	83 ec 0c             	sub    $0xc,%esp
  100600:	ff 75 ec             	pushl  -0x14(%ebp)
  100603:	e8 73 fe ff ff       	call   10047b <kputs>
  100608:	83 c4 10             	add    $0x10,%esp
  10060b:	e9 aa 00 00 00       	jmp    1006ba <kprintf+0x14d>
  100610:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100613:	8d 50 04             	lea    0x4(%eax),%edx
  100616:	89 55 e8             	mov    %edx,-0x18(%ebp)
  100619:	8b 00                	mov    (%eax),%eax
  10061b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10061e:	83 ec 08             	sub    $0x8,%esp
  100621:	6a 0a                	push   $0xa
  100623:	ff 75 f0             	pushl  -0x10(%ebp)
  100626:	e8 7a fe ff ff       	call   1004a5 <kputn>
  10062b:	83 c4 10             	add    $0x10,%esp
  10062e:	e9 87 00 00 00       	jmp    1006ba <kprintf+0x14d>
  100633:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100636:	8d 50 04             	lea    0x4(%eax),%edx
  100639:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10063c:	8b 00                	mov    (%eax),%eax
  10063e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100641:	83 ec 08             	sub    $0x8,%esp
  100644:	6a 10                	push   $0x10
  100646:	ff 75 f0             	pushl  -0x10(%ebp)
  100649:	e8 57 fe ff ff       	call   1004a5 <kputn>
  10064e:	83 c4 10             	add    $0x10,%esp
  100651:	eb 67                	jmp    1006ba <kprintf+0x14d>
  100653:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100656:	8d 50 04             	lea    0x4(%eax),%edx
  100659:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10065c:	8b 00                	mov    (%eax),%eax
  10065e:	88 45 f7             	mov    %al,-0x9(%ebp)
  100661:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
  100665:	83 ec 0c             	sub    $0xc,%esp
  100668:	50                   	push   %eax
  100669:	e8 72 fc ff ff       	call   1002e0 <kputc>
  10066e:	83 c4 10             	add    $0x10,%esp
  100671:	eb 47                	jmp    1006ba <kprintf+0x14d>
  100673:	83 ec 0c             	sub    $0xc,%esp
  100676:	6a 25                	push   $0x25
  100678:	e8 63 fc ff ff       	call   1002e0 <kputc>
  10067d:	83 c4 10             	add    $0x10,%esp
  100680:	90                   	nop    
  100681:	eb 37                	jmp    1006ba <kprintf+0x14d>
  100683:	83 ec 0c             	sub    $0xc,%esp
  100686:	6a 25                	push   $0x25
  100688:	e8 53 fc ff ff       	call   1002e0 <kputc>
  10068d:	83 c4 10             	add    $0x10,%esp
  100690:	8b 45 08             	mov    0x8(%ebp),%eax
  100693:	8a 00                	mov    (%eax),%al
  100695:	0f be c0             	movsbl %al,%eax
  100698:	83 ec 0c             	sub    $0xc,%esp
  10069b:	50                   	push   %eax
  10069c:	e8 3f fc ff ff       	call   1002e0 <kputc>
  1006a1:	83 c4 10             	add    $0x10,%esp
  1006a4:	eb 14                	jmp    1006ba <kprintf+0x14d>
  1006a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1006a9:	8a 00                	mov    (%eax),%al
  1006ab:	0f be c0             	movsbl %al,%eax
  1006ae:	83 ec 0c             	sub    $0xc,%esp
  1006b1:	50                   	push   %eax
  1006b2:	e8 29 fc ff ff       	call   1002e0 <kputc>
  1006b7:	83 c4 10             	add    $0x10,%esp
  1006ba:	ff 45 08             	incl   0x8(%ebp)
  1006bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1006c0:	8a 00                	mov    (%eax),%al
  1006c2:	84 c0                	test   %al,%al
  1006c4:	0f 85 be fe ff ff    	jne    100588 <kprintf+0x1b>
  1006ca:	eb 01                	jmp    1006cd <kprintf+0x160>
  1006cc:	90                   	nop    
  1006cd:	a1 0c 80 12 00       	mov    0x12800c,%eax
  1006d2:	c9                   	leave  
  1006d3:	c3                   	ret    

001006d4 <inb>:
}

void show_cod(struct cpu_state* cpu, char* fstr) {
    icod = 1;
#ifdef SCREEN_COD
    clrscr();
  1006d4:	55                   	push   %ebp
  1006d5:	89 e5                	mov    %esp,%ebp
  1006d7:	83 ec 14             	sub    $0x14,%esp
  1006da:	8b 45 08             	mov    0x8(%ebp),%eax
  1006dd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)

    kprintf ("        (`. \n");
  1006e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1006e4:	89 c2                	mov    %eax,%edx
  1006e6:	ec                   	in     (%dx),%al
  1006e7:	88 45 ff             	mov    %al,-0x1(%ebp)
    kprintf ("         ) ) \n");
  1006ea:	8a 45 ff             	mov    -0x1(%ebp),%al
    kprintf ("        ( ( \n");
  1006ed:	c9                   	leave  
  1006ee:	c3                   	ret    

001006ef <outb>:
    kprintf ("       \\  (         ) /      \\ \n");
    kprintf ("        \\  \\_(     / (    <6 (6 \n");
    kprintf ("         \\_)))\\   (   `._  .:Y)__ \n");
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
  1006ef:	55                   	push   %ebp
  1006f0:	89 e5                	mov    %esp,%ebp
  1006f2:	83 ec 08             	sub    $0x8,%esp
  1006f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1006f8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1006fb:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  1006ff:	88 55 f8             	mov    %dl,-0x8(%ebp)
#endif
  100702:	8a 45 f8             	mov    -0x8(%ebp),%al
  100705:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100708:	ee                   	out    %al,(%dx)

  100709:	c9                   	leave  
  10070a:	c3                   	ret    

0010070b <translate_scancode>:
uint32_t key_flags[256];

struct res_handle* charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
  10070b:	55                   	push   %ebp
  10070c:	89 e5                	mov    %esp,%ebp
  10070e:	83 ec 28             	sub    $0x28,%esp
  100711:	8b 45 0c             	mov    0xc(%ebp),%eax
  100714:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    uint8_t keycode = 0;
  100718:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    switch (set) {
  10071c:	8b 45 08             	mov    0x8(%ebp),%eax
  10071f:	83 f8 01             	cmp    $0x1,%eax
  100722:	74 1c                	je     100740 <translate_scancode+0x35>
  100724:	83 f8 02             	cmp    $0x2,%eax
  100727:	74 2a                	je     100753 <translate_scancode+0x48>
  100729:	85 c0                	test   %eax,%eax
  10072b:	75 3f                	jne    10076c <translate_scancode+0x61>
        // Normal scancodes
        case 0:
            keycode = sc_to_kc[0][scancode];
  10072d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100730:	25 ff ff 00 00       	and    $0xffff,%eax
  100735:	8a 80 20 60 10 00    	mov    0x106020(%eax),%al
  10073b:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
  10073e:	eb 2c                	jmp    10076c <translate_scancode+0x61>

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
  100740:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100743:	25 ff ff 00 00       	and    $0xffff,%eax
  100748:	8a 80 a0 60 10 00    	mov    0x1060a0(%eax),%al
  10074e:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
  100751:	eb 19                	jmp    10076c <translate_scancode+0x61>

        // e1-Scancodes
        case 2:
            switch (scancode) {
  100753:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100756:	25 ff ff 00 00       	and    $0xffff,%eax
  10075b:	3d 1d 45 00 00       	cmp    $0x451d,%eax
  100760:	75 06                	jne    100768 <translate_scancode+0x5d>
                // Pause
                case 0x451D:
                    keycode = 119;
  100762:	c6 45 f7 77          	movb   $0x77,-0x9(%ebp)
                    break;
  100766:	eb 04                	jmp    10076c <translate_scancode+0x61>

                default:
                    keycode = 0x0;
  100768:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
            };
            break;
    }

    if (keycode == 0) {
  10076c:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  100770:	75 1c                	jne    10078e <translate_scancode+0x83>
        kprintf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
  100772:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  100775:	25 ff ff 00 00       	and    $0xffff,%eax
  10077a:	83 ec 04             	sub    $0x4,%esp
  10077d:	ff 75 08             	pushl  0x8(%ebp)
  100780:	50                   	push   %eax
  100781:	68 80 71 10 00       	push   $0x107180
  100786:	e8 e2 fd ff ff       	call   10056d <kprintf>
  10078b:	83 c4 10             	add    $0x10,%esp
    }

    return keycode;
  10078e:	8a 45 f7             	mov    -0x9(%ebp),%al
}
  100791:	c9                   	leave  
  100792:	c3                   	ret    

00100793 <getchar>:

static char getchar(uint8_t keycode) {
  100793:	55                   	push   %ebp
  100794:	89 e5                	mov    %esp,%ebp
  100796:	83 ec 14             	sub    $0x14,%esp
  100799:	8b 45 08             	mov    0x8(%ebp),%eax
  10079c:	88 45 ec             	mov    %al,-0x14(%ebp)
    uint32_t index = 0;
  10079f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
  1007a6:	a1 48 86 12 00       	mov    0x128648,%eax
  1007ab:	83 e0 01             	and    $0x1,%eax
  1007ae:	84 c0                	test   %al,%al
  1007b0:	74 07                	je     1007b9 <getchar+0x26>
  1007b2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
  1007b9:	a1 78 86 12 00       	mov    0x128678,%eax
  1007be:	83 e0 01             	and    $0x1,%eax
  1007c1:	84 c0                	test   %al,%al
  1007c3:	74 07                	je     1007cc <getchar+0x39>
  1007c5:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

    return kc_to_char[index][keycode];
  1007cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1007cf:	b8 00 00 00 00       	mov    $0x0,%eax
  1007d4:	8a 45 ec             	mov    -0x14(%ebp),%al
  1007d7:	c1 e2 07             	shl    $0x7,%edx
  1007da:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1007dd:	05 20 61 10 00       	add    $0x106120,%eax
  1007e2:	8a 00                	mov    (%eax),%al
}
  1007e4:	c9                   	leave  
  1007e5:	c3                   	ret    

001007e6 <send_command>:

static void send_command(uint8_t command)
{
  1007e6:	55                   	push   %ebp
  1007e7:	89 e5                	mov    %esp,%ebp
  1007e9:	83 ec 04             	sub    $0x4,%esp
  1007ec:	8b 45 08             	mov    0x8(%ebp),%eax
  1007ef:	88 45 fc             	mov    %al,-0x4(%ebp)
    do {
        while (inb(0x64) & 0x2) {
  1007f2:	6a 64                	push   $0x64
  1007f4:	e8 db fe ff ff       	call   1006d4 <inb>
  1007f9:	83 c4 04             	add    $0x4,%esp
  1007fc:	25 ff 00 00 00       	and    $0xff,%eax
  100801:	83 e0 02             	and    $0x2,%eax
  100804:	85 c0                	test   %eax,%eax
  100806:	75 ea                	jne    1007f2 <send_command+0xc>
        }

        outb(0x60, command);
  100808:	b8 00 00 00 00       	mov    $0x0,%eax
  10080d:	8a 45 fc             	mov    -0x4(%ebp),%al
  100810:	50                   	push   %eax
  100811:	6a 60                	push   $0x60
  100813:	e8 d7 fe ff ff       	call   1006ef <outb>
  100818:	83 c4 08             	add    $0x8,%esp

        while ((inb(0x64) & 0x1) == 0) {
  10081b:	6a 64                	push   $0x64
  10081d:	e8 b2 fe ff ff       	call   1006d4 <inb>
  100822:	83 c4 04             	add    $0x4,%esp
  100825:	25 ff 00 00 00       	and    $0xff,%eax
  10082a:	83 e0 01             	and    $0x1,%eax
  10082d:	85 c0                	test   %eax,%eax
  10082f:	74 ea                	je     10081b <send_command+0x35>
        }
    } while (inb(0x60) == 0xfe);
  100831:	6a 60                	push   $0x60
  100833:	e8 9c fe ff ff       	call   1006d4 <inb>
  100838:	83 c4 04             	add    $0x4,%esp
  10083b:	3c fe                	cmp    $0xfe,%al
  10083d:	74 b3                	je     1007f2 <send_command+0xc>
}
  10083f:	c9                   	leave  
  100840:	c3                   	ret    

00100841 <irq_handler>:

void irq_handler() {
  100841:	55                   	push   %ebp
  100842:	89 e5                	mov    %esp,%ebp
  100844:	83 ec 18             	sub    $0x18,%esp
    uint8_t scancode;
    uint8_t keycode = 0;
  100847:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int break_code = 0;
  10084b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
  100852:	a1 10 80 12 00       	mov    0x128010,%eax
  100857:	85 c0                	test   %eax,%eax
  100859:	0f 84 d2 01 00 00    	je     100a31 <irq_handler+0x1f0>

    scancode = inb(0x60);
  10085f:	6a 60                	push   $0x60
  100861:	e8 6e fe ff ff       	call   1006d4 <inb>
  100866:	83 c4 04             	add    $0x4,%esp
  100869:	88 45 f2             	mov    %al,-0xe(%ebp)

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
  10086c:	8a 45 f2             	mov    -0xe(%ebp),%al
  10086f:	84 c0                	test   %al,%al
  100871:	79 29                	jns    10089c <irq_handler+0x5b>
        (e1_code || (scancode != 0xE1)) &&
  100873:	a1 18 80 12 00       	mov    0x128018,%eax

    scancode = inb(0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
  100878:	85 c0                	test   %eax,%eax
  10087a:	75 06                	jne    100882 <irq_handler+0x41>
  10087c:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
  100880:	74 1a                	je     10089c <irq_handler+0x5b>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
  100882:	a1 1c 80 12 00       	mov    0x12801c,%eax

    scancode = inb(0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
  100887:	85 c0                	test   %eax,%eax
  100889:	75 06                	jne    100891 <irq_handler+0x50>
  10088b:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
  10088f:	74 0b                	je     10089c <irq_handler+0x5b>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
  100891:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        scancode &= ~0x80;
  100898:	80 65 f2 7f          	andb   $0x7f,-0xe(%ebp)
    }

    if (e0_code) {
  10089c:	a1 1c 80 12 00       	mov    0x12801c,%eax
  1008a1:	85 c0                	test   %eax,%eax
  1008a3:	74 43                	je     1008e8 <irq_handler+0xa7>
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
  1008a5:	80 7d f2 2a          	cmpb   $0x2a,-0xe(%ebp)
  1008a9:	74 06                	je     1008b1 <irq_handler+0x70>
  1008ab:	80 7d f2 36          	cmpb   $0x36,-0xe(%ebp)
  1008af:	75 0f                	jne    1008c0 <irq_handler+0x7f>
            e0_code = 0;
  1008b1:	c7 05 1c 80 12 00 00 	movl   $0x0,0x12801c
  1008b8:	00 00 00 
            return;
  1008bb:	e9 72 01 00 00       	jmp    100a32 <irq_handler+0x1f1>
        }

        keycode = translate_scancode(1, scancode);
  1008c0:	b8 00 00 00 00       	mov    $0x0,%eax
  1008c5:	8a 45 f2             	mov    -0xe(%ebp),%al
  1008c8:	83 ec 08             	sub    $0x8,%esp
  1008cb:	50                   	push   %eax
  1008cc:	6a 01                	push   $0x1
  1008ce:	e8 38 fe ff ff       	call   10070b <translate_scancode>
  1008d3:	83 c4 10             	add    $0x10,%esp
  1008d6:	88 45 f3             	mov    %al,-0xd(%ebp)
        e0_code = 0;
  1008d9:	c7 05 1c 80 12 00 00 	movl   $0x0,0x12801c
  1008e0:	00 00 00 
  1008e3:	e9 af 00 00 00       	jmp    100997 <irq_handler+0x156>
    } else if (e1_code == 2) {
  1008e8:	a1 18 80 12 00       	mov    0x128018,%eax
  1008ed:	83 f8 02             	cmp    $0x2,%eax
  1008f0:	75 43                	jne    100935 <irq_handler+0xf4>
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
  1008f2:	b8 00 00 00 00       	mov    $0x0,%eax
  1008f7:	8a 45 f2             	mov    -0xe(%ebp),%al
  1008fa:	c1 e0 08             	shl    $0x8,%eax
  1008fd:	89 c2                	mov    %eax,%edx
  1008ff:	66 a1 20 80 12 00    	mov    0x128020,%ax
  100905:	09 d0                	or     %edx,%eax
  100907:	66 a3 20 80 12 00    	mov    %ax,0x128020
        keycode = translate_scancode(2, e1_prev);
  10090d:	66 a1 20 80 12 00    	mov    0x128020,%ax
  100913:	25 ff ff 00 00       	and    $0xffff,%eax
  100918:	83 ec 08             	sub    $0x8,%esp
  10091b:	50                   	push   %eax
  10091c:	6a 02                	push   $0x2
  10091e:	e8 e8 fd ff ff       	call   10070b <translate_scancode>
  100923:	83 c4 10             	add    $0x10,%esp
  100926:	88 45 f3             	mov    %al,-0xd(%ebp)
        e1_code = 0;
  100929:	c7 05 18 80 12 00 00 	movl   $0x0,0x128018
  100930:	00 00 00 
  100933:	eb 62                	jmp    100997 <irq_handler+0x156>
    } else if (e1_code == 1) {
  100935:	a1 18 80 12 00       	mov    0x128018,%eax
  10093a:	83 f8 01             	cmp    $0x1,%eax
  10093d:	75 1b                	jne    10095a <irq_handler+0x119>
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
  10093f:	b8 00 00 00 00       	mov    $0x0,%eax
  100944:	8a 45 f2             	mov    -0xe(%ebp),%al
  100947:	66 a3 20 80 12 00    	mov    %ax,0x128020
        e1_code++;
  10094d:	a1 18 80 12 00       	mov    0x128018,%eax
  100952:	40                   	inc    %eax
  100953:	a3 18 80 12 00       	mov    %eax,0x128018
  100958:	eb 3d                	jmp    100997 <irq_handler+0x156>
    } else if (scancode == 0xE0) {
  10095a:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
  10095e:	75 0c                	jne    10096c <irq_handler+0x12b>
        // Anfang eines e0-Codes
        e0_code = 1;
  100960:	c7 05 1c 80 12 00 01 	movl   $0x1,0x12801c
  100967:	00 00 00 
  10096a:	eb 2b                	jmp    100997 <irq_handler+0x156>
    } else if (scancode == 0xE1) {
  10096c:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
  100970:	75 0c                	jne    10097e <irq_handler+0x13d>
        // Anfang eines e1-Codes
        e1_code = 1;
  100972:	c7 05 18 80 12 00 01 	movl   $0x1,0x128018
  100979:	00 00 00 
  10097c:	eb 19                	jmp    100997 <irq_handler+0x156>
    } else {
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
  10097e:	b8 00 00 00 00       	mov    $0x0,%eax
  100983:	8a 45 f2             	mov    -0xe(%ebp),%al
  100986:	83 ec 08             	sub    $0x8,%esp
  100989:	50                   	push   %eax
  10098a:	6a 00                	push   $0x0
  10098c:	e8 7a fd ff ff       	call   10070b <translate_scancode>
  100991:	83 c4 10             	add    $0x10,%esp
  100994:	88 45 f3             	mov    %al,-0xd(%ebp)
    }

    if(break_code) {
  100997:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10099b:	74 23                	je     1009c0 <irq_handler+0x17f>
        key_flags[keycode] &= ~KF_PRESSED;
  10099d:	b8 00 00 00 00       	mov    $0x0,%eax
  1009a2:	8a 45 f3             	mov    -0xd(%ebp),%al
  1009a5:	ba 00 00 00 00       	mov    $0x0,%edx
  1009aa:	8a 55 f3             	mov    -0xd(%ebp),%dl
  1009ad:	8b 14 95 a0 85 12 00 	mov    0x1285a0(,%edx,4),%edx
  1009b4:	83 e2 fe             	and    $0xfffffffe,%edx
  1009b7:	89 14 85 a0 85 12 00 	mov    %edx,0x1285a0(,%eax,4)
  1009be:	eb 21                	jmp    1009e1 <irq_handler+0x1a0>
    }
    else
    {
        key_flags[keycode] |= KF_PRESSED;
  1009c0:	b8 00 00 00 00       	mov    $0x0,%eax
  1009c5:	8a 45 f3             	mov    -0xd(%ebp),%al
  1009c8:	ba 00 00 00 00       	mov    $0x0,%edx
  1009cd:	8a 55 f3             	mov    -0xd(%ebp),%dl
  1009d0:	8b 14 95 a0 85 12 00 	mov    0x1285a0(,%edx,4),%edx
  1009d7:	83 ca 01             	or     $0x1,%edx
  1009da:	89 14 85 a0 85 12 00 	mov    %edx,0x1285a0(,%eax,4)
    }

    char chr = getchar(keycode);
  1009e1:	b8 00 00 00 00       	mov    $0x0,%eax
  1009e6:	8a 45 f3             	mov    -0xd(%ebp),%al
  1009e9:	83 ec 0c             	sub    $0xc,%esp
  1009ec:	50                   	push   %eax
  1009ed:	e8 a1 fd ff ff       	call   100793 <getchar>
  1009f2:	83 c4 10             	add    $0x10,%esp
  1009f5:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(!break_code && chr) {
  1009f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1009fc:	75 34                	jne    100a32 <irq_handler+0x1f1>
  1009fe:	8a 45 f1             	mov    -0xf(%ebp),%al
  100a01:	84 c0                	test   %al,%al
  100a03:	74 2d                	je     100a32 <irq_handler+0x1f1>
        if(vfs_write(charout, &chr, sizeof(char), 1)) {
  100a05:	a1 14 80 12 00       	mov    0x128014,%eax
  100a0a:	6a 01                	push   $0x1
  100a0c:	6a 01                	push   $0x1
  100a0e:	8d 55 f1             	lea    -0xf(%ebp),%edx
  100a11:	52                   	push   %edx
  100a12:	50                   	push   %eax
  100a13:	e8 d1 39 00 00       	call   1043e9 <vfs_write>
  100a18:	83 c4 10             	add    $0x10,%esp
  100a1b:	85 c0                	test   %eax,%eax
  100a1d:	74 13                	je     100a32 <irq_handler+0x1f1>
            kprintf("[keyboard] BUFFER OVERFLOW! \n");
  100a1f:	83 ec 0c             	sub    $0xc,%esp
  100a22:	68 a2 71 10 00       	push   $0x1071a2
  100a27:	e8 41 fb ff ff       	call   10056d <kprintf>
  100a2c:	83 c4 10             	add    $0x10,%esp
  100a2f:	eb 01                	jmp    100a32 <irq_handler+0x1f1>

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
  100a31:	90                   	nop    
    if(!break_code && chr) {
        if(vfs_write(charout, &chr, sizeof(char), 1)) {
            kprintf("[keyboard] BUFFER OVERFLOW! \n");
        }
    }
}
  100a32:	c9                   	leave  
  100a33:	c3                   	ret    

00100a34 <driver_keyboard_init>:

void driver_keyboard_init(void)
{
  100a34:	55                   	push   %ebp
  100a35:	89 e5                	mov    %esp,%ebp
  100a37:	83 ec 18             	sub    $0x18,%esp
    register_intr_handler(0x21, &irq_handler);
  100a3a:	83 ec 08             	sub    $0x8,%esp
  100a3d:	68 41 08 10 00       	push   $0x100841
  100a42:	6a 21                	push   $0x21
  100a44:	e8 de 08 00 00       	call   101327 <register_intr_handler>
  100a49:	83 c4 10             	add    $0x10,%esp

    while (inb(0x64) & 0x1) {
  100a4c:	eb 0d                	jmp    100a5b <driver_keyboard_init+0x27>
        inb(0x60);
  100a4e:	83 ec 0c             	sub    $0xc,%esp
  100a51:	6a 60                	push   $0x60
  100a53:	e8 7c fc ff ff       	call   1006d4 <inb>
  100a58:	83 c4 10             	add    $0x10,%esp

void driver_keyboard_init(void)
{
    register_intr_handler(0x21, &irq_handler);

    while (inb(0x64) & 0x1) {
  100a5b:	83 ec 0c             	sub    $0xc,%esp
  100a5e:	6a 64                	push   $0x64
  100a60:	e8 6f fc ff ff       	call   1006d4 <inb>
  100a65:	83 c4 10             	add    $0x10,%esp
  100a68:	25 ff 00 00 00       	and    $0xff,%eax
  100a6d:	83 e0 01             	and    $0x1,%eax
  100a70:	84 c0                	test   %al,%al
  100a72:	75 da                	jne    100a4e <driver_keyboard_init+0x1a>
        inb(0x60);
    }

    memset(key_flags, 0, 256 * sizeof(uint32_t));
  100a74:	83 ec 04             	sub    $0x4,%esp
  100a77:	68 00 04 00 00       	push   $0x400
  100a7c:	6a 00                	push   $0x0
  100a7e:	68 a0 85 12 00       	push   $0x1285a0
  100a83:	e8 b8 2f 00 00       	call   103a40 <memset>
  100a88:	83 c4 10             	add    $0x10,%esp

    // Leds alle ausloeschen
    send_command(0xED);
  100a8b:	83 ec 0c             	sub    $0xc,%esp
  100a8e:	68 ed 00 00 00       	push   $0xed
  100a93:	e8 4e fd ff ff       	call   1007e6 <send_command>
  100a98:	83 c4 10             	add    $0x10,%esp
    send_command(0);
  100a9b:	83 ec 0c             	sub    $0xc,%esp
  100a9e:	6a 00                	push   $0x0
  100aa0:	e8 41 fd ff ff       	call   1007e6 <send_command>
  100aa5:	83 c4 10             	add    $0x10,%esp

    // Schnellste Wiederholrate
    send_command(0xF3);
  100aa8:	83 ec 0c             	sub    $0xc,%esp
  100aab:	68 f3 00 00 00       	push   $0xf3
  100ab0:	e8 31 fd ff ff       	call   1007e6 <send_command>
  100ab5:	83 c4 10             	add    $0x10,%esp
    send_command(0);
  100ab8:	83 ec 0c             	sub    $0xc,%esp
  100abb:	6a 00                	push   $0x0
  100abd:	e8 24 fd ff ff       	call   1007e6 <send_command>
  100ac2:	83 c4 10             	add    $0x10,%esp

    send_command(0xF4);
  100ac5:	83 ec 0c             	sub    $0xc,%esp
  100ac8:	68 f4 00 00 00       	push   $0xf4
  100acd:	e8 14 fd ff ff       	call   1007e6 <send_command>
  100ad2:	83 c4 10             	add    $0x10,%esp

    vfs_create_kfile("/dev/keyboard", ramfs_fifo_driver_struct(), &(uint32_t){512});
  100ad5:	c7 45 f4 00 02 00 00 	movl   $0x200,-0xc(%ebp)
  100adc:	e8 42 1a 00 00       	call   102523 <ramfs_fifo_driver_struct>
  100ae1:	83 ec 04             	sub    $0x4,%esp
  100ae4:	8d 55 f4             	lea    -0xc(%ebp),%edx
  100ae7:	52                   	push   %edx
  100ae8:	50                   	push   %eax
  100ae9:	68 c0 71 10 00       	push   $0x1071c0
  100aee:	e8 29 37 00 00       	call   10421c <vfs_create_kfile>
  100af3:	83 c4 10             	add    $0x10,%esp
    charout = vfs_open("/dev/keyboard", FM_WRITE);
  100af6:	83 ec 08             	sub    $0x8,%esp
  100af9:	6a 02                	push   $0x2
  100afb:	68 c0 71 10 00       	push   $0x1071c0
  100b00:	e8 b6 37 00 00       	call   1042bb <vfs_open>
  100b05:	83 c4 10             	add    $0x10,%esp
  100b08:	a3 14 80 12 00       	mov    %eax,0x128014

    init_done = 1;
  100b0d:	c7 05 10 80 12 00 01 	movl   $0x1,0x128010
  100b14:	00 00 00 
}
  100b17:	c9                   	leave  
  100b18:	c3                   	ret    
  100b19:	00 00                	add    %al,(%eax)
	...

00100b1c <load_gdt>:
#include "idt.h"
#include "ports.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "console.h"

  100b1c:	55                   	push   %ebp
  100b1d:	89 e5                	mov    %esp,%ebp
  100b1f:	83 ec 10             	sub    $0x10,%esp
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
  100b22:	66 c7 45 fa 2f 00    	movw   $0x2f,-0x6(%ebp)
  100b28:	c7 45 fc a0 89 12 00 	movl   $0x1289a0,-0x4(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
  100b2f:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
  100b33:	66 b8 10 00          	mov    $0x10,%ax
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
  100b37:	8e d8                	mov    %eax,%ds
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
  100b39:	8e c0                	mov    %eax,%es
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
  100b3b:	8e e0                	mov    %eax,%fs
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
  100b3d:	8e e8                	mov    %eax,%gs
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100b3f:	8e d0                	mov    %eax,%ss
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
  100b41:	c9                   	leave  
  100b42:	c3                   	ret    

00100b43 <set_gdt_entry>:
    },

  100b43:	55                   	push   %ebp
  100b44:	89 e5                	mov    %esp,%ebp
  100b46:	57                   	push   %edi
  100b47:	56                   	push   %esi
  100b48:	53                   	push   %ebx
  100b49:	83 ec 4c             	sub    $0x4c,%esp
    // Extended0-Scancodes (werden mit e0 eingeleitet)
  100b4c:	8b 45 08             	mov    0x8(%ebp),%eax
  100b4f:	89 45 a8             	mov    %eax,-0x58(%ebp)
  100b52:	8b 45 10             	mov    0x10(%ebp),%eax
  100b55:	ba 00 00 00 00       	mov    $0x0,%edx
  100b5a:	0f b7 c8             	movzwl %ax,%ecx
  100b5d:	89 d3                	mov    %edx,%ebx
  100b5f:	83 e3 00             	and    $0x0,%ebx
  100b62:	8b 55 a8             	mov    -0x58(%ebp),%edx
  100b65:	89 0c d5 a0 89 12 00 	mov    %ecx,0x1289a0(,%edx,8)
  100b6c:	89 1c d5 a4 89 12 00 	mov    %ebx,0x1289a4(,%edx,8)
    {
  100b73:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100b76:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  100b79:	8b 45 08             	mov    0x8(%ebp),%eax
  100b7c:	8b 0c c5 a0 89 12 00 	mov    0x1289a0(,%eax,8),%ecx
  100b83:	8b 1c c5 a4 89 12 00 	mov    0x1289a4(,%eax,8),%ebx
  100b8a:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b8d:	ba 00 00 00 00       	mov    $0x0,%edx
  100b92:	89 c6                	mov    %eax,%esi
  100b94:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
  100b9a:	89 d7                	mov    %edx,%edi
  100b9c:	83 e7 00             	and    $0x0,%edi
  100b9f:	89 f0                	mov    %esi,%eax
  100ba1:	89 fa                	mov    %edi,%edx
  100ba3:	0f a4 c2 10          	shld   $0x10,%eax,%edx
  100ba7:	c1 e0 10             	shl    $0x10,%eax
  100baa:	89 ce                	mov    %ecx,%esi
  100bac:	09 c6                	or     %eax,%esi
  100bae:	89 75 b0             	mov    %esi,-0x50(%ebp)
  100bb1:	89 df                	mov    %ebx,%edi
  100bb3:	09 d7                	or     %edx,%edi
  100bb5:	89 7d b4             	mov    %edi,-0x4c(%ebp)
  100bb8:	8b 45 b0             	mov    -0x50(%ebp),%eax
  100bbb:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  100bbe:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  100bc1:	89 04 cd a0 89 12 00 	mov    %eax,0x1289a0(,%ecx,8)
  100bc8:	89 14 cd a4 89 12 00 	mov    %edx,0x1289a4(,%ecx,8)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100bcf:	8b 75 08             	mov    0x8(%ebp),%esi
  100bd2:	8b 45 08             	mov    0x8(%ebp),%eax
  100bd5:	8b 0c c5 a0 89 12 00 	mov    0x1289a0(,%eax,8),%ecx
  100bdc:	8b 1c c5 a4 89 12 00 	mov    0x1289a4(,%eax,8),%ebx
  100be3:	8b 45 14             	mov    0x14(%ebp),%eax
  100be6:	89 c2                	mov    %eax,%edx
  100be8:	c1 fa 1f             	sar    $0x1f,%edx
  100beb:	0f b6 f8             	movzbl %al,%edi
  100bee:	89 7d b8             	mov    %edi,-0x48(%ebp)
  100bf1:	89 d7                	mov    %edx,%edi
  100bf3:	83 e7 00             	and    $0x0,%edi
  100bf6:	89 7d bc             	mov    %edi,-0x44(%ebp)
  100bf9:	8b 45 b8             	mov    -0x48(%ebp),%eax
  100bfc:	8b 55 bc             	mov    -0x44(%ebp),%edx
  100bff:	89 c2                	mov    %eax,%edx
  100c01:	b8 00 00 00 00       	mov    $0x0,%eax
  100c06:	c1 e2 08             	shl    $0x8,%edx
  100c09:	89 cf                	mov    %ecx,%edi
  100c0b:	09 c7                	or     %eax,%edi
  100c0d:	89 7d c0             	mov    %edi,-0x40(%ebp)
  100c10:	89 df                	mov    %ebx,%edi
  100c12:	09 d7                	or     %edx,%edi
  100c14:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  100c17:	8b 45 c0             	mov    -0x40(%ebp),%eax
  100c1a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  100c1d:	89 04 f5 a0 89 12 00 	mov    %eax,0x1289a0(,%esi,8)
  100c24:	89 14 f5 a4 89 12 00 	mov    %edx,0x1289a4(,%esi,8)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100c2b:	8b 75 08             	mov    0x8(%ebp),%esi
  100c2e:	8b 45 08             	mov    0x8(%ebp),%eax
  100c31:	8b 0c c5 a0 89 12 00 	mov    0x1289a0(,%eax,8),%ecx
  100c38:	8b 1c c5 a4 89 12 00 	mov    0x1289a4(,%eax,8),%ebx
  100c3f:	8b 45 10             	mov    0x10(%ebp),%eax
  100c42:	c1 e8 10             	shr    $0x10,%eax
  100c45:	ba 00 00 00 00       	mov    $0x0,%edx
  100c4a:	89 c7                	mov    %eax,%edi
  100c4c:	83 e7 0f             	and    $0xf,%edi
  100c4f:	89 7d c8             	mov    %edi,-0x38(%ebp)
  100c52:	89 d7                	mov    %edx,%edi
  100c54:	83 e7 00             	and    $0x0,%edi
  100c57:	89 7d cc             	mov    %edi,-0x34(%ebp)
  100c5a:	8b 45 c8             	mov    -0x38(%ebp),%eax
  100c5d:	8b 55 cc             	mov    -0x34(%ebp),%edx
  100c60:	89 c2                	mov    %eax,%edx
  100c62:	b8 00 00 00 00       	mov    $0x0,%eax
  100c67:	c1 e2 10             	shl    $0x10,%edx
  100c6a:	89 cf                	mov    %ecx,%edi
  100c6c:	09 c7                	or     %eax,%edi
  100c6e:	89 7d d0             	mov    %edi,-0x30(%ebp)
  100c71:	89 df                	mov    %ebx,%edi
  100c73:	09 d7                	or     %edx,%edi
  100c75:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  100c78:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100c7b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100c7e:	89 04 f5 a0 89 12 00 	mov    %eax,0x1289a0(,%esi,8)
  100c85:	89 14 f5 a4 89 12 00 	mov    %edx,0x1289a4(,%esi,8)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
  100c8c:	8b 75 08             	mov    0x8(%ebp),%esi
  100c8f:	8b 45 08             	mov    0x8(%ebp),%eax
  100c92:	8b 0c c5 a0 89 12 00 	mov    0x1289a0(,%eax,8),%ecx
  100c99:	8b 1c c5 a4 89 12 00 	mov    0x1289a4(,%eax,8),%ebx
  100ca0:	8b 45 14             	mov    0x14(%ebp),%eax
  100ca3:	c1 f8 08             	sar    $0x8,%eax
  100ca6:	89 c2                	mov    %eax,%edx
  100ca8:	c1 fa 1f             	sar    $0x1f,%edx
  100cab:	0f b6 f8             	movzbl %al,%edi
  100cae:	89 7d d8             	mov    %edi,-0x28(%ebp)
  100cb1:	89 d7                	mov    %edx,%edi
  100cb3:	83 e7 00             	and    $0x0,%edi
  100cb6:	89 7d dc             	mov    %edi,-0x24(%ebp)
  100cb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100cbc:	8b 55 dc             	mov    -0x24(%ebp),%edx
  100cbf:	89 c2                	mov    %eax,%edx
  100cc1:	b8 00 00 00 00       	mov    $0x0,%eax
  100cc6:	c1 e2 14             	shl    $0x14,%edx
  100cc9:	89 cf                	mov    %ecx,%edi
  100ccb:	09 c7                	or     %eax,%edi
  100ccd:	89 7d e0             	mov    %edi,-0x20(%ebp)
  100cd0:	89 df                	mov    %ebx,%edi
  100cd2:	09 d7                	or     %edx,%edi
  100cd4:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  100cd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100cda:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  100cdd:	89 04 f5 a0 89 12 00 	mov    %eax,0x1289a0(,%esi,8)
  100ce4:	89 14 f5 a4 89 12 00 	mov    %edx,0x1289a4(,%esi,8)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100ceb:	8b 75 08             	mov    0x8(%ebp),%esi
  100cee:	8b 45 08             	mov    0x8(%ebp),%eax
  100cf1:	8b 0c c5 a0 89 12 00 	mov    0x1289a0(,%eax,8),%ecx
  100cf8:	8b 1c c5 a4 89 12 00 	mov    0x1289a4(,%eax,8),%ebx
  100cff:	8b 45 0c             	mov    0xc(%ebp),%eax
  100d02:	c1 e8 18             	shr    $0x18,%eax
  100d05:	ba 00 00 00 00       	mov    $0x0,%edx
  100d0a:	89 c2                	mov    %eax,%edx
  100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
  100d11:	c1 e2 18             	shl    $0x18,%edx
  100d14:	89 cf                	mov    %ecx,%edi
  100d16:	09 c7                	or     %eax,%edi
  100d18:	89 7d e8             	mov    %edi,-0x18(%ebp)
  100d1b:	89 df                	mov    %ebx,%edi
  100d1d:	09 d7                	or     %edx,%edi
  100d1f:	89 7d ec             	mov    %edi,-0x14(%ebp)
  100d22:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100d25:	8b 55 ec             	mov    -0x14(%ebp),%edx
  100d28:	89 04 f5 a0 89 12 00 	mov    %eax,0x1289a0(,%esi,8)
  100d2f:	89 14 f5 a4 89 12 00 	mov    %edx,0x1289a4(,%esi,8)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100d36:	83 c4 4c             	add    $0x4c,%esp
  100d39:	5b                   	pop    %ebx
  100d3a:	5e                   	pop    %esi
  100d3b:	5f                   	pop    %edi
  100d3c:	5d                   	pop    %ebp
  100d3d:	c3                   	ret    

00100d3e <init_gdt>:
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100d3e:	55                   	push   %ebp
  100d3f:	89 e5                	mov    %esp,%ebp
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
  100d41:	6a 00                	push   $0x0
  100d43:	6a 00                	push   $0x0
  100d45:	6a 00                	push   $0x0
  100d47:	6a 00                	push   $0x0
  100d49:	e8 f5 fd ff ff       	call   100b43 <set_gdt_entry>
  100d4e:	83 c4 10             	add    $0x10,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
  100d51:	68 9a 0c 00 00       	push   $0xc9a
  100d56:	68 ff ff 0f 00       	push   $0xfffff
  100d5b:	6a 00                	push   $0x0
  100d5d:	6a 01                	push   $0x1
  100d5f:	e8 df fd ff ff       	call   100b43 <set_gdt_entry>
  100d64:	83 c4 10             	add    $0x10,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100d67:	68 92 0c 00 00       	push   $0xc92
  100d6c:	68 ff ff 0f 00       	push   $0xfffff
  100d71:	6a 00                	push   $0x0
  100d73:	6a 02                	push   $0x2
  100d75:	e8 c9 fd ff ff       	call   100b43 <set_gdt_entry>
  100d7a:	83 c4 10             	add    $0x10,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
  100d7d:	68 fa 0c 00 00       	push   $0xcfa
  100d82:	68 ff ff 0f 00       	push   $0xfffff
  100d87:	6a 00                	push   $0x0
  100d89:	6a 03                	push   $0x3
  100d8b:	e8 b3 fd ff ff       	call   100b43 <set_gdt_entry>
  100d90:	83 c4 10             	add    $0x10,%esp
    },
};
  100d93:	68 f2 0c 00 00       	push   $0xcf2
  100d98:	68 ff ff 0f 00       	push   $0xfffff
  100d9d:	6a 00                	push   $0x0
  100d9f:	6a 04                	push   $0x4
  100da1:	e8 9d fd ff ff       	call   100b43 <set_gdt_entry>
  100da6:	83 c4 10             	add    $0x10,%esp

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
  100da9:	e8 6e fd ff ff       	call   100b1c <load_gdt>
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
  100dae:	c9                   	leave  
  100daf:	c3                   	ret    

00100db0 <outb>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
  100db0:	55                   	push   %ebp
  100db1:	89 e5                	mov    %esp,%ebp
  100db3:	83 ec 08             	sub    $0x8,%esp
  100db6:	8b 45 08             	mov    0x8(%ebp),%eax
  100db9:	8b 55 0c             	mov    0xc(%ebp),%edx
  100dbc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  100dc0:	88 55 f8             	mov    %dl,-0x8(%ebp)
    {
  100dc3:	8a 45 f8             	mov    -0x8(%ebp),%al
  100dc6:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100dc9:	ee                   	out    %al,(%dx)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
  100dca:	c9                   	leave  
  100dcb:	c3                   	ret    

00100dcc <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  100dcc:	55                   	push   %ebp
  100dcd:	89 e5                	mov    %esp,%ebp
  100dcf:	57                   	push   %edi
  100dd0:	56                   	push   %esi
  100dd1:	53                   	push   %ebx
  100dd2:	83 ec 34             	sub    $0x34,%esp
  100dd5:	8b 45 10             	mov    0x10(%ebp),%eax
  100dd8:	8b 55 14             	mov    0x14(%ebp),%edx
  100ddb:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  100ddf:	88 55 d8             	mov    %dl,-0x28(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  100de2:	8b 45 0c             	mov    0xc(%ebp),%eax
  100de5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	idt[i] = handler & 0xffffLL;
  100de8:	8b 75 08             	mov    0x8(%ebp),%esi
  100deb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100dee:	ba 00 00 00 00       	mov    $0x0,%edx
  100df3:	0f b7 c8             	movzwl %ax,%ecx
  100df6:	89 d3                	mov    %edx,%ebx
  100df8:	83 e3 00             	and    $0x0,%ebx
  100dfb:	89 0c f5 40 80 12 00 	mov    %ecx,0x128040(,%esi,8)
  100e02:	89 1c f5 44 80 12 00 	mov    %ebx,0x128044(,%esi,8)
	idt[i] |= (selector & 0xffffLL) << 16;
  100e09:	8b 75 08             	mov    0x8(%ebp),%esi
  100e0c:	8b 45 08             	mov    0x8(%ebp),%eax
  100e0f:	8b 0c c5 40 80 12 00 	mov    0x128040(,%eax,8),%ecx
  100e16:	8b 1c c5 44 80 12 00 	mov    0x128044(,%eax,8),%ebx
  100e1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  100e20:	25 ff ff 00 00       	and    $0xffff,%eax
  100e25:	ba 00 00 00 00       	mov    $0x0,%edx
  100e2a:	0f a4 c2 10          	shld   $0x10,%eax,%edx
  100e2e:	c1 e0 10             	shl    $0x10,%eax
  100e31:	89 cf                	mov    %ecx,%edi
  100e33:	09 c7                	or     %eax,%edi
  100e35:	89 7d c0             	mov    %edi,-0x40(%ebp)
  100e38:	89 df                	mov    %ebx,%edi
  100e3a:	09 d7                	or     %edx,%edi
  100e3c:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  100e3f:	8b 45 c0             	mov    -0x40(%ebp),%eax
  100e42:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  100e45:	89 04 f5 40 80 12 00 	mov    %eax,0x128040(,%esi,8)
  100e4c:	89 14 f5 44 80 12 00 	mov    %edx,0x128044(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  100e53:	8b 75 08             	mov    0x8(%ebp),%esi
  100e56:	8b 45 08             	mov    0x8(%ebp),%eax
  100e59:	8b 0c c5 40 80 12 00 	mov    0x128040(,%eax,8),%ecx
  100e60:	8b 1c c5 44 80 12 00 	mov    0x128044(,%eax,8),%ebx
  100e67:	b8 00 00 00 00       	mov    $0x0,%eax
  100e6c:	8a 45 d8             	mov    -0x28(%ebp),%al
  100e6f:	ba 00 00 00 00       	mov    $0x0,%edx
  100e74:	89 c2                	mov    %eax,%edx
  100e76:	b8 00 00 00 00       	mov    $0x0,%eax
  100e7b:	c1 e2 08             	shl    $0x8,%edx
  100e7e:	89 cf                	mov    %ecx,%edi
  100e80:	09 c7                	or     %eax,%edi
  100e82:	89 7d c8             	mov    %edi,-0x38(%ebp)
  100e85:	89 df                	mov    %ebx,%edi
  100e87:	09 d7                	or     %edx,%edi
  100e89:	89 7d cc             	mov    %edi,-0x34(%ebp)
  100e8c:	8b 45 c8             	mov    -0x38(%ebp),%eax
  100e8f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  100e92:	89 04 f5 40 80 12 00 	mov    %eax,0x128040(,%esi,8)
  100e99:	89 14 f5 44 80 12 00 	mov    %edx,0x128044(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  100ea0:	8b 75 08             	mov    0x8(%ebp),%esi
  100ea3:	8b 45 08             	mov    0x8(%ebp),%eax
  100ea6:	8b 0c c5 40 80 12 00 	mov    0x128040(,%eax,8),%ecx
  100ead:	8b 1c c5 44 80 12 00 	mov    0x128044(,%eax,8),%ebx
  100eb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100eb7:	c1 e8 10             	shr    $0x10,%eax
  100eba:	ba 00 00 00 00       	mov    $0x0,%edx
  100ebf:	89 c2                	mov    %eax,%edx
  100ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  100ec6:	c1 e2 10             	shl    $0x10,%edx
  100ec9:	89 cf                	mov    %ecx,%edi
  100ecb:	09 c7                	or     %eax,%edi
  100ecd:	89 7d d0             	mov    %edi,-0x30(%ebp)
  100ed0:	89 df                	mov    %ebx,%edi
  100ed2:	09 d7                	or     %edx,%edi
  100ed4:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  100ed7:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100eda:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100edd:	89 04 f5 40 80 12 00 	mov    %eax,0x128040(,%esi,8)
  100ee4:	89 14 f5 44 80 12 00 	mov    %edx,0x128044(,%esi,8)
}
  100eeb:	83 c4 34             	add    $0x34,%esp
  100eee:	5b                   	pop    %ebx
  100eef:	5e                   	pop    %esi
  100ef0:	5f                   	pop    %edi
  100ef1:	5d                   	pop    %ebp
  100ef2:	c3                   	ret    

00100ef3 <init_idt>:

void init_idt() {
  100ef3:	55                   	push   %ebp
  100ef4:	89 e5                	mov    %esp,%ebp
  100ef6:	83 ec 18             	sub    $0x18,%esp
	struct {
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };
  100ef9:	66 c7 45 ee ff 01    	movw   $0x1ff,-0x12(%ebp)
  100eff:	c7 45 f0 40 80 12 00 	movl   $0x128040,-0x10(%ebp)

	int i = 0;
  100f06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  100f0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  100f14:	eb 1f                	jmp    100f35 <init_idt+0x42>
		handler_set[i] = 0;
  100f16:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f19:	c7 04 85 40 83 12 00 	movl   $0x0,0x128340(,%eax,4)
  100f20:	00 00 00 00 
		irq_rpcs[i] = 0;
  100f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f27:	c7 04 85 40 84 12 00 	movl   $0x0,0x128440(,%eax,4)
  100f2e:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  100f32:	ff 45 f4             	incl   -0xc(%ebp)
  100f35:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
  100f39:	7e db                	jle    100f16 <init_idt+0x23>
		handler_set[i] = 0;
		irq_rpcs[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  100f3b:	6a 11                	push   $0x11
  100f3d:	6a 20                	push   $0x20
  100f3f:	e8 6c fe ff ff       	call   100db0 <outb>
  100f44:	83 c4 08             	add    $0x8,%esp
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  100f47:	6a 20                	push   $0x20
  100f49:	6a 21                	push   $0x21
  100f4b:	e8 60 fe ff ff       	call   100db0 <outb>
  100f50:	83 c4 08             	add    $0x8,%esp
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  100f53:	6a 04                	push   $0x4
  100f55:	6a 21                	push   $0x21
  100f57:	e8 54 fe ff ff       	call   100db0 <outb>
  100f5c:	83 c4 08             	add    $0x8,%esp
	outb(0x21, 0x01); // ICW 4
  100f5f:	6a 01                	push   $0x1
  100f61:	6a 21                	push   $0x21
  100f63:	e8 48 fe ff ff       	call   100db0 <outb>
  100f68:	83 c4 08             	add    $0x8,%esp

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  100f6b:	6a 11                	push   $0x11
  100f6d:	68 a0 00 00 00       	push   $0xa0
  100f72:	e8 39 fe ff ff       	call   100db0 <outb>
  100f77:	83 c4 08             	add    $0x8,%esp
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  100f7a:	6a 28                	push   $0x28
  100f7c:	68 a1 00 00 00       	push   $0xa1
  100f81:	e8 2a fe ff ff       	call   100db0 <outb>
  100f86:	83 c4 08             	add    $0x8,%esp
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  100f89:	6a 02                	push   $0x2
  100f8b:	68 a1 00 00 00       	push   $0xa1
  100f90:	e8 1b fe ff ff       	call   100db0 <outb>
  100f95:	83 c4 08             	add    $0x8,%esp
	outb(0xa1, 0x01); // ICW 4
  100f98:	6a 01                	push   $0x1
  100f9a:	68 a1 00 00 00       	push   $0xa1
  100f9f:	e8 0c fe ff ff       	call   100db0 <outb>
  100fa4:	83 c4 08             	add    $0x8,%esp

	outb(0x20, 0x0);
  100fa7:	6a 00                	push   $0x0
  100fa9:	6a 20                	push   $0x20
  100fab:	e8 00 fe ff ff       	call   100db0 <outb>
  100fb0:	83 c4 08             	add    $0x8,%esp
	outb(0xa0, 0x0);
  100fb3:	6a 00                	push   $0x0
  100fb5:	68 a0 00 00 00       	push   $0xa0
  100fba:	e8 f1 fd ff ff       	call   100db0 <outb>
  100fbf:	83 c4 08             	add    $0x8,%esp

	idt_set_entry(0, intr_stub_0, 0x8,
  100fc2:	b8 0c 00 10 00       	mov    $0x10000c,%eax
  100fc7:	68 8e 00 00 00       	push   $0x8e
  100fcc:	6a 08                	push   $0x8
  100fce:	50                   	push   %eax
  100fcf:	6a 00                	push   $0x0
  100fd1:	e8 f6 fd ff ff       	call   100dcc <idt_set_entry>
  100fd6:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  100fd9:	b8 15 00 10 00       	mov    $0x100015,%eax
  100fde:	68 8e 00 00 00       	push   $0x8e
  100fe3:	6a 08                	push   $0x8
  100fe5:	50                   	push   %eax
  100fe6:	6a 01                	push   $0x1
  100fe8:	e8 df fd ff ff       	call   100dcc <idt_set_entry>
  100fed:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  100ff0:	b8 1e 00 10 00       	mov    $0x10001e,%eax
  100ff5:	68 8e 00 00 00       	push   $0x8e
  100ffa:	6a 08                	push   $0x8
  100ffc:	50                   	push   %eax
  100ffd:	6a 02                	push   $0x2
  100fff:	e8 c8 fd ff ff       	call   100dcc <idt_set_entry>
  101004:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  101007:	b8 27 00 10 00       	mov    $0x100027,%eax
  10100c:	68 8e 00 00 00       	push   $0x8e
  101011:	6a 08                	push   $0x8
  101013:	50                   	push   %eax
  101014:	6a 03                	push   $0x3
  101016:	e8 b1 fd ff ff       	call   100dcc <idt_set_entry>
  10101b:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  10101e:	b8 30 00 10 00       	mov    $0x100030,%eax
  101023:	68 8e 00 00 00       	push   $0x8e
  101028:	6a 08                	push   $0x8
  10102a:	50                   	push   %eax
  10102b:	6a 04                	push   $0x4
  10102d:	e8 9a fd ff ff       	call   100dcc <idt_set_entry>
  101032:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  101035:	b8 39 00 10 00       	mov    $0x100039,%eax
  10103a:	68 8e 00 00 00       	push   $0x8e
  10103f:	6a 08                	push   $0x8
  101041:	50                   	push   %eax
  101042:	6a 05                	push   $0x5
  101044:	e8 83 fd ff ff       	call   100dcc <idt_set_entry>
  101049:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  10104c:	b8 42 00 10 00       	mov    $0x100042,%eax
  101051:	68 8e 00 00 00       	push   $0x8e
  101056:	6a 08                	push   $0x8
  101058:	50                   	push   %eax
  101059:	6a 06                	push   $0x6
  10105b:	e8 6c fd ff ff       	call   100dcc <idt_set_entry>
  101060:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  101063:	b8 4b 00 10 00       	mov    $0x10004b,%eax
  101068:	68 8e 00 00 00       	push   $0x8e
  10106d:	6a 08                	push   $0x8
  10106f:	50                   	push   %eax
  101070:	6a 07                	push   $0x7
  101072:	e8 55 fd ff ff       	call   100dcc <idt_set_entry>
  101077:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  10107a:	b8 54 00 10 00       	mov    $0x100054,%eax
  10107f:	68 8e 00 00 00       	push   $0x8e
  101084:	6a 08                	push   $0x8
  101086:	50                   	push   %eax
  101087:	6a 08                	push   $0x8
  101089:	e8 3e fd ff ff       	call   100dcc <idt_set_entry>
  10108e:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  101091:	b8 5b 00 10 00       	mov    $0x10005b,%eax
  101096:	68 8e 00 00 00       	push   $0x8e
  10109b:	6a 08                	push   $0x8
  10109d:	50                   	push   %eax
  10109e:	6a 09                	push   $0x9
  1010a0:	e8 27 fd ff ff       	call   100dcc <idt_set_entry>
  1010a5:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  1010a8:	b8 64 00 10 00       	mov    $0x100064,%eax
  1010ad:	68 8e 00 00 00       	push   $0x8e
  1010b2:	6a 08                	push   $0x8
  1010b4:	50                   	push   %eax
  1010b5:	6a 0a                	push   $0xa
  1010b7:	e8 10 fd ff ff       	call   100dcc <idt_set_entry>
  1010bc:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  1010bf:	b8 6b 00 10 00       	mov    $0x10006b,%eax
  1010c4:	68 8e 00 00 00       	push   $0x8e
  1010c9:	6a 08                	push   $0x8
  1010cb:	50                   	push   %eax
  1010cc:	6a 0b                	push   $0xb
  1010ce:	e8 f9 fc ff ff       	call   100dcc <idt_set_entry>
  1010d3:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  1010d6:	b8 72 00 10 00       	mov    $0x100072,%eax
  1010db:	68 8e 00 00 00       	push   $0x8e
  1010e0:	6a 08                	push   $0x8
  1010e2:	50                   	push   %eax
  1010e3:	6a 0c                	push   $0xc
  1010e5:	e8 e2 fc ff ff       	call   100dcc <idt_set_entry>
  1010ea:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  1010ed:	b8 79 00 10 00       	mov    $0x100079,%eax
  1010f2:	68 8e 00 00 00       	push   $0x8e
  1010f7:	6a 08                	push   $0x8
  1010f9:	50                   	push   %eax
  1010fa:	6a 0d                	push   $0xd
  1010fc:	e8 cb fc ff ff       	call   100dcc <idt_set_entry>
  101101:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  101104:	b8 80 00 10 00       	mov    $0x100080,%eax
  101109:	68 8e 00 00 00       	push   $0x8e
  10110e:	6a 08                	push   $0x8
  101110:	50                   	push   %eax
  101111:	6a 0e                	push   $0xe
  101113:	e8 b4 fc ff ff       	call   100dcc <idt_set_entry>
  101118:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  10111b:	b8 84 00 10 00       	mov    $0x100084,%eax
  101120:	68 8e 00 00 00       	push   $0x8e
  101125:	6a 08                	push   $0x8
  101127:	50                   	push   %eax
  101128:	6a 0f                	push   $0xf
  10112a:	e8 9d fc ff ff       	call   100dcc <idt_set_entry>
  10112f:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  101132:	b8 8a 00 10 00       	mov    $0x10008a,%eax
  101137:	68 8e 00 00 00       	push   $0x8e
  10113c:	6a 08                	push   $0x8
  10113e:	50                   	push   %eax
  10113f:	6a 10                	push   $0x10
  101141:	e8 86 fc ff ff       	call   100dcc <idt_set_entry>
  101146:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  101149:	b8 90 00 10 00       	mov    $0x100090,%eax
  10114e:	68 8e 00 00 00       	push   $0x8e
  101153:	6a 08                	push   $0x8
  101155:	50                   	push   %eax
  101156:	6a 11                	push   $0x11
  101158:	e8 6f fc ff ff       	call   100dcc <idt_set_entry>
  10115d:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  101160:	b8 94 00 10 00       	mov    $0x100094,%eax
  101165:	68 8e 00 00 00       	push   $0x8e
  10116a:	6a 08                	push   $0x8
  10116c:	50                   	push   %eax
  10116d:	6a 12                	push   $0x12
  10116f:	e8 58 fc ff ff       	call   100dcc <idt_set_entry>
  101174:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  101177:	b8 9a 00 10 00       	mov    $0x10009a,%eax
  10117c:	68 8e 00 00 00       	push   $0x8e
  101181:	6a 08                	push   $0x8
  101183:	50                   	push   %eax
  101184:	6a 20                	push   $0x20
  101186:	e8 41 fc ff ff       	call   100dcc <idt_set_entry>
  10118b:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  10118e:	b8 a0 00 10 00       	mov    $0x1000a0,%eax
  101193:	68 8e 00 00 00       	push   $0x8e
  101198:	6a 08                	push   $0x8
  10119a:	50                   	push   %eax
  10119b:	6a 21                	push   $0x21
  10119d:	e8 2a fc ff ff       	call   100dcc <idt_set_entry>
  1011a2:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  1011a5:	b8 a6 00 10 00       	mov    $0x1000a6,%eax
  1011aa:	68 8e 00 00 00       	push   $0x8e
  1011af:	6a 08                	push   $0x8
  1011b1:	50                   	push   %eax
  1011b2:	6a 22                	push   $0x22
  1011b4:	e8 13 fc ff ff       	call   100dcc <idt_set_entry>
  1011b9:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  1011bc:	b8 ac 00 10 00       	mov    $0x1000ac,%eax
  1011c1:	68 8e 00 00 00       	push   $0x8e
  1011c6:	6a 08                	push   $0x8
  1011c8:	50                   	push   %eax
  1011c9:	6a 23                	push   $0x23
  1011cb:	e8 fc fb ff ff       	call   100dcc <idt_set_entry>
  1011d0:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  1011d3:	b8 b2 00 10 00       	mov    $0x1000b2,%eax
  1011d8:	68 8e 00 00 00       	push   $0x8e
  1011dd:	6a 08                	push   $0x8
  1011df:	50                   	push   %eax
  1011e0:	6a 24                	push   $0x24
  1011e2:	e8 e5 fb ff ff       	call   100dcc <idt_set_entry>
  1011e7:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  1011ea:	b8 b8 00 10 00       	mov    $0x1000b8,%eax
  1011ef:	68 8e 00 00 00       	push   $0x8e
  1011f4:	6a 08                	push   $0x8
  1011f6:	50                   	push   %eax
  1011f7:	6a 25                	push   $0x25
  1011f9:	e8 ce fb ff ff       	call   100dcc <idt_set_entry>
  1011fe:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  101201:	b8 be 00 10 00       	mov    $0x1000be,%eax
  101206:	68 8e 00 00 00       	push   $0x8e
  10120b:	6a 08                	push   $0x8
  10120d:	50                   	push   %eax
  10120e:	6a 26                	push   $0x26
  101210:	e8 b7 fb ff ff       	call   100dcc <idt_set_entry>
  101215:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  101218:	b8 c4 00 10 00       	mov    $0x1000c4,%eax
  10121d:	68 8e 00 00 00       	push   $0x8e
  101222:	6a 08                	push   $0x8
  101224:	50                   	push   %eax
  101225:	6a 27                	push   $0x27
  101227:	e8 a0 fb ff ff       	call   100dcc <idt_set_entry>
  10122c:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  10122f:	b8 ca 00 10 00       	mov    $0x1000ca,%eax
  101234:	68 8e 00 00 00       	push   $0x8e
  101239:	6a 08                	push   $0x8
  10123b:	50                   	push   %eax
  10123c:	6a 28                	push   $0x28
  10123e:	e8 89 fb ff ff       	call   100dcc <idt_set_entry>
  101243:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  101246:	b8 d0 00 10 00       	mov    $0x1000d0,%eax
  10124b:	68 8e 00 00 00       	push   $0x8e
  101250:	6a 08                	push   $0x8
  101252:	50                   	push   %eax
  101253:	6a 29                	push   $0x29
  101255:	e8 72 fb ff ff       	call   100dcc <idt_set_entry>
  10125a:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  10125d:	b8 d6 00 10 00       	mov    $0x1000d6,%eax
  101262:	68 8e 00 00 00       	push   $0x8e
  101267:	6a 08                	push   $0x8
  101269:	50                   	push   %eax
  10126a:	6a 2a                	push   $0x2a
  10126c:	e8 5b fb ff ff       	call   100dcc <idt_set_entry>
  101271:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  101274:	b8 dc 00 10 00       	mov    $0x1000dc,%eax
  101279:	68 8e 00 00 00       	push   $0x8e
  10127e:	6a 08                	push   $0x8
  101280:	50                   	push   %eax
  101281:	6a 2b                	push   $0x2b
  101283:	e8 44 fb ff ff       	call   100dcc <idt_set_entry>
  101288:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  10128b:	b8 e2 00 10 00       	mov    $0x1000e2,%eax
  101290:	68 8e 00 00 00       	push   $0x8e
  101295:	6a 08                	push   $0x8
  101297:	50                   	push   %eax
  101298:	6a 2c                	push   $0x2c
  10129a:	e8 2d fb ff ff       	call   100dcc <idt_set_entry>
  10129f:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  1012a2:	b8 e8 00 10 00       	mov    $0x1000e8,%eax
  1012a7:	68 8e 00 00 00       	push   $0x8e
  1012ac:	6a 08                	push   $0x8
  1012ae:	50                   	push   %eax
  1012af:	6a 2d                	push   $0x2d
  1012b1:	e8 16 fb ff ff       	call   100dcc <idt_set_entry>
  1012b6:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  1012b9:	b8 ee 00 10 00       	mov    $0x1000ee,%eax
  1012be:	68 8e 00 00 00       	push   $0x8e
  1012c3:	6a 08                	push   $0x8
  1012c5:	50                   	push   %eax
  1012c6:	6a 2e                	push   $0x2e
  1012c8:	e8 ff fa ff ff       	call   100dcc <idt_set_entry>
  1012cd:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  1012d0:	b8 f4 00 10 00       	mov    $0x1000f4,%eax
  1012d5:	68 8e 00 00 00       	push   $0x8e
  1012da:	6a 08                	push   $0x8
  1012dc:	50                   	push   %eax
  1012dd:	6a 2f                	push   $0x2f
  1012df:	e8 e8 fa ff ff       	call   100dcc <idt_set_entry>
  1012e4:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  1012e7:	b8 fa 00 10 00       	mov    $0x1000fa,%eax
  1012ec:	68 ee 00 00 00       	push   $0xee
  1012f1:	6a 08                	push   $0x8
  1012f3:	50                   	push   %eax
  1012f4:	6a 30                	push   $0x30
  1012f6:	e8 d1 fa ff ff       	call   100dcc <idt_set_entry>
  1012fb:	83 c4 10             	add    $0x10,%esp
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  1012fe:	b8 20 62 10 00       	mov    $0x106220,%eax
  101303:	68 e9 00 00 00       	push   $0xe9
  101308:	68 80 00 00 00       	push   $0x80
  10130d:	50                   	push   %eax
  10130e:	6a 05                	push   $0x5
  101310:	e8 2e f8 ff ff       	call   100b43 <set_gdt_entry>
  101315:	83 c4 10             	add    $0x10,%esp
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101318:	b8 28 00 00 00       	mov    $0x28,%eax
  10131d:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  101320:	0f 01 5d ee          	lidtl  -0x12(%ebp)
	asm volatile("sti");
  101324:	fb                   	sti    
}
  101325:	c9                   	leave  
  101326:	c3                   	ret    

00101327 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  101327:	55                   	push   %ebp
  101328:	89 e5                	mov    %esp,%ebp
	handlers[i] = fn;
  10132a:	8b 45 08             	mov    0x8(%ebp),%eax
  10132d:	8b 55 0c             	mov    0xc(%ebp),%edx
  101330:	89 14 85 40 82 12 00 	mov    %edx,0x128240(,%eax,4)
	handler_set[i] = 1;
  101337:	8b 45 08             	mov    0x8(%ebp),%eax
  10133a:	c7 04 85 40 83 12 00 	movl   $0x1,0x128340(,%eax,4)
  101341:	01 00 00 00 
}
  101345:	5d                   	pop    %ebp
  101346:	c3                   	ret    

00101347 <register_irq_rpc>:

uint32_t register_irq_rpc(uint32_t irq) {
  101347:	55                   	push   %ebp
  101348:	89 e5                	mov    %esp,%ebp
  10134a:	53                   	push   %ebx
  10134b:	83 ec 04             	sub    $0x4,%esp
    if (irq >= 0x20 && irq <= 0x2f) {
  10134e:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  101352:	76 1e                	jbe    101372 <register_irq_rpc+0x2b>
  101354:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  101358:	77 18                	ja     101372 <register_irq_rpc+0x2b>
        irq_rpcs[irq] = get_current_task()->PID;
  10135a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  10135d:	e8 47 19 00 00       	call   102ca9 <get_current_task>
  101362:	8b 00                	mov    (%eax),%eax
  101364:	89 04 9d 40 84 12 00 	mov    %eax,0x128440(,%ebx,4)
        return 1;
  10136b:	b8 01 00 00 00       	mov    $0x1,%eax
  101370:	eb 05                	jmp    101377 <register_irq_rpc+0x30>
    }
    return 0;
  101372:	b8 00 00 00 00       	mov    $0x0,%eax
}
  101377:	83 c4 04             	add    $0x4,%esp
  10137a:	5b                   	pop    %ebx
  10137b:	5d                   	pop    %ebp
  10137c:	c3                   	ret    

0010137d <disable_irq_rpc>:

void disable_irq_rpc(uint32_t irq) {
  10137d:	55                   	push   %ebp
  10137e:	89 e5                	mov    %esp,%ebp
    if (irq >= 0x20 && irq <= 0x2f) {
  101380:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  101384:	76 2a                	jbe    1013b0 <disable_irq_rpc+0x33>
  101386:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  10138a:	77 24                	ja     1013b0 <disable_irq_rpc+0x33>
        if(irq_rpcs[irq] > 0) {
  10138c:	8b 45 08             	mov    0x8(%ebp),%eax
  10138f:	8b 04 85 40 84 12 00 	mov    0x128440(,%eax,4),%eax
  101396:	85 c0                	test   %eax,%eax
  101398:	7e 16                	jle    1013b0 <disable_irq_rpc+0x33>
            irq_rpcs[irq] = -irq_rpcs[irq];
  10139a:	8b 45 08             	mov    0x8(%ebp),%eax
  10139d:	8b 55 08             	mov    0x8(%ebp),%edx
  1013a0:	8b 14 95 40 84 12 00 	mov    0x128440(,%edx,4),%edx
  1013a7:	f7 da                	neg    %edx
  1013a9:	89 14 85 40 84 12 00 	mov    %edx,0x128440(,%eax,4)
        }
    }
}
  1013b0:	5d                   	pop    %ebp
  1013b1:	c3                   	ret    

001013b2 <enable_irq_rpc>:

void enable_irq_rpc(uint32_t irq) {
  1013b2:	55                   	push   %ebp
  1013b3:	89 e5                	mov    %esp,%ebp
    if (irq >= 0x20 && irq <= 0x2f) {
  1013b5:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  1013b9:	76 2a                	jbe    1013e5 <enable_irq_rpc+0x33>
  1013bb:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  1013bf:	77 24                	ja     1013e5 <enable_irq_rpc+0x33>
        if(irq_rpcs[irq] < 0) {
  1013c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1013c4:	8b 04 85 40 84 12 00 	mov    0x128440(,%eax,4),%eax
  1013cb:	85 c0                	test   %eax,%eax
  1013cd:	79 16                	jns    1013e5 <enable_irq_rpc+0x33>
            irq_rpcs[irq] = -irq_rpcs[irq];
  1013cf:	8b 45 08             	mov    0x8(%ebp),%eax
  1013d2:	8b 55 08             	mov    0x8(%ebp),%edx
  1013d5:	8b 14 95 40 84 12 00 	mov    0x128440(,%edx,4),%edx
  1013dc:	f7 da                	neg    %edx
  1013de:	89 14 85 40 84 12 00 	mov    %edx,0x128440(,%eax,4)
        }
    }
}
  1013e5:	5d                   	pop    %ebp
  1013e6:	c3                   	ret    

001013e7 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  1013e7:	55                   	push   %ebp
  1013e8:	89 e5                	mov    %esp,%ebp
  1013ea:	83 ec 18             	sub    $0x18,%esp
	struct cpu_state* new_cpu = cpu;
  1013ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1013f0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (cpu->intr <= 0x1f) {
  1013f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1013f6:	8b 40 1c             	mov    0x1c(%eax),%eax
  1013f9:	83 f8 1f             	cmp    $0x1f,%eax
  1013fc:	77 37                	ja     101435 <handle_interrupt+0x4e>
		if (!isSchedulingEnabled()) {
  1013fe:	e8 9c 18 00 00       	call   102c9f <isSchedulingEnabled>
  101403:	85 c0                	test   %eax,%eax
  101405:	75 18                	jne    10141f <handle_interrupt+0x38>
			show_cod(cpu, "Kernel PANIC!");
  101407:	83 ec 08             	sub    $0x8,%esp
  10140a:	68 ce 71 10 00       	push   $0x1071ce
  10140f:	ff 75 08             	pushl  0x8(%ebp)
  101412:	e8 bf ed ff ff       	call   1001d6 <show_cod>
  101417:	83 c4 10             	add    $0x10,%esp
		} else {
			new_cpu = schedule_exception(cpu);
  10141a:	e9 08 01 00 00       	jmp    101527 <handle_interrupt+0x140>
  10141f:	83 ec 0c             	sub    $0xc,%esp
  101422:	ff 75 08             	pushl  0x8(%ebp)
  101425:	e8 af 19 00 00       	call   102dd9 <schedule_exception>
  10142a:	83 c4 10             	add    $0x10,%esp
  10142d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101430:	e9 f2 00 00 00       	jmp    101527 <handle_interrupt+0x140>
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  101435:	8b 45 08             	mov    0x8(%ebp),%eax
  101438:	8b 40 1c             	mov    0x1c(%eax),%eax
  10143b:	83 f8 1f             	cmp    $0x1f,%eax
  10143e:	0f 86 b2 00 00 00    	jbe    1014f6 <handle_interrupt+0x10f>
  101444:	8b 45 08             	mov    0x8(%ebp),%eax
  101447:	8b 40 1c             	mov    0x1c(%eax),%eax
  10144a:	83 f8 2f             	cmp    $0x2f,%eax
  10144d:	0f 87 a3 00 00 00    	ja     1014f6 <handle_interrupt+0x10f>
		if (cpu->intr >= 0x28) {
  101453:	8b 45 08             	mov    0x8(%ebp),%eax
  101456:	8b 40 1c             	mov    0x1c(%eax),%eax
  101459:	83 f8 27             	cmp    $0x27,%eax
  10145c:	76 12                	jbe    101470 <handle_interrupt+0x89>
			outb(0xa0, 0x20);
  10145e:	83 ec 08             	sub    $0x8,%esp
  101461:	6a 20                	push   $0x20
  101463:	68 a0 00 00 00       	push   $0xa0
  101468:	e8 43 f9 ff ff       	call   100db0 <outb>
  10146d:	83 c4 10             	add    $0x10,%esp
		}

		if (cpu->intr == 0x20) {
  101470:	8b 45 08             	mov    0x8(%ebp),%eax
  101473:	8b 40 1c             	mov    0x1c(%eax),%eax
  101476:	83 f8 20             	cmp    $0x20,%eax
  101479:	75 13                	jne    10148e <handle_interrupt+0xa7>
			new_cpu = schedule(cpu);
  10147b:	83 ec 0c             	sub    $0xc,%esp
  10147e:	ff 75 08             	pushl  0x8(%ebp)
  101481:	e8 36 1d 00 00       	call   1031bc <schedule>
  101486:	83 c4 10             	add    $0x10,%esp
  101489:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10148c:	eb 57                	jmp    1014e5 <handle_interrupt+0xfe>
		}
		else
		{
            if (handler_set[cpu->intr]) {
  10148e:	8b 45 08             	mov    0x8(%ebp),%eax
  101491:	8b 40 1c             	mov    0x1c(%eax),%eax
  101494:	8b 04 85 40 83 12 00 	mov    0x128340(,%eax,4),%eax
  10149b:	85 c0                	test   %eax,%eax
  10149d:	74 0f                	je     1014ae <handle_interrupt+0xc7>
                handlers[cpu->intr]();
  10149f:	8b 45 08             	mov    0x8(%ebp),%eax
  1014a2:	8b 40 1c             	mov    0x1c(%eax),%eax
  1014a5:	8b 04 85 40 82 12 00 	mov    0x128240(,%eax,4),%eax
  1014ac:	ff d0                	call   *%eax
            }
            if(irq_rpcs[cpu->intr] > 0) {
  1014ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1014b1:	8b 40 1c             	mov    0x1c(%eax),%eax
  1014b4:	8b 04 85 40 84 12 00 	mov    0x128440(,%eax,4),%eax
  1014bb:	85 c0                	test   %eax,%eax
  1014bd:	7e 26                	jle    1014e5 <handle_interrupt+0xfe>
                create_rpc_call(irq_rpcs[cpu->intr], RPCT_IRQ, cpu->intr, 0, 0);
  1014bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1014c2:	8b 50 1c             	mov    0x1c(%eax),%edx
  1014c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1014c8:	8b 40 1c             	mov    0x1c(%eax),%eax
  1014cb:	8b 04 85 40 84 12 00 	mov    0x128440(,%eax,4),%eax
  1014d2:	83 ec 0c             	sub    $0xc,%esp
  1014d5:	6a 00                	push   $0x0
  1014d7:	6a 00                	push   $0x0
  1014d9:	52                   	push   %edx
  1014da:	6a 00                	push   $0x0
  1014dc:	50                   	push   %eax
  1014dd:	e8 31 1e 00 00       	call   103313 <create_rpc_call>
  1014e2:	83 c4 20             	add    $0x20,%esp
                //disable_irq_rpc(cpu->intr); TODO find out if we need to block
            }
		}

        outb(0x20, 0x20);
  1014e5:	83 ec 08             	sub    $0x8,%esp
  1014e8:	6a 20                	push   $0x20
  1014ea:	6a 20                	push   $0x20
  1014ec:	e8 bf f8 ff ff       	call   100db0 <outb>
  1014f1:	83 c4 10             	add    $0x10,%esp
		if (!isSchedulingEnabled()) {
			show_cod(cpu, "Kernel PANIC!");
		} else {
			new_cpu = schedule_exception(cpu);
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  1014f4:	eb 31                	jmp    101527 <handle_interrupt+0x140>
                //disable_irq_rpc(cpu->intr); TODO find out if we need to block
            }
		}

        outb(0x20, 0x20);
	} else if (cpu->intr == 0x30) {
  1014f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1014f9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1014fc:	83 f8 30             	cmp    $0x30,%eax
  1014ff:	75 13                	jne    101514 <handle_interrupt+0x12d>
		new_cpu = syscall(new_cpu);
  101501:	83 ec 0c             	sub    $0xc,%esp
  101504:	ff 75 f4             	pushl  -0xc(%ebp)
  101507:	e8 5a 00 00 00       	call   101566 <syscall>
  10150c:	83 c4 10             	add    $0x10,%esp
  10150f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101512:	eb 13                	jmp    101527 <handle_interrupt+0x140>
	} else {
		show_cod(cpu, "Unknown Interrupt!");
  101514:	83 ec 08             	sub    $0x8,%esp
  101517:	68 dc 71 10 00       	push   $0x1071dc
  10151c:	ff 75 08             	pushl  0x8(%ebp)
  10151f:	e8 b2 ec ff ff       	call   1001d6 <show_cod>
  101524:	83 c4 10             	add    $0x10,%esp
	}

	return new_cpu;
  101527:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  10152a:	c9                   	leave  
  10152b:	c3                   	ret    

0010152c <outw>:
    uint32_t result;
    asm volatile ("inl %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline void outw(uint16_t _port, uint16_t _data) {
  10152c:	55                   	push   %ebp
  10152d:	89 e5                	mov    %esp,%ebp
  10152f:	83 ec 08             	sub    $0x8,%esp
  101532:	8b 55 08             	mov    0x8(%ebp),%edx
  101535:	8b 45 0c             	mov    0xc(%ebp),%eax
  101538:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
  10153c:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
  101540:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101543:	8b 55 fc             	mov    -0x4(%ebp),%edx
  101546:	66 ef                	out    %ax,(%dx)
}
  101548:	c9                   	leave  
  101549:	c3                   	ret    

0010154a <outb>:

static inline void outb(uint16_t _port, uint8_t _data) {
  10154a:	55                   	push   %ebp
  10154b:	89 e5                	mov    %esp,%ebp
  10154d:	83 ec 08             	sub    $0x8,%esp
  101550:	8b 45 08             	mov    0x8(%ebp),%eax
  101553:	8b 55 0c             	mov    0xc(%ebp),%edx
  101556:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  10155a:	88 55 f8             	mov    %dl,-0x8(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  10155d:	8a 45 f8             	mov    -0x8(%ebp),%al
  101560:	8b 55 fc             	mov    -0x4(%ebp),%edx
  101563:	ee                   	out    %al,(%dx)
}
  101564:	c9                   	leave  
  101565:	c3                   	ret    

00101566 <syscall>:
    char* stdin;
    char* stdout;
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
  101566:	55                   	push   %ebp
  101567:	89 e5                	mov    %esp,%ebp
  101569:	56                   	push   %esi
  10156a:	53                   	push   %ebx
  10156b:	83 ec 70             	sub    $0x70,%esp
    cpu = save_cpu_state(cpu);
  10156e:	83 ec 0c             	sub    $0xc,%esp
  101571:	ff 75 08             	pushl  0x8(%ebp)
  101574:	e8 7e 1b 00 00       	call   1030f7 <save_cpu_state>
  101579:	83 c4 10             	add    $0x10,%esp
  10157c:	89 45 08             	mov    %eax,0x8(%ebp)

	switch (cpu->eax) {
  10157f:	8b 45 08             	mov    0x8(%ebp),%eax
  101582:	8b 00                	mov    (%eax),%eax
  101584:	3d cd 00 00 00       	cmp    $0xcd,%eax
  101589:	0f 87 c5 06 00 00    	ja     101c54 <syscall+0x6ee>
  10158f:	8b 04 85 0c 72 10 00 	mov    0x10720c(,%eax,4),%eax
  101596:	ff e0                	jmp    *%eax
	case 1: /* exit */
		return terminate_current(cpu);
  101598:	83 ec 0c             	sub    $0xc,%esp
  10159b:	ff 75 08             	pushl  0x8(%ebp)
  10159e:	e8 28 19 00 00       	call   102ecb <terminate_current>
  1015a3:	83 c4 10             	add    $0x10,%esp
  1015a6:	e9 ce 06 00 00       	jmp    101c79 <syscall+0x713>

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  1015ab:	8b 45 08             	mov    0x8(%ebp),%eax
  1015ae:	8b 40 04             	mov    0x4(%eax),%eax
  1015b1:	83 ec 0c             	sub    $0xc,%esp
  1015b4:	50                   	push   %eax
  1015b5:	e8 36 26 00 00       	call   103bf0 <strclone>
  1015ba:	83 c4 10             	add    $0x10,%esp
  1015bd:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        struct exec_info* einp = (void*) cpu->edx;
  1015c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1015c3:	8b 40 0c             	mov    0xc(%eax),%eax
  1015c6:	89 45 a8             	mov    %eax,-0x58(%ebp)
        struct exec_info ein = {
            .execPath = 0,
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };
  1015c9:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
  1015d0:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
  1015d7:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
  1015de:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)

        if(einp != 0) {
  1015e5:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
  1015e9:	74 53                	je     10163e <syscall+0xd8>
            ein.execPath = strclone(einp->execPath);
  1015eb:	8b 45 a8             	mov    -0x58(%ebp),%eax
  1015ee:	8b 00                	mov    (%eax),%eax
  1015f0:	83 ec 0c             	sub    $0xc,%esp
  1015f3:	50                   	push   %eax
  1015f4:	e8 f7 25 00 00       	call   103bf0 <strclone>
  1015f9:	83 c4 10             	add    $0x10,%esp
  1015fc:	89 45 90             	mov    %eax,-0x70(%ebp)
            ein.stdin = strclone(einp->stdin);
  1015ff:	8b 45 a8             	mov    -0x58(%ebp),%eax
  101602:	8b 40 04             	mov    0x4(%eax),%eax
  101605:	83 ec 0c             	sub    $0xc,%esp
  101608:	50                   	push   %eax
  101609:	e8 e2 25 00 00       	call   103bf0 <strclone>
  10160e:	83 c4 10             	add    $0x10,%esp
  101611:	89 45 94             	mov    %eax,-0x6c(%ebp)
            ein.stdout = strclone(einp->stdout);
  101614:	8b 45 a8             	mov    -0x58(%ebp),%eax
  101617:	8b 40 08             	mov    0x8(%eax),%eax
  10161a:	83 ec 0c             	sub    $0xc,%esp
  10161d:	50                   	push   %eax
  10161e:	e8 cd 25 00 00       	call   103bf0 <strclone>
  101623:	83 c4 10             	add    $0x10,%esp
  101626:	89 45 98             	mov    %eax,-0x68(%ebp)
            ein.stderr = strclone(einp->stderr);
  101629:	8b 45 a8             	mov    -0x58(%ebp),%eax
  10162c:	8b 40 0c             	mov    0xc(%eax),%eax
  10162f:	83 ec 0c             	sub    $0xc,%esp
  101632:	50                   	push   %eax
  101633:	e8 b8 25 00 00       	call   103bf0 <strclone>
  101638:	83 c4 10             	add    $0x10,%esp
  10163b:	89 45 9c             	mov    %eax,-0x64(%ebp)
        }

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  10163e:	8b 75 9c             	mov    -0x64(%ebp),%esi
  101641:	8b 5d 98             	mov    -0x68(%ebp),%ebx
  101644:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
  101647:	8b 55 90             	mov    -0x70(%ebp),%edx
  10164a:	8b 45 08             	mov    0x8(%ebp),%eax
  10164d:	8b 40 08             	mov    0x8(%eax),%eax
  101650:	83 ec 08             	sub    $0x8,%esp
  101653:	56                   	push   %esi
  101654:	53                   	push   %ebx
  101655:	51                   	push   %ecx
  101656:	52                   	push   %edx
  101657:	50                   	push   %eax
  101658:	ff 75 a4             	pushl  -0x5c(%ebp)
  10165b:	e8 b9 2e 00 00       	call   104519 <vfs_exec>
  101660:	83 c4 20             	add    $0x20,%esp
  101663:	8b 55 08             	mov    0x8(%ebp),%edx
  101666:	89 02                	mov    %eax,(%edx)

        if(einp != 0) {
  101668:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
  10166c:	74 3c                	je     1016aa <syscall+0x144>
            free(ein.execPath);
  10166e:	8b 45 90             	mov    -0x70(%ebp),%eax
  101671:	83 ec 0c             	sub    $0xc,%esp
  101674:	50                   	push   %eax
  101675:	e8 72 23 00 00       	call   1039ec <free>
  10167a:	83 c4 10             	add    $0x10,%esp
            free(ein.stdin);
  10167d:	8b 45 94             	mov    -0x6c(%ebp),%eax
  101680:	83 ec 0c             	sub    $0xc,%esp
  101683:	50                   	push   %eax
  101684:	e8 63 23 00 00       	call   1039ec <free>
  101689:	83 c4 10             	add    $0x10,%esp
            free(ein.stdout);
  10168c:	8b 45 98             	mov    -0x68(%ebp),%eax
  10168f:	83 ec 0c             	sub    $0xc,%esp
  101692:	50                   	push   %eax
  101693:	e8 54 23 00 00       	call   1039ec <free>
  101698:	83 c4 10             	add    $0x10,%esp
            free(ein.stderr);
  10169b:	8b 45 9c             	mov    -0x64(%ebp),%eax
  10169e:	83 ec 0c             	sub    $0xc,%esp
  1016a1:	50                   	push   %eax
  1016a2:	e8 45 23 00 00       	call   1039ec <free>
  1016a7:	83 c4 10             	add    $0x10,%esp
        }

        free(path);
  1016aa:	83 ec 0c             	sub    $0xc,%esp
  1016ad:	ff 75 a4             	pushl  -0x5c(%ebp)
  1016b0:	e8 37 23 00 00       	call   1039ec <free>
  1016b5:	83 c4 10             	add    $0x10,%esp
    }
        break;
  1016b8:	e9 b9 05 00 00       	jmp    101c76 <syscall+0x710>

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  1016bd:	e8 e7 15 00 00       	call   102ca9 <get_current_task>
  1016c2:	8b 40 20             	mov    0x20(%eax),%eax
  1016c5:	89 c2                	mov    %eax,%edx
  1016c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1016ca:	89 10                	mov    %edx,(%eax)
    }
        break;
  1016cc:	e9 a5 05 00 00       	jmp    101c76 <syscall+0x710>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
  1016d1:	83 ec 0c             	sub    $0xc,%esp
  1016d4:	ff 75 08             	pushl  0x8(%ebp)
  1016d7:	e8 e0 1a 00 00       	call   1031bc <schedule>
  1016dc:	83 c4 10             	add    $0x10,%esp
  1016df:	89 45 08             	mov    %eax,0x8(%ebp)
    }
        break;
  1016e2:	e9 8f 05 00 00       	jmp    101c76 <syscall+0x710>

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  1016e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1016ea:	8b 40 04             	mov    0x4(%eax),%eax
  1016ed:	89 45 ac             	mov    %eax,-0x54(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  1016f0:	e8 b4 15 00 00       	call   102ca9 <get_current_task>
  1016f5:	8b 40 28             	mov    0x28(%eax),%eax
  1016f8:	85 c0                	test   %eax,%eax
  1016fa:	0f 84 6c 05 00 00    	je     101c6c <syscall+0x706>
  101700:	e8 a4 15 00 00       	call   102ca9 <get_current_task>
  101705:	8b 40 28             	mov    0x28(%eax),%eax
  101708:	83 ec 08             	sub    $0x8,%esp
  10170b:	50                   	push   %eax
  10170c:	ff 75 ac             	pushl  -0x54(%ebp)
  10170f:	e8 b9 24 00 00       	call   103bcd <strcpy>
  101714:	83 c4 10             	add    $0x10,%esp
    }
        break;
  101717:	e9 5a 05 00 00       	jmp    101c76 <syscall+0x710>

    case 7: /* changeExecPath */
    {
        vfs_reset_error();
  10171c:	e8 9f 26 00 00       	call   103dc0 <vfs_reset_error>
        char* path = strclone((char*) cpu->ebx);
  101721:	8b 45 08             	mov    0x8(%ebp),%eax
  101724:	8b 40 04             	mov    0x4(%eax),%eax
  101727:	83 ec 0c             	sub    $0xc,%esp
  10172a:	50                   	push   %eax
  10172b:	e8 c0 24 00 00       	call   103bf0 <strclone>
  101730:	83 c4 10             	add    $0x10,%esp
  101733:	89 45 b0             	mov    %eax,-0x50(%ebp)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  101736:	e8 6e 15 00 00       	call   102ca9 <get_current_task>
  10173b:	8b 40 28             	mov    0x28(%eax),%eax
  10173e:	85 c0                	test   %eax,%eax
  101740:	74 14                	je     101756 <syscall+0x1f0>
  101742:	e8 62 15 00 00       	call   102ca9 <get_current_task>
  101747:	8b 40 28             	mov    0x28(%eax),%eax
  10174a:	83 ec 0c             	sub    $0xc,%esp
  10174d:	50                   	push   %eax
  10174e:	e8 99 22 00 00       	call   1039ec <free>
  101753:	83 c4 10             	add    $0x10,%esp

        char* new = vfs_resolve_path(path);
  101756:	83 ec 0c             	sub    $0xc,%esp
  101759:	ff 75 b0             	pushl  -0x50(%ebp)
  10175c:	e8 92 32 00 00       	call   1049f3 <vfs_resolve_path>
  101761:	83 c4 10             	add    $0x10,%esp
  101764:	89 45 b4             	mov    %eax,-0x4c(%ebp)

        cpu->eax = 0;
  101767:	8b 45 08             	mov    0x8(%ebp),%eax
  10176a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        if(new) {
  101770:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  101774:	74 14                	je     10178a <syscall+0x224>
            get_current_task()->execPath = new;
  101776:	e8 2e 15 00 00       	call   102ca9 <get_current_task>
  10177b:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  10177e:	89 50 28             	mov    %edx,0x28(%eax)
            cpu->eax = 1;
  101781:	8b 45 08             	mov    0x8(%ebp),%eax
  101784:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        }

        free(path);
  10178a:	83 ec 0c             	sub    $0xc,%esp
  10178d:	ff 75 b0             	pushl  -0x50(%ebp)
  101790:	e8 57 22 00 00       	call   1039ec <free>
  101795:	83 c4 10             	add    $0x10,%esp
    }
        break;
  101798:	e9 d9 04 00 00       	jmp    101c76 <syscall+0x710>

	case 10: /* fopen */
	{
        vfs_reset_error();
  10179d:	e8 1e 26 00 00       	call   103dc0 <vfs_reset_error>
	    char* name = strclone((char*) cpu->ebx);
  1017a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1017a5:	8b 40 04             	mov    0x4(%eax),%eax
  1017a8:	83 ec 0c             	sub    $0xc,%esp
  1017ab:	50                   	push   %eax
  1017ac:	e8 3f 24 00 00       	call   103bf0 <strclone>
  1017b1:	83 c4 10             	add    $0x10,%esp
  1017b4:	89 45 b8             	mov    %eax,-0x48(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  1017b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1017ba:	8b 40 08             	mov    0x8(%eax),%eax
  1017bd:	89 45 bc             	mov    %eax,-0x44(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  1017c0:	83 ec 08             	sub    $0x8,%esp
  1017c3:	ff 75 bc             	pushl  -0x44(%ebp)
  1017c6:	ff 75 b8             	pushl  -0x48(%ebp)
  1017c9:	e8 ed 2a 00 00       	call   1042bb <vfs_open>
  1017ce:	83 c4 10             	add    $0x10,%esp
  1017d1:	89 45 c0             	mov    %eax,-0x40(%ebp)
	    if(handle) {
  1017d4:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  1017d8:	74 18                	je     1017f2 <syscall+0x28c>
	        register_handle(handle);
  1017da:	83 ec 0c             	sub    $0xc,%esp
  1017dd:	ff 75 c0             	pushl  -0x40(%ebp)
  1017e0:	e8 fc 14 00 00       	call   102ce1 <register_handle>
  1017e5:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = (uint32_t) handle;
  1017e8:	8b 55 c0             	mov    -0x40(%ebp),%edx
  1017eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1017ee:	89 10                	mov    %edx,(%eax)
  1017f0:	eb 09                	jmp    1017fb <syscall+0x295>
	    }
	    else
	    {
	        cpu->eax = 0;
  1017f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1017f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }

	    free(name);
  1017fb:	83 ec 0c             	sub    $0xc,%esp
  1017fe:	ff 75 b8             	pushl  -0x48(%ebp)
  101801:	e8 e6 21 00 00       	call   1039ec <free>
  101806:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  101809:	e9 68 04 00 00       	jmp    101c76 <syscall+0x710>

	case 11: /* fclose */
	{
        vfs_reset_error();
  10180e:	e8 ad 25 00 00       	call   103dc0 <vfs_reset_error>
	    struct res_handle* handle = (void*) cpu->ebx;
  101813:	8b 45 08             	mov    0x8(%ebp),%eax
  101816:	8b 40 04             	mov    0x4(%eax),%eax
  101819:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	    if(!unregister_handle(handle)) {
  10181c:	83 ec 0c             	sub    $0xc,%esp
  10181f:	ff 75 c4             	pushl  -0x3c(%ebp)
  101822:	e8 07 15 00 00       	call   102d2e <unregister_handle>
  101827:	83 c4 10             	add    $0x10,%esp
  10182a:	85 c0                	test   %eax,%eax
  10182c:	75 1c                	jne    10184a <syscall+0x2e4>
	        vfs_close(handle);
  10182e:	83 ec 0c             	sub    $0xc,%esp
  101831:	ff 75 c4             	pushl  -0x3c(%ebp)
  101834:	e8 df 2a 00 00       	call   104318 <vfs_close>
  101839:	83 c4 10             	add    $0x10,%esp

	        cpu->eax = 0;
  10183c:	8b 45 08             	mov    0x8(%ebp),%eax
  10183f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    else
	    {
	        cpu->eax = (uint32_t) -1;
	    }
	}
	    break;
  101845:	e9 2c 04 00 00       	jmp    101c76 <syscall+0x710>

	        cpu->eax = 0;
	    }
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  10184a:	8b 45 08             	mov    0x8(%ebp),%eax
  10184d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  101853:	e9 1e 04 00 00       	jmp    101c76 <syscall+0x710>

	case 12: /* fwrite */
	{
        vfs_reset_error();
  101858:	e8 63 25 00 00       	call   103dc0 <vfs_reset_error>
	    struct res_handle* handle = (void*) cpu->ebx;
  10185d:	8b 45 08             	mov    0x8(%ebp),%eax
  101860:	8b 40 04             	mov    0x4(%eax),%eax
  101863:	89 45 c8             	mov    %eax,-0x38(%ebp)
	    if(handle != 0) {
  101866:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  10186a:	74 25                	je     101891 <syscall+0x32b>
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  10186c:	8b 45 08             	mov    0x8(%ebp),%eax
  10186f:	8b 50 0c             	mov    0xc(%eax),%edx
  101872:	8b 45 08             	mov    0x8(%ebp),%eax
  101875:	8b 40 08             	mov    0x8(%eax),%eax
  101878:	6a 01                	push   $0x1
  10187a:	52                   	push   %edx
  10187b:	50                   	push   %eax
  10187c:	ff 75 c8             	pushl  -0x38(%ebp)
  10187f:	e8 65 2b 00 00       	call   1043e9 <vfs_write>
  101884:	83 c4 10             	add    $0x10,%esp
  101887:	8b 55 08             	mov    0x8(%ebp),%edx
  10188a:	89 02                	mov    %eax,(%edx)
	    else
	    {
            cpu->eax = RW_ERR_VFS;
	    }
	}
	    break;
  10188c:	e9 e5 03 00 00       	jmp    101c76 <syscall+0x710>
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  101891:	8b 45 08             	mov    0x8(%ebp),%eax
  101894:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  10189a:	e9 d7 03 00 00       	jmp    101c76 <syscall+0x710>

	case 13: /* fread */
	{
        vfs_reset_error();
  10189f:	e8 1c 25 00 00       	call   103dc0 <vfs_reset_error>
        struct res_handle* handle = (void*) cpu->ebx;
  1018a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1018a7:	8b 40 04             	mov    0x4(%eax),%eax
  1018aa:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(handle != 0) {
  1018ad:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  1018b1:	74 25                	je     1018d8 <syscall+0x372>
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  1018b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1018b6:	8b 50 0c             	mov    0xc(%eax),%edx
  1018b9:	8b 45 08             	mov    0x8(%ebp),%eax
  1018bc:	8b 40 08             	mov    0x8(%eax),%eax
  1018bf:	6a 01                	push   $0x1
  1018c1:	52                   	push   %edx
  1018c2:	50                   	push   %eax
  1018c3:	ff 75 cc             	pushl  -0x34(%ebp)
  1018c6:	e8 83 2a 00 00       	call   10434e <vfs_read>
  1018cb:	83 c4 10             	add    $0x10,%esp
  1018ce:	8b 55 08             	mov    0x8(%ebp),%edx
  1018d1:	89 02                	mov    %eax,(%edx)
        else
        {
            cpu->eax = RW_ERR_VFS;
        }
	}
	    break;
  1018d3:	e9 9e 03 00 00       	jmp    101c76 <syscall+0x710>
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
        {
            cpu->eax = RW_ERR_VFS;
  1018d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1018db:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  1018e1:	e9 90 03 00 00       	jmp    101c76 <syscall+0x710>

	case 14: /* fmkfifo */
	{
        vfs_reset_error();
  1018e6:	e8 d5 24 00 00       	call   103dc0 <vfs_reset_error>
        char* name = strclone((char*) cpu->ebx);
  1018eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1018ee:	8b 40 04             	mov    0x4(%eax),%eax
  1018f1:	83 ec 0c             	sub    $0xc,%esp
  1018f4:	50                   	push   %eax
  1018f5:	e8 f6 22 00 00       	call   103bf0 <strclone>
  1018fa:	83 c4 10             	add    $0x10,%esp
  1018fd:	89 45 d0             	mov    %eax,-0x30(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  101900:	c7 45 a0 00 10 00 00 	movl   $0x1000,-0x60(%ebp)
  101907:	e8 17 0c 00 00       	call   102523 <ramfs_fifo_driver_struct>
  10190c:	83 ec 04             	sub    $0x4,%esp
  10190f:	8d 55 a0             	lea    -0x60(%ebp),%edx
  101912:	52                   	push   %edx
  101913:	50                   	push   %eax
  101914:	ff 75 d0             	pushl  -0x30(%ebp)
  101917:	e8 00 29 00 00       	call   10421c <vfs_create_kfile>
  10191c:	83 c4 10             	add    $0x10,%esp

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  10191f:	83 ec 08             	sub    $0x8,%esp
  101922:	6a 03                	push   $0x3
  101924:	ff 75 d0             	pushl  -0x30(%ebp)
  101927:	e8 8f 29 00 00       	call   1042bb <vfs_open>
  10192c:	83 c4 10             	add    $0x10,%esp
  10192f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(handle) {
  101932:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  101936:	74 18                	je     101950 <syscall+0x3ea>
            register_handle(handle);
  101938:	83 ec 0c             	sub    $0xc,%esp
  10193b:	ff 75 d4             	pushl  -0x2c(%ebp)
  10193e:	e8 9e 13 00 00       	call   102ce1 <register_handle>
  101943:	83 c4 10             	add    $0x10,%esp
            cpu->eax = (uint32_t) handle;
  101946:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  101949:	8b 45 08             	mov    0x8(%ebp),%eax
  10194c:	89 10                	mov    %edx,(%eax)
  10194e:	eb 09                	jmp    101959 <syscall+0x3f3>
        }
        else
        {
            cpu->eax = 0;
  101950:	8b 45 08             	mov    0x8(%ebp),%eax
  101953:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        free(name);
  101959:	83 ec 0c             	sub    $0xc,%esp
  10195c:	ff 75 d0             	pushl  -0x30(%ebp)
  10195f:	e8 88 20 00 00       	call   1039ec <free>
  101964:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  101967:	e9 0a 03 00 00       	jmp    101c76 <syscall+0x710>

	case 15: /* getLastVFSErr */
	{
	    cpu->eax = get_current_task()->vfserr;
  10196c:	e8 38 13 00 00       	call   102ca9 <get_current_task>
  101971:	8b 50 2c             	mov    0x2c(%eax),%edx
  101974:	8b 45 08             	mov    0x8(%ebp),%eax
  101977:	89 10                	mov    %edx,(%eax)
        vfs_reset_error();
  101979:	e8 42 24 00 00       	call   103dc0 <vfs_reset_error>
	}
	    break;
  10197e:	e9 f3 02 00 00       	jmp    101c76 <syscall+0x710>

	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  101983:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	    switch(cpu->ebx) {
  10198a:	8b 45 08             	mov    0x8(%ebp),%eax
  10198d:	8b 40 04             	mov    0x4(%eax),%eax
  101990:	83 f8 01             	cmp    $0x1,%eax
  101993:	74 19                	je     1019ae <syscall+0x448>
  101995:	83 f8 01             	cmp    $0x1,%eax
  101998:	72 07                	jb     1019a1 <syscall+0x43b>
  10199a:	83 f8 02             	cmp    $0x2,%eax
  10199d:	74 1c                	je     1019bb <syscall+0x455>
  10199f:	eb 27                	jmp    1019c8 <syscall+0x462>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
  1019a1:	e8 03 13 00 00       	call   102ca9 <get_current_task>
  1019a6:	8b 40 30             	mov    0x30(%eax),%eax
  1019a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
	        break;
  1019ac:	eb 25                	jmp    1019d3 <syscall+0x46d>
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  1019ae:	e8 f6 12 00 00       	call   102ca9 <get_current_task>
  1019b3:	8b 40 38             	mov    0x38(%eax),%eax
  1019b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
            break;
  1019b9:	eb 18                	jmp    1019d3 <syscall+0x46d>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  1019bb:	e8 e9 12 00 00       	call   102ca9 <get_current_task>
  1019c0:	8b 40 34             	mov    0x34(%eax),%eax
  1019c3:	89 45 d8             	mov    %eax,-0x28(%ebp)
            break;
  1019c6:	eb 0b                	jmp    1019d3 <syscall+0x46d>
        default:
            handle = get_current_task()->stdout;
  1019c8:	e8 dc 12 00 00       	call   102ca9 <get_current_task>
  1019cd:	8b 40 30             	mov    0x30(%eax),%eax
  1019d0:	89 45 d8             	mov    %eax,-0x28(%ebp)
            break;
	    }

	    cpu->eax = (uint32_t) handle;
  1019d3:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1019d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1019d9:	89 10                	mov    %edx,(%eax)
	}
	    break;
  1019db:	e9 96 02 00 00       	jmp    101c76 <syscall+0x710>

	case 21: /* fopenpmhandle */
	{
	    vfs_reset_error();
  1019e0:	e8 db 23 00 00       	call   103dc0 <vfs_reset_error>
	    char* path = strclone((char*)cpu->ecx);
  1019e5:	8b 45 08             	mov    0x8(%ebp),%eax
  1019e8:	8b 40 08             	mov    0x8(%eax),%eax
  1019eb:	83 ec 0c             	sub    $0xc,%esp
  1019ee:	50                   	push   %eax
  1019ef:	e8 fc 21 00 00       	call   103bf0 <strclone>
  1019f4:	83 c4 10             	add    $0x10,%esp
  1019f7:	89 45 dc             	mov    %eax,-0x24(%ebp)

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  1019fa:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)

	    if(cpu->ebx == PMID_STDIN) {
  101a01:	8b 45 08             	mov    0x8(%ebp),%eax
  101a04:	8b 40 04             	mov    0x4(%eax),%eax
  101a07:	83 f8 01             	cmp    $0x1,%eax
  101a0a:	75 07                	jne    101a13 <syscall+0x4ad>
	        fm = FM_READ;
  101a0c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
	    }

	    open = vfs_open(path, fm);
  101a13:	83 ec 08             	sub    $0x8,%esp
  101a16:	ff 75 e4             	pushl  -0x1c(%ebp)
  101a19:	ff 75 dc             	pushl  -0x24(%ebp)
  101a1c:	e8 9a 28 00 00       	call   1042bb <vfs_open>
  101a21:	83 c4 10             	add    $0x10,%esp
  101a24:	89 45 e0             	mov    %eax,-0x20(%ebp)

	    free(path);
  101a27:	83 ec 0c             	sub    $0xc,%esp
  101a2a:	ff 75 dc             	pushl  -0x24(%ebp)
  101a2d:	e8 ba 1f 00 00       	call   1039ec <free>
  101a32:	83 c4 10             	add    $0x10,%esp

	    if(!open) {
  101a35:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  101a39:	75 0e                	jne    101a49 <syscall+0x4e3>
	        cpu->eax = (uint32_t) -1;
  101a3b:	8b 45 08             	mov    0x8(%ebp),%eax
  101a3e:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	        break;
  101a44:	e9 2d 02 00 00       	jmp    101c76 <syscall+0x710>
	    }

	    struct res_handle* oldhandle = 0;
  101a49:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

        switch(cpu->ebx) {
  101a50:	8b 45 08             	mov    0x8(%ebp),%eax
  101a53:	8b 40 04             	mov    0x4(%eax),%eax
  101a56:	83 f8 01             	cmp    $0x1,%eax
  101a59:	74 24                	je     101a7f <syscall+0x519>
  101a5b:	83 f8 01             	cmp    $0x1,%eax
  101a5e:	72 07                	jb     101a67 <syscall+0x501>
  101a60:	83 f8 02             	cmp    $0x2,%eax
  101a63:	74 32                	je     101a97 <syscall+0x531>
  101a65:	eb 48                	jmp    101aaf <syscall+0x549>
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  101a67:	e8 3d 12 00 00       	call   102ca9 <get_current_task>
  101a6c:	8b 40 30             	mov    0x30(%eax),%eax
  101a6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stdout = open;
  101a72:	e8 32 12 00 00       	call   102ca9 <get_current_task>
  101a77:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101a7a:	89 50 30             	mov    %edx,0x30(%eax)
            break;
  101a7d:	eb 46                	jmp    101ac5 <syscall+0x55f>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  101a7f:	e8 25 12 00 00       	call   102ca9 <get_current_task>
  101a84:	8b 40 38             	mov    0x38(%eax),%eax
  101a87:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stdin = open;
  101a8a:	e8 1a 12 00 00       	call   102ca9 <get_current_task>
  101a8f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101a92:	89 50 38             	mov    %edx,0x38(%eax)
            break;
  101a95:	eb 2e                	jmp    101ac5 <syscall+0x55f>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  101a97:	e8 0d 12 00 00       	call   102ca9 <get_current_task>
  101a9c:	8b 40 34             	mov    0x34(%eax),%eax
  101a9f:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stderr = open;
  101aa2:	e8 02 12 00 00       	call   102ca9 <get_current_task>
  101aa7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101aaa:	89 50 34             	mov    %edx,0x34(%eax)
            break;
  101aad:	eb 16                	jmp    101ac5 <syscall+0x55f>
        default:
            oldhandle = get_current_task()->stdout;
  101aaf:	e8 f5 11 00 00       	call   102ca9 <get_current_task>
  101ab4:	8b 40 30             	mov    0x30(%eax),%eax
  101ab7:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stdout = open;
  101aba:	e8 ea 11 00 00       	call   102ca9 <get_current_task>
  101abf:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101ac2:	89 50 30             	mov    %edx,0x30(%eax)
            break;
        }

        if(oldhandle != 0) {
  101ac5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101ac9:	74 0e                	je     101ad9 <syscall+0x573>
            vfs_close(oldhandle);
  101acb:	83 ec 0c             	sub    $0xc,%esp
  101ace:	ff 75 e8             	pushl  -0x18(%ebp)
  101ad1:	e8 42 28 00 00       	call   104318 <vfs_close>
  101ad6:	83 c4 10             	add    $0x10,%esp
        }

        cpu->eax = 0;
  101ad9:	8b 45 08             	mov    0x8(%ebp),%eax
  101adc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	    break;
  101ae2:	e9 8f 01 00 00       	jmp    101c76 <syscall+0x710>

	case 30: /* return_rpc */
	{
	    cpu = return_rpc_call(cpu);
  101ae7:	83 ec 0c             	sub    $0xc,%esp
  101aea:	ff 75 08             	pushl  0x8(%ebp)
  101aed:	e8 8c 19 00 00       	call   10347e <return_rpc_call>
  101af2:	83 c4 10             	add    $0x10,%esp
  101af5:	89 45 08             	mov    %eax,0x8(%ebp)
	}
	    break;
  101af8:	e9 79 01 00 00       	jmp    101c76 <syscall+0x710>

	case 31: /* call_rpc */
	{
	    int PID = cpu->ebx;
  101afd:	8b 45 08             	mov    0x8(%ebp),%eax
  101b00:	8b 40 04             	mov    0x4(%eax),%eax
  101b03:	89 45 ec             	mov    %eax,-0x14(%ebp)

	    //TODO create RPC for U2U
	}
	    break;
  101b06:	e9 6b 01 00 00       	jmp    101c76 <syscall+0x710>

	case 32: /* set_rpc_handler */
	{
	    uint32_t handlerAddr = cpu->ebx;
  101b0b:	8b 45 08             	mov    0x8(%ebp),%eax
  101b0e:	8b 40 04             	mov    0x4(%eax),%eax
  101b11:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    if(get_current_task()->rpc_handler_addr == 0) {
  101b14:	e8 90 11 00 00       	call   102ca9 <get_current_task>
  101b19:	8b 40 1c             	mov    0x1c(%eax),%eax
  101b1c:	85 c0                	test   %eax,%eax
  101b1e:	0f 85 4b 01 00 00    	jne    101c6f <syscall+0x709>
	        get_current_task()->rpc_handler_addr = handlerAddr;
  101b24:	e8 80 11 00 00       	call   102ca9 <get_current_task>
  101b29:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101b2c:	89 50 1c             	mov    %edx,0x1c(%eax)
	    }
	}
	    break;
  101b2f:	e9 42 01 00 00       	jmp    101c76 <syscall+0x710>

	case 33: /* fetch_rpc_data */
	{
	    cpu->eax = 0;
  101b34:	8b 45 08             	mov    0x8(%ebp),%eax
  101b37:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    void* dest = (void*) cpu->ebx;
  101b3d:	8b 45 08             	mov    0x8(%ebp),%eax
  101b40:	8b 40 04             	mov    0x4(%eax),%eax
  101b43:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    if(get_current_task()->rpc != 0) {
  101b46:	e8 5e 11 00 00       	call   102ca9 <get_current_task>
  101b4b:	8b 40 18             	mov    0x18(%eax),%eax
  101b4e:	85 c0                	test   %eax,%eax
  101b50:	0f 84 1c 01 00 00    	je     101c72 <syscall+0x70c>
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
  101b56:	e8 4e 11 00 00       	call   102ca9 <get_current_task>
  101b5b:	8b 40 18             	mov    0x18(%eax),%eax
  101b5e:	8b 58 10             	mov    0x10(%eax),%ebx
  101b61:	e8 43 11 00 00       	call   102ca9 <get_current_task>
  101b66:	8b 40 18             	mov    0x18(%eax),%eax
  101b69:	8b 40 0c             	mov    0xc(%eax),%eax
  101b6c:	83 ec 04             	sub    $0x4,%esp
  101b6f:	53                   	push   %ebx
  101b70:	50                   	push   %eax
  101b71:	ff 75 f4             	pushl  -0xc(%ebp)
  101b74:	e8 f5 1e 00 00       	call   103a6e <memcpy>
  101b79:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = get_current_task()->rpc->dataSize;
  101b7c:	e8 28 11 00 00       	call   102ca9 <get_current_task>
  101b81:	8b 40 18             	mov    0x18(%eax),%eax
  101b84:	8b 50 10             	mov    0x10(%eax),%edx
  101b87:	8b 45 08             	mov    0x8(%ebp),%eax
  101b8a:	89 10                	mov    %edx,(%eax)
	    }
	}
	    break;
  101b8c:	e9 e5 00 00 00       	jmp    101c76 <syscall+0x710>

	case 40:
	{
	    cpu->eax = register_irq_rpc(cpu->ebx);
  101b91:	8b 45 08             	mov    0x8(%ebp),%eax
  101b94:	8b 40 04             	mov    0x4(%eax),%eax
  101b97:	83 ec 0c             	sub    $0xc,%esp
  101b9a:	50                   	push   %eax
  101b9b:	e8 a7 f7 ff ff       	call   101347 <register_irq_rpc>
  101ba0:	83 c4 10             	add    $0x10,%esp
  101ba3:	8b 55 08             	mov    0x8(%ebp),%edx
  101ba6:	89 02                	mov    %eax,(%edx)
	}
	    break;
  101ba8:	e9 c9 00 00 00       	jmp    101c76 <syscall+0x710>

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  101bad:	8b 45 08             	mov    0x8(%ebp),%eax
  101bb0:	8b 40 04             	mov    0x4(%eax),%eax
  101bb3:	83 ec 08             	sub    $0x8,%esp
  101bb6:	50                   	push   %eax
  101bb7:	68 f0 71 10 00       	push   $0x1071f0
  101bbc:	e8 ac e9 ff ff       	call   10056d <kprintf>
  101bc1:	83 c4 10             	add    $0x10,%esp
  101bc4:	89 c2                	mov    %eax,%edx
  101bc6:	8b 45 08             	mov    0x8(%ebp),%eax
  101bc9:	89 10                	mov    %edx,(%eax)
		break;
  101bcb:	e9 a6 00 00 00       	jmp    101c76 <syscall+0x710>

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  101bd0:	8b 45 08             	mov    0x8(%ebp),%eax
  101bd3:	8b 40 04             	mov    0x4(%eax),%eax
  101bd6:	83 ec 08             	sub    $0x8,%esp
  101bd9:	50                   	push   %eax
  101bda:	68 f3 71 10 00       	push   $0x1071f3
  101bdf:	e8 89 e9 ff ff       	call   10056d <kprintf>
  101be4:	83 c4 10             	add    $0x10,%esp
  101be7:	89 c2                	mov    %eax,%edx
  101be9:	8b 45 08             	mov    0x8(%ebp),%eax
  101bec:	89 10                	mov    %edx,(%eax)
		break;
  101bee:	e9 83 00 00 00       	jmp    101c76 <syscall+0x710>

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  101bf3:	8b 45 08             	mov    0x8(%ebp),%eax
  101bf6:	8b 40 04             	mov    0x4(%eax),%eax
  101bf9:	83 ec 0c             	sub    $0xc,%esp
  101bfc:	50                   	push   %eax
  101bfd:	e8 91 36 00 00       	call   105293 <vmm_alloc_ucont>
  101c02:	83 c4 10             	add    $0x10,%esp
  101c05:	89 c2                	mov    %eax,%edx
  101c07:	8b 45 08             	mov    0x8(%ebp),%eax
  101c0a:	89 10                	mov    %edx,(%eax)
		break;
  101c0c:	eb 68                	jmp    101c76 <syscall+0x710>

	case 204: /* vmm_free */
		cpu->eax = 0;
  101c0e:	8b 45 08             	mov    0x8(%ebp),%eax
  101c11:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  101c17:	8b 45 08             	mov    0x8(%ebp),%eax
  101c1a:	8b 40 04             	mov    0x4(%eax),%eax
  101c1d:	3d ff 0f 40 01       	cmp    $0x1400fff,%eax
  101c22:	76 51                	jbe    101c75 <syscall+0x70f>
			vmm_free((void*) cpu->ebx);
  101c24:	8b 45 08             	mov    0x8(%ebp),%eax
  101c27:	8b 40 04             	mov    0x4(%eax),%eax
  101c2a:	83 ec 0c             	sub    $0xc,%esp
  101c2d:	50                   	push   %eax
  101c2e:	e8 c6 34 00 00       	call   1050f9 <vmm_free>
  101c33:	83 c4 10             	add    $0x10,%esp
		}
		break;
  101c36:	eb 3e                	jmp    101c76 <syscall+0x710>

	case 205: /* pmm_print_stats */
		pmm_print_stats();
  101c38:	e8 a8 02 00 00       	call   101ee5 <pmm_print_stats>
        create_rpc_call(1, RPCT_KERNEL, 1, 0, 0);
  101c3d:	83 ec 0c             	sub    $0xc,%esp
  101c40:	6a 00                	push   $0x0
  101c42:	6a 00                	push   $0x0
  101c44:	6a 01                	push   $0x1
  101c46:	6a 01                	push   $0x1
  101c48:	6a 01                	push   $0x1
  101c4a:	e8 c4 16 00 00       	call   103313 <create_rpc_call>
  101c4f:	83 c4 20             	add    $0x20,%esp
		break;
  101c52:	eb 22                	jmp    101c76 <syscall+0x710>

	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  101c54:	8b 45 08             	mov    0x8(%ebp),%eax
  101c57:	8b 00                	mov    (%eax),%eax
  101c59:	83 ec 08             	sub    $0x8,%esp
  101c5c:	50                   	push   %eax
  101c5d:	68 f6 71 10 00       	push   $0x1071f6
  101c62:	e8 06 e9 ff ff       	call   10056d <kprintf>
  101c67:	83 c4 10             	add    $0x10,%esp
  101c6a:	eb 0a                	jmp    101c76 <syscall+0x710>
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;
  101c6c:	90                   	nop    
  101c6d:	eb 07                	jmp    101c76 <syscall+0x710>
	    uint32_t handlerAddr = cpu->ebx;
	    if(get_current_task()->rpc_handler_addr == 0) {
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
	}
	    break;
  101c6f:	90                   	nop    
  101c70:	eb 04                	jmp    101c76 <syscall+0x710>
	    if(get_current_task()->rpc != 0) {
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
	    break;
  101c72:	90                   	nop    
  101c73:	eb 01                	jmp    101c76 <syscall+0x710>
	case 204: /* vmm_free */
		cpu->eax = 0;
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
			vmm_free((void*) cpu->ebx);
		}
		break;
  101c75:	90                   	nop    
	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
		break;
	}

	return cpu;
  101c76:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101c79:	8d 65 f8             	lea    -0x8(%ebp),%esp
  101c7c:	83 c4 00             	add    $0x0,%esp
  101c7f:	5b                   	pop    %ebx
  101c80:	5e                   	pop    %esi
  101c81:	5d                   	pop    %ebp
  101c82:	c3                   	ret    

00101c83 <kernel_main>:

void kernel_main(struct multiboot_info* mb_info) {
  101c83:	55                   	push   %ebp
  101c84:	89 e5                	mov    %esp,%ebp
  101c86:	83 ec 18             	sub    $0x18,%esp
	uint32_t kernel_init_pdir = vmm_init();
  101c89:	e8 39 37 00 00       	call   1053c7 <vmm_init>
  101c8e:	89 45 f4             	mov    %eax,-0xc(%ebp)

	kprintf("Setting PIT interval...\n");
  101c91:	83 ec 0c             	sub    $0xc,%esp
  101c94:	68 44 75 10 00       	push   $0x107544
  101c99:	e8 cf e8 ff ff       	call   10056d <kprintf>
  101c9e:	83 c4 10             	add    $0x10,%esp

	outb(0x43, 0x36);
  101ca1:	83 ec 08             	sub    $0x8,%esp
  101ca4:	6a 36                	push   $0x36
  101ca6:	6a 43                	push   $0x43
  101ca8:	e8 9d f8 ff ff       	call   10154a <outb>
  101cad:	83 c4 10             	add    $0x10,%esp
	outw(0x40, 1000);
  101cb0:	83 ec 08             	sub    $0x8,%esp
  101cb3:	68 e8 03 00 00       	push   $0x3e8
  101cb8:	6a 40                	push   $0x40
  101cba:	e8 6d f8 ff ff       	call   10152c <outw>
  101cbf:	83 c4 10             	add    $0x10,%esp

    kprintf("Initializing vfs...\n");
  101cc2:	83 ec 0c             	sub    $0xc,%esp
  101cc5:	68 5d 75 10 00       	push   $0x10755d
  101cca:	e8 9e e8 ff ff       	call   10056d <kprintf>
  101ccf:	83 c4 10             	add    $0x10,%esp

    vfs_init_root();
  101cd2:	e8 50 2d 00 00       	call   104a27 <vfs_init_root>
    ramfs_fifo_init();
  101cd7:	e8 28 08 00 00       	call   102504 <ramfs_fifo_init>
    ramfs_block_init();
  101cdc:	e8 d3 04 00 00       	call   1021b4 <ramfs_block_init>

    driver_keyboard_init();
  101ce1:	e8 4e ed ff ff       	call   100a34 <driver_keyboard_init>


    map_address_active((uint32_t) mb_info,
  101ce6:	8b 55 08             	mov    0x8(%ebp),%edx
  101ce9:	8b 45 08             	mov    0x8(%ebp),%eax
  101cec:	83 ec 04             	sub    $0x4,%esp
  101cef:	6a 00                	push   $0x0
  101cf1:	52                   	push   %edx
  101cf2:	50                   	push   %eax
  101cf3:	e8 ac 33 00 00       	call   1050a4 <map_address_active>
  101cf8:	83 c4 10             	add    $0x10,%esp
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  101cfb:	8b 45 08             	mov    0x8(%ebp),%eax
  101cfe:	8b 40 18             	mov    0x18(%eax),%eax
  101d01:	89 c2                	mov    %eax,%edx
  101d03:	8b 45 08             	mov    0x8(%ebp),%eax
  101d06:	8b 40 18             	mov    0x18(%eax),%eax
  101d09:	83 ec 04             	sub    $0x4,%esp
  101d0c:	6a 00                	push   $0x0
  101d0e:	52                   	push   %edx
  101d0f:	50                   	push   %eax
  101d10:	e8 8f 33 00 00       	call   1050a4 <map_address_active>
  101d15:	83 c4 10             	add    $0x10,%esp
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  101d18:	8b 45 08             	mov    0x8(%ebp),%eax
  101d1b:	8b 00                	mov    (%eax),%eax
  101d1d:	83 e0 08             	and    $0x8,%eax
  101d20:	85 c0                	test   %eax,%eax
  101d22:	0f 84 9b 00 00 00    	je     101dc3 <kernel_main+0x140>
        vmm_map_range(mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
  101d28:	8b 45 08             	mov    0x8(%ebp),%eax
  101d2b:	8b 40 18             	mov    0x18(%eax),%eax
  101d2e:	8b 40 04             	mov    0x4(%eax),%eax
  101d31:	89 c2                	mov    %eax,%edx
  101d33:	8b 45 08             	mov    0x8(%ebp),%eax
  101d36:	8b 40 18             	mov    0x18(%eax),%eax
  101d39:	8b 00                	mov    (%eax),%eax
  101d3b:	89 d1                	mov    %edx,%ecx
  101d3d:	29 c1                	sub    %eax,%ecx
  101d3f:	89 c8                	mov    %ecx,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  101d41:	89 c1                	mov    %eax,%ecx
                      mb_info->mi_mods_addr[0].start,
  101d43:	8b 45 08             	mov    0x8(%ebp),%eax
  101d46:	8b 40 18             	mov    0x18(%eax),%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  101d49:	8b 10                	mov    (%eax),%edx
  101d4b:	8b 45 08             	mov    0x8(%ebp),%eax
  101d4e:	8b 40 18             	mov    0x18(%eax),%eax
  101d51:	8b 00                	mov    (%eax),%eax
  101d53:	6a 00                	push   $0x0
  101d55:	51                   	push   %ecx
  101d56:	52                   	push   %edx
  101d57:	50                   	push   %eax
  101d58:	e8 67 32 00 00       	call   104fc4 <vmm_map_range>
  101d5d:	83 c4 10             	add    $0x10,%esp
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  101d60:	8b 45 08             	mov    0x8(%ebp),%eax
  101d63:	8b 40 18             	mov    0x18(%eax),%eax
  101d66:	8b 40 04             	mov    0x4(%eax),%eax
  101d69:	89 c2                	mov    %eax,%edx
  101d6b:	8b 45 08             	mov    0x8(%ebp),%eax
  101d6e:	8b 40 18             	mov    0x18(%eax),%eax
  101d71:	8b 00                	mov    (%eax),%eax
  101d73:	89 d1                	mov    %edx,%ecx
  101d75:	29 c1                	sub    %eax,%ecx
  101d77:	89 c8                	mov    %ecx,%eax
  101d79:	83 ec 08             	sub    $0x8,%esp
  101d7c:	50                   	push   %eax
  101d7d:	68 74 75 10 00       	push   $0x107574
  101d82:	e8 e6 e7 ff ff       	call   10056d <kprintf>
  101d87:	83 c4 10             	add    $0x10,%esp
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);
  101d8a:	8b 45 08             	mov    0x8(%ebp),%eax
  101d8d:	8b 40 18             	mov    0x18(%eax),%eax
  101d90:	8b 50 04             	mov    0x4(%eax),%edx
  101d93:	8b 45 08             	mov    0x8(%ebp),%eax
  101d96:	8b 40 18             	mov    0x18(%eax),%eax
  101d99:	8b 00                	mov    (%eax),%eax
  101d9b:	83 ec 04             	sub    $0x4,%esp
  101d9e:	52                   	push   %edx
  101d9f:	50                   	push   %eax
  101da0:	68 b4 75 10 00       	push   $0x1075b4
  101da5:	e8 c3 e7 ff ff       	call   10056d <kprintf>
  101daa:	83 c4 10             	add    $0x10,%esp

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  101dad:	8b 45 08             	mov    0x8(%ebp),%eax
  101db0:	8b 40 18             	mov    0x18(%eax),%eax
  101db3:	8b 00                	mov    (%eax),%eax
  101db5:	83 ec 0c             	sub    $0xc,%esp
  101db8:	50                   	push   %eax
  101db9:	e8 9f 0b 00 00       	call   10295d <tar_load_ramfs>
  101dbe:	83 c4 10             	add    $0x10,%esp
  101dc1:	eb 10                	jmp    101dd3 <kernel_main+0x150>
    } else {
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  101dc3:	83 ec 0c             	sub    $0xc,%esp
  101dc6:	68 d0 75 10 00       	push   $0x1075d0
  101dcb:	e8 9d e7 ff ff       	call   10056d <kprintf>
  101dd0:	83 c4 10             	add    $0x10,%esp
    }

    kprintf("[kernel_res] Creating /dev/vga\n");
  101dd3:	83 ec 0c             	sub    $0xc,%esp
  101dd6:	68 04 76 10 00       	push   $0x107604
  101ddb:	e8 8d e7 ff ff       	call   10056d <kprintf>
  101de0:	83 c4 10             	add    $0x10,%esp
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  101de3:	e8 b8 0c 00 00       	call   102aa0 <ramfs_vga_driver_struct>
  101de8:	83 ec 04             	sub    $0x4,%esp
  101deb:	6a 00                	push   $0x0
  101ded:	50                   	push   %eax
  101dee:	68 24 76 10 00       	push   $0x107624
  101df3:	e8 24 24 00 00       	call   10421c <vfs_create_kfile>
  101df8:	83 c4 10             	add    $0x10,%esp

    if(vfs_exists("/ibin/init")) {
  101dfb:	83 ec 0c             	sub    $0xc,%esp
  101dfe:	68 2d 76 10 00       	push   $0x10762d
  101e03:	e8 c0 26 00 00       	call   1044c8 <vfs_exists>
  101e08:	83 c4 10             	add    $0x10,%esp
  101e0b:	85 c0                	test   %eax,%eax
  101e0d:	74 2f                	je     101e3e <kernel_main+0x1bb>
        kprintf("[init] /ibin/init found. Executing...\n");
  101e0f:	83 ec 0c             	sub    $0xc,%esp
  101e12:	68 38 76 10 00       	push   $0x107638
  101e17:	e8 51 e7 ff ff       	call   10056d <kprintf>
  101e1c:	83 c4 10             	add    $0x10,%esp

        vfs_exec("/ibin/init", 0, 0, 0, 0, 0);
  101e1f:	83 ec 08             	sub    $0x8,%esp
  101e22:	6a 00                	push   $0x0
  101e24:	6a 00                	push   $0x0
  101e26:	6a 00                	push   $0x0
  101e28:	6a 00                	push   $0x0
  101e2a:	6a 00                	push   $0x0
  101e2c:	68 2d 76 10 00       	push   $0x10762d
  101e31:	e8 e3 26 00 00       	call   104519 <vfs_exec>
  101e36:	83 c4 20             	add    $0x20,%esp
        enableScheduling();
  101e39:	e8 52 0e 00 00       	call   102c90 <enableScheduling>
    }

	while(1);
  101e3e:	eb fe                	jmp    101e3e <kernel_main+0x1bb>

00101e40 <pmm_alloc>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"

  101e40:	55                   	push   %ebp
  101e41:	89 e5                	mov    %esp,%ebp
  101e43:	57                   	push   %edi
  101e44:	56                   	push   %esi
  101e45:	53                   	push   %ebx
  101e46:	83 ec 10             	sub    $0x10,%esp
struct exec_info {
    char* execPath;
  101e49:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101e50:	eb 79                	jmp    101ecb <pmm_alloc+0x8b>
    char* stdin;
  101e52:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101e55:	8b 04 85 e0 89 12 00 	mov    0x1289e0(,%eax,4),%eax
  101e5c:	85 c0                	test   %eax,%eax
  101e5e:	74 68                	je     101ec8 <pmm_alloc+0x88>
    char* stdout;
    char* stderr;
  101e60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101e67:	eb 59                	jmp    101ec2 <pmm_alloc+0x82>
};
  101e69:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101e6c:	8b 14 85 e0 89 12 00 	mov    0x1289e0(,%eax,4),%edx
  101e73:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101e76:	bb 01 00 00 00       	mov    $0x1,%ebx
  101e7b:	89 de                	mov    %ebx,%esi
  101e7d:	88 c1                	mov    %al,%cl
  101e7f:	d3 e6                	shl    %cl,%esi
  101e81:	89 f0                	mov    %esi,%eax
  101e83:	21 d0                	and    %edx,%eax
  101e85:	85 c0                	test   %eax,%eax
  101e87:	74 36                	je     101ebf <pmm_alloc+0x7f>

  101e89:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101e8c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101e8f:	8b 1c 95 e0 89 12 00 	mov    0x1289e0(,%edx,4),%ebx
  101e96:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101e99:	be 01 00 00 00       	mov    $0x1,%esi
  101e9e:	89 f7                	mov    %esi,%edi
  101ea0:	88 d1                	mov    %dl,%cl
  101ea2:	d3 e7                	shl    %cl,%edi
  101ea4:	89 fa                	mov    %edi,%edx
  101ea6:	f7 d2                	not    %edx
  101ea8:	21 da                	and    %ebx,%edx
  101eaa:	89 14 85 e0 89 12 00 	mov    %edx,0x1289e0(,%eax,4)
struct cpu_state* syscall(struct cpu_state* cpu) {
  101eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101eb4:	c1 e0 05             	shl    $0x5,%eax
  101eb7:	03 45 f0             	add    -0x10(%ebp),%eax
  101eba:	c1 e0 0c             	shl    $0xc,%eax
  101ebd:	eb 1e                	jmp    101edd <pmm_alloc+0x9d>

struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
    char* stderr;
  101ebf:	ff 45 f0             	incl   -0x10(%ebp)
  101ec2:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
  101ec6:	7e a1                	jle    101e69 <pmm_alloc+0x29>
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"

struct exec_info {
    char* execPath;
  101ec8:	ff 45 ec             	incl   -0x14(%ebp)
  101ecb:	81 7d ec ff 7f 00 00 	cmpl   $0x7fff,-0x14(%ebp)
  101ed2:	0f 8e 7a ff ff ff    	jle    101e52 <pmm_alloc+0x12>
struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
		return terminate_current(cpu);
  101ed8:	b8 00 00 00 00       	mov    $0x0,%eax

  101edd:	83 c4 10             	add    $0x10,%esp
  101ee0:	5b                   	pop    %ebx
  101ee1:	5e                   	pop    %esi
  101ee2:	5f                   	pop    %edi
  101ee3:	5d                   	pop    %ebp
  101ee4:	c3                   	ret    

00101ee5 <pmm_print_stats>:
    case 3: /* exec */
    {
  101ee5:	55                   	push   %ebp
  101ee6:	89 e5                	mov    %esp,%ebp
  101ee8:	57                   	push   %edi
  101ee9:	56                   	push   %esi
  101eea:	53                   	push   %ebx
  101eeb:	83 ec 0c             	sub    $0xc,%esp
        char* path = strclone((char*) cpu->ebx);
  101eee:	a1 40 85 12 00       	mov    0x128540,%eax
  101ef3:	89 c7                	mov    %eax,%edi
  101ef5:	c1 ef 0a             	shr    $0xa,%edi
  101ef8:	83 ec 0c             	sub    $0xc,%esp
  101efb:	68 00 04 00 00       	push   $0x400
  101f00:	e8 3e 00 00 00       	call   101f43 <pmm_get_free_space>
  101f05:	83 c4 10             	add    $0x10,%esp
  101f08:	89 c3                	mov    %eax,%ebx
  101f0a:	a1 40 85 12 00       	mov    0x128540,%eax
  101f0f:	89 c6                	mov    %eax,%esi
  101f11:	c1 ee 14             	shr    $0x14,%esi
  101f14:	83 ec 0c             	sub    $0xc,%esp
  101f17:	68 00 00 10 00       	push   $0x100000
  101f1c:	e8 22 00 00 00       	call   101f43 <pmm_get_free_space>
  101f21:	83 c4 10             	add    $0x10,%esp
  101f24:	83 ec 0c             	sub    $0xc,%esp
  101f27:	57                   	push   %edi
  101f28:	53                   	push   %ebx
  101f29:	56                   	push   %esi
  101f2a:	50                   	push   %eax
  101f2b:	68 60 76 10 00       	push   $0x107660
  101f30:	e8 38 e6 ff ff       	call   10056d <kprintf>
  101f35:	83 c4 20             	add    $0x20,%esp

        struct exec_info* einp = (void*) cpu->edx;

  101f38:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101f3b:	83 c4 00             	add    $0x0,%esp
  101f3e:	5b                   	pop    %ebx
  101f3f:	5e                   	pop    %esi
  101f40:	5f                   	pop    %edi
  101f41:	5d                   	pop    %ebp
  101f42:	c3                   	ret    

00101f43 <pmm_get_free_space>:
        struct exec_info ein = {
            .execPath = 0,
  101f43:	55                   	push   %ebp
  101f44:	89 e5                	mov    %esp,%ebp
  101f46:	56                   	push   %esi
  101f47:	53                   	push   %ebx
  101f48:	83 ec 10             	sub    $0x10,%esp
            .stdin = 0,
  101f4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            .stdout = 0,
            .stderr = 0
  101f52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101f59:	eb 3c                	jmp    101f97 <pmm_get_free_space+0x54>
        };
  101f5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  101f62:	eb 2a                	jmp    101f8e <pmm_get_free_space+0x4b>

  101f64:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101f67:	8b 14 85 e0 89 12 00 	mov    0x1289e0(,%eax,4),%edx
  101f6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f71:	bb 01 00 00 00       	mov    $0x1,%ebx
  101f76:	89 de                	mov    %ebx,%esi
  101f78:	88 c1                	mov    %al,%cl
  101f7a:	d3 e6                	shl    %cl,%esi
  101f7c:	89 f0                	mov    %esi,%eax
  101f7e:	21 d0                	and    %edx,%eax
  101f80:	85 c0                	test   %eax,%eax
  101f82:	74 07                	je     101f8b <pmm_get_free_space+0x48>
        if(einp != 0) {
  101f84:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
        struct exec_info ein = {
            .execPath = 0,
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };
  101f8b:	ff 45 f4             	incl   -0xc(%ebp)
  101f8e:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
  101f92:	76 d0                	jbe    101f64 <pmm_get_free_space+0x21>

        struct exec_info ein = {
            .execPath = 0,
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
  101f94:	ff 45 f0             	incl   -0x10(%ebp)
  101f97:	81 7d f0 ff 7f 00 00 	cmpl   $0x7fff,-0x10(%ebp)
  101f9e:	76 bb                	jbe    101f5b <pmm_get_free_space+0x18>

        if(einp != 0) {
            ein.execPath = strclone(einp->execPath);
            ein.stdin = strclone(einp->stdin);
            ein.stdout = strclone(einp->stdout);
            ein.stderr = strclone(einp->stderr);
  101fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fa3:	ba 00 00 00 00       	mov    $0x0,%edx
  101fa8:	f7 75 08             	divl   0x8(%ebp)
        }
  101fab:	83 c4 10             	add    $0x10,%esp
  101fae:	5b                   	pop    %ebx
  101faf:	5e                   	pop    %esi
  101fb0:	5d                   	pop    %ebp
  101fb1:	c3                   	ret    

00101fb2 <pmm_free>:

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  101fb2:	55                   	push   %ebp
  101fb3:	89 e5                	mov    %esp,%ebp
  101fb5:	57                   	push   %edi
  101fb6:	56                   	push   %esi
  101fb7:	53                   	push   %ebx
  101fb8:	83 ec 10             	sub    $0x10,%esp

  101fbb:	8b 45 08             	mov    0x8(%ebp),%eax
  101fbe:	c1 e8 0c             	shr    $0xc,%eax
  101fc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(einp != 0) {
            free(ein.execPath);
  101fc4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101fc7:	83 e0 1f             	and    $0x1f,%eax
  101fca:	89 45 ec             	mov    %eax,-0x14(%ebp)
            free(ein.stdin);
  101fcd:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101fd0:	c1 e8 05             	shr    $0x5,%eax
  101fd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
            free(ein.stdout);
            free(ein.stderr);
  101fd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101fd9:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101fdc:	8b 1c 95 e0 89 12 00 	mov    0x1289e0(,%edx,4),%ebx
  101fe3:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101fe6:	be 01 00 00 00       	mov    $0x1,%esi
  101feb:	89 f7                	mov    %esi,%edi
  101fed:	88 d1                	mov    %dl,%cl
  101fef:	d3 e7                	shl    %cl,%edi
  101ff1:	89 fa                	mov    %edi,%edx
  101ff3:	09 da                	or     %ebx,%edx
  101ff5:	89 14 85 e0 89 12 00 	mov    %edx,0x1289e0(,%eax,4)
        }
  101ffc:	83 c4 10             	add    $0x10,%esp
  101fff:	5b                   	pop    %ebx
  102000:	5e                   	pop    %esi
  102001:	5f                   	pop    %edi
  102002:	5d                   	pop    %ebp
  102003:	c3                   	ret    

00102004 <pmm_mark_used>:

        free(path);
  102004:	55                   	push   %ebp
  102005:	89 e5                	mov    %esp,%ebp
  102007:	57                   	push   %edi
  102008:	56                   	push   %esi
  102009:	53                   	push   %ebx
  10200a:	83 ec 10             	sub    $0x10,%esp
    }
  10200d:	8b 45 08             	mov    0x8(%ebp),%eax
  102010:	c1 e8 0c             	shr    $0xc,%eax
  102013:	89 45 e8             	mov    %eax,-0x18(%ebp)
        break;

  102016:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102019:	83 e0 1f             	and    $0x1f,%eax
  10201c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    case 4: /* getargs */
  10201f:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102022:	c1 e8 05             	shr    $0x5,%eax
  102025:	89 45 f0             	mov    %eax,-0x10(%ebp)
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  102028:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10202b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10202e:	8b 1c 95 e0 89 12 00 	mov    0x1289e0(,%edx,4),%ebx
  102035:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102038:	be 01 00 00 00       	mov    $0x1,%esi
  10203d:	89 f7                	mov    %esi,%edi
  10203f:	88 d1                	mov    %dl,%cl
  102041:	d3 e7                	shl    %cl,%edi
  102043:	89 fa                	mov    %edi,%edx
  102045:	f7 d2                	not    %edx
  102047:	21 da                	and    %ebx,%edx
  102049:	89 14 85 e0 89 12 00 	mov    %edx,0x1289e0(,%eax,4)
    }
  102050:	83 c4 10             	add    $0x10,%esp
  102053:	5b                   	pop    %ebx
  102054:	5e                   	pop    %esi
  102055:	5f                   	pop    %edi
  102056:	5d                   	pop    %ebp
  102057:	c3                   	ret    

00102058 <pmm_init>:
        break;

  102058:	55                   	push   %ebp
  102059:	89 e5                	mov    %esp,%ebp
  10205b:	83 ec 28             	sub    $0x28,%esp
    case 5: /* yield */
  10205e:	8b 45 08             	mov    0x8(%ebp),%eax
  102061:	8b 40 30             	mov    0x30(%eax),%eax
  102064:	89 45 dc             	mov    %eax,-0x24(%ebp)
    {
  102067:	8b 45 08             	mov    0x8(%ebp),%eax
  10206a:	8b 40 30             	mov    0x30(%eax),%eax
  10206d:	89 c2                	mov    %eax,%edx
  10206f:	8b 45 08             	mov    0x8(%ebp),%eax
  102072:	8b 40 2c             	mov    0x2c(%eax),%eax
  102075:	8d 04 02             	lea    (%edx,%eax,1),%eax
        cpu = schedule(cpu);
  102078:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }
        break;
  10207b:	83 ec 04             	sub    $0x4,%esp
  10207e:	68 00 00 02 00       	push   $0x20000
  102083:	6a 00                	push   $0x0
  102085:	68 e0 89 12 00       	push   $0x1289e0
  10208a:	e8 b1 19 00 00       	call   103a40 <memset>
  10208f:	83 c4 10             	add    $0x10,%esp

    case 6: /* getExecPath */
  102092:	b8 e0 89 14 00       	mov    $0x1489e0,%eax
  102097:	83 ec 04             	sub    $0x4,%esp
  10209a:	50                   	push   %eax
  10209b:	68 e0 89 12 00       	push   $0x1289e0
  1020a0:	68 9d 76 10 00       	push   $0x10769d
  1020a5:	e8 c3 e4 ff ff       	call   10056d <kprintf>
  1020aa:	83 c4 10             	add    $0x10,%esp
    {
        char* dest = (char*)cpu->ebx;
  1020ad:	eb 5c                	jmp    10210b <pmm_init+0xb3>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  1020af:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1020b2:	8b 40 14             	mov    0x14(%eax),%eax
  1020b5:	83 f8 01             	cmp    $0x1,%eax
  1020b8:	75 4d                	jne    102107 <pmm_init+0xaf>
    }
  1020ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1020bd:	8b 50 08             	mov    0x8(%eax),%edx
  1020c0:	8b 40 04             	mov    0x4(%eax),%eax
  1020c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        break;
  1020c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1020c9:	8b 50 10             	mov    0x10(%eax),%edx
  1020cc:	8b 40 0c             	mov    0xc(%eax),%eax
  1020cf:	03 45 f0             	add    -0x10(%ebp),%eax
  1020d2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    case 7: /* changeExecPath */
  1020d5:	eb 28                	jmp    1020ff <pmm_init+0xa7>
    {
  1020d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1020da:	83 ec 0c             	sub    $0xc,%esp
  1020dd:	50                   	push   %eax
  1020de:	e8 cf fe ff ff       	call   101fb2 <pmm_free>
  1020e3:	83 c4 10             	add    $0x10,%esp
        vfs_reset_error();
  1020e6:	a1 40 85 12 00       	mov    0x128540,%eax
  1020eb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  1020ee:	76 08                	jbe    1020f8 <pmm_init+0xa0>
        char* path = strclone((char*) cpu->ebx);
  1020f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1020f3:	a3 40 85 12 00       	mov    %eax,0x128540

  1020f8:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;

    case 7: /* changeExecPath */
  1020ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102102:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  102105:	72 d0                	jb     1020d7 <pmm_init+0x7f>
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);
  102107:	83 45 dc 18          	addl   $0x18,-0x24(%ebp)
    }
        break;

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  10210b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10210e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  102111:	72 9c                	jb     1020af <pmm_init+0x57>

        cpu->eax = 0;
        if(new) {
            get_current_task()->execPath = new;
            cpu->eax = 1;
        }
  102113:	c7 45 e4 00 00 10 00 	movl   $0x100000,-0x1c(%ebp)

  10211a:	eb 16                	jmp    102132 <pmm_init+0xda>
        free(path);
  10211c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10211f:	83 ec 0c             	sub    $0xc,%esp
  102122:	50                   	push   %eax
  102123:	e8 dc fe ff ff       	call   102004 <pmm_mark_used>
  102128:	83 c4 10             	add    $0x10,%esp
    }
  10212b:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
        cpu->eax = 0;
        if(new) {
            get_current_task()->execPath = new;
            cpu->eax = 1;
        }

  102132:	b8 00 90 18 00       	mov    $0x189000,%eax
  102137:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  10213a:	72 e0                	jb     10211c <pmm_init+0xc4>
        free(path);
    }
        break;

	case 10: /* fopen */
  10213c:	8b 45 08             	mov    0x8(%ebp),%eax
  10213f:	8b 40 18             	mov    0x18(%eax),%eax
  102142:	89 45 e8             	mov    %eax,-0x18(%ebp)
	{
        vfs_reset_error();
  102145:	83 ec 0c             	sub    $0xc,%esp
  102148:	ff 75 08             	pushl  0x8(%ebp)
  10214b:	e8 b4 fe ff ff       	call   102004 <pmm_mark_used>
  102150:	83 c4 10             	add    $0x10,%esp
	    char* name = strclone((char*) cpu->ebx);
  102153:	83 ec 0c             	sub    $0xc,%esp
  102156:	ff 75 e8             	pushl  -0x18(%ebp)
  102159:	e8 a6 fe ff ff       	call   102004 <pmm_mark_used>
  10215e:	83 c4 10             	add    $0x10,%esp
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
  102161:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  102168:	eb 3a                	jmp    1021a4 <pmm_init+0x14c>
	    if(handle) {
  10216a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10216d:	c1 e0 04             	shl    $0x4,%eax
  102170:	03 45 e8             	add    -0x18(%ebp),%eax
  102173:	8b 00                	mov    (%eax),%eax
  102175:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	        register_handle(handle);
  102178:	eb 16                	jmp    102190 <pmm_init+0x138>
	        cpu->eax = (uint32_t) handle;
  10217a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10217d:	83 ec 0c             	sub    $0xc,%esp
  102180:	50                   	push   %eax
  102181:	e8 7e fe ff ff       	call   102004 <pmm_mark_used>
  102186:	83 c4 10             	add    $0x10,%esp
	    }
  102189:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
	        register_handle(handle);
  102190:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102193:	c1 e0 04             	shl    $0x4,%eax
  102196:	03 45 e8             	add    -0x18(%ebp),%eax
  102199:	8b 40 04             	mov    0x4(%eax),%eax
  10219c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  10219f:	77 d9                	ja     10217a <pmm_init+0x122>
	{
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
  1021a1:	ff 45 ec             	incl   -0x14(%ebp)
  1021a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1021a7:	8b 40 14             	mov    0x14(%eax),%eax
  1021aa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1021ad:	77 bb                	ja     10216a <pmm_init+0x112>
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
	    }
	    else
	    {
	        cpu->eax = 0;
  1021af:	c9                   	leave  
  1021b0:	c3                   	ret    
  1021b1:	00 00                	add    %al,(%eax)
	...

001021b4 <ramfs_block_init>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  1021b4:	55                   	push   %ebp
  1021b5:	89 e5                	mov    %esp,%ebp
  1021b7:	83 ec 08             	sub    $0x8,%esp
#include "ramfs/vgacntrl.h"
  1021ba:	83 ec 04             	sub    $0x4,%esp
  1021bd:	68 00 00 04 00       	push   $0x40000
  1021c2:	6a 00                	push   $0x0
  1021c4:	68 e0 89 14 00       	push   $0x1489e0
  1021c9:	e8 72 18 00 00       	call   103a40 <memset>
  1021ce:	83 c4 10             	add    $0x10,%esp
#include "drivers/keyboard.h"
  1021d1:	c9                   	leave  
  1021d2:	c3                   	ret    

001021d3 <ramfs_block_driver_struct>:
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
  1021d3:	55                   	push   %ebp
  1021d4:	89 e5                	mov    %esp,%ebp
	case 1: /* exit */
  1021d6:	b8 a0 62 10 00       	mov    $0x1062a0,%eax
		return terminate_current(cpu);
  1021db:	5d                   	pop    %ebp
  1021dc:	c3                   	ret    

001021dd <ramfs_block_available>:

    case 3: /* exec */
  1021dd:	55                   	push   %ebp
  1021de:	89 e5                	mov    %esp,%ebp
  1021e0:	83 ec 10             	sub    $0x10,%esp
    {
  1021e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1021e6:	8b 40 04             	mov    0x4(%eax),%eax
  1021e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
        char* path = strclone((char*) cpu->ebx);

  1021ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1021ef:	8b 00                	mov    (%eax),%eax
  1021f1:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1021f8:	85 c0                	test   %eax,%eax
  1021fa:	74 1d                	je     102219 <ramfs_block_available+0x3c>
        struct exec_info* einp = (void*) cpu->edx;
  1021fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1021ff:	8b 00                	mov    (%eax),%eax
  102201:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102208:	8b 50 04             	mov    0x4(%eax),%edx
  10220b:	8b 45 08             	mov    0x8(%ebp),%eax
  10220e:	8b 40 08             	mov    0x8(%eax),%eax
  102211:	89 d1                	mov    %edx,%ecx
  102213:	29 c1                	sub    %eax,%ecx
  102215:	89 c8                	mov    %ecx,%eax
  102217:	eb 05                	jmp    10221e <ramfs_block_available+0x41>

        struct exec_info ein = {
            .execPath = 0,
  102219:	b8 00 00 00 00       	mov    $0x0,%eax
            .stdin = 0,
  10221e:	c9                   	leave  
  10221f:	c3                   	ret    

00102220 <ramfs_block_create>:
            .stdout = 0,
            .stderr = 0
  102220:	55                   	push   %ebp
  102221:	89 e5                	mov    %esp,%ebp
  102223:	53                   	push   %ebx
  102224:	83 ec 14             	sub    $0x14,%esp
        };
  102227:	83 ec 0c             	sub    $0xc,%esp
  10222a:	6a 08                	push   $0x8
  10222c:	e8 75 15 00 00       	call   1037a6 <malloc>
  102231:	83 c4 10             	add    $0x10,%esp
  102234:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(einp != 0) {
  102237:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10223e:	e9 86 00 00 00       	jmp    1022c9 <ramfs_block_create+0xa9>
            ein.execPath = strclone(einp->execPath);
  102243:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102246:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10224d:	85 c0                	test   %eax,%eax
  10224f:	75 75                	jne    1022c6 <ramfs_block_create+0xa6>
            ein.stdin = strclone(einp->stdin);
  102251:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  102254:	83 ec 0c             	sub    $0xc,%esp
  102257:	6a 10                	push   $0x10
  102259:	e8 48 15 00 00       	call   1037a6 <malloc>
  10225e:	83 c4 10             	add    $0x10,%esp
  102261:	89 04 9d e0 89 14 00 	mov    %eax,0x1489e0(,%ebx,4)
            ein.stdout = strclone(einp->stdout);
  102268:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10226b:	8b 1c 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%ebx
  102272:	8b 45 08             	mov    0x8(%ebp),%eax
  102275:	8b 00                	mov    (%eax),%eax
  102277:	83 ec 0c             	sub    $0xc,%esp
  10227a:	50                   	push   %eax
  10227b:	e8 26 15 00 00       	call   1037a6 <malloc>
  102280:	83 c4 10             	add    $0x10,%esp
  102283:	89 03                	mov    %eax,(%ebx)
            ein.stderr = strclone(einp->stderr);
  102285:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102288:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10228f:	8b 55 08             	mov    0x8(%ebp),%edx
  102292:	8b 12                	mov    (%edx),%edx
  102294:	89 50 04             	mov    %edx,0x4(%eax)
        }

  102297:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10229a:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1022a1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  1022a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022ab:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1022b2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

        if(einp != 0) {
  1022b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1022bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1022bf:	89 10                	mov    %edx,(%eax)
            free(ein.execPath);
            free(ein.stdin);
  1022c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1022c4:	eb 15                	jmp    1022db <ramfs_block_create+0xbb>
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };

        if(einp != 0) {
  1022c6:	ff 45 f4             	incl   -0xc(%ebp)
  1022c9:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
  1022d0:	0f 8e 6d ff ff ff    	jle    102243 <ramfs_block_create+0x23>
            free(ein.execPath);
            free(ein.stdin);
            free(ein.stdout);
            free(ein.stderr);
        }

  1022d6:	b8 00 00 00 00       	mov    $0x0,%eax
        free(path);
  1022db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1022de:	c9                   	leave  
  1022df:	c3                   	ret    

001022e0 <ramfs_block_read>:
    }
        break;
  1022e0:	55                   	push   %ebp
  1022e1:	89 e5                	mov    %esp,%ebp
  1022e3:	83 ec 18             	sub    $0x18,%esp

  1022e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1022e9:	8b 40 04             	mov    0x4(%eax),%eax
  1022ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    case 4: /* getargs */
    {
  1022ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022f2:	8b 00                	mov    (%eax),%eax
  1022f4:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1022fb:	85 c0                	test   %eax,%eax
  1022fd:	74 68                	je     102367 <ramfs_block_read+0x87>
        cpu->eax = (uint32_t) get_current_task()->args;
  1022ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102302:	8b 00                	mov    (%eax),%eax
  102304:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10230b:	8b 50 04             	mov    0x4(%eax),%edx
  10230e:	8b 45 08             	mov    0x8(%ebp),%eax
  102311:	8b 40 08             	mov    0x8(%eax),%eax
  102314:	89 d1                	mov    %edx,%ecx
  102316:	29 c1                	sub    %eax,%ecx
  102318:	89 c8                	mov    %ecx,%eax
  10231a:	3b 45 10             	cmp    0x10(%ebp),%eax
  10231d:	73 07                	jae    102326 <ramfs_block_read+0x46>
  10231f:	b8 03 00 00 00       	mov    $0x3,%eax
  102324:	eb 46                	jmp    10236c <ramfs_block_read+0x8c>
    }
        break;
  102326:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102329:	8b 00                	mov    (%eax),%eax
  10232b:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102332:	8b 10                	mov    (%eax),%edx
  102334:	8b 45 08             	mov    0x8(%ebp),%eax
  102337:	8b 40 08             	mov    0x8(%eax),%eax
  10233a:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10233d:	83 ec 04             	sub    $0x4,%esp
  102340:	ff 75 10             	pushl  0x10(%ebp)
  102343:	50                   	push   %eax
  102344:	ff 75 0c             	pushl  0xc(%ebp)
  102347:	e8 22 17 00 00       	call   103a6e <memcpy>
  10234c:	83 c4 10             	add    $0x10,%esp

  10234f:	8b 45 08             	mov    0x8(%ebp),%eax
  102352:	8b 40 08             	mov    0x8(%eax),%eax
  102355:	89 c2                	mov    %eax,%edx
  102357:	03 55 10             	add    0x10(%ebp),%edx
  10235a:	8b 45 08             	mov    0x8(%ebp),%eax
  10235d:	89 50 08             	mov    %edx,0x8(%eax)
    case 5: /* yield */
    {
  102360:	b8 00 00 00 00       	mov    $0x0,%eax
  102365:	eb 05                	jmp    10236c <ramfs_block_read+0x8c>
        cpu = schedule(cpu);
    }
        break;
  102367:	b8 03 00 00 00       	mov    $0x3,%eax

  10236c:	c9                   	leave  
  10236d:	c3                   	ret    

0010236e <ramfs_block_write>:
    case 6: /* getExecPath */
    {
  10236e:	55                   	push   %ebp
  10236f:	89 e5                	mov    %esp,%ebp
  102371:	83 ec 18             	sub    $0x18,%esp
        char* dest = (char*)cpu->ebx;
  102374:	8b 45 08             	mov    0x8(%ebp),%eax
  102377:	8b 40 04             	mov    0x4(%eax),%eax
  10237a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  10237d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102380:	8b 00                	mov    (%eax),%eax
  102382:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102389:	85 c0                	test   %eax,%eax
  10238b:	74 68                	je     1023f5 <ramfs_block_write+0x87>
        break;
  10238d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102390:	8b 00                	mov    (%eax),%eax
  102392:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102399:	8b 50 04             	mov    0x4(%eax),%edx
  10239c:	8b 45 08             	mov    0x8(%ebp),%eax
  10239f:	8b 40 08             	mov    0x8(%eax),%eax
  1023a2:	89 d1                	mov    %edx,%ecx
  1023a4:	29 c1                	sub    %eax,%ecx
  1023a6:	89 c8                	mov    %ecx,%eax
  1023a8:	3b 45 10             	cmp    0x10(%ebp),%eax
  1023ab:	73 07                	jae    1023b4 <ramfs_block_write+0x46>
  1023ad:	b8 03 00 00 00       	mov    $0x3,%eax
  1023b2:	eb 46                	jmp    1023fa <ramfs_block_write+0x8c>

    case 7: /* changeExecPath */
  1023b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1023b7:	8b 00                	mov    (%eax),%eax
  1023b9:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1023c0:	8b 10                	mov    (%eax),%edx
  1023c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1023c5:	8b 40 08             	mov    0x8(%eax),%eax
  1023c8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1023cb:	83 ec 04             	sub    $0x4,%esp
  1023ce:	ff 75 10             	pushl  0x10(%ebp)
  1023d1:	ff 75 0c             	pushl  0xc(%ebp)
  1023d4:	50                   	push   %eax
  1023d5:	e8 94 16 00 00       	call   103a6e <memcpy>
  1023da:	83 c4 10             	add    $0x10,%esp
    {
  1023dd:	8b 45 08             	mov    0x8(%ebp),%eax
  1023e0:	8b 40 08             	mov    0x8(%eax),%eax
  1023e3:	89 c2                	mov    %eax,%edx
  1023e5:	03 55 10             	add    0x10(%ebp),%edx
  1023e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1023eb:	89 50 08             	mov    %edx,0x8(%eax)
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);
  1023ee:	b8 00 00 00 00       	mov    $0x0,%eax
  1023f3:	eb 05                	jmp    1023fa <ramfs_block_write+0x8c>

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

  1023f5:	b8 03 00 00 00       	mov    $0x3,%eax
        char* new = vfs_resolve_path(path);
  1023fa:	c9                   	leave  
  1023fb:	c3                   	ret    

001023fc <ramfs_block_open>:

        cpu->eax = 0;
  1023fc:	55                   	push   %ebp
  1023fd:	89 e5                	mov    %esp,%ebp
  1023ff:	83 ec 18             	sub    $0x18,%esp
        if(new) {
  102402:	8b 45 08             	mov    0x8(%ebp),%eax
  102405:	8b 00                	mov    (%eax),%eax
  102407:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10240e:	85 c0                	test   %eax,%eax
  102410:	74 74                	je     102486 <ramfs_block_open+0x8a>
            get_current_task()->execPath = new;
  102412:	8b 45 0c             	mov    0xc(%ebp),%eax
  102415:	83 e0 01             	and    $0x1,%eax
  102418:	84 c0                	test   %al,%al
  10241a:	74 13                	je     10242f <ramfs_block_open+0x33>
  10241c:	8b 45 08             	mov    0x8(%ebp),%eax
  10241f:	8b 00                	mov    (%eax),%eax
  102421:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102428:	8b 50 08             	mov    0x8(%eax),%edx
  10242b:	42                   	inc    %edx
  10242c:	89 50 08             	mov    %edx,0x8(%eax)
            cpu->eax = 1;
  10242f:	8b 45 0c             	mov    0xc(%ebp),%eax
  102432:	83 e0 02             	and    $0x2,%eax
  102435:	85 c0                	test   %eax,%eax
  102437:	74 13                	je     10244c <ramfs_block_open+0x50>
  102439:	8b 45 08             	mov    0x8(%ebp),%eax
  10243c:	8b 00                	mov    (%eax),%eax
  10243e:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102445:	8b 50 0c             	mov    0xc(%eax),%edx
  102448:	42                   	inc    %edx
  102449:	89 50 0c             	mov    %edx,0xc(%eax)
        }

  10244c:	83 ec 0c             	sub    $0xc,%esp
  10244f:	6a 10                	push   $0x10
  102451:	e8 50 13 00 00       	call   1037a6 <malloc>
  102456:	83 c4 10             	add    $0x10,%esp
  102459:	89 45 f4             	mov    %eax,-0xc(%ebp)
        free(path);
    }
  10245c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10245f:	8b 55 0c             	mov    0xc(%ebp),%edx
  102462:	89 50 0c             	mov    %edx,0xc(%eax)
        break;
  102465:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102468:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  10246f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102472:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	case 10: /* fopen */
  102478:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10247b:	8b 55 08             	mov    0x8(%ebp),%edx
  10247e:	89 50 04             	mov    %edx,0x4(%eax)
	{
        vfs_reset_error();
  102481:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102484:	eb 05                	jmp    10248b <ramfs_block_open+0x8f>
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

  102486:	b8 01 00 00 00       	mov    $0x1,%eax
	    struct res_handle* handle = vfs_open(name, fmode);
  10248b:	c9                   	leave  
  10248c:	c3                   	ret    

0010248d <ramfs_block_close>:
	    if(handle) {
	        register_handle(handle);
  10248d:	55                   	push   %ebp
  10248e:	89 e5                	mov    %esp,%ebp
  102490:	83 ec 18             	sub    $0x18,%esp
	        cpu->eax = (uint32_t) handle;
  102493:	8b 45 08             	mov    0x8(%ebp),%eax
  102496:	8b 40 04             	mov    0x4(%eax),%eax
  102499:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    }
	    else
  10249c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10249f:	8b 00                	mov    (%eax),%eax
  1024a1:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1024a8:	85 c0                	test   %eax,%eax
  1024aa:	74 40                	je     1024ec <ramfs_block_close+0x5f>
	    {
  1024ac:	8b 45 08             	mov    0x8(%ebp),%eax
  1024af:	8b 40 0c             	mov    0xc(%eax),%eax
  1024b2:	83 e0 01             	and    $0x1,%eax
  1024b5:	84 c0                	test   %al,%al
  1024b7:	74 13                	je     1024cc <ramfs_block_close+0x3f>
  1024b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024bc:	8b 00                	mov    (%eax),%eax
  1024be:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1024c5:	8b 50 08             	mov    0x8(%eax),%edx
  1024c8:	4a                   	dec    %edx
  1024c9:	89 50 08             	mov    %edx,0x8(%eax)
	        cpu->eax = 0;
  1024cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1024cf:	8b 40 0c             	mov    0xc(%eax),%eax
  1024d2:	83 e0 02             	and    $0x2,%eax
  1024d5:	85 c0                	test   %eax,%eax
  1024d7:	74 13                	je     1024ec <ramfs_block_close+0x5f>
  1024d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024dc:	8b 00                	mov    (%eax),%eax
  1024de:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1024e5:	8b 50 0c             	mov    0xc(%eax),%edx
  1024e8:	4a                   	dec    %edx
  1024e9:	89 50 0c             	mov    %edx,0xc(%eax)
	    }

	    free(name);
  1024ec:	83 ec 0c             	sub    $0xc,%esp
  1024ef:	ff 75 08             	pushl  0x8(%ebp)
  1024f2:	e8 f5 14 00 00       	call   1039ec <free>
  1024f7:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  1024fa:	b8 00 00 00 00       	mov    $0x0,%eax

  1024ff:	c9                   	leave  
  102500:	c3                   	ret    
  102501:	00 00                	add    %al,(%eax)
	...

00102504 <ramfs_fifo_init>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  102504:	55                   	push   %ebp
  102505:	89 e5                	mov    %esp,%ebp
  102507:	83 ec 08             	sub    $0x8,%esp
#include "ramfs/vgacntrl.h"
  10250a:	83 ec 04             	sub    $0x4,%esp
  10250d:	68 00 00 04 00       	push   $0x40000
  102512:	6a 00                	push   $0x0
  102514:	68 e0 89 14 00       	push   $0x1489e0
  102519:	e8 22 15 00 00       	call   103a40 <memset>
  10251e:	83 c4 10             	add    $0x10,%esp
#include "drivers/keyboard.h"
  102521:	c9                   	leave  
  102522:	c3                   	ret    

00102523 <ramfs_fifo_driver_struct>:
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
  102523:	55                   	push   %ebp
  102524:	89 e5                	mov    %esp,%ebp
	case 1: /* exit */
  102526:	b8 bc 62 10 00       	mov    $0x1062bc,%eax
		return terminate_current(cpu);
  10252b:	5d                   	pop    %ebp
  10252c:	c3                   	ret    

0010252d <ramfs_fifo_available>:

    case 3: /* exec */
  10252d:	55                   	push   %ebp
  10252e:	89 e5                	mov    %esp,%ebp
  102530:	83 ec 10             	sub    $0x10,%esp
    {
  102533:	8b 45 08             	mov    0x8(%ebp),%eax
  102536:	8b 40 04             	mov    0x4(%eax),%eax
  102539:	89 45 fc             	mov    %eax,-0x4(%ebp)
        char* path = strclone((char*) cpu->ebx);

  10253c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10253f:	8b 00                	mov    (%eax),%eax
  102541:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102548:	85 c0                	test   %eax,%eax
  10254a:	74 11                	je     10255d <ramfs_fifo_available+0x30>
        struct exec_info* einp = (void*) cpu->edx;
  10254c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10254f:	8b 00                	mov    (%eax),%eax
  102551:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102558:	8b 40 08             	mov    0x8(%eax),%eax
  10255b:	eb 05                	jmp    102562 <ramfs_fifo_available+0x35>

        struct exec_info ein = {
            .execPath = 0,
  10255d:	b8 00 00 00 00       	mov    $0x0,%eax
            .stdin = 0,
  102562:	c9                   	leave  
  102563:	c3                   	ret    

00102564 <ramfs_fifo_create>:
            .stdout = 0,
            .stderr = 0
  102564:	55                   	push   %ebp
  102565:	89 e5                	mov    %esp,%ebp
  102567:	53                   	push   %ebx
  102568:	83 ec 14             	sub    $0x14,%esp
        };
  10256b:	83 ec 0c             	sub    $0xc,%esp
  10256e:	6a 08                	push   $0x8
  102570:	e8 31 12 00 00       	call   1037a6 <malloc>
  102575:	83 c4 10             	add    $0x10,%esp
  102578:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(einp != 0) {
  10257b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102582:	e9 9b 00 00 00       	jmp    102622 <ramfs_fifo_create+0xbe>
            ein.execPath = strclone(einp->execPath);
  102587:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10258a:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102591:	85 c0                	test   %eax,%eax
  102593:	0f 85 86 00 00 00    	jne    10261f <ramfs_fifo_create+0xbb>
            ein.stdin = strclone(einp->stdin);
  102599:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  10259c:	83 ec 0c             	sub    $0xc,%esp
  10259f:	6a 14                	push   $0x14
  1025a1:	e8 00 12 00 00       	call   1037a6 <malloc>
  1025a6:	83 c4 10             	add    $0x10,%esp
  1025a9:	89 04 9d e0 89 14 00 	mov    %eax,0x1489e0(,%ebx,4)
            ein.stdout = strclone(einp->stdout);
  1025b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025b3:	8b 1c 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%ebx
  1025ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1025bd:	8b 00                	mov    (%eax),%eax
  1025bf:	83 ec 0c             	sub    $0xc,%esp
  1025c2:	50                   	push   %eax
  1025c3:	e8 de 11 00 00       	call   1037a6 <malloc>
  1025c8:	83 c4 10             	add    $0x10,%esp
  1025cb:	89 03                	mov    %eax,(%ebx)
            ein.stderr = strclone(einp->stderr);
  1025cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025d0:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1025d7:	8b 55 08             	mov    0x8(%ebp),%edx
  1025da:	8b 12                	mov    (%edx),%edx
  1025dc:	89 50 04             	mov    %edx,0x4(%eax)
        }

  1025df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025e2:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1025e9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  1025f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025f3:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1025fa:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  102601:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102604:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10260b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        if(einp != 0) {
            free(ein.execPath);
  102612:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102615:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102618:	89 10                	mov    %edx,(%eax)
            free(ein.stdin);
            free(ein.stdout);
  10261a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10261d:	eb 15                	jmp    102634 <ramfs_fifo_create+0xd0>
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };

        if(einp != 0) {
  10261f:	ff 45 f4             	incl   -0xc(%ebp)
  102622:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
  102629:	0f 8e 58 ff ff ff    	jle    102587 <ramfs_fifo_create+0x23>
            free(ein.stdin);
            free(ein.stdout);
            free(ein.stderr);
        }

        free(path);
  10262f:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  102634:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102637:	c9                   	leave  
  102638:	c3                   	ret    

00102639 <ramfs_fifo_read>:
        break;

  102639:	55                   	push   %ebp
  10263a:	89 e5                	mov    %esp,%ebp
  10263c:	83 ec 18             	sub    $0x18,%esp
    case 4: /* getargs */
  10263f:	8b 45 08             	mov    0x8(%ebp),%eax
  102642:	8b 40 04             	mov    0x4(%eax),%eax
  102645:	89 45 f4             	mov    %eax,-0xc(%ebp)
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  102648:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10264b:	8b 00                	mov    (%eax),%eax
  10264d:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102654:	85 c0                	test   %eax,%eax
  102656:	0f 84 c7 00 00 00    	je     102723 <ramfs_fifo_read+0xea>
    }
  10265c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10265f:	8b 00                	mov    (%eax),%eax
  102661:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102668:	8b 40 04             	mov    0x4(%eax),%eax
  10266b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10266e:	73 0a                	jae    10267a <ramfs_fifo_read+0x41>
  102670:	b8 03 00 00 00       	mov    $0x3,%eax
  102675:	e9 ae 00 00 00       	jmp    102728 <ramfs_fifo_read+0xef>
        break;
  10267a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10267d:	8b 00                	mov    (%eax),%eax
  10267f:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102686:	8b 40 08             	mov    0x8(%eax),%eax
  102689:	3b 45 10             	cmp    0x10(%ebp),%eax
  10268c:	73 0a                	jae    102698 <ramfs_fifo_read+0x5f>
  10268e:	b8 01 00 00 00       	mov    $0x1,%eax
  102693:	e9 90 00 00 00       	jmp    102728 <ramfs_fifo_read+0xef>

    case 5: /* yield */
  102698:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10269b:	8b 00                	mov    (%eax),%eax
  10269d:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1026a4:	8b 00                	mov    (%eax),%eax
  1026a6:	83 ec 04             	sub    $0x4,%esp
  1026a9:	ff 75 10             	pushl  0x10(%ebp)
  1026ac:	50                   	push   %eax
  1026ad:	ff 75 0c             	pushl  0xc(%ebp)
  1026b0:	e8 b9 13 00 00       	call   103a6e <memcpy>
  1026b5:	83 c4 10             	add    $0x10,%esp
    {
  1026b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026bb:	8b 00                	mov    (%eax),%eax
  1026bd:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1026c4:	8b 40 08             	mov    0x8(%eax),%eax
  1026c7:	89 c1                	mov    %eax,%ecx
  1026c9:	2b 4d 10             	sub    0x10(%ebp),%ecx
  1026cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026cf:	8b 00                	mov    (%eax),%eax
  1026d1:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1026d8:	8b 00                	mov    (%eax),%eax
  1026da:	89 c2                	mov    %eax,%edx
  1026dc:	03 55 10             	add    0x10(%ebp),%edx
  1026df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026e2:	8b 00                	mov    (%eax),%eax
  1026e4:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1026eb:	8b 00                	mov    (%eax),%eax
  1026ed:	83 ec 04             	sub    $0x4,%esp
  1026f0:	51                   	push   %ecx
  1026f1:	52                   	push   %edx
  1026f2:	50                   	push   %eax
  1026f3:	e8 76 13 00 00       	call   103a6e <memcpy>
  1026f8:	83 c4 10             	add    $0x10,%esp
        cpu = schedule(cpu);
  1026fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026fe:	8b 00                	mov    (%eax),%eax
  102700:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102707:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10270a:	8b 12                	mov    (%edx),%edx
  10270c:	8b 14 95 e0 89 14 00 	mov    0x1489e0(,%edx,4),%edx
  102713:	8b 52 08             	mov    0x8(%edx),%edx
  102716:	2b 55 10             	sub    0x10(%ebp),%edx
  102719:	89 50 08             	mov    %edx,0x8(%eax)
    }
        break;
  10271c:	b8 00 00 00 00       	mov    $0x0,%eax
  102721:	eb 05                	jmp    102728 <ramfs_fifo_read+0xef>

    case 6: /* getExecPath */
    {
  102723:	b8 03 00 00 00       	mov    $0x3,%eax
        char* dest = (char*)cpu->ebx;
  102728:	c9                   	leave  
  102729:	c3                   	ret    

0010272a <ramfs_fifo_write>:
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  10272a:	55                   	push   %ebp
  10272b:	89 e5                	mov    %esp,%ebp
  10272d:	83 ec 18             	sub    $0x18,%esp
        break;
  102730:	8b 45 08             	mov    0x8(%ebp),%eax
  102733:	8b 40 04             	mov    0x4(%eax),%eax
  102736:	89 45 f4             	mov    %eax,-0xc(%ebp)

    case 7: /* changeExecPath */
  102739:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10273c:	8b 00                	mov    (%eax),%eax
  10273e:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102745:	85 c0                	test   %eax,%eax
  102747:	0f 84 a8 00 00 00    	je     1027f5 <ramfs_fifo_write+0xcb>
    {
  10274d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102750:	8b 00                	mov    (%eax),%eax
  102752:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102759:	8b 40 04             	mov    0x4(%eax),%eax
  10275c:	3b 45 10             	cmp    0x10(%ebp),%eax
  10275f:	73 0a                	jae    10276b <ramfs_fifo_write+0x41>
  102761:	b8 03 00 00 00       	mov    $0x3,%eax
  102766:	e9 8f 00 00 00       	jmp    1027fa <ramfs_fifo_write+0xd0>
        vfs_reset_error();
  10276b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10276e:	8b 00                	mov    (%eax),%eax
  102770:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102777:	8b 50 04             	mov    0x4(%eax),%edx
  10277a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10277d:	8b 00                	mov    (%eax),%eax
  10277f:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  102786:	8b 40 08             	mov    0x8(%eax),%eax
  102789:	89 d1                	mov    %edx,%ecx
  10278b:	29 c1                	sub    %eax,%ecx
  10278d:	89 c8                	mov    %ecx,%eax
  10278f:	3b 45 10             	cmp    0x10(%ebp),%eax
  102792:	73 07                	jae    10279b <ramfs_fifo_write+0x71>
  102794:	b8 01 00 00 00       	mov    $0x1,%eax
  102799:	eb 5f                	jmp    1027fa <ramfs_fifo_write+0xd0>
        char* path = strclone((char*) cpu->ebx);

  10279b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10279e:	8b 00                	mov    (%eax),%eax
  1027a0:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1027a7:	8b 10                	mov    (%eax),%edx
  1027a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027ac:	8b 00                	mov    (%eax),%eax
  1027ae:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1027b5:	8b 40 08             	mov    0x8(%eax),%eax
  1027b8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1027bb:	83 ec 04             	sub    $0x4,%esp
  1027be:	ff 75 10             	pushl  0x10(%ebp)
  1027c1:	ff 75 0c             	pushl  0xc(%ebp)
  1027c4:	50                   	push   %eax
  1027c5:	e8 a4 12 00 00       	call   103a6e <memcpy>
  1027ca:	83 c4 10             	add    $0x10,%esp
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  1027cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027d0:	8b 00                	mov    (%eax),%eax
  1027d2:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1027d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1027dc:	8b 12                	mov    (%edx),%edx
  1027de:	8b 14 95 e0 89 14 00 	mov    0x1489e0(,%edx,4),%edx
  1027e5:	8b 52 08             	mov    0x8(%edx),%edx
  1027e8:	03 55 10             	add    0x10(%ebp),%edx
  1027eb:	89 50 08             	mov    %edx,0x8(%eax)

        char* new = vfs_resolve_path(path);
  1027ee:	b8 00 00 00 00       	mov    $0x0,%eax
  1027f3:	eb 05                	jmp    1027fa <ramfs_fifo_write+0xd0>

        cpu->eax = 0;
        if(new) {
  1027f5:	b8 03 00 00 00       	mov    $0x3,%eax
            get_current_task()->execPath = new;
  1027fa:	c9                   	leave  
  1027fb:	c3                   	ret    

001027fc <ramfs_fifo_open>:
            cpu->eax = 1;
        }
  1027fc:	55                   	push   %ebp
  1027fd:	89 e5                	mov    %esp,%ebp
  1027ff:	83 ec 18             	sub    $0x18,%esp

  102802:	8b 45 08             	mov    0x8(%ebp),%eax
  102805:	8b 00                	mov    (%eax),%eax
  102807:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10280e:	85 c0                	test   %eax,%eax
  102810:	0f 84 85 00 00 00    	je     10289b <ramfs_fifo_open+0x9f>
        free(path);
  102816:	8b 45 0c             	mov    0xc(%ebp),%eax
  102819:	83 e0 04             	and    $0x4,%eax
  10281c:	85 c0                	test   %eax,%eax
  10281e:	74 07                	je     102827 <ramfs_fifo_open+0x2b>
  102820:	b8 00 00 00 00       	mov    $0x0,%eax
  102825:	eb 79                	jmp    1028a0 <ramfs_fifo_open+0xa4>
    }
        break;
  102827:	8b 45 0c             	mov    0xc(%ebp),%eax
  10282a:	83 e0 01             	and    $0x1,%eax
  10282d:	84 c0                	test   %al,%al
  10282f:	74 13                	je     102844 <ramfs_fifo_open+0x48>
  102831:	8b 45 08             	mov    0x8(%ebp),%eax
  102834:	8b 00                	mov    (%eax),%eax
  102836:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10283d:	8b 50 0c             	mov    0xc(%eax),%edx
  102840:	42                   	inc    %edx
  102841:	89 50 0c             	mov    %edx,0xc(%eax)

  102844:	8b 45 0c             	mov    0xc(%ebp),%eax
  102847:	83 e0 02             	and    $0x2,%eax
  10284a:	85 c0                	test   %eax,%eax
  10284c:	74 13                	je     102861 <ramfs_fifo_open+0x65>
  10284e:	8b 45 08             	mov    0x8(%ebp),%eax
  102851:	8b 00                	mov    (%eax),%eax
  102853:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  10285a:	8b 50 10             	mov    0x10(%eax),%edx
  10285d:	42                   	inc    %edx
  10285e:	89 50 10             	mov    %edx,0x10(%eax)
	case 10: /* fopen */
	{
  102861:	83 ec 0c             	sub    $0xc,%esp
  102864:	6a 10                	push   $0x10
  102866:	e8 3b 0f 00 00       	call   1037a6 <malloc>
  10286b:	83 c4 10             	add    $0x10,%esp
  10286e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  102871:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102874:	8b 55 0c             	mov    0xc(%ebp),%edx
  102877:	89 50 0c             	mov    %edx,0xc(%eax)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  10287a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10287d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  102884:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102887:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	    struct res_handle* handle = vfs_open(name, fmode);
  10288d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102890:	8b 55 08             	mov    0x8(%ebp),%edx
  102893:	89 50 04             	mov    %edx,0x4(%eax)
	    if(handle) {
	        register_handle(handle);
  102896:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102899:	eb 05                	jmp    1028a0 <ramfs_fifo_open+0xa4>
	        cpu->eax = (uint32_t) handle;
	    }
	    else
  10289b:	b8 00 00 00 00       	mov    $0x0,%eax
	    {
  1028a0:	c9                   	leave  
  1028a1:	c3                   	ret    

001028a2 <ramfs_fifo_close>:
	        cpu->eax = 0;
	    }
  1028a2:	55                   	push   %ebp
  1028a3:	89 e5                	mov    %esp,%ebp
  1028a5:	83 ec 18             	sub    $0x18,%esp

  1028a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1028ab:	8b 40 04             	mov    0x4(%eax),%eax
  1028ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    free(name);
	}
  1028b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028b4:	8b 00                	mov    (%eax),%eax
  1028b6:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1028bd:	85 c0                	test   %eax,%eax
  1028bf:	74 40                	je     102901 <ramfs_fifo_close+0x5f>
	    break;
  1028c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1028c4:	8b 40 0c             	mov    0xc(%eax),%eax
  1028c7:	83 e0 01             	and    $0x1,%eax
  1028ca:	84 c0                	test   %al,%al
  1028cc:	74 13                	je     1028e1 <ramfs_fifo_close+0x3f>
  1028ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028d1:	8b 00                	mov    (%eax),%eax
  1028d3:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1028da:	8b 50 0c             	mov    0xc(%eax),%edx
  1028dd:	4a                   	dec    %edx
  1028de:	89 50 0c             	mov    %edx,0xc(%eax)

  1028e1:	8b 45 08             	mov    0x8(%ebp),%eax
  1028e4:	8b 40 0c             	mov    0xc(%eax),%eax
  1028e7:	83 e0 02             	and    $0x2,%eax
  1028ea:	85 c0                	test   %eax,%eax
  1028ec:	74 13                	je     102901 <ramfs_fifo_close+0x5f>
  1028ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028f1:	8b 00                	mov    (%eax),%eax
  1028f3:	8b 04 85 e0 89 14 00 	mov    0x1489e0(,%eax,4),%eax
  1028fa:	8b 50 10             	mov    0x10(%eax),%edx
  1028fd:	4a                   	dec    %edx
  1028fe:	89 50 10             	mov    %edx,0x10(%eax)
	case 11: /* fclose */
	{
        vfs_reset_error();
  102901:	83 ec 0c             	sub    $0xc,%esp
  102904:	ff 75 08             	pushl  0x8(%ebp)
  102907:	e8 e0 10 00 00       	call   1039ec <free>
  10290c:	83 c4 10             	add    $0x10,%esp
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
  10290f:	b8 00 00 00 00       	mov    $0x0,%eax
	        vfs_close(handle);
  102914:	c9                   	leave  
  102915:	c3                   	ret    
	...

00102918 <tar_parse_number>:
  102918:	55                   	push   %ebp
  102919:	89 e5                	mov    %esp,%ebp
  10291b:	83 ec 10             	sub    $0x10,%esp
  10291e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102925:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10292c:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
  102933:	eb 1d                	jmp    102952 <tar_parse_number+0x3a>
  102935:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102938:	48                   	dec    %eax
  102939:	03 45 08             	add    0x8(%ebp),%eax
  10293c:	8a 00                	mov    (%eax),%al
  10293e:	0f be c0             	movsbl %al,%eax
  102941:	83 e8 30             	sub    $0x30,%eax
  102944:	0f af 45 fc          	imul   -0x4(%ebp),%eax
  102948:	01 45 f4             	add    %eax,-0xc(%ebp)
  10294b:	ff 4d f8             	decl   -0x8(%ebp)
  10294e:	c1 65 fc 03          	shll   $0x3,-0x4(%ebp)
  102952:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  102956:	75 dd                	jne    102935 <tar_parse_number+0x1d>
  102958:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10295b:	c9                   	leave  
  10295c:	c3                   	ret    

0010295d <tar_load_ramfs>:
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
  10295d:	55                   	push   %ebp
  10295e:	89 e5                	mov    %esp,%ebp
  102960:	83 ec 28             	sub    $0x28,%esp
	case 1: /* exit */
  102963:	8b 45 08             	mov    0x8(%ebp),%eax
  102966:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return terminate_current(cpu);

    case 3: /* exec */
    {
  102969:	83 ec 08             	sub    $0x8,%esp
  10296c:	ff 75 e4             	pushl  -0x1c(%ebp)
  10296f:	68 c0 76 10 00       	push   $0x1076c0
  102974:	e8 f4 db ff ff       	call   10056d <kprintf>
  102979:	83 c4 10             	add    $0x10,%esp
        char* path = strclone((char*) cpu->ebx);

  10297c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        struct exec_info* einp = (void*) cpu->edx;

        struct exec_info ein = {
  102983:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102986:	89 45 ec             	mov    %eax,-0x14(%ebp)
            .execPath = 0,
            .stdin = 0,
  102989:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10298c:	8a 00                	mov    (%eax),%al
  10298e:	84 c0                	test   %al,%al
  102990:	75 12                	jne    1029a4 <tar_load_ramfs+0x47>
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

    case 5: /* yield */
    {
  102992:	83 ec 0c             	sub    $0xc,%esp
  102995:	68 ec 76 10 00       	push   $0x1076ec
  10299a:	e8 ce db ff ff       	call   10056d <kprintf>
  10299f:	83 c4 10             	add    $0x10,%esp
        cpu = schedule(cpu);
  1029a2:	c9                   	leave  
  1029a3:	c3                   	ret    
        struct exec_info ein = {
            .execPath = 0,
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };
  1029a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1029a7:	83 c0 7c             	add    $0x7c,%eax
  1029aa:	83 ec 0c             	sub    $0xc,%esp
  1029ad:	50                   	push   %eax
  1029ae:	e8 65 ff ff ff       	call   102918 <tar_parse_number>
  1029b3:	83 c4 10             	add    $0x10,%esp
  1029b6:	89 45 e0             	mov    %eax,-0x20(%ebp)

  1029b9:	81 45 e4 00 02 00 00 	addl   $0x200,-0x1c(%ebp)
        if(einp != 0) {
            ein.execPath = strclone(einp->execPath);
  1029c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1029c3:	85 c0                	test   %eax,%eax
  1029c5:	0f 84 85 00 00 00    	je     102a50 <tar_load_ramfs+0xf3>
            ein.stdin = strclone(einp->stdin);
  1029cb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1029ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1029d1:	83 ec 04             	sub    $0x4,%esp
  1029d4:	52                   	push   %edx
  1029d5:	50                   	push   %eax
  1029d6:	68 14 77 10 00       	push   $0x107714
  1029db:	e8 8d db ff ff       	call   10056d <kprintf>
  1029e0:	83 c4 10             	add    $0x10,%esp
            ein.stdout = strclone(einp->stdout);
            ein.stderr = strclone(einp->stderr);
  1029e3:	e8 eb f7 ff ff       	call   1021d3 <ramfs_block_driver_struct>
  1029e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1029eb:	83 ec 04             	sub    $0x4,%esp
  1029ee:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  1029f1:	51                   	push   %ecx
  1029f2:	50                   	push   %eax
  1029f3:	52                   	push   %edx
  1029f4:	e8 23 18 00 00       	call   10421c <vfs_create_kfile>
  1029f9:	83 c4 10             	add    $0x10,%esp
        }
  1029fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1029ff:	83 ec 08             	sub    $0x8,%esp
  102a02:	6a 02                	push   $0x2
  102a04:	50                   	push   %eax
  102a05:	e8 b1 18 00 00       	call   1042bb <vfs_open>
  102a0a:	83 c4 10             	add    $0x10,%esp
  102a0d:	89 45 f0             	mov    %eax,-0x10(%ebp)

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  102a10:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102a13:	6a 01                	push   $0x1
  102a15:	50                   	push   %eax
  102a16:	ff 75 e4             	pushl  -0x1c(%ebp)
  102a19:	ff 75 f0             	pushl  -0x10(%ebp)
  102a1c:	e8 c8 19 00 00       	call   1043e9 <vfs_write>
  102a21:	83 c4 10             	add    $0x10,%esp
  102a24:	89 45 f4             	mov    %eax,-0xc(%ebp)

  102a27:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  102a2b:	74 13                	je     102a40 <tar_load_ramfs+0xe3>
        if(einp != 0) {
  102a2d:	83 ec 08             	sub    $0x8,%esp
  102a30:	ff 75 f4             	pushl  -0xc(%ebp)
  102a33:	68 38 77 10 00       	push   $0x107738
  102a38:	e8 30 db ff ff       	call   10056d <kprintf>
  102a3d:	83 c4 10             	add    $0x10,%esp
            free(ein.execPath);
            free(ein.stdin);
            free(ein.stdout);
  102a40:	83 ec 0c             	sub    $0xc,%esp
  102a43:	ff 75 f0             	pushl  -0x10(%ebp)
  102a46:	e8 cd 18 00 00       	call   104318 <vfs_close>
  102a4b:	83 c4 10             	add    $0x10,%esp
  102a4e:	eb 27                	jmp    102a77 <tar_load_ramfs+0x11a>
            free(ein.stderr);
        }

        free(path);
  102a50:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102a53:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a56:	83 ec 04             	sub    $0x4,%esp
  102a59:	52                   	push   %edx
  102a5a:	50                   	push   %eax
  102a5b:	68 54 77 10 00       	push   $0x107754
  102a60:	e8 08 db ff ff       	call   10056d <kprintf>
  102a65:	83 c4 10             	add    $0x10,%esp
    }
  102a68:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a6b:	83 ec 0c             	sub    $0xc,%esp
  102a6e:	50                   	push   %eax
  102a6f:	e8 92 17 00 00       	call   104206 <vfs_create_dir>
  102a74:	83 c4 10             	add    $0x10,%esp
        break;

    case 4: /* getargs */
  102a77:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102a7a:	c1 e8 09             	shr    $0x9,%eax
  102a7d:	c1 e0 09             	shl    $0x9,%eax
  102a80:	01 45 e4             	add    %eax,-0x1c(%ebp)
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  102a83:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102a86:	25 ff 01 00 00       	and    $0x1ff,%eax
  102a8b:	85 c0                	test   %eax,%eax
  102a8d:	74 07                	je     102a96 <tar_load_ramfs+0x139>
    }
  102a8f:	81 45 e4 00 02 00 00 	addl   $0x200,-0x1c(%ebp)
		return terminate_current(cpu);

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);

  102a96:	ff 45 e8             	incl   -0x18(%ebp)
    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

  102a99:	e9 e5 fe ff ff       	jmp    102983 <tar_load_ramfs+0x26>
	...

00102aa0 <ramfs_vga_driver_struct>:
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
  102aa0:	55                   	push   %ebp
  102aa1:	89 e5                	mov    %esp,%ebp
    return &vga_driver;
  102aa3:	b8 dc 62 10 00       	mov    $0x1062dc,%eax
}
  102aa8:	5d                   	pop    %ebp
  102aa9:	c3                   	ret    

00102aaa <ramfs_vga_writers>:

uint32_t ramfs_vga_writers() {
  102aaa:	55                   	push   %ebp
  102aab:	89 e5                	mov    %esp,%ebp
    return vga_writers;
  102aad:	a1 44 85 12 00       	mov    0x128544,%eax
}
  102ab2:	5d                   	pop    %ebp
  102ab3:	c3                   	ret    

00102ab4 <ramfs_vga_available>:

uint32_t ramfs_vga_available(struct res_handle* handle) {
  102ab4:	55                   	push   %ebp
  102ab5:	89 e5                	mov    %esp,%ebp
    return sizeof(struct vga_command);
  102ab7:	b8 06 00 00 00       	mov    $0x6,%eax
}
  102abc:	5d                   	pop    %ebp
  102abd:	c3                   	ret    

00102abe <ramfs_vga_create>:

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  102abe:	55                   	push   %ebp
  102abf:	89 e5                	mov    %esp,%ebp
  102ac1:	83 ec 08             	sub    $0x8,%esp
    return malloc(sizeof(struct res_kfile));
  102ac4:	83 ec 0c             	sub    $0xc,%esp
  102ac7:	6a 08                	push   $0x8
  102ac9:	e8 d8 0c 00 00       	call   1037a6 <malloc>
  102ace:	83 c4 10             	add    $0x10,%esp
}
  102ad1:	c9                   	leave  
  102ad2:	c3                   	ret    

00102ad3 <ramfs_vga_read>:

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  102ad3:	55                   	push   %ebp
  102ad4:	89 e5                	mov    %esp,%ebp
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102ad6:	b8 03 00 00 00       	mov    $0x3,%eax
}
  102adb:	5d                   	pop    %ebp
  102adc:	c3                   	ret    

00102add <ramfs_vga_write>:

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  102add:	55                   	push   %ebp
  102ade:	89 e5                	mov    %esp,%ebp
  102ae0:	83 ec 10             	sub    $0x10,%esp
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  102ae3:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
  102ae7:	74 0a                	je     102af3 <ramfs_vga_write+0x16>
  102ae9:	b8 03 00 00 00       	mov    $0x3,%eax
  102aee:	e9 d7 00 00 00       	jmp    102bca <ramfs_vga_write+0xed>

    struct vga_command* vgac = src;
  102af3:	8b 45 0c             	mov    0xc(%ebp),%eax
  102af6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(vgac->command == CMD_SET) {
  102af9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102afc:	66 8b 00             	mov    (%eax),%ax
  102aff:	66 85 c0             	test   %ax,%ax
  102b02:	75 2d                	jne    102b31 <ramfs_vga_write+0x54>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  102b04:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b07:	66 8b 40 02          	mov    0x2(%eax),%ax
  102b0b:	66 3d cf 07          	cmp    $0x7cf,%ax
  102b0f:	77 20                	ja     102b31 <ramfs_vga_write+0x54>
  102b11:	8b 15 d8 62 10 00    	mov    0x1062d8,%edx
  102b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b1a:	66 8b 40 02          	mov    0x2(%eax),%ax
  102b1e:	25 ff ff 00 00       	and    $0xffff,%eax
  102b23:	01 c0                	add    %eax,%eax
  102b25:	01 c2                	add    %eax,%edx
  102b27:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b2a:	66 8b 40 04          	mov    0x4(%eax),%ax
  102b2e:	66 89 02             	mov    %ax,(%edx)
    }

    if(vgac->command == CMD_CLEAR) {
  102b31:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b34:	66 8b 00             	mov    (%eax),%ax
  102b37:	66 83 f8 01          	cmp    $0x1,%ax
  102b3b:	75 26                	jne    102b63 <ramfs_vga_write+0x86>
        for(int i = 0; i < (80 * 25); i++) {
  102b3d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  102b44:	eb 14                	jmp    102b5a <ramfs_vga_write+0x7d>
            vga_buffer[i] = 0;
  102b46:	a1 d8 62 10 00       	mov    0x1062d8,%eax
  102b4b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102b4e:	01 d2                	add    %edx,%edx
  102b50:	01 d0                	add    %edx,%eax
  102b52:	66 c7 00 00 00       	movw   $0x0,(%eax)
    if(vgac->command == CMD_SET) {
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
  102b57:	ff 45 f8             	incl   -0x8(%ebp)
  102b5a:	81 7d f8 cf 07 00 00 	cmpl   $0x7cf,-0x8(%ebp)
  102b61:	7e e3                	jle    102b46 <ramfs_vga_write+0x69>
            vga_buffer[i] = 0;
        }
    }

    if(vgac->command == CMD_SCROLL) {
  102b63:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b66:	66 8b 00             	mov    (%eax),%ax
  102b69:	66 83 f8 02          	cmp    $0x2,%ax
  102b6d:	75 56                	jne    102bc5 <ramfs_vga_write+0xe8>
        int i;
        for (i = 0; i < 24 * 80; i++) {
  102b6f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102b76:	eb 25                	jmp    102b9d <ramfs_vga_write+0xc0>
            vga_buffer[i] = vga_buffer[i + 80];
  102b78:	a1 d8 62 10 00       	mov    0x1062d8,%eax
  102b7d:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102b80:	01 d2                	add    %edx,%edx
  102b82:	8d 14 10             	lea    (%eax,%edx,1),%edx
  102b85:	a1 d8 62 10 00       	mov    0x1062d8,%eax
  102b8a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  102b8d:	83 c1 50             	add    $0x50,%ecx
  102b90:	01 c9                	add    %ecx,%ecx
  102b92:	01 c8                	add    %ecx,%eax
  102b94:	66 8b 00             	mov    (%eax),%ax
  102b97:	66 89 02             	mov    %ax,(%edx)
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  102b9a:	ff 45 fc             	incl   -0x4(%ebp)
  102b9d:	81 7d fc 7f 07 00 00 	cmpl   $0x77f,-0x4(%ebp)
  102ba4:	7e d2                	jle    102b78 <ramfs_vga_write+0x9b>
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  102ba6:	eb 14                	jmp    102bbc <ramfs_vga_write+0xdf>
            vga_buffer[i] = 0;
  102ba8:	a1 d8 62 10 00       	mov    0x1062d8,%eax
  102bad:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102bb0:	01 d2                	add    %edx,%edx
  102bb2:	01 d0                	add    %edx,%eax
  102bb4:	66 c7 00 00 00       	movw   $0x0,(%eax)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  102bb9:	ff 45 fc             	incl   -0x4(%ebp)
  102bbc:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
  102bc3:	7e e3                	jle    102ba8 <ramfs_vga_write+0xcb>
            vga_buffer[i] = 0;
        }
    }

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  102bc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102bca:	c9                   	leave  
  102bcb:	c3                   	ret    

00102bcc <ramfs_vga_open>:

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
  102bcc:	55                   	push   %ebp
  102bcd:	89 e5                	mov    %esp,%ebp
  102bcf:	83 ec 18             	sub    $0x18,%esp
    if(filemode & FM_EXEC) return 0;
  102bd2:	8b 45 0c             	mov    0xc(%ebp),%eax
  102bd5:	83 e0 04             	and    $0x4,%eax
  102bd8:	85 c0                	test   %eax,%eax
  102bda:	74 07                	je     102be3 <ramfs_vga_open+0x17>
  102bdc:	b8 00 00 00 00       	mov    $0x0,%eax
  102be1:	eb 78                	jmp    102c5b <ramfs_vga_open+0x8f>
    if(filemode & FM_READ) return 0;
  102be3:	8b 45 0c             	mov    0xc(%ebp),%eax
  102be6:	83 e0 01             	and    $0x1,%eax
  102be9:	84 c0                	test   %al,%al
  102beb:	74 07                	je     102bf4 <ramfs_vga_open+0x28>
  102bed:	b8 00 00 00 00       	mov    $0x0,%eax
  102bf2:	eb 67                	jmp    102c5b <ramfs_vga_open+0x8f>

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  102bf4:	8b 45 0c             	mov    0xc(%ebp),%eax
  102bf7:	83 e0 02             	and    $0x2,%eax
  102bfa:	85 c0                	test   %eax,%eax
  102bfc:	74 10                	je     102c0e <ramfs_vga_open+0x42>
  102bfe:	a1 44 85 12 00       	mov    0x128544,%eax
  102c03:	85 c0                	test   %eax,%eax
  102c05:	74 07                	je     102c0e <ramfs_vga_open+0x42>
  102c07:	b8 00 00 00 00       	mov    $0x0,%eax
  102c0c:	eb 4d                	jmp    102c5b <ramfs_vga_open+0x8f>
    if((filemode & FM_WRITE)) vga_writers++;
  102c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102c11:	83 e0 02             	and    $0x2,%eax
  102c14:	85 c0                	test   %eax,%eax
  102c16:	74 0b                	je     102c23 <ramfs_vga_open+0x57>
  102c18:	a1 44 85 12 00       	mov    0x128544,%eax
  102c1d:	40                   	inc    %eax
  102c1e:	a3 44 85 12 00       	mov    %eax,0x128544

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  102c23:	83 ec 0c             	sub    $0xc,%esp
  102c26:	6a 10                	push   $0x10
  102c28:	e8 79 0b 00 00       	call   1037a6 <malloc>
  102c2d:	83 c4 10             	add    $0x10,%esp
  102c30:	89 45 f4             	mov    %eax,-0xc(%ebp)

    rethandle->filemode = filemode;
  102c33:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c36:	8b 55 0c             	mov    0xc(%ebp),%edx
  102c39:	89 50 0c             	mov    %edx,0xc(%eax)
    rethandle->position = 0;
  102c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c3f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    rethandle->res_type = RES_KERNDRV;
  102c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c49:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    rethandle->res_ptr  = kf;
  102c4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c52:	8b 55 08             	mov    0x8(%ebp),%edx
  102c55:	89 50 04             	mov    %edx,0x4(%eax)

    return rethandle;
  102c58:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  102c5b:	c9                   	leave  
  102c5c:	c3                   	ret    

00102c5d <ramfs_vga_close>:

uint32_t ramfs_vga_close(struct res_handle* handle) {
  102c5d:	55                   	push   %ebp
  102c5e:	89 e5                	mov    %esp,%ebp
  102c60:	83 ec 08             	sub    $0x8,%esp
    if(handle->filemode & FM_WRITE) vga_writers--;
  102c63:	8b 45 08             	mov    0x8(%ebp),%eax
  102c66:	8b 40 0c             	mov    0xc(%eax),%eax
  102c69:	83 e0 02             	and    $0x2,%eax
  102c6c:	85 c0                	test   %eax,%eax
  102c6e:	74 0b                	je     102c7b <ramfs_vga_close+0x1e>
  102c70:	a1 44 85 12 00       	mov    0x128544,%eax
  102c75:	48                   	dec    %eax
  102c76:	a3 44 85 12 00       	mov    %eax,0x128544

    free(handle);
  102c7b:	83 ec 0c             	sub    $0xc,%esp
  102c7e:	ff 75 08             	pushl  0x8(%ebp)
  102c81:	e8 66 0d 00 00       	call   1039ec <free>
  102c86:	83 c4 10             	add    $0x10,%esp

    return 0;
  102c89:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102c8e:	c9                   	leave  
  102c8f:	c3                   	ret    

00102c90 <enableScheduling>:
    char* execPath;
    char* stdin;
    char* stdout;
    char* stderr;
};

  102c90:	55                   	push   %ebp
  102c91:	89 e5                	mov    %esp,%ebp
struct cpu_state* syscall(struct cpu_state* cpu) {
  102c93:	c7 05 48 85 12 00 01 	movl   $0x1,0x128548
  102c9a:	00 00 00 
    cpu = save_cpu_state(cpu);
  102c9d:	5d                   	pop    %ebp
  102c9e:	c3                   	ret    

00102c9f <isSchedulingEnabled>:

	switch (cpu->eax) {
  102c9f:	55                   	push   %ebp
  102ca0:	89 e5                	mov    %esp,%ebp
	case 1: /* exit */
  102ca2:	a1 48 85 12 00       	mov    0x128548,%eax
		return terminate_current(cpu);
  102ca7:	5d                   	pop    %ebp
  102ca8:	c3                   	ret    

00102ca9 <get_current_task>:

    case 3: /* exec */
  102ca9:	55                   	push   %ebp
  102caa:	89 e5                	mov    %esp,%ebp
    {
  102cac:	a1 50 85 12 00       	mov    0x128550,%eax
        char* path = strclone((char*) cpu->ebx);
  102cb1:	5d                   	pop    %ebp
  102cb2:	c3                   	ret    

00102cb3 <get_task_by_pid>:

        struct exec_info* einp = (void*) cpu->edx;
  102cb3:	55                   	push   %ebp
  102cb4:	89 e5                	mov    %esp,%ebp
  102cb6:	83 ec 10             	sub    $0x10,%esp

  102cb9:	a1 4c 85 12 00       	mov    0x12854c,%eax
  102cbe:	89 45 fc             	mov    %eax,-0x4(%ebp)
        struct exec_info ein = {
            .execPath = 0,
  102cc1:	eb 09                	jmp    102ccc <get_task_by_pid+0x19>
            .stdin = 0,
  102cc3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cc6:	8b 40 08             	mov    0x8(%eax),%eax
  102cc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
        char* path = strclone((char*) cpu->ebx);

        struct exec_info* einp = (void*) cpu->edx;

        struct exec_info ein = {
            .execPath = 0,
  102ccc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  102cd0:	74 0a                	je     102cdc <get_task_by_pid+0x29>
  102cd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cd5:	8b 00                	mov    (%eax),%eax
  102cd7:	3b 45 08             	cmp    0x8(%ebp),%eax
  102cda:	75 e7                	jne    102cc3 <get_task_by_pid+0x10>
            .stdin = 0,
            .stdout = 0,
            .stderr = 0
        };
  102cdc:	8b 45 fc             	mov    -0x4(%ebp),%eax

  102cdf:	c9                   	leave  
  102ce0:	c3                   	ret    

00102ce1 <register_handle>:
        if(einp != 0) {
            ein.execPath = strclone(einp->execPath);
  102ce1:	55                   	push   %ebp
  102ce2:	89 e5                	mov    %esp,%ebp
  102ce4:	53                   	push   %ebx
  102ce5:	83 ec 14             	sub    $0x14,%esp
            ein.stdin = strclone(einp->stdin);
  102ce8:	a1 50 85 12 00       	mov    0x128550,%eax
  102ced:	8b 40 3c             	mov    0x3c(%eax),%eax
  102cf0:	89 45 f4             	mov    %eax,-0xc(%ebp)
            ein.stdout = strclone(einp->stdout);
            ein.stderr = strclone(einp->stderr);
  102cf3:	8b 1d 50 85 12 00    	mov    0x128550,%ebx
  102cf9:	83 ec 0c             	sub    $0xc,%esp
  102cfc:	6a 08                	push   $0x8
  102cfe:	e8 a3 0a 00 00       	call   1037a6 <malloc>
  102d03:	83 c4 10             	add    $0x10,%esp
  102d06:	89 43 3c             	mov    %eax,0x3c(%ebx)
        }
  102d09:	a1 50 85 12 00       	mov    0x128550,%eax
  102d0e:	8b 40 3c             	mov    0x3c(%eax),%eax
  102d11:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102d14:	89 50 04             	mov    %edx,0x4(%eax)

  102d17:	a1 50 85 12 00       	mov    0x128550,%eax
  102d1c:	8b 40 3c             	mov    0x3c(%eax),%eax
  102d1f:	8b 55 08             	mov    0x8(%ebp),%edx
  102d22:	89 10                	mov    %edx,(%eax)
        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);

  102d24:	b8 00 00 00 00       	mov    $0x0,%eax
        if(einp != 0) {
  102d29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102d2c:	c9                   	leave  
  102d2d:	c3                   	ret    

00102d2e <unregister_handle>:
            free(ein.execPath);
            free(ein.stdin);
  102d2e:	55                   	push   %ebp
  102d2f:	89 e5                	mov    %esp,%ebp
  102d31:	83 ec 18             	sub    $0x18,%esp
            free(ein.stdout);
  102d34:	a1 50 85 12 00       	mov    0x128550,%eax
  102d39:	8b 40 3c             	mov    0x3c(%eax),%eax
  102d3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
            free(ein.stderr);
        }
  102d3f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102d43:	75 0a                	jne    102d4f <unregister_handle+0x21>
  102d45:	b8 02 00 00 00       	mov    $0x2,%eax
  102d4a:	e9 88 00 00 00       	jmp    102dd7 <unregister_handle+0xa9>

  102d4f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102d53:	75 07                	jne    102d5c <unregister_handle+0x2e>
  102d55:	b8 01 00 00 00       	mov    $0x1,%eax
  102d5a:	eb 7b                	jmp    102dd7 <unregister_handle+0xa9>
        free(path);
    }
  102d5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d5f:	8b 00                	mov    (%eax),%eax
  102d61:	3b 45 08             	cmp    0x8(%ebp),%eax
  102d64:	75 66                	jne    102dcc <unregister_handle+0x9e>
        break;
  102d66:	a1 50 85 12 00       	mov    0x128550,%eax
  102d6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102d6e:	8b 52 04             	mov    0x4(%edx),%edx
  102d71:	89 50 3c             	mov    %edx,0x3c(%eax)

  102d74:	83 ec 0c             	sub    $0xc,%esp
  102d77:	ff 75 f0             	pushl  -0x10(%ebp)
  102d7a:	e8 6d 0c 00 00       	call   1039ec <free>
  102d7f:	83 c4 10             	add    $0x10,%esp
    case 4: /* getargs */
    {
  102d82:	b8 00 00 00 00       	mov    $0x0,%eax
  102d87:	eb 4e                	jmp    102dd7 <unregister_handle+0xa9>
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

  102d89:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d8c:	8b 40 04             	mov    0x4(%eax),%eax
  102d8f:	8b 00                	mov    (%eax),%eax
  102d91:	3b 45 08             	cmp    0x8(%ebp),%eax
  102d94:	75 2d                	jne    102dc3 <unregister_handle+0x95>
    case 5: /* yield */
  102d96:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d99:	8b 40 04             	mov    0x4(%eax),%eax
  102d9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    {
  102d9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102da2:	8b 40 04             	mov    0x4(%eax),%eax
  102da5:	8b 50 04             	mov    0x4(%eax),%edx
  102da8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102dab:	89 50 04             	mov    %edx,0x4(%eax)
        cpu = schedule(cpu);
    }
  102dae:	83 ec 0c             	sub    $0xc,%esp
  102db1:	ff 75 f4             	pushl  -0xc(%ebp)
  102db4:	e8 33 0c 00 00       	call   1039ec <free>
  102db9:	83 c4 10             	add    $0x10,%esp
        break;

  102dbc:	b8 00 00 00 00       	mov    $0x0,%eax
  102dc1:	eb 14                	jmp    102dd7 <unregister_handle+0xa9>
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  102dc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102dc6:	8b 40 04             	mov    0x4(%eax),%eax
  102dc9:	89 45 f0             	mov    %eax,-0x10(%ebp)

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;
  102dcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102dd0:	75 b7                	jne    102d89 <unregister_handle+0x5b>
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;
  102dd2:	b8 03 00 00 00       	mov    $0x3,%eax

  102dd7:	c9                   	leave  
  102dd8:	c3                   	ret    

00102dd9 <schedule_exception>:
    case 7: /* changeExecPath */
    {
  102dd9:	55                   	push   %ebp
  102dda:	89 e5                	mov    %esp,%ebp
  102ddc:	53                   	push   %ebx
  102ddd:	83 ec 04             	sub    $0x4,%esp
        vfs_reset_error();
  102de0:	8b 15 50 85 12 00    	mov    0x128550,%edx
  102de6:	a1 4c 85 12 00       	mov    0x12854c,%eax
  102deb:	39 c2                	cmp    %eax,%edx
  102ded:	75 62                	jne    102e51 <schedule_exception+0x78>
  102def:	a1 50 85 12 00       	mov    0x128550,%eax
  102df4:	8b 40 08             	mov    0x8(%eax),%eax
  102df7:	85 c0                	test   %eax,%eax
  102df9:	75 56                	jne    102e51 <schedule_exception+0x78>
        char* path = strclone((char*) cpu->ebx);

  102dfb:	83 ec 0c             	sub    $0xc,%esp
  102dfe:	6a 04                	push   $0x4
  102e00:	e8 52 d7 ff ff       	call   100557 <setclr>
  102e05:	83 c4 10             	add    $0x10,%esp
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  102e08:	8b 45 08             	mov    0x8(%ebp),%eax
  102e0b:	8b 58 20             	mov    0x20(%eax),%ebx
  102e0e:	8b 45 08             	mov    0x8(%ebp),%eax
  102e11:	8b 48 1c             	mov    0x1c(%eax),%ecx
  102e14:	a1 50 85 12 00       	mov    0x128550,%eax
  102e19:	8b 50 24             	mov    0x24(%eax),%edx
  102e1c:	a1 50 85 12 00       	mov    0x128550,%eax
  102e21:	8b 00                	mov    (%eax),%eax
  102e23:	83 ec 0c             	sub    $0xc,%esp
  102e26:	53                   	push   %ebx
  102e27:	51                   	push   %ecx
  102e28:	52                   	push   %edx
  102e29:	50                   	push   %eax
  102e2a:	68 88 77 10 00       	push   $0x107788
  102e2f:	e8 39 d7 ff ff       	call   10056d <kprintf>
  102e34:	83 c4 20             	add    $0x20,%esp

  102e37:	83 ec 08             	sub    $0x8,%esp
  102e3a:	68 c8 77 10 00       	push   $0x1077c8
  102e3f:	ff 75 08             	pushl  0x8(%ebp)
  102e42:	e8 8f d3 ff ff       	call   1001d6 <show_cod>
  102e47:	83 c4 10             	add    $0x10,%esp
        char* new = vfs_resolve_path(path);

        cpu->eax = 0;
  102e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  102e4f:	eb 75                	jmp    102ec6 <schedule_exception+0xed>
        if(new) {
            get_current_task()->execPath = new;
            cpu->eax = 1;
  102e51:	83 ec 0c             	sub    $0xc,%esp
  102e54:	6a 04                	push   $0x4
  102e56:	e8 fc d6 ff ff       	call   100557 <setclr>
  102e5b:	83 c4 10             	add    $0x10,%esp
        }
  102e5e:	8b 45 08             	mov    0x8(%ebp),%eax
  102e61:	8b 58 20             	mov    0x20(%eax),%ebx
  102e64:	8b 45 08             	mov    0x8(%ebp),%eax
  102e67:	8b 48 1c             	mov    0x1c(%eax),%ecx
  102e6a:	a1 50 85 12 00       	mov    0x128550,%eax
  102e6f:	8b 50 24             	mov    0x24(%eax),%edx
  102e72:	a1 50 85 12 00       	mov    0x128550,%eax
  102e77:	8b 00                	mov    (%eax),%eax
  102e79:	83 ec 0c             	sub    $0xc,%esp
  102e7c:	53                   	push   %ebx
  102e7d:	51                   	push   %ecx
  102e7e:	52                   	push   %edx
  102e7f:	50                   	push   %eax
  102e80:	68 88 77 10 00       	push   $0x107788
  102e85:	e8 e3 d6 ff ff       	call   10056d <kprintf>
  102e8a:	83 c4 20             	add    $0x20,%esp

  102e8d:	83 ec 0c             	sub    $0xc,%esp
  102e90:	68 f1 77 10 00       	push   $0x1077f1
  102e95:	e8 d3 d6 ff ff       	call   10056d <kprintf>
  102e9a:	83 c4 10             	add    $0x10,%esp
        free(path);
  102e9d:	83 ec 0c             	sub    $0xc,%esp
  102ea0:	ff 75 08             	pushl  0x8(%ebp)
  102ea3:	e8 89 d3 ff ff       	call   100231 <show_dump>
  102ea8:	83 c4 10             	add    $0x10,%esp
    }
  102eab:	83 ec 0c             	sub    $0xc,%esp
  102eae:	6a 07                	push   $0x7
  102eb0:	e8 a2 d6 ff ff       	call   100557 <setclr>
  102eb5:	83 c4 10             	add    $0x10,%esp
        break;

  102eb8:	83 ec 0c             	sub    $0xc,%esp
  102ebb:	ff 75 08             	pushl  0x8(%ebp)
  102ebe:	e8 08 00 00 00       	call   102ecb <terminate_current>
  102ec3:	83 c4 10             	add    $0x10,%esp
	case 10: /* fopen */
	{
  102ec6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102ec9:	c9                   	leave  
  102eca:	c3                   	ret    

00102ecb <terminate_current>:
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  102ecb:	55                   	push   %ebp
  102ecc:	89 e5                	mov    %esp,%ebp
  102ece:	83 ec 18             	sub    $0x18,%esp
	    uint32_t fmode = (uint32_t) cpu->ecx;
  102ed1:	a1 50 85 12 00       	mov    0x128550,%eax
  102ed6:	8b 40 08             	mov    0x8(%eax),%eax
  102ed9:	89 45 ec             	mov    %eax,-0x14(%ebp)

  102edc:	a1 50 85 12 00       	mov    0x128550,%eax
  102ee1:	8b 40 0c             	mov    0xc(%eax),%eax
  102ee4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    struct res_handle* handle = vfs_open(name, fmode);
  102ee7:	a1 50 85 12 00       	mov    0x128550,%eax
  102eec:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    if(handle) {
	        register_handle(handle);
  102eef:	e8 fd 1e 00 00       	call   104df1 <vmm_free_current_pagetables>
	        cpu->eax = (uint32_t) handle;
	    }
  102ef4:	8b 15 50 85 12 00    	mov    0x128550,%edx
  102efa:	a1 4c 85 12 00       	mov    0x12854c,%eax
  102eff:	39 c2                	cmp    %eax,%edx
  102f01:	75 0d                	jne    102f10 <terminate_current+0x45>
	    else
  102f03:	a1 50 85 12 00       	mov    0x128550,%eax
  102f08:	8b 40 08             	mov    0x8(%eax),%eax
  102f0b:	a3 4c 85 12 00       	mov    %eax,0x12854c
	    {
	        cpu->eax = 0;
	    }
  102f10:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102f14:	74 09                	je     102f1f <terminate_current+0x54>

  102f16:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102f19:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102f1c:	89 50 0c             	mov    %edx,0xc(%eax)
	    free(name);
	}
	    break;
  102f1f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102f23:	74 09                	je     102f2e <terminate_current+0x63>

  102f25:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f28:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102f2b:	89 50 08             	mov    %edx,0x8(%eax)
	case 11: /* fclose */
	{
        vfs_reset_error();
  102f2e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102f32:	75 08                	jne    102f3c <terminate_current+0x71>
	    struct res_handle* handle = (void*) cpu->ebx;
  102f34:	a1 4c 85 12 00       	mov    0x12854c,%eax
  102f39:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);
  102f3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102f3f:	a3 50 85 12 00       	mov    %eax,0x128550

	        cpu->eax = 0;
  102f44:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f47:	8b 40 04             	mov    0x4(%eax),%eax
  102f4a:	83 ec 0c             	sub    $0xc,%esp
  102f4d:	50                   	push   %eax
  102f4e:	e8 99 0a 00 00       	call   1039ec <free>
  102f53:	83 c4 10             	add    $0x10,%esp
	    }
  102f56:	83 ec 0c             	sub    $0xc,%esp
  102f59:	ff 75 f4             	pushl  -0xc(%ebp)
  102f5c:	e8 8b 0a 00 00       	call   1039ec <free>
  102f61:	83 c4 10             	add    $0x10,%esp
	    else
	    {
  102f64:	a1 50 85 12 00       	mov    0x128550,%eax
  102f69:	85 c0                	test   %eax,%eax
  102f6b:	75 13                	jne    102f80 <terminate_current+0xb5>
	        cpu->eax = (uint32_t) -1;
  102f6d:	83 ec 08             	sub    $0x8,%esp
  102f70:	68 f3 77 10 00       	push   $0x1077f3
  102f75:	ff 75 08             	pushl  0x8(%ebp)
  102f78:	e8 59 d2 ff ff       	call   1001d6 <show_cod>
  102f7d:	83 c4 10             	add    $0x10,%esp
	    }
	}
	    break;
  102f80:	a1 50 85 12 00       	mov    0x128550,%eax
  102f85:	8b 40 14             	mov    0x14(%eax),%eax
  102f88:	83 ec 0c             	sub    $0xc,%esp
  102f8b:	50                   	push   %eax
  102f8c:	e8 23 24 00 00       	call   1053b4 <vmm_activate_pagedir>
  102f91:	83 c4 10             	add    $0x10,%esp

  102f94:	a1 50 85 12 00       	mov    0x128550,%eax
  102f99:	8b 40 04             	mov    0x4(%eax),%eax
	case 12: /* fwrite */
  102f9c:	c9                   	leave  
  102f9d:	c3                   	ret    

00102f9e <init_task>:
	{
        vfs_reset_error();
  102f9e:	55                   	push   %ebp
  102f9f:	89 e5                	mov    %esp,%ebp
  102fa1:	57                   	push   %edi
  102fa2:	56                   	push   %esi
  102fa3:	53                   	push   %ebx
  102fa4:	83 ec 5c             	sub    $0x5c,%esp
	    struct res_handle* handle = (void*) cpu->ebx;
  102fa7:	83 ec 08             	sub    $0x8,%esp
  102faa:	6a 40                	push   $0x40
  102fac:	6a 01                	push   $0x1
  102fae:	e8 69 09 00 00       	call   10391c <calloc>
  102fb3:	83 c4 10             	add    $0x10,%esp
  102fb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    if(handle != 0) {
  102fb9:	83 ec 08             	sub    $0x8,%esp
  102fbc:	6a 38                	push   $0x38
  102fbe:	6a 01                	push   $0x1
  102fc0:	e8 57 09 00 00       	call   10391c <calloc>
  102fc5:	83 c4 10             	add    $0x10,%esp
  102fc8:	89 c2                	mov    %eax,%edx
  102fca:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102fcd:	89 50 04             	mov    %edx,0x4(%eax)
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
  102fd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102fd3:	8b 55 08             	mov    0x8(%ebp),%edx
  102fd6:	89 50 14             	mov    %edx,0x14(%eax)
	    else
  102fd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102fdc:	c7 40 10 00 e0 ff ff 	movl   $0xffffe000,0x10(%eax)
	    {
  102fe3:	a1 f8 62 10 00       	mov    0x1062f8,%eax
  102fe8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102feb:	89 02                	mov    %eax,(%edx)
  102fed:	40                   	inc    %eax
  102fee:	a3 f8 62 10 00       	mov    %eax,0x1062f8
            cpu->eax = RW_ERR_VFS;
	    }
  102ff3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102ff6:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
	}
  102ffd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103000:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
	    break;
  103007:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10300a:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

	case 13: /* fread */
  103011:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103014:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	{
  10301b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10301e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
  103025:	a1 4c 85 12 00       	mov    0x12854c,%eax
  10302a:	85 c0                	test   %eax,%eax
  10302c:	75 0a                	jne    103038 <init_task+0x9a>
        if(handle != 0) {
  10302e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103031:	a3 4c 85 12 00       	mov    %eax,0x12854c
  103036:	eb 1f                	jmp    103057 <init_task+0xb9>
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
  103038:	8b 15 4c 85 12 00    	mov    0x12854c,%edx
  10303e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103041:	89 50 08             	mov    %edx,0x8(%eax)
        else
  103044:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103049:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10304c:	89 50 0c             	mov    %edx,0xc(%eax)
        {
  10304f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103052:	a3 4c 85 12 00       	mov    %eax,0x12854c
            cpu->eax = RW_ERR_VFS;
        }
	}
  103057:	e8 60 1d 00 00       	call   104dbc <vmm_get_current_pagedir>
  10305c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    break;
  10305f:	83 ec 0c             	sub    $0xc,%esp
  103062:	ff 75 08             	pushl  0x8(%ebp)
  103065:	e8 4a 23 00 00       	call   1053b4 <vmm_activate_pagedir>
  10306a:	83 c4 10             	add    $0x10,%esp

	case 14: /* fmkfifo */
  10306d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103070:	8b 40 10             	mov    0x10(%eax),%eax
  103073:	83 ec 08             	sub    $0x8,%esp
  103076:	6a 00                	push   $0x0
  103078:	50                   	push   %eax
  103079:	e8 91 22 00 00       	call   10530f <vmm_alloc_addr>
  10307e:	83 c4 10             	add    $0x10,%esp
	{
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size

  103081:	8b 75 0c             	mov    0xc(%ebp),%esi

	case 14: /* fmkfifo */
	{
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  103084:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103087:	8b 40 10             	mov    0x10(%eax),%eax
  10308a:	05 00 10 00 00       	add    $0x1000,%eax
  10308f:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
            register_handle(handle);
            cpu->eax = (uint32_t) handle;
        }
  103092:	8d 5d a8             	lea    -0x58(%ebp),%ebx
  103095:	b8 00 00 00 00       	mov    $0x0,%eax
  10309a:	ba 0e 00 00 00       	mov    $0xe,%edx
  10309f:	89 df                	mov    %ebx,%edi
  1030a1:	89 d1                	mov    %edx,%ecx
  1030a3:	f3 ab                	rep stos %eax,%es:(%edi)
  1030a5:	89 75 cc             	mov    %esi,-0x34(%ebp)
  1030a8:	c7 45 d0 1b 00 00 00 	movl   $0x1b,-0x30(%ebp)
  1030af:	c7 45 d4 00 02 00 00 	movl   $0x200,-0x2c(%ebp)
  1030b6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1030b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1030bc:	c7 45 dc 23 00 00 00 	movl   $0x23,-0x24(%ebp)
        else
        {
  1030c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1030c6:	8b 40 04             	mov    0x4(%eax),%eax
  1030c9:	83 ec 04             	sub    $0x4,%esp
  1030cc:	6a 38                	push   $0x38
  1030ce:	8d 55 a8             	lea    -0x58(%ebp),%edx
  1030d1:	52                   	push   %edx
  1030d2:	50                   	push   %eax
  1030d3:	e8 96 09 00 00       	call   103a6e <memcpy>
  1030d8:	83 c4 10             	add    $0x10,%esp
            cpu->eax = 0;
        }
  1030db:	83 ec 0c             	sub    $0xc,%esp
  1030de:	ff 75 e4             	pushl  -0x1c(%ebp)
  1030e1:	e8 ce 22 00 00       	call   1053b4 <vmm_activate_pagedir>
  1030e6:	83 c4 10             	add    $0x10,%esp

        free(name);
  1030e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
	}
  1030ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  1030ef:	83 c4 00             	add    $0x0,%esp
  1030f2:	5b                   	pop    %ebx
  1030f3:	5e                   	pop    %esi
  1030f4:	5f                   	pop    %edi
  1030f5:	5d                   	pop    %ebp
  1030f6:	c3                   	ret    

001030f7 <save_cpu_state>:
	    break;

  1030f7:	55                   	push   %ebp
  1030f8:	89 e5                	mov    %esp,%ebp
  1030fa:	83 ec 08             	sub    $0x8,%esp
	case 15: /* getLastVFSErr */
  1030fd:	a1 50 85 12 00       	mov    0x128550,%eax
  103102:	8b 40 18             	mov    0x18(%eax),%eax
  103105:	85 c0                	test   %eax,%eax
  103107:	74 38                	je     103141 <save_cpu_state+0x4a>
  103109:	a1 50 85 12 00       	mov    0x128550,%eax
  10310e:	8b 40 18             	mov    0x18(%eax),%eax
  103111:	8a 40 14             	mov    0x14(%eax),%al
  103114:	84 c0                	test   %al,%al
  103116:	74 29                	je     103141 <save_cpu_state+0x4a>
	{
  103118:	a1 50 85 12 00       	mov    0x128550,%eax
  10311d:	8b 40 18             	mov    0x18(%eax),%eax
  103120:	8b 40 18             	mov    0x18(%eax),%eax
  103123:	83 ec 04             	sub    $0x4,%esp
  103126:	6a 38                	push   $0x38
  103128:	ff 75 08             	pushl  0x8(%ebp)
  10312b:	50                   	push   %eax
  10312c:	e8 3d 09 00 00       	call   103a6e <memcpy>
  103131:	83 c4 10             	add    $0x10,%esp
	    cpu->eax = get_current_task()->vfserr;
  103134:	a1 50 85 12 00       	mov    0x128550,%eax
  103139:	8b 40 18             	mov    0x18(%eax),%eax
  10313c:	8b 40 18             	mov    0x18(%eax),%eax
  10313f:	eb 21                	jmp    103162 <save_cpu_state+0x6b>
        vfs_reset_error();
	}
	    break;

  103141:	a1 50 85 12 00       	mov    0x128550,%eax
  103146:	8b 40 04             	mov    0x4(%eax),%eax
  103149:	83 ec 04             	sub    $0x4,%esp
  10314c:	6a 38                	push   $0x38
  10314e:	ff 75 08             	pushl  0x8(%ebp)
  103151:	50                   	push   %eax
  103152:	e8 17 09 00 00       	call   103a6e <memcpy>
  103157:	83 c4 10             	add    $0x10,%esp
	case 20: /* getpmhandle */
  10315a:	a1 50 85 12 00       	mov    0x128550,%eax
  10315f:	8b 40 04             	mov    0x4(%eax),%eax
	{
	    struct res_handle* handle = 0;
  103162:	c9                   	leave  
  103163:	c3                   	ret    

00103164 <schedule_to_task>:

	    switch(cpu->ebx) {
  103164:	55                   	push   %ebp
  103165:	89 e5                	mov    %esp,%ebp
  103167:	83 ec 08             	sub    $0x8,%esp
	    case PMID_STDOUT:
  10316a:	8b 45 08             	mov    0x8(%ebp),%eax
  10316d:	a3 50 85 12 00       	mov    %eax,0x128550
	        handle = get_current_task()->stdout;
	        break;
  103172:	8b 45 08             	mov    0x8(%ebp),%eax
  103175:	8b 40 14             	mov    0x14(%eax),%eax
  103178:	83 ec 0c             	sub    $0xc,%esp
  10317b:	50                   	push   %eax
  10317c:	e8 33 22 00 00       	call   1053b4 <vmm_activate_pagedir>
  103181:	83 c4 10             	add    $0x10,%esp
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  103184:	8b 45 08             	mov    0x8(%ebp),%eax
  103187:	8b 40 18             	mov    0x18(%eax),%eax
  10318a:	85 c0                	test   %eax,%eax
  10318c:	75 08                	jne    103196 <schedule_to_task+0x32>
            break;
  10318e:	8b 45 08             	mov    0x8(%ebp),%eax
  103191:	8b 40 04             	mov    0x4(%eax),%eax
  103194:	eb 24                	jmp    1031ba <schedule_to_task+0x56>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
            break;
        default:
  103196:	8b 45 08             	mov    0x8(%ebp),%eax
  103199:	8b 40 18             	mov    0x18(%eax),%eax
  10319c:	8a 40 14             	mov    0x14(%eax),%al
  10319f:	84 c0                	test   %al,%al
  1031a1:	75 0e                	jne    1031b1 <schedule_to_task+0x4d>
            handle = get_current_task()->stdout;
  1031a3:	83 ec 0c             	sub    $0xc,%esp
  1031a6:	ff 75 08             	pushl  0x8(%ebp)
  1031a9:	e8 96 00 00 00       	call   103244 <init_rpc_call>
  1031ae:	83 c4 10             	add    $0x10,%esp
            break;
	    }
  1031b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1031b4:	8b 40 18             	mov    0x18(%eax),%eax
  1031b7:	8b 40 18             	mov    0x18(%eax),%eax

	    cpu->eax = (uint32_t) handle;
  1031ba:	c9                   	leave  
  1031bb:	c3                   	ret    

001031bc <schedule>:
	}
	    break;
  1031bc:	55                   	push   %ebp
  1031bd:	89 e5                	mov    %esp,%ebp
  1031bf:	83 ec 18             	sub    $0x18,%esp

  1031c2:	a1 4c 85 12 00       	mov    0x12854c,%eax
  1031c7:	85 c0                	test   %eax,%eax
  1031c9:	74 71                	je     10323c <schedule+0x80>
  1031cb:	a1 48 85 12 00       	mov    0x128548,%eax
  1031d0:	85 c0                	test   %eax,%eax
  1031d2:	74 68                	je     10323c <schedule+0x80>
	case 21: /* fopenpmhandle */
  1031d4:	a1 50 85 12 00       	mov    0x128550,%eax
  1031d9:	85 c0                	test   %eax,%eax
  1031db:	75 28                	jne    103205 <schedule+0x49>
	{
  1031dd:	a1 4c 85 12 00       	mov    0x12854c,%eax
  1031e2:	a3 50 85 12 00       	mov    %eax,0x128550
	    vfs_reset_error();
  1031e7:	a1 50 85 12 00       	mov    0x128550,%eax
  1031ec:	8b 40 14             	mov    0x14(%eax),%eax
  1031ef:	83 ec 0c             	sub    $0xc,%esp
  1031f2:	50                   	push   %eax
  1031f3:	e8 bc 21 00 00       	call   1053b4 <vmm_activate_pagedir>
  1031f8:	83 c4 10             	add    $0x10,%esp
	    char* path = strclone((char*)cpu->ecx);
  1031fb:	a1 50 85 12 00       	mov    0x128550,%eax
  103200:	8b 40 04             	mov    0x4(%eax),%eax
  103203:	eb 3a                	jmp    10323f <schedule+0x83>

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  103205:	a1 50 85 12 00       	mov    0x128550,%eax
  10320a:	8b 40 08             	mov    0x8(%eax),%eax
  10320d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  103210:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103214:	75 08                	jne    10321e <schedule+0x62>
	    if(cpu->ebx == PMID_STDIN) {
  103216:	a1 4c 85 12 00       	mov    0x12854c,%eax
  10321b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	        fm = FM_READ;
	    }
  10321e:	83 ec 0c             	sub    $0xc,%esp
  103221:	ff 75 08             	pushl  0x8(%ebp)
  103224:	e8 ce fe ff ff       	call   1030f7 <save_cpu_state>
  103229:	83 c4 10             	add    $0x10,%esp

	    open = vfs_open(path, fm);
  10322c:	83 ec 0c             	sub    $0xc,%esp
  10322f:	ff 75 f4             	pushl  -0xc(%ebp)
  103232:	e8 2d ff ff ff       	call   103164 <schedule_to_task>
  103237:	83 c4 10             	add    $0x10,%esp
  10323a:	eb 03                	jmp    10323f <schedule+0x83>

	    free(path);
  10323c:	8b 45 08             	mov    0x8(%ebp),%eax

  10323f:	c9                   	leave  
  103240:	c3                   	ret    
  103241:	00 00                	add    %al,(%eax)
	...

00103244 <init_rpc_call>:
uint16_t* vga_buffer = (void*) 0xB8000;
uint32_t  vga_writers = 0;

struct kfs_driver vga_driver = {
    .rread     = ramfs_vga_read,
    .rwrite    = ramfs_vga_write,
  103244:	55                   	push   %ebp
  103245:	89 e5                	mov    %esp,%ebp
  103247:	57                   	push   %edi
  103248:	56                   	push   %esi
  103249:	53                   	push   %ebx
  10324a:	83 ec 5c             	sub    $0x5c,%esp
    .open      = ramfs_vga_open,
  10324d:	8b 45 08             	mov    0x8(%ebp),%eax
  103250:	8b 40 18             	mov    0x18(%eax),%eax
  103253:	89 45 e0             	mov    %eax,-0x20(%ebp)
    .create    = ramfs_vga_create,
    .close     = ramfs_vga_close,
  103256:	83 ec 08             	sub    $0x8,%esp
  103259:	6a 38                	push   $0x38
  10325b:	6a 01                	push   $0x1
  10325d:	e8 ba 06 00 00       	call   10391c <calloc>
  103262:	83 c4 10             	add    $0x10,%esp
  103265:	89 c2                	mov    %eax,%edx
  103267:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10326a:	89 50 18             	mov    %edx,0x18(%eax)
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
}
  10326d:	8b 45 08             	mov    0x8(%ebp),%eax
  103270:	8b 70 1c             	mov    0x1c(%eax),%esi
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
  103273:	8b 45 08             	mov    0x8(%ebp),%eax
  103276:	8b 40 04             	mov    0x4(%eax),%eax
}

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

  103279:	8b 40 30             	mov    0x30(%eax),%eax
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
    return &vga_driver;
  10327c:	83 e8 10             	sub    $0x10,%eax
  10327f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
}

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

  103282:	8d 5d a8             	lea    -0x58(%ebp),%ebx
  103285:	b8 00 00 00 00       	mov    $0x0,%eax
  10328a:	ba 0e 00 00 00       	mov    $0xe,%edx
  10328f:	89 df                	mov    %ebx,%edi
  103291:	89 d1                	mov    %edx,%ecx
  103293:	f3 ab                	rep stos %eax,%es:(%edi)
  103295:	89 75 cc             	mov    %esi,-0x34(%ebp)
  103298:	c7 45 d0 1b 00 00 00 	movl   $0x1b,-0x30(%ebp)
  10329f:	c7 45 d4 00 02 00 00 	movl   $0x200,-0x2c(%ebp)
  1032a6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1032a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1032ac:	c7 45 dc 23 00 00 00 	movl   $0x23,-0x24(%ebp)
uint32_t ramfs_vga_available(struct res_handle* handle) {
    return sizeof(struct vga_command);
  1032b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1032b6:	8b 40 18             	mov    0x18(%eax),%eax
  1032b9:	83 ec 04             	sub    $0x4,%esp
  1032bc:	6a 38                	push   $0x38
  1032be:	8d 55 a8             	lea    -0x58(%ebp),%edx
  1032c1:	52                   	push   %edx
  1032c2:	50                   	push   %eax
  1032c3:	e8 a6 07 00 00       	call   103a6e <memcpy>
  1032c8:	83 c4 10             	add    $0x10,%esp
}

  1032cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1032ce:	8b 40 18             	mov    0x18(%eax),%eax
  1032d1:	8b 40 30             	mov    0x30(%eax),%eax
  1032d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
  1032d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032da:	8d 50 04             	lea    0x4(%eax),%edx
  1032dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1032e0:	8b 40 04             	mov    0x4(%eax),%eax
  1032e3:	89 02                	mov    %eax,(%edx)
}
  1032e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032e8:	8d 50 08             	lea    0x8(%eax),%edx
  1032eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1032ee:	8b 40 08             	mov    0x8(%eax),%eax
  1032f1:	89 02                	mov    %eax,(%edx)

  1032f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1032f6:	8d 50 0c             	lea    0xc(%eax),%edx
  1032f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1032fc:	8b 40 10             	mov    0x10(%eax),%eax
  1032ff:	89 02                	mov    %eax,(%edx)
uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  103301:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103304:	c6 40 14 01          	movb   $0x1,0x14(%eax)
}
  103308:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10330b:	83 c4 00             	add    $0x0,%esp
  10330e:	5b                   	pop    %ebx
  10330f:	5e                   	pop    %esi
  103310:	5f                   	pop    %edi
  103311:	5d                   	pop    %ebp
  103312:	c3                   	ret    

00103313 <create_rpc_call>:

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  103313:	55                   	push   %ebp
  103314:	89 e5                	mov    %esp,%ebp
  103316:	83 ec 18             	sub    $0x18,%esp
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  103319:	83 ec 08             	sub    $0x8,%esp
  10331c:	6a 20                	push   $0x20
  10331e:	6a 01                	push   $0x1
  103320:	e8 f7 05 00 00       	call   10391c <calloc>
  103325:	83 c4 10             	add    $0x10,%esp
  103328:	89 45 ec             	mov    %eax,-0x14(%ebp)

  10332b:	83 ec 0c             	sub    $0xc,%esp
  10332e:	ff 75 08             	pushl  0x8(%ebp)
  103331:	e8 7d f9 ff ff       	call   102cb3 <get_task_by_pid>
  103336:	83 c4 10             	add    $0x10,%esp
  103339:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct vga_command* vgac = src;

  10333c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103340:	75 34                	jne    103376 <create_rpc_call+0x63>
    if(vgac->command == CMD_SET) {
  103342:	83 ec 0c             	sub    $0xc,%esp
  103345:	6a 0a                	push   $0xa
  103347:	e8 0b d2 ff ff       	call   100557 <setclr>
  10334c:	83 c4 10             	add    $0x10,%esp
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  10334f:	83 ec 0c             	sub    $0xc,%esp
  103352:	68 0c 78 10 00       	push   $0x10780c
  103357:	e8 11 d2 ff ff       	call   10056d <kprintf>
  10335c:	83 c4 10             	add    $0x10,%esp
    }
  10335f:	83 ec 0c             	sub    $0xc,%esp
  103362:	6a 07                	push   $0x7
  103364:	e8 ee d1 ff ff       	call   100557 <setclr>
  103369:	83 c4 10             	add    $0x10,%esp

  10336c:	b8 02 00 00 00       	mov    $0x2,%eax
  103371:	e9 06 01 00 00       	jmp    10347c <create_rpc_call+0x169>
    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
            vga_buffer[i] = 0;
  103376:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103379:	8b 40 1c             	mov    0x1c(%eax),%eax
  10337c:	85 c0                	test   %eax,%eax
  10337e:	75 34                	jne    1033b4 <create_rpc_call+0xa1>
        }
  103380:	83 ec 0c             	sub    $0xc,%esp
  103383:	6a 0a                	push   $0xa
  103385:	e8 cd d1 ff ff       	call   100557 <setclr>
  10338a:	83 c4 10             	add    $0x10,%esp
    }
  10338d:	83 ec 0c             	sub    $0xc,%esp
  103390:	68 38 78 10 00       	push   $0x107838
  103395:	e8 d3 d1 ff ff       	call   10056d <kprintf>
  10339a:	83 c4 10             	add    $0x10,%esp

  10339d:	83 ec 0c             	sub    $0xc,%esp
  1033a0:	6a 07                	push   $0x7
  1033a2:	e8 b0 d1 ff ff       	call   100557 <setclr>
  1033a7:	83 c4 10             	add    $0x10,%esp
    if(vgac->command == CMD_SCROLL) {
  1033aa:	b8 03 00 00 00       	mov    $0x3,%eax
  1033af:	e9 c8 00 00 00       	jmp    10347c <create_rpc_call+0x169>
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
  1033b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033b7:	8b 55 0c             	mov    0xc(%ebp),%edx
  1033ba:	89 50 04             	mov    %edx,0x4(%eax)
        }
  1033bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033c0:	8b 55 10             	mov    0x10(%ebp),%edx
  1033c3:	89 50 08             	mov    %edx,0x8(%eax)

  1033c6:	e8 de f8 ff ff       	call   102ca9 <get_current_task>
  1033cb:	85 c0                	test   %eax,%eax
  1033cd:	74 09                	je     1033d8 <create_rpc_call+0xc5>
  1033cf:	e8 d5 f8 ff ff       	call   102ca9 <get_current_task>
  1033d4:	8b 00                	mov    (%eax),%eax
  1033d6:	eb 05                	jmp    1033dd <create_rpc_call+0xca>
  1033d8:	b8 00 00 00 00       	mov    $0x0,%eax
  1033dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1033e0:	89 02                	mov    %eax,(%edx)
        for (; i < 25 * 80; i++) {
            vga_buffer[i] = 0;
  1033e2:	83 ec 0c             	sub    $0xc,%esp
  1033e5:	ff 75 14             	pushl  0x14(%ebp)
  1033e8:	e8 b9 03 00 00       	call   1037a6 <malloc>
  1033ed:	83 c4 10             	add    $0x10,%esp
  1033f0:	89 c2                	mov    %eax,%edx
  1033f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033f5:	89 50 0c             	mov    %edx,0xc(%eax)
        }
  1033f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033fb:	8b 40 0c             	mov    0xc(%eax),%eax
  1033fe:	83 ec 04             	sub    $0x4,%esp
  103401:	ff 75 14             	pushl  0x14(%ebp)
  103404:	ff 75 18             	pushl  0x18(%ebp)
  103407:	50                   	push   %eax
  103408:	e8 61 06 00 00       	call   103a6e <memcpy>
  10340d:	83 c4 10             	add    $0x10,%esp
    }
  103410:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103413:	8b 55 14             	mov    0x14(%ebp),%edx
  103416:	89 50 10             	mov    %edx,0x10(%eax)

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103419:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10341c:	8b 40 18             	mov    0x18(%eax),%eax
  10341f:	85 c0                	test   %eax,%eax
  103421:	75 10                	jne    103433 <create_rpc_call+0x120>
}
  103423:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103426:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103429:	89 50 18             	mov    %edx,0x18(%eax)

  10342c:	b8 00 00 00 00       	mov    $0x0,%eax
  103431:	eb 49                	jmp    10347c <create_rpc_call+0x169>
struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
    if(filemode & FM_READ) return 0;

  103433:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103436:	8b 40 18             	mov    0x18(%eax),%eax
  103439:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
    if((filemode & FM_WRITE)) vga_writers++;
  10343c:	eb 33                	jmp    103471 <create_rpc_call+0x15e>

  10343e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103441:	8b 40 1c             	mov    0x1c(%eax),%eax
  103444:	85 c0                	test   %eax,%eax
  103446:	75 20                	jne    103468 <create_rpc_call+0x155>
    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103448:	83 ec 0c             	sub    $0xc,%esp
  10344b:	68 67 78 10 00       	push   $0x107867
  103450:	e8 18 d1 ff ff       	call   10056d <kprintf>
  103455:	83 c4 10             	add    $0x10,%esp

    rethandle->filemode = filemode;
  103458:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10345b:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10345e:	89 50 1c             	mov    %edx,0x1c(%eax)
    rethandle->position = 0;
  103461:	b8 00 00 00 00       	mov    $0x0,%eax
  103466:	eb 14                	jmp    10347c <create_rpc_call+0x169>
    rethandle->res_type = RES_KERNDRV;
    rethandle->res_ptr  = kf;
  103468:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10346b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10346e:	89 45 f4             	mov    %eax,-0xc(%ebp)
struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
    if(filemode & FM_EXEC) return 0;
    if(filemode & FM_READ) return 0;

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
    if((filemode & FM_WRITE)) vga_writers++;
  103471:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103475:	75 c7                	jne    10343e <create_rpc_call+0x12b>
    rethandle->res_type = RES_KERNDRV;
    rethandle->res_ptr  = kf;

    return rethandle;
}

  103477:	b8 01 00 00 00       	mov    $0x1,%eax
uint32_t ramfs_vga_close(struct res_handle* handle) {
  10347c:	c9                   	leave  
  10347d:	c3                   	ret    

0010347e <return_rpc_call>:
    if(handle->filemode & FM_WRITE) vga_writers--;

  10347e:	55                   	push   %ebp
  10347f:	89 e5                	mov    %esp,%ebp
  103481:	83 ec 18             	sub    $0x18,%esp
    free(handle);
  103484:	e8 20 f8 ff ff       	call   102ca9 <get_current_task>
  103489:	89 45 ec             	mov    %eax,-0x14(%ebp)

    return 0;
  10348c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10348f:	8b 40 18             	mov    0x18(%eax),%eax
  103492:	85 c0                	test   %eax,%eax
  103494:	75 68                	jne    1034fe <return_rpc_call+0x80>
}
  103496:	83 ec 0c             	sub    $0xc,%esp
  103499:	6a 04                	push   $0x4
  10349b:	e8 b7 d0 ff ff       	call   100557 <setclr>
  1034a0:	83 c4 10             	add    $0x10,%esp
  1034a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1034a6:	8b 50 24             	mov    0x24(%eax),%edx
  1034a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1034ac:	8b 00                	mov    (%eax),%eax
  1034ae:	83 ec 04             	sub    $0x4,%esp
  1034b1:	52                   	push   %edx
  1034b2:	50                   	push   %eax
  1034b3:	68 7c 78 10 00       	push   $0x10787c
  1034b8:	e8 b0 d0 ff ff       	call   10056d <kprintf>
  1034bd:	83 c4 10             	add    $0x10,%esp
  1034c0:	83 ec 0c             	sub    $0xc,%esp
  1034c3:	68 ba 78 10 00       	push   $0x1078ba
  1034c8:	e8 a0 d0 ff ff       	call   10056d <kprintf>
  1034cd:	83 c4 10             	add    $0x10,%esp
  1034d0:	83 ec 0c             	sub    $0xc,%esp
  1034d3:	ff 75 08             	pushl  0x8(%ebp)
  1034d6:	e8 56 cd ff ff       	call   100231 <show_dump>
  1034db:	83 c4 10             	add    $0x10,%esp
  1034de:	83 ec 0c             	sub    $0xc,%esp
  1034e1:	6a 07                	push   $0x7
  1034e3:	e8 6f d0 ff ff       	call   100557 <setclr>
  1034e8:	83 c4 10             	add    $0x10,%esp
  1034eb:	83 ec 0c             	sub    $0xc,%esp
  1034ee:	ff 75 08             	pushl  0x8(%ebp)
  1034f1:	e8 d5 f9 ff ff       	call   102ecb <terminate_current>
  1034f6:	83 c4 10             	add    $0x10,%esp
  1034f9:	e9 b5 00 00 00       	jmp    1035b3 <return_rpc_call+0x135>
  1034fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103501:	8b 40 18             	mov    0x18(%eax),%eax
  103504:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103507:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10350a:	8b 40 18             	mov    0x18(%eax),%eax
  10350d:	8b 50 1c             	mov    0x1c(%eax),%edx
  103510:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103513:	89 50 18             	mov    %edx,0x18(%eax)
  103516:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103519:	8b 00                	mov    (%eax),%eax
  10351b:	85 c0                	test   %eax,%eax
  10351d:	0f 84 82 00 00 00    	je     1035a5 <return_rpc_call+0x127>
  103523:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103526:	8b 00                	mov    (%eax),%eax
  103528:	83 ec 0c             	sub    $0xc,%esp
  10352b:	50                   	push   %eax
  10352c:	e8 82 f7 ff ff       	call   102cb3 <get_task_by_pid>
  103531:	83 c4 10             	add    $0x10,%esp
  103534:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103537:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10353a:	8b 40 04             	mov    0x4(%eax),%eax
  10353d:	85 c0                	test   %eax,%eax
  10353f:	75 12                	jne    103553 <return_rpc_call+0xd5>
  103541:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103544:	8b 40 08             	mov    0x8(%eax),%eax
  103547:	83 ec 0c             	sub    $0xc,%esp
  10354a:	50                   	push   %eax
  10354b:	e8 62 de ff ff       	call   1013b2 <enable_irq_rpc>
  103550:	83 c4 10             	add    $0x10,%esp
  103553:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103556:	8b 40 18             	mov    0x18(%eax),%eax
  103559:	83 ec 0c             	sub    $0xc,%esp
  10355c:	50                   	push   %eax
  10355d:	e8 8a 04 00 00       	call   1039ec <free>
  103562:	83 c4 10             	add    $0x10,%esp
  103565:	83 ec 0c             	sub    $0xc,%esp
  103568:	ff 75 f0             	pushl  -0x10(%ebp)
  10356b:	e8 7c 04 00 00       	call   1039ec <free>
  103570:	83 c4 10             	add    $0x10,%esp
  103573:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103577:	75 10                	jne    103589 <return_rpc_call+0x10b>
  103579:	83 ec 0c             	sub    $0xc,%esp
  10357c:	ff 75 ec             	pushl  -0x14(%ebp)
  10357f:	e8 e0 fb ff ff       	call   103164 <schedule_to_task>
  103584:	83 c4 10             	add    $0x10,%esp
  103587:	eb 2a                	jmp    1035b3 <return_rpc_call+0x135>
  103589:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10358c:	8b 40 04             	mov    0x4(%eax),%eax
  10358f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  103595:	83 ec 0c             	sub    $0xc,%esp
  103598:	ff 75 f4             	pushl  -0xc(%ebp)
  10359b:	e8 c4 fb ff ff       	call   103164 <schedule_to_task>
  1035a0:	83 c4 10             	add    $0x10,%esp
  1035a3:	eb 0e                	jmp    1035b3 <return_rpc_call+0x135>
  1035a5:	83 ec 0c             	sub    $0xc,%esp
  1035a8:	ff 75 ec             	pushl  -0x14(%ebp)
  1035ab:	e8 b4 fb ff ff       	call   103164 <schedule_to_task>
  1035b0:	83 c4 10             	add    $0x10,%esp
  1035b3:	c9                   	leave  
  1035b4:	c3                   	ret    
  1035b5:	00 00                	add    %al,(%eax)
	...

001035b8 <remove_from_list>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"

  1035b8:	55                   	push   %ebp
  1035b9:	89 e5                	mov    %esp,%ebp
  1035bb:	83 ec 10             	sub    $0x10,%esp
struct exec_info {
  1035be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    char* execPath;
  1035c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1035c8:	8b 00                	mov    (%eax),%eax
  1035ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* stdin;
    char* stdout;
  1035cd:	eb 38                	jmp    103607 <remove_from_list+0x4f>
    char* stderr;
  1035cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1035d2:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1035d5:	75 21                	jne    1035f8 <remove_from_list+0x40>
};
  1035d7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1035db:	75 0d                	jne    1035ea <remove_from_list+0x32>

  1035dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1035e0:	8b 50 08             	mov    0x8(%eax),%edx
  1035e3:	8b 45 08             	mov    0x8(%ebp),%eax
  1035e6:	89 10                	mov    %edx,(%eax)
struct cpu_state* syscall(struct cpu_state* cpu) {
  1035e8:	eb 23                	jmp    10360d <remove_from_list+0x55>
    cpu = save_cpu_state(cpu);

  1035ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1035ed:	8b 50 08             	mov    0x8(%eax),%edx
  1035f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1035f3:	89 50 08             	mov    %edx,0x8(%eax)
	switch (cpu->eax) {
  1035f6:	eb 15                	jmp    10360d <remove_from_list+0x55>
	case 1: /* exit */
		return terminate_current(cpu);

  1035f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1035fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    case 3: /* exec */
  1035fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103601:	8b 40 08             	mov    0x8(%eax),%eax
  103604:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include "drivers/keyboard.h"

struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
  103607:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10360b:	75 c2                	jne    1035cf <remove_from_list+0x17>
	case 1: /* exit */
		return terminate_current(cpu);

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  10360d:	c9                   	leave  
  10360e:	c3                   	ret    

0010360f <append_to_list>:

        struct exec_info* einp = (void*) cpu->edx;

  10360f:	55                   	push   %ebp
  103610:	89 e5                	mov    %esp,%ebp
        struct exec_info ein = {
  103612:	8b 45 08             	mov    0x8(%ebp),%eax
  103615:	8b 10                	mov    (%eax),%edx
  103617:	8b 45 0c             	mov    0xc(%ebp),%eax
  10361a:	89 50 08             	mov    %edx,0x8(%eax)
            .execPath = 0,
  10361d:	8b 45 08             	mov    0x8(%ebp),%eax
  103620:	8b 55 0c             	mov    0xc(%ebp),%edx
  103623:	89 10                	mov    %edx,(%eax)
            .stdin = 0,
  103625:	5d                   	pop    %ebp
  103626:	c3                   	ret    

00103627 <pop_from_list>:
            .stdout = 0,
            .stderr = 0
  103627:	55                   	push   %ebp
  103628:	89 e5                	mov    %esp,%ebp
  10362a:	83 ec 10             	sub    $0x10,%esp
        };
  10362d:	8b 45 08             	mov    0x8(%ebp),%eax
  103630:	8b 00                	mov    (%eax),%eax
  103632:	85 c0                	test   %eax,%eax
  103634:	75 07                	jne    10363d <pop_from_list+0x16>

  103636:	b8 00 00 00 00       	mov    $0x0,%eax
  10363b:	eb 19                	jmp    103656 <pop_from_list+0x2f>
        if(einp != 0) {
  10363d:	8b 45 08             	mov    0x8(%ebp),%eax
  103640:	8b 00                	mov    (%eax),%eax
  103642:	89 45 fc             	mov    %eax,-0x4(%ebp)
            ein.execPath = strclone(einp->execPath);
  103645:	ff 75 fc             	pushl  -0x4(%ebp)
  103648:	ff 75 08             	pushl  0x8(%ebp)
  10364b:	e8 68 ff ff ff       	call   1035b8 <remove_from_list>
  103650:	83 c4 08             	add    $0x8,%esp
            ein.stdin = strclone(einp->stdin);
  103653:	8b 45 fc             	mov    -0x4(%ebp),%eax
            ein.stdout = strclone(einp->stdout);
  103656:	c9                   	leave  
  103657:	c3                   	ret    

00103658 <allocate_unused_nodes>:
            ein.stderr = strclone(einp->stderr);
        }
  103658:	55                   	push   %ebp
  103659:	89 e5                	mov    %esp,%ebp
  10365b:	83 ec 18             	sub    $0x18,%esp

  10365e:	83 ec 0c             	sub    $0xc,%esp
  103661:	6a 01                	push   $0x1
  103663:	e8 69 1c 00 00       	call   1052d1 <vmm_alloc_cont>
  103668:	83 c4 10             	add    $0x10,%esp
  10366b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  10366e:	83 ec 04             	sub    $0x4,%esp
  103671:	68 00 10 00 00       	push   $0x1000
  103676:	6a 00                	push   $0x0
  103678:	ff 75 f0             	pushl  -0x10(%ebp)
  10367b:	e8 c0 03 00 00       	call   103a40 <memset>
  103680:	83 c4 10             	add    $0x10,%esp

        if(einp != 0) {
  103683:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  10368a:	eb 23                	jmp    1036af <allocate_unused_nodes+0x57>
            free(ein.execPath);
  10368c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10368f:	89 d0                	mov    %edx,%eax
  103691:	01 c0                	add    %eax,%eax
  103693:	01 d0                	add    %edx,%eax
  103695:	c1 e0 02             	shl    $0x2,%eax
  103698:	03 45 f0             	add    -0x10(%ebp),%eax
  10369b:	83 ec 08             	sub    $0x8,%esp
  10369e:	50                   	push   %eax
  10369f:	68 54 85 12 00       	push   $0x128554
  1036a4:	e8 66 ff ff ff       	call   10360f <append_to_list>
  1036a9:	83 c4 10             	add    $0x10,%esp
            ein.stderr = strclone(einp->stderr);
        }

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);

        if(einp != 0) {
  1036ac:	ff 45 f4             	incl   -0xc(%ebp)
  1036af:	81 7d f4 54 01 00 00 	cmpl   $0x154,-0xc(%ebp)
  1036b6:	76 d4                	jbe    10368c <allocate_unused_nodes+0x34>
            free(ein.execPath);
            free(ein.stdin);
            free(ein.stdout);
  1036b8:	c9                   	leave  
  1036b9:	c3                   	ret    

001036ba <pop_unused_node>:
            free(ein.stderr);
        }
  1036ba:	55                   	push   %ebp
  1036bb:	89 e5                	mov    %esp,%ebp
  1036bd:	83 ec 18             	sub    $0x18,%esp

  1036c0:	68 54 85 12 00       	push   $0x128554
  1036c5:	e8 5d ff ff ff       	call   103627 <pop_from_list>
  1036ca:	83 c4 04             	add    $0x4,%esp
  1036cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        free(path);
    }
  1036d0:	eb 18                	jmp    1036ea <pop_unused_node+0x30>
        break;
  1036d2:	e8 81 ff ff ff       	call   103658 <allocate_unused_nodes>

  1036d7:	83 ec 0c             	sub    $0xc,%esp
  1036da:	68 54 85 12 00       	push   $0x128554
  1036df:	e8 43 ff ff ff       	call   103627 <pop_from_list>
  1036e4:	83 c4 10             	add    $0x10,%esp
  1036e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
            free(ein.stdout);
            free(ein.stderr);
        }

        free(path);
    }
  1036ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1036ee:	74 e2                	je     1036d2 <pop_unused_node+0x18>
        break;

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  1036f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
  1036f3:	c9                   	leave  
  1036f4:	c3                   	ret    

001036f5 <merge_into_frees>:
        break;

  1036f5:	55                   	push   %ebp
  1036f6:	89 e5                	mov    %esp,%ebp
  1036f8:	83 ec 10             	sub    $0x10,%esp
    case 5: /* yield */
  1036fb:	ff 75 08             	pushl  0x8(%ebp)
  1036fe:	68 58 85 12 00       	push   $0x128558
  103703:	e8 b0 fe ff ff       	call   1035b8 <remove_from_list>
  103708:	83 c4 08             	add    $0x8,%esp
    {
        cpu = schedule(cpu);
    }
        break;

  10370b:	a1 5c 85 12 00       	mov    0x12855c,%eax
  103710:	89 45 fc             	mov    %eax,-0x4(%ebp)
    case 6: /* getExecPath */
    {
  103713:	eb 79                	jmp    10378e <merge_into_frees+0x99>
        char* dest = (char*)cpu->ebx;
  103715:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103718:	8b 50 04             	mov    0x4(%eax),%edx
  10371b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10371e:	8b 00                	mov    (%eax),%eax
  103720:	01 c2                	add    %eax,%edx
  103722:	8b 45 08             	mov    0x8(%ebp),%eax
  103725:	8b 40 04             	mov    0x4(%eax),%eax
  103728:	39 c2                	cmp    %eax,%edx
  10372a:	75 1e                	jne    10374a <merge_into_frees+0x55>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  10372c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10372f:	8b 50 04             	mov    0x4(%eax),%edx
  103732:	8b 45 08             	mov    0x8(%ebp),%eax
  103735:	89 50 04             	mov    %edx,0x4(%eax)
    }
  103738:	ff 75 fc             	pushl  -0x4(%ebp)
  10373b:	68 5c 85 12 00       	push   $0x12855c
  103740:	e8 73 fe ff ff       	call   1035b8 <remove_from_list>
  103745:	83 c4 08             	add    $0x8,%esp
        break;
  103748:	eb c1                	jmp    10370b <merge_into_frees+0x16>

    case 7: /* changeExecPath */
    {
  10374a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10374d:	8b 50 04             	mov    0x4(%eax),%edx
  103750:	8b 45 08             	mov    0x8(%ebp),%eax
  103753:	8b 48 04             	mov    0x4(%eax),%ecx
  103756:	8b 45 08             	mov    0x8(%ebp),%eax
  103759:	8b 00                	mov    (%eax),%eax
  10375b:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  10375e:	39 c2                	cmp    %eax,%edx
  103760:	75 23                	jne    103785 <merge_into_frees+0x90>
        vfs_reset_error();
  103762:	8b 45 08             	mov    0x8(%ebp),%eax
  103765:	8b 10                	mov    (%eax),%edx
  103767:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10376a:	8b 00                	mov    (%eax),%eax
  10376c:	01 c2                	add    %eax,%edx
  10376e:	8b 45 08             	mov    0x8(%ebp),%eax
  103771:	89 10                	mov    %edx,(%eax)
        char* path = strclone((char*) cpu->ebx);
  103773:	ff 75 fc             	pushl  -0x4(%ebp)
  103776:	68 5c 85 12 00       	push   $0x12855c
  10377b:	e8 38 fe ff ff       	call   1035b8 <remove_from_list>
  103780:	83 c4 08             	add    $0x8,%esp

  103783:	eb 86                	jmp    10370b <merge_into_frees+0x16>
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);
  103785:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103788:	8b 40 08             	mov    0x8(%eax),%eax
  10378b:	89 45 fc             	mov    %eax,-0x4(%ebp)
        cpu = schedule(cpu);
    }
        break;

    case 6: /* getExecPath */
    {
  10378e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103792:	75 81                	jne    103715 <merge_into_frees+0x20>
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);

        cpu->eax = 0;
        if(new) {
  103794:	ff 75 08             	pushl  0x8(%ebp)
  103797:	68 5c 85 12 00       	push   $0x12855c
  10379c:	e8 6e fe ff ff       	call   10360f <append_to_list>
  1037a1:	83 c4 08             	add    $0x8,%esp
            get_current_task()->execPath = new;
  1037a4:	c9                   	leave  
  1037a5:	c3                   	ret    

001037a6 <malloc>:
            cpu->eax = 1;
        }

        free(path);
    }
  1037a6:	55                   	push   %ebp
  1037a7:	89 e5                	mov    %esp,%ebp
  1037a9:	83 ec 28             	sub    $0x28,%esp
  1037ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1037b0:	75 0a                	jne    1037bc <malloc+0x16>
  1037b2:	b8 00 00 00 00       	mov    $0x0,%eax
  1037b7:	e9 5e 01 00 00       	jmp    10391a <malloc+0x174>
        break;

  1037bc:	a1 60 85 12 00       	mov    0x128560,%eax
  1037c1:	03 45 08             	add    0x8(%ebp),%eax
  1037c4:	a3 60 85 12 00       	mov    %eax,0x128560
	case 10: /* fopen */
	{
  1037c9:	a1 5c 85 12 00       	mov    0x12855c,%eax
  1037ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  1037d1:	eb 13                	jmp    1037e6 <malloc+0x40>
	    uint32_t fmode = (uint32_t) cpu->ecx;
  1037d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037d6:	8b 00                	mov    (%eax),%eax
  1037d8:	3b 45 08             	cmp    0x8(%ebp),%eax
  1037db:	73 11                	jae    1037ee <malloc+0x48>

	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
  1037dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037e0:	8b 40 08             	mov    0x8(%eax),%eax
  1037e3:	89 45 dc             	mov    %eax,-0x24(%ebp)
        break;

	case 10: /* fopen */
	{
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  1037e6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1037ea:	75 e7                	jne    1037d3 <malloc+0x2d>
  1037ec:	eb 01                	jmp    1037ef <malloc+0x49>
	    uint32_t fmode = (uint32_t) cpu->ecx;

  1037ee:	90                   	nop    
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
	    }
  1037ef:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1037f3:	0f 85 a6 00 00 00    	jne    10389f <malloc+0xf9>
	    else
  1037f9:	8b 45 08             	mov    0x8(%ebp),%eax
  1037fc:	c1 e8 0c             	shr    $0xc,%eax
  1037ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    {
	        cpu->eax = 0;
  103802:	8b 45 08             	mov    0x8(%ebp),%eax
  103805:	25 ff 0f 00 00       	and    $0xfff,%eax
  10380a:	85 c0                	test   %eax,%eax
  10380c:	74 03                	je     103811 <malloc+0x6b>
	    }
  10380e:	ff 45 e0             	incl   -0x20(%ebp)

	    free(name);
  103811:	83 ec 0c             	sub    $0xc,%esp
  103814:	ff 75 e0             	pushl  -0x20(%ebp)
  103817:	e8 b5 1a 00 00       	call   1052d1 <vmm_alloc_cont>
  10381c:	83 c4 10             	add    $0x10,%esp
  10381f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}
	    break;
  103822:	e8 93 fe ff ff       	call   1036ba <pop_unused_node>
  103827:	89 45 e8             	mov    %eax,-0x18(%ebp)

	case 11: /* fclose */
  10382a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10382d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103830:	89 50 04             	mov    %edx,0x4(%eax)
	{
  103833:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103836:	8b 55 08             	mov    0x8(%ebp),%edx
  103839:	89 10                	mov    %edx,(%eax)
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
  10383b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10383e:	c1 e0 0c             	shl    $0xc,%eax
  103841:	3b 45 08             	cmp    0x8(%ebp),%eax
  103844:	76 3e                	jbe    103884 <malloc+0xde>
	    if(!unregister_handle(handle)) {
  103846:	e8 6f fe ff ff       	call   1036ba <pop_unused_node>
  10384b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	        vfs_close(handle);

  10384e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103851:	8b 50 04             	mov    0x4(%eax),%edx
  103854:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103857:	8b 00                	mov    (%eax),%eax
  103859:	01 c2                	add    %eax,%edx
  10385b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10385e:	89 50 04             	mov    %edx,0x4(%eax)
	        cpu->eax = 0;
  103861:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103864:	c1 e0 0c             	shl    $0xc,%eax
  103867:	89 c2                	mov    %eax,%edx
  103869:	2b 55 08             	sub    0x8(%ebp),%edx
  10386c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10386f:	89 10                	mov    %edx,(%eax)
	    }
	    else
  103871:	83 ec 08             	sub    $0x8,%esp
  103874:	ff 75 ec             	pushl  -0x14(%ebp)
  103877:	68 5c 85 12 00       	push   $0x12855c
  10387c:	e8 8e fd ff ff       	call   10360f <append_to_list>
  103881:	83 c4 10             	add    $0x10,%esp
	    {
	        cpu->eax = (uint32_t) -1;
	    }
  103884:	83 ec 08             	sub    $0x8,%esp
  103887:	ff 75 e8             	pushl  -0x18(%ebp)
  10388a:	68 58 85 12 00       	push   $0x128558
  10388f:	e8 7b fd ff ff       	call   10360f <append_to_list>
  103894:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  103897:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10389a:	8b 40 04             	mov    0x4(%eax),%eax
  10389d:	eb 7b                	jmp    10391a <malloc+0x174>

	case 12: /* fwrite */
  10389f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1038a2:	8b 00                	mov    (%eax),%eax
  1038a4:	2b 45 08             	sub    0x8(%ebp),%eax
  1038a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
        vfs_reset_error();
  1038aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1038ad:	8b 55 08             	mov    0x8(%ebp),%edx
  1038b0:	89 10                	mov    %edx,(%eax)
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
  1038b2:	83 ec 08             	sub    $0x8,%esp
  1038b5:	ff 75 dc             	pushl  -0x24(%ebp)
  1038b8:	68 5c 85 12 00       	push   $0x12855c
  1038bd:	e8 f6 fc ff ff       	call   1035b8 <remove_from_list>
  1038c2:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  1038c5:	83 ec 08             	sub    $0x8,%esp
  1038c8:	ff 75 dc             	pushl  -0x24(%ebp)
  1038cb:	68 58 85 12 00       	push   $0x128558
  1038d0:	e8 3a fd ff ff       	call   10360f <append_to_list>
  1038d5:	83 c4 10             	add    $0x10,%esp
	    }
	    else
  1038d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1038dc:	74 36                	je     103914 <malloc+0x16e>
	    {
  1038de:	e8 d7 fd ff ff       	call   1036ba <pop_unused_node>
  1038e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = RW_ERR_VFS;
	    }
  1038e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1038e9:	8b 50 04             	mov    0x4(%eax),%edx
  1038ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1038ef:	8b 00                	mov    (%eax),%eax
  1038f1:	01 c2                	add    %eax,%edx
  1038f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1038f6:	89 50 04             	mov    %edx,0x4(%eax)
	}
  1038f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1038fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1038ff:	89 10                	mov    %edx,(%eax)
	    break;

  103901:	83 ec 08             	sub    $0x8,%esp
  103904:	ff 75 f4             	pushl  -0xc(%ebp)
  103907:	68 5c 85 12 00       	push   $0x12855c
  10390c:	e8 fe fc ff ff       	call   10360f <append_to_list>
  103911:	83 c4 10             	add    $0x10,%esp
	case 13: /* fread */
	{
        vfs_reset_error();
  103914:	8b 45 dc             	mov    -0x24(%ebp),%eax
  103917:	8b 40 04             	mov    0x4(%eax),%eax
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
  10391a:	c9                   	leave  
  10391b:	c3                   	ret    

0010391c <calloc>:
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
  10391c:	55                   	push   %ebp
  10391d:	89 e5                	mov    %esp,%ebp
  10391f:	83 ec 18             	sub    $0x18,%esp
  103922:	8b 45 08             	mov    0x8(%ebp),%eax
  103925:	0f af 45 0c          	imul   0xc(%ebp),%eax
  103929:	89 45 f0             	mov    %eax,-0x10(%ebp)
        {
  10392c:	83 ec 0c             	sub    $0xc,%esp
  10392f:	ff 75 f0             	pushl  -0x10(%ebp)
  103932:	e8 6f fe ff ff       	call   1037a6 <malloc>
  103937:	83 c4 10             	add    $0x10,%esp
  10393a:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = RW_ERR_VFS;
        }
  10393d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103941:	74 13                	je     103956 <calloc+0x3a>
	}
  103943:	83 ec 04             	sub    $0x4,%esp
  103946:	ff 75 f0             	pushl  -0x10(%ebp)
  103949:	6a 00                	push   $0x0
  10394b:	ff 75 f4             	pushl  -0xc(%ebp)
  10394e:	e8 ed 00 00 00       	call   103a40 <memset>
  103953:	83 c4 10             	add    $0x10,%esp
	    break;

	case 14: /* fmkfifo */
  103956:	8b 45 f4             	mov    -0xc(%ebp),%eax
	{
  103959:	c9                   	leave  
  10395a:	c3                   	ret    

0010395b <realloc>:
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  10395b:	55                   	push   %ebp
  10395c:	89 e5                	mov    %esp,%ebp
  10395e:	83 ec 18             	sub    $0x18,%esp
  103961:	a1 58 85 12 00       	mov    0x128558,%eax
  103966:	89 45 f0             	mov    %eax,-0x10(%ebp)

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  103969:	eb 74                	jmp    1039df <realloc+0x84>
        if(handle) {
  10396b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10396e:	8b 50 04             	mov    0x4(%eax),%edx
  103971:	8b 45 08             	mov    0x8(%ebp),%eax
  103974:	39 c2                	cmp    %eax,%edx
  103976:	75 5e                	jne    1039d6 <realloc+0x7b>
            register_handle(handle);
  103978:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10397c:	75 15                	jne    103993 <realloc+0x38>
            cpu->eax = (uint32_t) handle;
  10397e:	83 ec 0c             	sub    $0xc,%esp
  103981:	ff 75 08             	pushl  0x8(%ebp)
  103984:	e8 63 00 00 00       	call   1039ec <free>
  103989:	83 c4 10             	add    $0x10,%esp
        }
  10398c:	b8 00 00 00 00       	mov    $0x0,%eax
  103991:	eb 57                	jmp    1039ea <realloc+0x8f>
        else
        {
  103993:	83 ec 0c             	sub    $0xc,%esp
  103996:	ff 75 0c             	pushl  0xc(%ebp)
  103999:	e8 08 fe ff ff       	call   1037a6 <malloc>
  10399e:	83 c4 10             	add    $0x10,%esp
  1039a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = 0;
  1039a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039a7:	8b 10                	mov    (%eax),%edx
  1039a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039ac:	8b 40 04             	mov    0x4(%eax),%eax
  1039af:	83 ec 04             	sub    $0x4,%esp
  1039b2:	52                   	push   %edx
  1039b3:	50                   	push   %eax
  1039b4:	ff 75 f4             	pushl  -0xc(%ebp)
  1039b7:	e8 b2 00 00 00       	call   103a6e <memcpy>
  1039bc:	83 c4 10             	add    $0x10,%esp
        }
  1039bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039c2:	8b 40 04             	mov    0x4(%eax),%eax
  1039c5:	83 ec 0c             	sub    $0xc,%esp
  1039c8:	50                   	push   %eax
  1039c9:	e8 1e 00 00 00       	call   1039ec <free>
  1039ce:	83 c4 10             	add    $0x10,%esp

        free(name);
  1039d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1039d4:	eb 14                	jmp    1039ea <realloc+0x8f>
	}
	    break;

  1039d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039d9:	8b 40 08             	mov    0x8(%eax),%eax
  1039dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  1039df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1039e3:	75 86                	jne    10396b <realloc+0x10>
        free(name);
	}
	    break;

	case 15: /* getLastVFSErr */
	{
  1039e5:	b8 00 00 00 00       	mov    $0x0,%eax
	    cpu->eax = get_current_task()->vfserr;
  1039ea:	c9                   	leave  
  1039eb:	c3                   	ret    

001039ec <free>:
        vfs_reset_error();
	}
	    break;
  1039ec:	55                   	push   %ebp
  1039ed:	89 e5                	mov    %esp,%ebp
  1039ef:	83 ec 10             	sub    $0x10,%esp
  1039f2:	a1 58 85 12 00       	mov    0x128558,%eax
  1039f7:	89 45 fc             	mov    %eax,-0x4(%ebp)

	case 20: /* getpmhandle */
  1039fa:	eb 39                	jmp    103a35 <free+0x49>
	{
  1039fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039ff:	8b 50 04             	mov    0x4(%eax),%edx
  103a02:	8b 45 08             	mov    0x8(%ebp),%eax
  103a05:	39 c2                	cmp    %eax,%edx
  103a07:	75 23                	jne    103a2c <free+0x40>
	    struct res_handle* handle = 0;
  103a09:	8b 15 60 85 12 00    	mov    0x128560,%edx
  103a0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a12:	8b 00                	mov    (%eax),%eax
  103a14:	89 d1                	mov    %edx,%ecx
  103a16:	29 c1                	sub    %eax,%ecx
  103a18:	89 c8                	mov    %ecx,%eax
  103a1a:	a3 60 85 12 00       	mov    %eax,0x128560

	    switch(cpu->ebx) {
  103a1f:	ff 75 fc             	pushl  -0x4(%ebp)
  103a22:	e8 ce fc ff ff       	call   1036f5 <merge_into_frees>
  103a27:	83 c4 04             	add    $0x4,%esp
	    case PMID_STDOUT:
  103a2a:	eb 0f                	jmp    103a3b <free+0x4f>
	        handle = get_current_task()->stdout;
	        break;
  103a2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a2f:	8b 40 08             	mov    0x8(%eax),%eax
  103a32:	89 45 fc             	mov    %eax,-0x4(%ebp)
	    cpu->eax = get_current_task()->vfserr;
        vfs_reset_error();
	}
	    break;

	case 20: /* getpmhandle */
  103a35:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103a39:	75 c1                	jne    1039fc <free+0x10>
	    switch(cpu->ebx) {
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
	        break;
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  103a3b:	c9                   	leave  
  103a3c:	c3                   	ret    
  103a3d:	00 00                	add    %al,(%eax)
	...

00103a40 <memset>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  103a40:	55                   	push   %ebp
  103a41:	89 e5                	mov    %esp,%ebp
  103a43:	83 ec 10             	sub    $0x10,%esp
  103a46:	8b 45 08             	mov    0x8(%ebp),%eax
  103a49:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"
  103a4c:	eb 0d                	jmp    103a5b <memset+0x1b>

  103a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
  103a51:	88 c2                	mov    %al,%dl
  103a53:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a56:	88 10                	mov    %dl,(%eax)
  103a58:	ff 45 fc             	incl   -0x4(%ebp)
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"
  103a5b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103a5f:	0f 95 c0             	setne  %al
  103a62:	ff 4d 10             	decl   0x10(%ebp)
  103a65:	84 c0                	test   %al,%al
  103a67:	75 e5                	jne    103a4e <memset+0xe>

struct exec_info {
    char* execPath;
    char* stdin;
  103a69:	8b 45 08             	mov    0x8(%ebp),%eax
    char* stdout;
  103a6c:	c9                   	leave  
  103a6d:	c3                   	ret    

00103a6e <memcpy>:
    char* stderr;
};

  103a6e:	55                   	push   %ebp
  103a6f:	89 e5                	mov    %esp,%ebp
  103a71:	83 ec 10             	sub    $0x10,%esp
  103a74:	8b 45 08             	mov    0x8(%ebp),%eax
  103a77:	89 45 f8             	mov    %eax,-0x8(%ebp)
struct cpu_state* syscall(struct cpu_state* cpu) {
  103a7a:	8b 45 0c             	mov    0xc(%ebp),%eax
  103a7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    cpu = save_cpu_state(cpu);

  103a80:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103a84:	75 19                	jne    103a9f <memcpy+0x31>
  103a86:	b8 00 00 00 00       	mov    $0x0,%eax
  103a8b:	eb 24                	jmp    103ab1 <memcpy+0x43>
	switch (cpu->eax) {
	case 1: /* exit */
		return terminate_current(cpu);
  103a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a90:	8a 10                	mov    (%eax),%dl
  103a92:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103a95:	88 10                	mov    %dl,(%eax)
  103a97:	ff 45 f8             	incl   -0x8(%ebp)
  103a9a:	ff 45 fc             	incl   -0x4(%ebp)
  103a9d:	eb 01                	jmp    103aa0 <memcpy+0x32>

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
  103a9f:	90                   	nop    
  103aa0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103aa4:	0f 95 c0             	setne  %al
  103aa7:	ff 4d 10             	decl   0x10(%ebp)
  103aaa:	84 c0                	test   %al,%al
  103aac:	75 df                	jne    103a8d <memcpy+0x1f>
		return terminate_current(cpu);

    case 3: /* exec */
    {
  103aae:	8b 45 08             	mov    0x8(%ebp),%eax
        char* path = strclone((char*) cpu->ebx);
  103ab1:	c9                   	leave  
  103ab2:	c3                   	ret    

00103ab3 <memcmp>:

        struct exec_info* einp = (void*) cpu->edx;

  103ab3:	55                   	push   %ebp
  103ab4:	89 e5                	mov    %esp,%ebp
  103ab6:	83 ec 10             	sub    $0x10,%esp
  103ab9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103abd:	75 0a                	jne    103ac9 <memcmp+0x16>
        struct exec_info ein = {
  103abf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  103ac4:	e9 83 00 00 00       	jmp    103b4c <memcmp+0x99>
            .execPath = 0,
  103ac9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103acd:	75 07                	jne    103ad6 <memcmp+0x23>
            .stdin = 0,
  103acf:	b8 01 00 00 00       	mov    $0x1,%eax
  103ad4:	eb 76                	jmp    103b4c <memcmp+0x99>
            .stdout = 0,
  103ad6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103ada:	75 07                	jne    103ae3 <memcmp+0x30>
            .stderr = 0
  103adc:	b8 00 00 00 00       	mov    $0x0,%eax
  103ae1:	eb 69                	jmp    103b4c <memcmp+0x99>
        };

  103ae3:	8b 45 08             	mov    0x8(%ebp),%eax
  103ae6:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(einp != 0) {
  103ae9:	8b 45 0c             	mov    0xc(%ebp),%eax
  103aec:	89 45 f8             	mov    %eax,-0x8(%ebp)
            ein.execPath = strclone(einp->execPath);
            ein.stdin = strclone(einp->stdin);
  103aef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103af6:	eb 47                	jmp    103b3f <memcmp+0x8c>
            ein.stdout = strclone(einp->stdout);
  103af8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103afb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103afe:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103b01:	8a 10                	mov    (%eax),%dl
  103b03:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b06:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103b09:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103b0c:	8a 00                	mov    (%eax),%al
  103b0e:	38 c2                	cmp    %al,%dl
  103b10:	74 2a                	je     103b3c <memcmp+0x89>
            ein.stderr = strclone(einp->stderr);
  103b12:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b15:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103b18:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103b1b:	8a 00                	mov    (%eax),%al
  103b1d:	ba 00 00 00 00       	mov    $0x0,%edx
  103b22:	88 c2                	mov    %al,%dl
  103b24:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b27:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103b2a:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103b2d:	8a 00                	mov    (%eax),%al
  103b2f:	25 ff 00 00 00       	and    $0xff,%eax
  103b34:	89 d1                	mov    %edx,%ecx
  103b36:	29 c1                	sub    %eax,%ecx
  103b38:	89 c8                	mov    %ecx,%eax
  103b3a:	eb 10                	jmp    103b4c <memcmp+0x99>
            .stderr = 0
        };

        if(einp != 0) {
            ein.execPath = strclone(einp->execPath);
            ein.stdin = strclone(einp->stdin);
  103b3c:	ff 45 fc             	incl   -0x4(%ebp)
  103b3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b42:	3b 45 10             	cmp    0x10(%ebp),%eax
  103b45:	72 b1                	jb     103af8 <memcmp+0x45>
            ein.stdout = strclone(einp->stdout);
            ein.stderr = strclone(einp->stderr);
        }

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  103b47:	b8 00 00 00 00       	mov    $0x0,%eax

  103b4c:	c9                   	leave  
  103b4d:	c3                   	ret    

00103b4e <strcmp>:
        if(einp != 0) {
            free(ein.execPath);
            free(ein.stdin);
  103b4e:	55                   	push   %ebp
  103b4f:	89 e5                	mov    %esp,%ebp
  103b51:	83 ec 18             	sub    $0x18,%esp
  103b54:	83 ec 0c             	sub    $0xc,%esp
  103b57:	ff 75 08             	pushl  0x8(%ebp)
  103b5a:	e8 3e 00 00 00       	call   103b9d <strlen>
  103b5f:	83 c4 10             	add    $0x10,%esp
  103b62:	89 45 f0             	mov    %eax,-0x10(%ebp)
            free(ein.stdout);
  103b65:	83 ec 0c             	sub    $0xc,%esp
  103b68:	ff 75 0c             	pushl  0xc(%ebp)
  103b6b:	e8 2d 00 00 00       	call   103b9d <strlen>
  103b70:	83 c4 10             	add    $0x10,%esp
  103b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
            free(ein.stderr);
  103b76:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103b79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b7c:	39 d0                	cmp    %edx,%eax
  103b7e:	7e 02                	jle    103b82 <strcmp+0x34>
  103b80:	89 d0                	mov    %edx,%eax
  103b82:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }

  103b85:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103b88:	40                   	inc    %eax
  103b89:	83 ec 04             	sub    $0x4,%esp
  103b8c:	50                   	push   %eax
  103b8d:	ff 75 0c             	pushl  0xc(%ebp)
  103b90:	ff 75 08             	pushl  0x8(%ebp)
  103b93:	e8 1b ff ff ff       	call   103ab3 <memcmp>
  103b98:	83 c4 10             	add    $0x10,%esp
        free(path);
  103b9b:	c9                   	leave  
  103b9c:	c3                   	ret    

00103b9d <strlen>:
    }
        break;

  103b9d:	55                   	push   %ebp
  103b9e:	89 e5                	mov    %esp,%ebp
  103ba0:	83 ec 10             	sub    $0x10,%esp
  103ba3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103ba7:	75 07                	jne    103bb0 <strlen+0x13>
    case 4: /* getargs */
  103ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  103bae:	eb 1b                	jmp    103bcb <strlen+0x2e>
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  103bb0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103bb7:	eb 03                	jmp    103bbc <strlen+0x1f>
  103bb9:	ff 45 fc             	incl   -0x4(%ebp)
  103bbc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bbf:	03 45 08             	add    0x8(%ebp),%eax
  103bc2:	8a 00                	mov    (%eax),%al
  103bc4:	84 c0                	test   %al,%al
  103bc6:	75 f1                	jne    103bb9 <strlen+0x1c>
    }
        break;
  103bc8:	8b 45 fc             	mov    -0x4(%ebp),%eax

  103bcb:	c9                   	leave  
  103bcc:	c3                   	ret    

00103bcd <strcpy>:
    case 5: /* yield */
    {
        cpu = schedule(cpu);
  103bcd:	55                   	push   %ebp
  103bce:	89 e5                	mov    %esp,%ebp
  103bd0:	ff 75 0c             	pushl  0xc(%ebp)
  103bd3:	e8 c5 ff ff ff       	call   103b9d <strlen>
  103bd8:	83 c4 04             	add    $0x4,%esp
  103bdb:	40                   	inc    %eax
  103bdc:	50                   	push   %eax
  103bdd:	ff 75 0c             	pushl  0xc(%ebp)
  103be0:	ff 75 08             	pushl  0x8(%ebp)
  103be3:	e8 86 fe ff ff       	call   103a6e <memcpy>
  103be8:	83 c4 0c             	add    $0xc,%esp
    }
  103beb:	8b 45 08             	mov    0x8(%ebp),%eax
        break;
  103bee:	c9                   	leave  
  103bef:	c3                   	ret    

00103bf0 <strclone>:

    case 6: /* getExecPath */
  103bf0:	55                   	push   %ebp
  103bf1:	89 e5                	mov    %esp,%ebp
  103bf3:	83 ec 18             	sub    $0x18,%esp
    {
  103bf6:	ff 75 08             	pushl  0x8(%ebp)
  103bf9:	e8 9f ff ff ff       	call   103b9d <strlen>
  103bfe:	83 c4 04             	add    $0x4,%esp
  103c01:	40                   	inc    %eax
  103c02:	83 ec 0c             	sub    $0xc,%esp
  103c05:	50                   	push   %eax
  103c06:	e8 9b fb ff ff       	call   1037a6 <malloc>
  103c0b:	83 c4 10             	add    $0x10,%esp
  103c0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        char* dest = (char*)cpu->ebx;
  103c11:	83 ec 08             	sub    $0x8,%esp
  103c14:	ff 75 08             	pushl  0x8(%ebp)
  103c17:	ff 75 f4             	pushl  -0xc(%ebp)
  103c1a:	e8 ae ff ff ff       	call   103bcd <strcpy>
  103c1f:	83 c4 10             	add    $0x10,%esp
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  103c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
        break;
  103c25:	c9                   	leave  
  103c26:	c3                   	ret    

00103c27 <strtok>:

    case 7: /* changeExecPath */
    {
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);
  103c27:	55                   	push   %ebp
  103c28:	89 e5                	mov    %esp,%ebp
  103c2a:	83 ec 08             	sub    $0x8,%esp

  103c2d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103c31:	74 43                	je     103c76 <strtok+0x4f>
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  103c33:	a1 68 85 12 00       	mov    0x128568,%eax
  103c38:	85 c0                	test   %eax,%eax
  103c3a:	74 11                	je     103c4d <strtok+0x26>

  103c3c:	a1 68 85 12 00       	mov    0x128568,%eax
  103c41:	83 ec 0c             	sub    $0xc,%esp
  103c44:	50                   	push   %eax
  103c45:	e8 a2 fd ff ff       	call   1039ec <free>
  103c4a:	83 c4 10             	add    $0x10,%esp
        char* new = vfs_resolve_path(path);

  103c4d:	83 ec 0c             	sub    $0xc,%esp
  103c50:	ff 75 08             	pushl  0x8(%ebp)
  103c53:	e8 98 ff ff ff       	call   103bf0 <strclone>
  103c58:	83 c4 10             	add    $0x10,%esp
  103c5b:	a3 68 85 12 00       	mov    %eax,0x128568
        cpu->eax = 0;
  103c60:	a1 68 85 12 00       	mov    0x128568,%eax
  103c65:	83 ec 08             	sub    $0x8,%esp
  103c68:	ff 75 0c             	pushl  0xc(%ebp)
  103c6b:	50                   	push   %eax
  103c6c:	e8 17 00 00 00       	call   103c88 <strtoknc>
  103c71:	83 c4 10             	add    $0x10,%esp
  103c74:	eb 10                	jmp    103c86 <strtok+0x5f>
        if(new) {
            get_current_task()->execPath = new;
  103c76:	83 ec 08             	sub    $0x8,%esp
  103c79:	ff 75 0c             	pushl  0xc(%ebp)
  103c7c:	6a 00                	push   $0x0
  103c7e:	e8 05 00 00 00       	call   103c88 <strtoknc>
  103c83:	83 c4 10             	add    $0x10,%esp
            cpu->eax = 1;
  103c86:	c9                   	leave  
  103c87:	c3                   	ret    

00103c88 <strtoknc>:
        }

  103c88:	55                   	push   %ebp
  103c89:	89 e5                	mov    %esp,%ebp
  103c8b:	83 ec 10             	sub    $0x10,%esp
        free(path);
  103c8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    }
  103c95:	ff 75 0c             	pushl  0xc(%ebp)
  103c98:	e8 00 ff ff ff       	call   103b9d <strlen>
  103c9d:	83 c4 04             	add    $0x4,%esp
  103ca0:	89 45 f8             	mov    %eax,-0x8(%ebp)
        break;

	case 10: /* fopen */
  103ca3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  103ca7:	75 0a                	jne    103cb3 <strtoknc+0x2b>
	{
  103ca9:	b8 00 00 00 00       	mov    $0x0,%eax
  103cae:	e9 e0 00 00 00       	jmp    103d93 <strtoknc+0x10b>
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;
  103cb3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103cb7:	75 13                	jne    103ccc <strtoknc+0x44>
  103cb9:	a1 64 85 12 00       	mov    0x128564,%eax
  103cbe:	85 c0                	test   %eax,%eax
  103cc0:	75 0a                	jne    103ccc <strtoknc+0x44>

  103cc2:	b8 00 00 00 00       	mov    $0x0,%eax
  103cc7:	e9 c7 00 00 00       	jmp    103d93 <strtoknc+0x10b>
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
	        register_handle(handle);
  103ccc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103cd0:	74 08                	je     103cda <strtoknc+0x52>
	        cpu->eax = (uint32_t) handle;
  103cd2:	8b 45 08             	mov    0x8(%ebp),%eax
  103cd5:	a3 64 85 12 00       	mov    %eax,0x128564
	    }
	    else
	    {
	        cpu->eax = 0;
  103cda:	a1 64 85 12 00       	mov    0x128564,%eax
  103cdf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103ce2:	eb 01                	jmp    103ce5 <strtoknc+0x5d>
	{
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

  103ce4:	90                   	nop    
	    }
	    else
	    {
	        cpu->eax = 0;
	    }

  103ce5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103cec:	eb 19                	jmp    103d07 <strtoknc+0x7f>
	    free(name);
  103cee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103cf1:	8a 10                	mov    (%eax),%dl
  103cf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103cf6:	03 45 0c             	add    0xc(%ebp),%eax
  103cf9:	8a 00                	mov    (%eax),%al
  103cfb:	38 c2                	cmp    %al,%dl
  103cfd:	75 05                	jne    103d04 <strtoknc+0x7c>
	}
  103cff:	ff 45 fc             	incl   -0x4(%ebp)
	    break;
  103d02:	eb 0b                	jmp    103d0f <strtoknc+0x87>
	    }
	    else
	    {
	        cpu->eax = 0;
	    }

  103d04:	ff 45 f4             	incl   -0xc(%ebp)
  103d07:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d0a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103d0d:	7c df                	jl     103cee <strtoknc+0x66>
	}
	    break;

	case 11: /* fclose */
	{
        vfs_reset_error();
  103d0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d12:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103d15:	75 cd                	jne    103ce4 <strtoknc+0x5c>
	    struct res_handle* handle = (void*) cpu->ebx;
  103d17:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103d1a:	a3 64 85 12 00       	mov    %eax,0x128564
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

	        cpu->eax = 0;
	    }
	    else
  103d1f:	a1 64 85 12 00       	mov    0x128564,%eax
  103d24:	8a 00                	mov    (%eax),%al
  103d26:	84 c0                	test   %al,%al
  103d28:	75 57                	jne    103d81 <strtoknc+0xf9>
	    {
  103d2a:	c7 05 64 85 12 00 00 	movl   $0x0,0x128564
  103d31:	00 00 00 
	        cpu->eax = (uint32_t) -1;
  103d34:	a1 64 85 12 00       	mov    0x128564,%eax
  103d39:	eb 58                	jmp    103d93 <strtoknc+0x10b>
	    }
	}
	    break;

	case 12: /* fwrite */
  103d3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103d42:	eb 20                	jmp    103d64 <strtoknc+0xdc>
	{
  103d44:	a1 64 85 12 00       	mov    0x128564,%eax
  103d49:	8a 10                	mov    (%eax),%dl
  103d4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d4e:	03 45 0c             	add    0xc(%ebp),%eax
  103d51:	8a 00                	mov    (%eax),%al
  103d53:	38 c2                	cmp    %al,%dl
  103d55:	75 0a                	jne    103d61 <strtoknc+0xd9>
        vfs_reset_error();
  103d57:	a1 64 85 12 00       	mov    0x128564,%eax
  103d5c:	c6 00 00             	movb   $0x0,(%eax)
	    struct res_handle* handle = (void*) cpu->ebx;
  103d5f:	eb 0b                	jmp    103d6c <strtoknc+0xe4>
	        cpu->eax = (uint32_t) -1;
	    }
	}
	    break;

	case 12: /* fwrite */
  103d61:	ff 45 f4             	incl   -0xc(%ebp)
  103d64:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d67:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103d6a:	7c d8                	jl     103d44 <strtoknc+0xbc>
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
	    else
  103d6c:	a1 64 85 12 00       	mov    0x128564,%eax
  103d71:	40                   	inc    %eax
  103d72:	a3 64 85 12 00       	mov    %eax,0x128564
	    {
  103d77:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d7a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103d7d:	7c 10                	jl     103d8f <strtoknc+0x107>
  103d7f:	eb 01                	jmp    103d82 <strtoknc+0xfa>
	    {
	        cpu->eax = (uint32_t) -1;
	    }
	}
	    break;

  103d81:	90                   	nop    
  103d82:	a1 64 85 12 00       	mov    0x128564,%eax
  103d87:	8a 00                	mov    (%eax),%al
  103d89:	84 c0                	test   %al,%al
  103d8b:	75 ae                	jne    103d3b <strtoknc+0xb3>
  103d8d:	eb 01                	jmp    103d90 <strtoknc+0x108>
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  103d8f:	90                   	nop    
	    }
	}
	    break;
  103d90:	8b 45 fc             	mov    -0x4(%ebp),%eax

  103d93:	c9                   	leave  
  103d94:	c3                   	ret    
  103d95:	00 00                	add    %al,(%eax)
	...

00103d98 <vfs_set_error>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"

  103d98:	55                   	push   %ebp
  103d99:	89 e5                	mov    %esp,%ebp
  103d9b:	83 ec 08             	sub    $0x8,%esp
struct exec_info {
  103d9e:	e8 06 ef ff ff       	call   102ca9 <get_current_task>
  103da3:	85 c0                	test   %eax,%eax
  103da5:	74 17                	je     103dbe <vfs_set_error+0x26>
    char* execPath;
  103da7:	e8 fd ee ff ff       	call   102ca9 <get_current_task>
  103dac:	8b 40 2c             	mov    0x2c(%eax),%eax
  103daf:	85 c0                	test   %eax,%eax
  103db1:	75 0b                	jne    103dbe <vfs_set_error+0x26>
    char* stdin;
  103db3:	e8 f1 ee ff ff       	call   102ca9 <get_current_task>
  103db8:	8b 55 08             	mov    0x8(%ebp),%edx
  103dbb:	89 50 2c             	mov    %edx,0x2c(%eax)
    char* stdout;
    char* stderr;
};
  103dbe:	c9                   	leave  
  103dbf:	c3                   	ret    

00103dc0 <vfs_reset_error>:

struct cpu_state* syscall(struct cpu_state* cpu) {
  103dc0:	55                   	push   %ebp
  103dc1:	89 e5                	mov    %esp,%ebp
  103dc3:	83 ec 08             	sub    $0x8,%esp
    cpu = save_cpu_state(cpu);
  103dc6:	e8 de ee ff ff       	call   102ca9 <get_current_task>
  103dcb:	85 c0                	test   %eax,%eax
  103dcd:	74 0c                	je     103ddb <vfs_reset_error+0x1b>

  103dcf:	e8 d5 ee ff ff       	call   102ca9 <get_current_task>
  103dd4:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	switch (cpu->eax) {
	case 1: /* exit */
  103ddb:	c9                   	leave  
  103ddc:	c3                   	ret    

00103ddd <vfs_construct_absolute_path_for_node>:
		return terminate_current(cpu);

    case 3: /* exec */
    {
  103ddd:	55                   	push   %ebp
  103dde:	89 e5                	mov    %esp,%ebp
  103de0:	83 ec 18             	sub    $0x18,%esp
        char* path = strclone((char*) cpu->ebx);
  103de3:	c6 05 e0 8b 18 00 00 	movb   $0x0,0x188be0

  103dea:	c7 45 f4 df 8b 18 00 	movl   $0x188bdf,-0xc(%ebp)
        struct exec_info* einp = (void*) cpu->edx;

  103df1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103df4:	c6 00 2f             	movb   $0x2f,(%eax)
        struct exec_info ein = {
            .execPath = 0,
  103df7:	eb 3b                	jmp    103e34 <vfs_construct_absolute_path_for_node+0x57>
            .stdin = 0,
  103df9:	8b 45 08             	mov    0x8(%ebp),%eax
  103dfc:	83 ec 0c             	sub    $0xc,%esp
  103dff:	50                   	push   %eax
  103e00:	e8 98 fd ff ff       	call   103b9d <strlen>
  103e05:	83 c4 10             	add    $0x10,%esp
  103e08:	f7 d8                	neg    %eax
  103e0a:	01 45 f4             	add    %eax,-0xc(%ebp)
            .stdout = 0,
  103e0d:	8b 45 08             	mov    0x8(%ebp),%eax
  103e10:	83 ec 08             	sub    $0x8,%esp
  103e13:	50                   	push   %eax
  103e14:	ff 75 f4             	pushl  -0xc(%ebp)
  103e17:	e8 b1 fd ff ff       	call   103bcd <strcpy>
  103e1c:	83 c4 10             	add    $0x10,%esp
            .stderr = 0
  103e1f:	ff 4d f4             	decl   -0xc(%ebp)
  103e22:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e25:	c6 00 2f             	movb   $0x2f,(%eax)
        };

  103e28:	8b 45 08             	mov    0x8(%ebp),%eax
  103e2b:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  103e31:	89 45 08             	mov    %eax,0x8(%ebp)
        char* path = strclone((char*) cpu->ebx);

        struct exec_info* einp = (void*) cpu->edx;

        struct exec_info ein = {
            .execPath = 0,
  103e34:	a1 6c 85 12 00       	mov    0x12856c,%eax
  103e39:	39 45 08             	cmp    %eax,0x8(%ebp)
  103e3c:	75 bb                	jne    103df9 <vfs_construct_absolute_path_for_node+0x1c>
            .stderr = 0
        };

        if(einp != 0) {
            ein.execPath = strclone(einp->execPath);
            ein.stdin = strclone(einp->stdin);
  103e3e:	83 ec 0c             	sub    $0xc,%esp
  103e41:	ff 75 f4             	pushl  -0xc(%ebp)
  103e44:	e8 a7 fd ff ff       	call   103bf0 <strclone>
  103e49:	83 c4 10             	add    $0x10,%esp
            ein.stdout = strclone(einp->stdout);
  103e4c:	c9                   	leave  
  103e4d:	c3                   	ret    

00103e4e <vfs_find_node>:
            ein.stderr = strclone(einp->stderr);
        }
  103e4e:	55                   	push   %ebp
  103e4f:	89 e5                	mov    %esp,%ebp
  103e51:	83 ec 18             	sub    $0x18,%esp

  103e54:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103e58:	75 08                	jne    103e62 <vfs_find_node+0x14>
  103e5a:	8b 45 08             	mov    0x8(%ebp),%eax
  103e5d:	e9 ab 00 00 00       	jmp    103f0d <vfs_find_node+0xbf>
        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);
  103e62:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e65:	8a 00                	mov    (%eax),%al
  103e67:	84 c0                	test   %al,%al
  103e69:	75 08                	jne    103e73 <vfs_find_node+0x25>
  103e6b:	8b 45 08             	mov    0x8(%ebp),%eax
  103e6e:	e9 9a 00 00 00       	jmp    103f0d <vfs_find_node+0xbf>

        if(einp != 0) {
  103e73:	83 ec 08             	sub    $0x8,%esp
  103e76:	68 bc 78 10 00       	push   $0x1078bc
  103e7b:	ff 75 0c             	pushl  0xc(%ebp)
  103e7e:	e8 cb fc ff ff       	call   103b4e <strcmp>
  103e83:	83 c4 10             	add    $0x10,%esp
  103e86:	85 c0                	test   %eax,%eax
  103e88:	75 05                	jne    103e8f <vfs_find_node+0x41>
  103e8a:	8b 45 08             	mov    0x8(%ebp),%eax
  103e8d:	eb 7e                	jmp    103f0d <vfs_find_node+0xbf>
            free(ein.execPath);
  103e8f:	83 ec 08             	sub    $0x8,%esp
  103e92:	68 be 78 10 00       	push   $0x1078be
  103e97:	ff 75 0c             	pushl  0xc(%ebp)
  103e9a:	e8 af fc ff ff       	call   103b4e <strcmp>
  103e9f:	83 c4 10             	add    $0x10,%esp
  103ea2:	85 c0                	test   %eax,%eax
  103ea4:	75 1a                	jne    103ec0 <vfs_find_node+0x72>
            free(ein.stdin);
  103ea6:	a1 6c 85 12 00       	mov    0x12856c,%eax
  103eab:	39 45 08             	cmp    %eax,0x8(%ebp)
  103eae:	75 05                	jne    103eb5 <vfs_find_node+0x67>
  103eb0:	8b 45 08             	mov    0x8(%ebp),%eax
  103eb3:	eb 58                	jmp    103f0d <vfs_find_node+0xbf>
            free(ein.stdout);
  103eb5:	8b 45 08             	mov    0x8(%ebp),%eax
  103eb8:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  103ebe:	eb 4d                	jmp    103f0d <vfs_find_node+0xbf>
            free(ein.stderr);
        }

  103ec0:	8b 45 08             	mov    0x8(%ebp),%eax
  103ec3:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103ec9:	85 c0                	test   %eax,%eax
  103ecb:	75 3b                	jne    103f08 <vfs_find_node+0xba>
        free(path);
  103ecd:	8b 45 08             	mov    0x8(%ebp),%eax
  103ed0:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103ed6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
        break;
  103ed9:	eb 27                	jmp    103f02 <vfs_find_node+0xb4>

  103edb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ede:	83 ec 08             	sub    $0x8,%esp
  103ee1:	50                   	push   %eax
  103ee2:	ff 75 0c             	pushl  0xc(%ebp)
  103ee5:	e8 64 fc ff ff       	call   103b4e <strcmp>
  103eea:	83 c4 10             	add    $0x10,%esp
  103eed:	85 c0                	test   %eax,%eax
  103eef:	75 05                	jne    103ef6 <vfs_find_node+0xa8>
    case 4: /* getargs */
  103ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ef4:	eb 17                	jmp    103f0d <vfs_find_node+0xbf>
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
  103ef6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ef9:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  103eff:	89 45 f4             	mov    %eax,-0xc(%ebp)
            free(ein.stderr);
        }

        free(path);
    }
        break;
  103f02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103f06:	75 d3                	jne    103edb <vfs_find_node+0x8d>
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

    case 5: /* yield */
    {
  103f08:	b8 00 00 00 00       	mov    $0x0,%eax
        cpu = schedule(cpu);
  103f0d:	c9                   	leave  
  103f0e:	c3                   	ret    

00103f0f <vfs_insert_node>:
    }
        break;
  103f0f:	55                   	push   %ebp
  103f10:	89 e5                	mov    %esp,%ebp

  103f12:	8b 45 08             	mov    0x8(%ebp),%eax
  103f15:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103f1b:	85 c0                	test   %eax,%eax
  103f1d:	75 0d                	jne    103f2c <vfs_insert_node+0x1d>
    case 6: /* getExecPath */
  103f1f:	8b 45 08             	mov    0x8(%ebp),%eax
  103f22:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  103f29:	00 00 00 
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  103f2c:	8b 45 08             	mov    0x8(%ebp),%eax
  103f2f:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103f35:	85 c0                	test   %eax,%eax
  103f37:	75 33                	jne    103f6c <vfs_insert_node+0x5d>
    }
  103f39:	8b 45 08             	mov    0x8(%ebp),%eax
  103f3c:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103f42:	89 c2                	mov    %eax,%edx
  103f44:	8b 45 0c             	mov    0xc(%ebp),%eax
  103f47:	89 90 08 01 00 00    	mov    %edx,0x108(%eax)
        break;
  103f4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  103f50:	8b 55 08             	mov    0x8(%ebp),%edx
  103f53:	89 90 0c 01 00 00    	mov    %edx,0x10c(%eax)

  103f59:	8b 45 08             	mov    0x8(%ebp),%eax
  103f5c:	8b 55 0c             	mov    0xc(%ebp),%edx
  103f5f:	89 90 04 01 00 00    	mov    %edx,0x104(%eax)
    case 7: /* changeExecPath */
    {
  103f65:	b8 00 00 00 00       	mov    $0x0,%eax
  103f6a:	eb 05                	jmp    103f71 <vfs_insert_node+0x62>
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);

  103f6c:	b8 01 00 00 00       	mov    $0x1,%eax
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  103f71:	5d                   	pop    %ebp
  103f72:	c3                   	ret    

00103f73 <vfs_get_relative_node>:

        char* new = vfs_resolve_path(path);

  103f73:	55                   	push   %ebp
  103f74:	89 e5                	mov    %esp,%ebp
  103f76:	83 ec 18             	sub    $0x18,%esp
        cpu->eax = 0;
        if(new) {
  103f79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            get_current_task()->execPath = new;
            cpu->eax = 1;
  103f80:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103f84:	75 17                	jne    103f9d <vfs_get_relative_node+0x2a>
        }
  103f86:	83 ec 0c             	sub    $0xc,%esp
  103f89:	6a 05                	push   $0x5
  103f8b:	e8 08 fe ff ff       	call   103d98 <vfs_set_error>
  103f90:	83 c4 10             	add    $0x10,%esp

  103f93:	b8 00 00 00 00       	mov    $0x0,%eax
  103f98:	e9 af 00 00 00       	jmp    10404c <vfs_get_relative_node+0xd9>
        free(path);
    }
        break;
  103f9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  103fa0:	8a 00                	mov    (%eax),%al
  103fa2:	84 c0                	test   %al,%al
  103fa4:	75 17                	jne    103fbd <vfs_get_relative_node+0x4a>

  103fa6:	83 ec 0c             	sub    $0xc,%esp
  103fa9:	6a 05                	push   $0x5
  103fab:	e8 e8 fd ff ff       	call   103d98 <vfs_set_error>
  103fb0:	83 c4 10             	add    $0x10,%esp
	case 10: /* fopen */
  103fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  103fb8:	e9 8f 00 00 00       	jmp    10404c <vfs_get_relative_node+0xd9>
	{
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  103fbd:	83 ec 08             	sub    $0x8,%esp
  103fc0:	68 c1 78 10 00       	push   $0x1078c1
  103fc5:	ff 75 0c             	pushl  0xc(%ebp)
  103fc8:	e8 5a fc ff ff       	call   103c27 <strtok>
  103fcd:	83 c4 10             	add    $0x10,%esp
  103fd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;

  103fd3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103fd7:	75 05                	jne    103fde <vfs_get_relative_node+0x6b>
	    struct res_handle* handle = vfs_open(name, fmode);
  103fd9:	8b 45 08             	mov    0x8(%ebp),%eax
  103fdc:	eb 6e                	jmp    10404c <vfs_get_relative_node+0xd9>
	    if(handle) {
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
  103fde:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103fe1:	8a 00                	mov    (%eax),%al
  103fe3:	84 c0                	test   %al,%al
  103fe5:	75 15                	jne    103ffc <vfs_get_relative_node+0x89>
  103fe7:	83 ec 08             	sub    $0x8,%esp
  103fea:	68 c1 78 10 00       	push   $0x1078c1
  103fef:	6a 00                	push   $0x0
  103ff1:	e8 31 fc ff ff       	call   103c27 <strtok>
  103ff6:	83 c4 10             	add    $0x10,%esp
  103ff9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    }
	    else
  103ffc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104000:	75 41                	jne    104043 <vfs_get_relative_node+0xd0>
	    {
  104002:	8b 45 08             	mov    0x8(%ebp),%eax
  104005:	eb 45                	jmp    10404c <vfs_get_relative_node+0xd9>
	        cpu->eax = 0;
	    }

	    free(name);
	}
  104007:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10400b:	75 07                	jne    104014 <vfs_get_relative_node+0xa1>
  10400d:	b8 00 00 00 00       	mov    $0x0,%eax
  104012:	eb 38                	jmp    10404c <vfs_get_relative_node+0xd9>
	    break;

  104014:	83 ec 08             	sub    $0x8,%esp
  104017:	ff 75 f0             	pushl  -0x10(%ebp)
  10401a:	ff 75 08             	pushl  0x8(%ebp)
  10401d:	e8 2c fe ff ff       	call   103e4e <vfs_find_node>
  104022:	83 c4 10             	add    $0x10,%esp
  104025:	89 45 f4             	mov    %eax,-0xc(%ebp)
	case 11: /* fclose */
  104028:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10402b:	89 45 08             	mov    %eax,0x8(%ebp)
	{
        vfs_reset_error();
  10402e:	83 ec 08             	sub    $0x8,%esp
  104031:	68 c1 78 10 00       	push   $0x1078c1
  104036:	6a 00                	push   $0x0
  104038:	e8 ea fb ff ff       	call   103c27 <strtok>
  10403d:	83 c4 10             	add    $0x10,%esp
  104040:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    }
	    else
	    {
	        cpu->eax = 0;
	    }

  104043:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104047:	75 be                	jne    104007 <vfs_get_relative_node+0x94>
	case 11: /* fclose */
	{
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);
  104049:	8b 45 f4             	mov    -0xc(%ebp),%eax

  10404c:	c9                   	leave  
  10404d:	c3                   	ret    

0010404e <vfs_get_current_task_root_node_for_path>:
	        cpu->eax = 0;
	    }
  10404e:	55                   	push   %ebp
  10404f:	89 e5                	mov    %esp,%ebp
  104051:	83 ec 08             	sub    $0x8,%esp
	    else
  104054:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104058:	74 09                	je     104063 <vfs_get_current_task_root_node_for_path+0x15>
  10405a:	8b 45 08             	mov    0x8(%ebp),%eax
  10405d:	8a 00                	mov    (%eax),%al
  10405f:	84 c0                	test   %al,%al
  104061:	75 14                	jne    104077 <vfs_get_current_task_root_node_for_path+0x29>
	    {
  104063:	83 ec 0c             	sub    $0xc,%esp
  104066:	6a 05                	push   $0x5
  104068:	e8 2b fd ff ff       	call   103d98 <vfs_set_error>
  10406d:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = (uint32_t) -1;
  104070:	b8 00 00 00 00       	mov    $0x0,%eax
  104075:	eb 4d                	jmp    1040c4 <vfs_get_current_task_root_node_for_path+0x76>
	    }
	}
	    break;
  104077:	8b 45 08             	mov    0x8(%ebp),%eax
  10407a:	8a 00                	mov    (%eax),%al
  10407c:	3c 2f                	cmp    $0x2f,%al
  10407e:	75 07                	jne    104087 <vfs_get_current_task_root_node_for_path+0x39>
  104080:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104085:	eb 3d                	jmp    1040c4 <vfs_get_current_task_root_node_for_path+0x76>

  104087:	e8 1d ec ff ff       	call   102ca9 <get_current_task>
  10408c:	85 c0                	test   %eax,%eax
  10408e:	75 07                	jne    104097 <vfs_get_current_task_root_node_for_path+0x49>
  104090:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104095:	eb 2d                	jmp    1040c4 <vfs_get_current_task_root_node_for_path+0x76>
	case 12: /* fwrite */
  104097:	e8 0d ec ff ff       	call   102ca9 <get_current_task>
  10409c:	8b 40 28             	mov    0x28(%eax),%eax
  10409f:	85 c0                	test   %eax,%eax
  1040a1:	75 07                	jne    1040aa <vfs_get_current_task_root_node_for_path+0x5c>
  1040a3:	a1 6c 85 12 00       	mov    0x12856c,%eax
  1040a8:	eb 1a                	jmp    1040c4 <vfs_get_current_task_root_node_for_path+0x76>
	{
        vfs_reset_error();
  1040aa:	e8 fa eb ff ff       	call   102ca9 <get_current_task>
  1040af:	8b 50 28             	mov    0x28(%eax),%edx
  1040b2:	a1 6c 85 12 00       	mov    0x12856c,%eax
  1040b7:	83 ec 08             	sub    $0x8,%esp
  1040ba:	52                   	push   %edx
  1040bb:	50                   	push   %eax
  1040bc:	e8 b2 fe ff ff       	call   103f73 <vfs_get_relative_node>
  1040c1:	83 c4 10             	add    $0x10,%esp
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
  1040c4:	c9                   	leave  
  1040c5:	c3                   	ret    

001040c6 <vfs_get_node>:
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
  1040c6:	55                   	push   %ebp
  1040c7:	89 e5                	mov    %esp,%ebp
  1040c9:	83 ec 08             	sub    $0x8,%esp
	    else
  1040cc:	83 ec 0c             	sub    $0xc,%esp
  1040cf:	ff 75 08             	pushl  0x8(%ebp)
  1040d2:	e8 77 ff ff ff       	call   10404e <vfs_get_current_task_root_node_for_path>
  1040d7:	83 c4 10             	add    $0x10,%esp
  1040da:	83 ec 08             	sub    $0x8,%esp
  1040dd:	ff 75 08             	pushl  0x8(%ebp)
  1040e0:	50                   	push   %eax
  1040e1:	e8 8d fe ff ff       	call   103f73 <vfs_get_relative_node>
  1040e6:	83 c4 10             	add    $0x10,%esp
	    {
  1040e9:	c9                   	leave  
  1040ea:	c3                   	ret    

001040eb <vfs_create_path>:
            cpu->eax = RW_ERR_VFS;
	    }
  1040eb:	55                   	push   %ebp
  1040ec:	89 e5                	mov    %esp,%ebp
  1040ee:	83 ec 18             	sub    $0x18,%esp
	}
	    break;
  1040f1:	83 ec 0c             	sub    $0xc,%esp
  1040f4:	ff 75 08             	pushl  0x8(%ebp)
  1040f7:	e8 52 ff ff ff       	call   10404e <vfs_get_current_task_root_node_for_path>
  1040fc:	83 c4 10             	add    $0x10,%esp
  1040ff:	89 45 ec             	mov    %eax,-0x14(%ebp)

  104102:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	case 13: /* fread */
	{
  104109:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
  104110:	83 ec 08             	sub    $0x8,%esp
  104113:	68 c1 78 10 00       	push   $0x1078c1
  104118:	ff 75 08             	pushl  0x8(%ebp)
  10411b:	e8 07 fb ff ff       	call   103c27 <strtok>
  104120:	83 c4 10             	add    $0x10,%esp
  104123:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(handle != 0) {
  104126:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104129:	8a 00                	mov    (%eax),%al
  10412b:	84 c0                	test   %al,%al
  10412d:	0f 85 c4 00 00 00    	jne    1041f7 <vfs_create_path+0x10c>
  104133:	83 ec 08             	sub    $0x8,%esp
  104136:	68 c1 78 10 00       	push   $0x1078c1
  10413b:	6a 00                	push   $0x0
  10413d:	e8 e5 fa ff ff       	call   103c27 <strtok>
  104142:	83 c4 10             	add    $0x10,%esp
  104145:	89 45 e8             	mov    %eax,-0x18(%ebp)
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
  104148:	e9 aa 00 00 00       	jmp    1041f7 <vfs_create_path+0x10c>
        else
        {
  10414d:	83 ec 08             	sub    $0x8,%esp
  104150:	ff 75 e8             	pushl  -0x18(%ebp)
  104153:	ff 75 ec             	pushl  -0x14(%ebp)
  104156:	e8 f3 fc ff ff       	call   103e4e <vfs_find_node>
  10415b:	83 c4 10             	add    $0x10,%esp
  10415e:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cpu->eax = RW_ERR_VFS;
        }
  104161:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104165:	75 75                	jne    1041dc <vfs_create_path+0xf1>
	}
  104167:	83 ec 0c             	sub    $0xc,%esp
  10416a:	68 10 01 00 00       	push   $0x110
  10416f:	e8 32 f6 ff ff       	call   1037a6 <malloc>
  104174:	83 c4 10             	add    $0x10,%esp
  104177:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    break;

  10417a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10417d:	83 ec 08             	sub    $0x8,%esp
  104180:	ff 75 e8             	pushl  -0x18(%ebp)
  104183:	50                   	push   %eax
  104184:	e8 44 fa ff ff       	call   103bcd <strcpy>
  104189:	83 c4 10             	add    $0x10,%esp
	case 14: /* fmkfifo */
  10418c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10418f:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  104196:	00 00 00 
	{
  104199:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10419c:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  1041a3:	00 00 00 
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
  1041a6:	ff 45 f4             	incl   -0xc(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size

  1041a9:	83 ec 08             	sub    $0x8,%esp
  1041ac:	ff 75 f0             	pushl  -0x10(%ebp)
  1041af:	ff 75 ec             	pushl  -0x14(%ebp)
  1041b2:	e8 58 fd ff ff       	call   103f0f <vfs_insert_node>
  1041b7:	83 c4 10             	add    $0x10,%esp
  1041ba:	85 c0                	test   %eax,%eax
  1041bc:	74 1e                	je     1041dc <vfs_create_path+0xf1>
        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  1041be:	83 ec 0c             	sub    $0xc,%esp
  1041c1:	6a 38                	push   $0x38
  1041c3:	e8 de f5 ff ff       	call   1037a6 <malloc>
  1041c8:	83 c4 10             	add    $0x10,%esp
  1041cb:	83 ec 08             	sub    $0x8,%esp
  1041ce:	68 c4 78 10 00       	push   $0x1078c4
  1041d3:	50                   	push   %eax
  1041d4:	e8 fd bf ff ff       	call   1001d6 <show_cod>
  1041d9:	83 c4 10             	add    $0x10,%esp
        if(handle) {
            register_handle(handle);
            cpu->eax = (uint32_t) handle;
        }
  1041dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041df:	89 45 ec             	mov    %eax,-0x14(%ebp)
        else
        {
  1041e2:	83 ec 08             	sub    $0x8,%esp
  1041e5:	68 c1 78 10 00       	push   $0x1078c1
  1041ea:	6a 00                	push   $0x0
  1041ec:	e8 36 fa ff ff       	call   103c27 <strtok>
  1041f1:	83 c4 10             	add    $0x10,%esp
  1041f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	{
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
  1041f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  1041fb:	0f 85 4c ff ff ff    	jne    10414d <vfs_create_path+0x62>
        }
        else
        {
            cpu->eax = 0;
        }

  104201:	8b 45 f4             	mov    -0xc(%ebp),%eax
        free(name);
  104204:	c9                   	leave  
  104205:	c3                   	ret    

00104206 <vfs_create_dir>:
	}
	    break;
  104206:	55                   	push   %ebp
  104207:	89 e5                	mov    %esp,%ebp
  104209:	83 ec 08             	sub    $0x8,%esp

  10420c:	83 ec 0c             	sub    $0xc,%esp
  10420f:	ff 75 08             	pushl  0x8(%ebp)
  104212:	e8 d4 fe ff ff       	call   1040eb <vfs_create_path>
  104217:	83 c4 10             	add    $0x10,%esp
	case 15: /* getLastVFSErr */
  10421a:	c9                   	leave  
  10421b:	c3                   	ret    

0010421c <vfs_create_kfile>:
	{
	    cpu->eax = get_current_task()->vfserr;
  10421c:	55                   	push   %ebp
  10421d:	89 e5                	mov    %esp,%ebp
  10421f:	53                   	push   %ebx
  104220:	83 ec 14             	sub    $0x14,%esp
        vfs_reset_error();
  104223:	83 ec 0c             	sub    $0xc,%esp
  104226:	ff 75 08             	pushl  0x8(%ebp)
  104229:	e8 6f f9 ff ff       	call   103b9d <strlen>
  10422e:	83 c4 10             	add    $0x10,%esp
  104231:	40                   	inc    %eax
  104232:	83 ec 0c             	sub    $0xc,%esp
  104235:	50                   	push   %eax
  104236:	e8 6b f5 ff ff       	call   1037a6 <malloc>
  10423b:	83 c4 10             	add    $0x10,%esp
  10423e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}
  104241:	83 ec 08             	sub    $0x8,%esp
  104244:	ff 75 08             	pushl  0x8(%ebp)
  104247:	ff 75 f0             	pushl  -0x10(%ebp)
  10424a:	e8 7e f9 ff ff       	call   103bcd <strcpy>
  10424f:	83 c4 10             	add    $0x10,%esp
	    break;

  104252:	83 ec 0c             	sub    $0xc,%esp
  104255:	ff 75 f0             	pushl  -0x10(%ebp)
  104258:	e8 8e fe ff ff       	call   1040eb <vfs_create_path>
  10425d:	83 c4 10             	add    $0x10,%esp
  104260:	89 45 f4             	mov    %eax,-0xc(%ebp)
	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  104263:	83 ec 0c             	sub    $0xc,%esp
  104266:	ff 75 08             	pushl  0x8(%ebp)
  104269:	e8 58 fe ff ff       	call   1040c6 <vfs_get_node>
  10426e:	83 c4 10             	add    $0x10,%esp
  104271:	a3 80 85 12 00       	mov    %eax,0x128580

	    switch(cpu->ebx) {
  104276:	a1 80 85 12 00       	mov    0x128580,%eax
  10427b:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  104282:	00 00 00 
	    case PMID_STDOUT:
  104285:	8b 1d 80 85 12 00    	mov    0x128580,%ebx
  10428b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10428e:	8b 40 14             	mov    0x14(%eax),%eax
  104291:	83 ec 0c             	sub    $0xc,%esp
  104294:	ff 75 10             	pushl  0x10(%ebp)
  104297:	ff d0                	call   *%eax
  104299:	83 c4 10             	add    $0x10,%esp
  10429c:	89 83 04 01 00 00    	mov    %eax,0x104(%ebx)
	        handle = get_current_task()->stdout;
  1042a2:	a1 80 85 12 00       	mov    0x128580,%eax
  1042a7:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1042ad:	8b 55 0c             	mov    0xc(%ebp),%edx
  1042b0:	89 50 04             	mov    %edx,0x4(%eax)
	        break;
        case PMID_STDIN:
  1042b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
            handle = get_current_task()->stdin;
  1042b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1042b9:	c9                   	leave  
  1042ba:	c3                   	ret    

001042bb <vfs_open>:
            break;
        case PMID_STDERR:
  1042bb:	55                   	push   %ebp
  1042bc:	89 e5                	mov    %esp,%ebp
  1042be:	83 ec 18             	sub    $0x18,%esp
            handle = get_current_task()->stderr;
            break;
        default:
  1042c1:	83 ec 0c             	sub    $0xc,%esp
  1042c4:	ff 75 08             	pushl  0x8(%ebp)
  1042c7:	e8 fa fd ff ff       	call   1040c6 <vfs_get_node>
  1042cc:	83 c4 10             	add    $0x10,%esp
  1042cf:	a3 7c 85 12 00       	mov    %eax,0x12857c
            handle = get_current_task()->stdout;
            break;
  1042d4:	a1 7c 85 12 00       	mov    0x12857c,%eax
  1042d9:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  1042df:	83 f8 01             	cmp    $0x1,%eax
  1042e2:	75 2d                	jne    104311 <vfs_open+0x56>
	    }
  1042e4:	a1 7c 85 12 00       	mov    0x12857c,%eax
  1042e9:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1042ef:	89 45 f0             	mov    %eax,-0x10(%ebp)

  1042f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1042f5:	8b 40 04             	mov    0x4(%eax),%eax
  1042f8:	8b 40 08             	mov    0x8(%eax),%eax
  1042fb:	83 ec 08             	sub    $0x8,%esp
  1042fe:	ff 75 0c             	pushl  0xc(%ebp)
  104301:	ff 75 f0             	pushl  -0x10(%ebp)
  104304:	ff d0                	call   *%eax
  104306:	83 c4 10             	add    $0x10,%esp
  104309:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    cpu->eax = (uint32_t) handle;
	}
  10430c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10430f:	eb 05                	jmp    104316 <vfs_open+0x5b>
	    break;

	case 21: /* fopenpmhandle */
  104311:	b8 00 00 00 00       	mov    $0x0,%eax
	{
  104316:	c9                   	leave  
  104317:	c3                   	ret    

00104318 <vfs_close>:
	    vfs_reset_error();
	    char* path = strclone((char*)cpu->ecx);
  104318:	55                   	push   %ebp
  104319:	89 e5                	mov    %esp,%ebp
  10431b:	83 ec 18             	sub    $0x18,%esp

  10431e:	8b 45 08             	mov    0x8(%ebp),%eax
  104321:	8b 00                	mov    (%eax),%eax
  104323:	83 f8 01             	cmp    $0x1,%eax
  104326:	75 1f                	jne    104347 <vfs_close+0x2f>
	    struct res_handle* open;
  104328:	8b 45 08             	mov    0x8(%ebp),%eax
  10432b:	8b 40 04             	mov    0x4(%eax),%eax
  10432e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    uint32_t fm = FM_WRITE;

  104331:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104334:	8b 40 04             	mov    0x4(%eax),%eax
  104337:	8b 40 0c             	mov    0xc(%eax),%eax
  10433a:	83 ec 0c             	sub    $0xc,%esp
  10433d:	ff 75 08             	pushl  0x8(%ebp)
  104340:	ff d0                	call   *%eax
  104342:	83 c4 10             	add    $0x10,%esp
  104345:	eb 05                	jmp    10434c <vfs_close+0x34>
	    if(cpu->ebx == PMID_STDIN) {
	        fm = FM_READ;
	    }
  104347:	b8 00 00 00 00       	mov    $0x0,%eax

  10434c:	c9                   	leave  
  10434d:	c3                   	ret    

0010434e <vfs_read>:
	    open = vfs_open(path, fm);

  10434e:	55                   	push   %ebp
  10434f:	89 e5                	mov    %esp,%ebp
  104351:	83 ec 18             	sub    $0x18,%esp
	    free(path);
  104354:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104358:	75 0a                	jne    104364 <vfs_read+0x16>
  10435a:	b8 02 00 00 00       	mov    $0x2,%eax
  10435f:	e9 83 00 00 00       	jmp    1043e7 <vfs_read+0x99>

	    if(!open) {
  104364:	8b 45 08             	mov    0x8(%ebp),%eax
  104367:	8b 40 0c             	mov    0xc(%eax),%eax
  10436a:	83 e0 01             	and    $0x1,%eax
  10436d:	85 c0                	test   %eax,%eax
  10436f:	75 07                	jne    104378 <vfs_read+0x2a>
  104371:	b8 04 00 00 00       	mov    $0x4,%eax
  104376:	eb 6f                	jmp    1043e7 <vfs_read+0x99>
	        cpu->eax = (uint32_t) -1;
	        break;
  104378:	8b 45 08             	mov    0x8(%ebp),%eax
  10437b:	8b 00                	mov    (%eax),%eax
  10437d:	83 f8 01             	cmp    $0x1,%eax
  104380:	75 60                	jne    1043e2 <vfs_read+0x94>
	    }
  104382:	8b 45 08             	mov    0x8(%ebp),%eax
  104385:	8b 40 04             	mov    0x4(%eax),%eax
  104388:	89 45 f0             	mov    %eax,-0x10(%ebp)

	    struct res_handle* oldhandle = 0;
  10438b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10438e:	8b 40 04             	mov    0x4(%eax),%eax
  104391:	8b 10                	mov    (%eax),%edx
  104393:	8b 45 10             	mov    0x10(%ebp),%eax
  104396:	0f af 45 14          	imul   0x14(%ebp),%eax
  10439a:	83 ec 04             	sub    $0x4,%esp
  10439d:	50                   	push   %eax
  10439e:	ff 75 0c             	pushl  0xc(%ebp)
  1043a1:	ff 75 08             	pushl  0x8(%ebp)
  1043a4:	ff d2                	call   *%edx
  1043a6:	83 c4 10             	add    $0x10,%esp
  1043a9:	89 45 f4             	mov    %eax,-0xc(%ebp)

        switch(cpu->ebx) {
  1043ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1043b0:	75 1c                	jne    1043ce <vfs_read+0x80>
        case PMID_STDOUT:
  1043b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1043b5:	8b 50 08             	mov    0x8(%eax),%edx
  1043b8:	8b 45 10             	mov    0x10(%ebp),%eax
  1043bb:	0f af 45 14          	imul   0x14(%ebp),%eax
  1043bf:	01 c2                	add    %eax,%edx
  1043c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1043c4:	89 50 08             	mov    %edx,0x8(%eax)
            oldhandle = get_current_task()->stdout;
  1043c7:	b8 00 00 00 00       	mov    $0x0,%eax
  1043cc:	eb 19                	jmp    1043e7 <vfs_read+0x99>
            get_current_task()->stdout = open;
            break;
        case PMID_STDIN:
  1043ce:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
  1043d2:	75 07                	jne    1043db <vfs_read+0x8d>
            oldhandle = get_current_task()->stdin;
  1043d4:	b8 01 00 00 00       	mov    $0x1,%eax
  1043d9:	eb 0c                	jmp    1043e7 <vfs_read+0x99>
            get_current_task()->stdin = open;
            break;
        case PMID_STDERR:
  1043db:	b8 03 00 00 00       	mov    $0x3,%eax
  1043e0:	eb 05                	jmp    1043e7 <vfs_read+0x99>
            oldhandle = get_current_task()->stderr;
            get_current_task()->stderr = open;
            break;
  1043e2:	b8 02 00 00 00       	mov    $0x2,%eax
        default:
  1043e7:	c9                   	leave  
  1043e8:	c3                   	ret    

001043e9 <vfs_write>:
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
  1043e9:	55                   	push   %ebp
  1043ea:	89 e5                	mov    %esp,%ebp
  1043ec:	83 ec 18             	sub    $0x18,%esp
            break;
  1043ef:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1043f3:	75 0a                	jne    1043ff <vfs_write+0x16>
  1043f5:	b8 02 00 00 00       	mov    $0x2,%eax
  1043fa:	e9 84 00 00 00       	jmp    104483 <vfs_write+0x9a>
        }

  1043ff:	8b 45 08             	mov    0x8(%ebp),%eax
  104402:	8b 40 0c             	mov    0xc(%eax),%eax
  104405:	83 e0 02             	and    $0x2,%eax
  104408:	85 c0                	test   %eax,%eax
  10440a:	75 07                	jne    104413 <vfs_write+0x2a>
  10440c:	b8 05 00 00 00       	mov    $0x5,%eax
  104411:	eb 70                	jmp    104483 <vfs_write+0x9a>
        if(oldhandle != 0) {
            vfs_close(oldhandle);
  104413:	8b 45 08             	mov    0x8(%ebp),%eax
  104416:	8b 00                	mov    (%eax),%eax
  104418:	83 f8 01             	cmp    $0x1,%eax
  10441b:	75 61                	jne    10447e <vfs_write+0x95>
        }
  10441d:	8b 45 08             	mov    0x8(%ebp),%eax
  104420:	8b 40 04             	mov    0x4(%eax),%eax
  104423:	89 45 f0             	mov    %eax,-0x10(%ebp)

        cpu->eax = 0;
  104426:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104429:	8b 40 04             	mov    0x4(%eax),%eax
  10442c:	8b 50 04             	mov    0x4(%eax),%edx
  10442f:	8b 45 10             	mov    0x10(%ebp),%eax
  104432:	0f af 45 14          	imul   0x14(%ebp),%eax
  104436:	83 ec 04             	sub    $0x4,%esp
  104439:	50                   	push   %eax
  10443a:	ff 75 0c             	pushl  0xc(%ebp)
  10443d:	ff 75 08             	pushl  0x8(%ebp)
  104440:	ff d2                	call   *%edx
  104442:	83 c4 10             	add    $0x10,%esp
  104445:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	    break;
  104448:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10444c:	75 1c                	jne    10446a <vfs_write+0x81>

  10444e:	8b 45 08             	mov    0x8(%ebp),%eax
  104451:	8b 50 08             	mov    0x8(%eax),%edx
  104454:	8b 45 10             	mov    0x10(%ebp),%eax
  104457:	0f af 45 14          	imul   0x14(%ebp),%eax
  10445b:	01 c2                	add    %eax,%edx
  10445d:	8b 45 08             	mov    0x8(%ebp),%eax
  104460:	89 50 08             	mov    %edx,0x8(%eax)
	case 30: /* return_rpc */
  104463:	b8 00 00 00 00       	mov    $0x0,%eax
  104468:	eb 19                	jmp    104483 <vfs_write+0x9a>
	{
	    cpu = return_rpc_call(cpu);
	}
  10446a:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
  10446e:	75 07                	jne    104477 <vfs_write+0x8e>
	    break;
  104470:	b8 01 00 00 00       	mov    $0x1,%eax
  104475:	eb 0c                	jmp    104483 <vfs_write+0x9a>

	case 31: /* call_rpc */
	{
  104477:	b8 03 00 00 00       	mov    $0x3,%eax
  10447c:	eb 05                	jmp    104483 <vfs_write+0x9a>
	    int PID = cpu->ebx;

	    //TODO create RPC for U2U
  10447e:	b8 02 00 00 00       	mov    $0x2,%eax
	}
  104483:	c9                   	leave  
  104484:	c3                   	ret    

00104485 <vfs_available>:
	    break;

  104485:	55                   	push   %ebp
  104486:	89 e5                	mov    %esp,%ebp
  104488:	83 ec 18             	sub    $0x18,%esp
	case 32: /* set_rpc_handler */
  10448b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10448f:	75 07                	jne    104498 <vfs_available+0x13>
  104491:	b8 00 00 00 00       	mov    $0x0,%eax
  104496:	eb 2e                	jmp    1044c6 <vfs_available+0x41>
	{
	    uint32_t handlerAddr = cpu->ebx;
  104498:	8b 45 08             	mov    0x8(%ebp),%eax
  10449b:	8b 00                	mov    (%eax),%eax
  10449d:	83 f8 01             	cmp    $0x1,%eax
  1044a0:	75 1f                	jne    1044c1 <vfs_available+0x3c>
	    if(get_current_task()->rpc_handler_addr == 0) {
  1044a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1044a5:	8b 40 04             	mov    0x4(%eax),%eax
  1044a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
  1044ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044ae:	8b 40 04             	mov    0x4(%eax),%eax
  1044b1:	8b 40 10             	mov    0x10(%eax),%eax
  1044b4:	83 ec 0c             	sub    $0xc,%esp
  1044b7:	ff 75 08             	pushl  0x8(%ebp)
  1044ba:	ff d0                	call   *%eax
  1044bc:	83 c4 10             	add    $0x10,%esp
  1044bf:	eb 05                	jmp    1044c6 <vfs_available+0x41>
	}
	    break;

  1044c1:	b8 00 00 00 00       	mov    $0x0,%eax
	case 33: /* fetch_rpc_data */
  1044c6:	c9                   	leave  
  1044c7:	c3                   	ret    

001044c8 <vfs_exists>:
	{
	    cpu->eax = 0;
  1044c8:	55                   	push   %ebp
  1044c9:	89 e5                	mov    %esp,%ebp
  1044cb:	83 ec 08             	sub    $0x8,%esp
	    void* dest = (void*) cpu->ebx;
  1044ce:	83 ec 0c             	sub    $0xc,%esp
  1044d1:	ff 75 08             	pushl  0x8(%ebp)
  1044d4:	e8 ed fb ff ff       	call   1040c6 <vfs_get_node>
  1044d9:	83 c4 10             	add    $0x10,%esp
  1044dc:	85 c0                	test   %eax,%eax
  1044de:	74 07                	je     1044e7 <vfs_exists+0x1f>
  1044e0:	b8 01 00 00 00       	mov    $0x1,%eax
  1044e5:	eb 05                	jmp    1044ec <vfs_exists+0x24>
	    if(get_current_task()->rpc != 0) {
  1044e7:	b8 00 00 00 00       	mov    $0x0,%eax
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
  1044ec:	c9                   	leave  
  1044ed:	c3                   	ret    

001044ee <vfs_seek>:
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
  1044ee:	55                   	push   %ebp
  1044ef:	89 e5                	mov    %esp,%ebp
	}
  1044f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1044f5:	75 09                	jne    104500 <vfs_seek+0x12>
	    break;
  1044f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1044fa:	8b 55 0c             	mov    0xc(%ebp),%edx
  1044fd:	89 50 08             	mov    %edx,0x8(%eax)

	case 40:
	{
  104500:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  104504:	75 11                	jne    104517 <vfs_seek+0x29>
	    cpu->eax = register_irq_rpc(cpu->ebx);
  104506:	8b 45 08             	mov    0x8(%ebp),%eax
  104509:	8b 40 08             	mov    0x8(%eax),%eax
  10450c:	89 c2                	mov    %eax,%edx
  10450e:	03 55 0c             	add    0xc(%ebp),%edx
  104511:	8b 45 08             	mov    0x8(%ebp),%eax
  104514:	89 50 08             	mov    %edx,0x8(%eax)
	}
	    break;
  104517:	5d                   	pop    %ebp
  104518:	c3                   	ret    

00104519 <vfs_exec>:

	case 201: /* kputc */
  104519:	55                   	push   %ebp
  10451a:	89 e5                	mov    %esp,%ebp
  10451c:	53                   	push   %ebx
  10451d:	83 ec 64             	sub    $0x64,%esp
		cpu->eax = kprintf("%c", cpu->ebx);
  104520:	83 ec 0c             	sub    $0xc,%esp
  104523:	ff 75 08             	pushl  0x8(%ebp)
  104526:	e8 c5 f6 ff ff       	call   103bf0 <strclone>
  10452b:	83 c4 10             	add    $0x10,%esp
  10452e:	89 45 08             	mov    %eax,0x8(%ebp)
		break;
  104531:	83 ec 0c             	sub    $0xc,%esp
  104534:	ff 75 08             	pushl  0x8(%ebp)
  104537:	e8 8c ff ff ff       	call   1044c8 <vfs_exists>
  10453c:	83 c4 10             	add    $0x10,%esp
  10453f:	85 c0                	test   %eax,%eax
  104541:	75 25                	jne    104568 <vfs_exec+0x4f>

  104543:	83 ec 0c             	sub    $0xc,%esp
  104546:	ff 75 08             	pushl  0x8(%ebp)
  104549:	e8 9e f4 ff ff       	call   1039ec <free>
  10454e:	83 c4 10             	add    $0x10,%esp
	case 202: /* kputs */
  104551:	83 ec 0c             	sub    $0xc,%esp
  104554:	6a 01                	push   $0x1
  104556:	e8 3d f8 ff ff       	call   103d98 <vfs_set_error>
  10455b:	83 c4 10             	add    $0x10,%esp
		cpu->eax = kprintf("%s", cpu->ebx);
  10455e:	b8 00 00 00 00       	mov    $0x0,%eax
  104563:	e9 86 04 00 00       	jmp    1049ee <vfs_exec+0x4d5>
		break;

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
		break;
  104568:	e8 59 08 00 00       	call   104dc6 <vmm_create_pagedir>
  10456d:	89 45 a0             	mov    %eax,-0x60(%ebp)

	case 204: /* vmm_free */
		cpu->eax = 0;
  104570:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
			vmm_free((void*) cpu->ebx);
  104577:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10457b:	74 14                	je     104591 <vfs_exec+0x78>
		}
  10457d:	eb 03                	jmp    104582 <vfs_exec+0x69>
		break;
  10457f:	ff 45 a4             	incl   -0x5c(%ebp)

	case 204: /* vmm_free */
		cpu->eax = 0;
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
			vmm_free((void*) cpu->ebx);
		}
  104582:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104585:	c1 e0 02             	shl    $0x2,%eax
  104588:	03 45 0c             	add    0xc(%ebp),%eax
  10458b:	8b 00                	mov    (%eax),%eax
  10458d:	85 c0                	test   %eax,%eax
  10458f:	75 ee                	jne    10457f <vfs_exec+0x66>
		break;

	case 205: /* pmm_print_stats */
		pmm_print_stats();
        create_rpc_call(1, RPCT_KERNEL, 1, 0, 0);
  104591:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104594:	40                   	inc    %eax
  104595:	c1 e0 02             	shl    $0x2,%eax
  104598:	83 ec 0c             	sub    $0xc,%esp
  10459b:	50                   	push   %eax
  10459c:	e8 05 f2 ff ff       	call   1037a6 <malloc>
  1045a1:	83 c4 10             	add    $0x10,%esp
  1045a4:	89 45 a8             	mov    %eax,-0x58(%ebp)
		break;

  1045a7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  1045ae:	eb 57                	jmp    104607 <vfs_exec+0xee>
	default:
  1045b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1045b3:	c1 e0 02             	shl    $0x2,%eax
  1045b6:	89 c3                	mov    %eax,%ebx
  1045b8:	03 5d a8             	add    -0x58(%ebp),%ebx
  1045bb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1045be:	c1 e0 02             	shl    $0x2,%eax
  1045c1:	03 45 0c             	add    0xc(%ebp),%eax
  1045c4:	8b 00                	mov    (%eax),%eax
  1045c6:	83 ec 0c             	sub    $0xc,%esp
  1045c9:	50                   	push   %eax
  1045ca:	e8 ce f5 ff ff       	call   103b9d <strlen>
  1045cf:	83 c4 10             	add    $0x10,%esp
  1045d2:	40                   	inc    %eax
  1045d3:	83 ec 0c             	sub    $0xc,%esp
  1045d6:	50                   	push   %eax
  1045d7:	e8 ca f1 ff ff       	call   1037a6 <malloc>
  1045dc:	83 c4 10             	add    $0x10,%esp
  1045df:	89 03                	mov    %eax,(%ebx)
		kprintf("Invalid Syscall %d...", cpu->eax);
  1045e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1045e4:	c1 e0 02             	shl    $0x2,%eax
  1045e7:	03 45 0c             	add    0xc(%ebp),%eax
  1045ea:	8b 10                	mov    (%eax),%edx
  1045ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1045ef:	c1 e0 02             	shl    $0x2,%eax
  1045f2:	03 45 a8             	add    -0x58(%ebp),%eax
  1045f5:	8b 00                	mov    (%eax),%eax
  1045f7:	83 ec 08             	sub    $0x8,%esp
  1045fa:	52                   	push   %edx
  1045fb:	50                   	push   %eax
  1045fc:	e8 cc f5 ff ff       	call   103bcd <strcpy>
  104601:	83 c4 10             	add    $0x10,%esp

	case 205: /* pmm_print_stats */
		pmm_print_stats();
        create_rpc_call(1, RPCT_KERNEL, 1, 0, 0);
		break;

  104604:	ff 45 d4             	incl   -0x2c(%ebp)
  104607:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10460a:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
  10460d:	72 a1                	jb     1045b0 <vfs_exec+0x97>
	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
		break;
	}

  10460f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104612:	c1 e0 02             	shl    $0x2,%eax
  104615:	03 45 a8             	add    -0x58(%ebp),%eax
  104618:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return cpu;
}

  10461e:	83 ec 08             	sub    $0x8,%esp
  104621:	6a 05                	push   $0x5
  104623:	ff 75 08             	pushl  0x8(%ebp)
  104626:	e8 90 fc ff ff       	call   1042bb <vfs_open>
  10462b:	83 c4 10             	add    $0x10,%esp
  10462e:	89 45 ac             	mov    %eax,-0x54(%ebp)
void kernel_main(struct multiboot_info* mb_info) {
	uint32_t kernel_init_pdir = vmm_init();
  104631:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
  104635:	75 25                	jne    10465c <vfs_exec+0x143>

  104637:	83 ec 0c             	sub    $0xc,%esp
  10463a:	6a 02                	push   $0x2
  10463c:	e8 57 f7 ff ff       	call   103d98 <vfs_set_error>
  104641:	83 c4 10             	add    $0x10,%esp
	kprintf("Setting PIT interval...\n");
  104644:	83 ec 0c             	sub    $0xc,%esp
  104647:	ff 75 08             	pushl  0x8(%ebp)
  10464a:	e8 9d f3 ff ff       	call   1039ec <free>
  10464f:	83 c4 10             	add    $0x10,%esp

  104652:	b8 00 00 00 00       	mov    $0x0,%eax
  104657:	e9 92 03 00 00       	jmp    1049ee <vfs_exec+0x4d5>
	outb(0x43, 0x36);
	outw(0x40, 1000);

  10465c:	83 ec 0c             	sub    $0xc,%esp
  10465f:	ff 75 ac             	pushl  -0x54(%ebp)
  104662:	e8 1e fe ff ff       	call   104485 <vfs_available>
  104667:	83 c4 10             	add    $0x10,%esp
  10466a:	89 45 b0             	mov    %eax,-0x50(%ebp)
    kprintf("Initializing vfs...\n");
  10466d:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  104671:	75 25                	jne    104698 <vfs_exec+0x17f>

  104673:	83 ec 0c             	sub    $0xc,%esp
  104676:	6a 03                	push   $0x3
  104678:	e8 1b f7 ff ff       	call   103d98 <vfs_set_error>
  10467d:	83 c4 10             	add    $0x10,%esp
    vfs_init_root();
  104680:	83 ec 0c             	sub    $0xc,%esp
  104683:	ff 75 08             	pushl  0x8(%ebp)
  104686:	e8 61 f3 ff ff       	call   1039ec <free>
  10468b:	83 c4 10             	add    $0x10,%esp
    ramfs_fifo_init();
  10468e:	b8 00 00 00 00       	mov    $0x0,%eax
  104693:	e9 56 03 00 00       	jmp    1049ee <vfs_exec+0x4d5>
    ramfs_block_init();

    driver_keyboard_init();
  104698:	83 ec 0c             	sub    $0xc,%esp
  10469b:	ff 75 b0             	pushl  -0x50(%ebp)
  10469e:	e8 03 f1 ff ff       	call   1037a6 <malloc>
  1046a3:	83 c4 10             	add    $0x10,%esp
  1046a6:	89 45 b4             	mov    %eax,-0x4c(%ebp)


  1046a9:	6a 01                	push   $0x1
  1046ab:	ff 75 b0             	pushl  -0x50(%ebp)
  1046ae:	ff 75 b4             	pushl  -0x4c(%ebp)
  1046b1:	ff 75 ac             	pushl  -0x54(%ebp)
  1046b4:	e8 95 fc ff ff       	call   10434e <vfs_read>
  1046b9:	83 c4 10             	add    $0x10,%esp
  1046bc:	89 45 b8             	mov    %eax,-0x48(%ebp)
    map_address_active((uint32_t) mb_info,
                       (uint32_t) mb_info, 0);
  1046bf:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  1046c3:	74 33                	je     1046f8 <vfs_exec+0x1df>
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  1046c5:	83 ec 0c             	sub    $0xc,%esp
  1046c8:	ff 75 08             	pushl  0x8(%ebp)
  1046cb:	e8 1c f3 ff ff       	call   1039ec <free>
  1046d0:	83 c4 10             	add    $0x10,%esp
                       (uint32_t) mb_info->mi_mods_addr, 0);
  1046d3:	83 ec 0c             	sub    $0xc,%esp
  1046d6:	ff 75 b4             	pushl  -0x4c(%ebp)
  1046d9:	e8 0e f3 ff ff       	call   1039ec <free>
  1046de:	83 c4 10             	add    $0x10,%esp

  1046e1:	83 ec 0c             	sub    $0xc,%esp
  1046e4:	6a 04                	push   $0x4
  1046e6:	e8 ad f6 ff ff       	call   103d98 <vfs_set_error>
  1046eb:	83 c4 10             	add    $0x10,%esp
    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  1046ee:	b8 00 00 00 00       	mov    $0x0,%eax
  1046f3:	e9 f6 02 00 00       	jmp    1049ee <vfs_exec+0x4d5>
        vmm_map_range(mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
  1046f8:	e8 bf 06 00 00       	call   104dbc <vmm_get_current_pagedir>
  1046fd:	89 45 bc             	mov    %eax,-0x44(%ebp)
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  104700:	83 ec 0c             	sub    $0xc,%esp
  104703:	ff 75 a0             	pushl  -0x60(%ebp)
  104706:	e8 a9 0c 00 00       	call   1053b4 <vmm_activate_pagedir>
  10470b:	83 c4 10             	add    $0x10,%esp
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);

  10470e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  104711:	89 45 c0             	mov    %eax,-0x40(%ebp)
        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
    } else {
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
    }
  104714:	8b 45 c0             	mov    -0x40(%ebp),%eax
  104717:	8b 00                	mov    (%eax),%eax
  104719:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  10471e:	74 33                	je     104753 <vfs_exec+0x23a>

  104720:	83 ec 0c             	sub    $0xc,%esp
  104723:	ff 75 b4             	pushl  -0x4c(%ebp)
  104726:	e8 c1 f2 ff ff       	call   1039ec <free>
  10472b:	83 c4 10             	add    $0x10,%esp
    kprintf("[kernel_res] Creating /dev/vga\n");
  10472e:	83 ec 0c             	sub    $0xc,%esp
  104731:	ff 75 08             	pushl  0x8(%ebp)
  104734:	e8 b3 f2 ff ff       	call   1039ec <free>
  104739:	83 c4 10             	add    $0x10,%esp
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  10473c:	83 ec 0c             	sub    $0xc,%esp
  10473f:	6a 03                	push   $0x3
  104741:	e8 52 f6 ff ff       	call   103d98 <vfs_set_error>
  104746:	83 c4 10             	add    $0x10,%esp

  104749:	b8 00 00 00 00       	mov    $0x0,%eax
  10474e:	e9 9b 02 00 00       	jmp    1049ee <vfs_exec+0x4d5>
    if(vfs_exists("/ibin/init")) {
        kprintf("[init] /ibin/init found. Executing...\n");

  104753:	8b 45 c0             	mov    -0x40(%ebp),%eax
  104756:	8b 40 18             	mov    0x18(%eax),%eax
  104759:	89 45 c8             	mov    %eax,-0x38(%ebp)
        vfs_exec("/ibin/init", 0, 0, 0, 0, 0);
        enableScheduling();
  10475c:	8b 55 c0             	mov    -0x40(%ebp),%edx
  10475f:	8b 45 c0             	mov    -0x40(%ebp),%eax
  104762:	8b 40 1c             	mov    0x1c(%eax),%eax
  104765:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104768:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    }

  10476b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104772:	e9 88 00 00 00       	jmp    1047ff <vfs_exec+0x2e6>
	while(1);
  104777:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10477a:	8b 40 08             	mov    0x8(%eax),%eax
  10477d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //*********************************************************************** KERNEL END
  104780:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104783:	8b 40 04             	mov    0x4(%eax),%eax
  104786:	03 45 c0             	add    -0x40(%ebp),%eax
  104789:	89 45 e0             	mov    %eax,-0x20(%ebp)
}
  10478c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10478f:	8b 00                	mov    (%eax),%eax
  104791:	83 f8 01             	cmp    $0x1,%eax
  104794:	75 61                	jne    1047f7 <vfs_exec+0x2de>
  104796:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  10479d:	eb 33                	jmp    1047d2 <vfs_exec+0x2b9>
  10479f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1047a2:	8b 55 dc             	mov    -0x24(%ebp),%edx
  1047a5:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1047a8:	83 ec 0c             	sub    $0xc,%esp
  1047ab:	50                   	push   %eax
  1047ac:	e8 48 09 00 00       	call   1050f9 <vmm_free>
  1047b1:	83 c4 10             	add    $0x10,%esp
  1047b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1047b7:	8b 55 dc             	mov    -0x24(%ebp),%edx
  1047ba:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1047bd:	83 ec 08             	sub    $0x8,%esp
  1047c0:	6a 00                	push   $0x0
  1047c2:	50                   	push   %eax
  1047c3:	e8 47 0b 00 00       	call   10530f <vmm_alloc_addr>
  1047c8:	83 c4 10             	add    $0x10,%esp
  1047cb:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  1047d2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  1047d5:	8b 40 14             	mov    0x14(%eax),%eax
  1047d8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  1047db:	77 c2                	ja     10479f <vfs_exec+0x286>
  1047dd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  1047e0:	8b 40 10             	mov    0x10(%eax),%eax
  1047e3:	83 ec 04             	sub    $0x4,%esp
  1047e6:	50                   	push   %eax
  1047e7:	ff 75 e0             	pushl  -0x20(%ebp)
  1047ea:	ff 75 dc             	pushl  -0x24(%ebp)
  1047ed:	e8 7c f2 ff ff       	call   103a6e <memcpy>
  1047f2:	83 c4 10             	add    $0x10,%esp
  1047f5:	eb 01                	jmp    1047f8 <vfs_exec+0x2df>
	while(1);
    //*********************************************************************** KERNEL END
}
  1047f7:	90                   	nop    
        kprintf("[init] /ibin/init found. Executing...\n");

        vfs_exec("/ibin/init", 0, 0, 0, 0, 0);
        enableScheduling();
    }

  1047f8:	ff 45 d8             	incl   -0x28(%ebp)
  1047fb:	83 45 c4 20          	addl   $0x20,-0x3c(%ebp)
  1047ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
  104802:	66 8b 40 2c          	mov    0x2c(%eax),%ax
  104806:	25 ff ff 00 00       	and    $0xffff,%eax
  10480b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  10480e:	0f 87 63 ff ff ff    	ja     104777 <vfs_exec+0x25e>
  104814:	83 ec 0c             	sub    $0xc,%esp
  104817:	6a 01                	push   $0x1
  104819:	e8 75 0a 00 00       	call   105293 <vmm_alloc_ucont>
  10481e:	83 c4 10             	add    $0x10,%esp
  104821:	89 45 cc             	mov    %eax,-0x34(%ebp)
  104824:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10482b:	eb 57                	jmp    104884 <vfs_exec+0x36b>
  10482d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104830:	c1 e0 02             	shl    $0x2,%eax
  104833:	89 c3                	mov    %eax,%ebx
  104835:	03 5d cc             	add    -0x34(%ebp),%ebx
  104838:	83 ec 0c             	sub    $0xc,%esp
  10483b:	6a 01                	push   $0x1
  10483d:	e8 51 0a 00 00       	call   105293 <vmm_alloc_ucont>
  104842:	83 c4 10             	add    $0x10,%esp
  104845:	89 03                	mov    %eax,(%ebx)
  104847:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10484a:	c1 e0 02             	shl    $0x2,%eax
  10484d:	03 45 a8             	add    -0x58(%ebp),%eax
  104850:	8b 10                	mov    (%eax),%edx
  104852:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104855:	c1 e0 02             	shl    $0x2,%eax
  104858:	03 45 cc             	add    -0x34(%ebp),%eax
  10485b:	8b 00                	mov    (%eax),%eax
  10485d:	83 ec 08             	sub    $0x8,%esp
  104860:	52                   	push   %edx
  104861:	50                   	push   %eax
  104862:	e8 66 f3 ff ff       	call   103bcd <strcpy>
  104867:	83 c4 10             	add    $0x10,%esp
  10486a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10486d:	c1 e0 02             	shl    $0x2,%eax
  104870:	03 45 a8             	add    -0x58(%ebp),%eax
  104873:	8b 00                	mov    (%eax),%eax
  104875:	83 ec 0c             	sub    $0xc,%esp
  104878:	50                   	push   %eax
  104879:	e8 6e f1 ff ff       	call   1039ec <free>
  10487e:	83 c4 10             	add    $0x10,%esp
  104881:	ff 45 e8             	incl   -0x18(%ebp)
  104884:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104887:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
  10488a:	72 a1                	jb     10482d <vfs_exec+0x314>
  10488c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  10488f:	c1 e0 02             	shl    $0x2,%eax
  104892:	03 45 cc             	add    -0x34(%ebp),%eax
  104895:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10489b:	83 ec 0c             	sub    $0xc,%esp
  10489e:	ff 75 a8             	pushl  -0x58(%ebp)
  1048a1:	e8 46 f1 ff ff       	call   1039ec <free>
  1048a6:	83 c4 10             	add    $0x10,%esp
  1048a9:	83 ec 08             	sub    $0x8,%esp
  1048ac:	ff 75 c8             	pushl  -0x38(%ebp)
  1048af:	ff 75 a0             	pushl  -0x60(%ebp)
  1048b2:	e8 e7 e6 ff ff       	call   102f9e <init_task>
  1048b7:	83 c4 10             	add    $0x10,%esp
  1048ba:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1048bd:	e8 e7 e3 ff ff       	call   102ca9 <get_current_task>
  1048c2:	85 c0                	test   %eax,%eax
  1048c4:	74 38                	je     1048fe <vfs_exec+0x3e5>
  1048c6:	e8 de e3 ff ff       	call   102ca9 <get_current_task>
  1048cb:	8b 50 38             	mov    0x38(%eax),%edx
  1048ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048d1:	89 50 38             	mov    %edx,0x38(%eax)
  1048d4:	e8 d0 e3 ff ff       	call   102ca9 <get_current_task>
  1048d9:	8b 50 30             	mov    0x30(%eax),%edx
  1048dc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048df:	89 50 30             	mov    %edx,0x30(%eax)
  1048e2:	e8 c2 e3 ff ff       	call   102ca9 <get_current_task>
  1048e7:	8b 50 34             	mov    0x34(%eax),%edx
  1048ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048ed:	89 50 34             	mov    %edx,0x34(%eax)
  1048f0:	e8 b4 e3 ff ff       	call   102ca9 <get_current_task>
  1048f5:	8b 50 28             	mov    0x28(%eax),%edx
  1048f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048fb:	89 50 28             	mov    %edx,0x28(%eax)
  1048fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  104902:	74 09                	je     10490d <vfs_exec+0x3f4>
  104904:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104907:	8b 55 10             	mov    0x10(%ebp),%edx
  10490a:	89 50 28             	mov    %edx,0x28(%eax)
  10490d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  104911:	74 34                	je     104947 <vfs_exec+0x42e>
  104913:	83 ec 0c             	sub    $0xc,%esp
  104916:	ff 75 14             	pushl  0x14(%ebp)
  104919:	e8 aa fb ff ff       	call   1044c8 <vfs_exists>
  10491e:	83 c4 10             	add    $0x10,%esp
  104921:	85 c0                	test   %eax,%eax
  104923:	74 22                	je     104947 <vfs_exec+0x42e>
  104925:	83 ec 08             	sub    $0x8,%esp
  104928:	6a 01                	push   $0x1
  10492a:	ff 75 14             	pushl  0x14(%ebp)
  10492d:	e8 89 f9 ff ff       	call   1042bb <vfs_open>
  104932:	83 c4 10             	add    $0x10,%esp
  104935:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104938:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  10493c:	74 09                	je     104947 <vfs_exec+0x42e>
  10493e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104941:	8b 55 ec             	mov    -0x14(%ebp),%edx
  104944:	89 50 38             	mov    %edx,0x38(%eax)
  104947:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  10494b:	74 34                	je     104981 <vfs_exec+0x468>
  10494d:	83 ec 0c             	sub    $0xc,%esp
  104950:	ff 75 18             	pushl  0x18(%ebp)
  104953:	e8 70 fb ff ff       	call   1044c8 <vfs_exists>
  104958:	83 c4 10             	add    $0x10,%esp
  10495b:	85 c0                	test   %eax,%eax
  10495d:	74 22                	je     104981 <vfs_exec+0x468>
  10495f:	83 ec 08             	sub    $0x8,%esp
  104962:	6a 01                	push   $0x1
  104964:	ff 75 18             	pushl  0x18(%ebp)
  104967:	e8 4f f9 ff ff       	call   1042bb <vfs_open>
  10496c:	83 c4 10             	add    $0x10,%esp
  10496f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104972:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104976:	74 09                	je     104981 <vfs_exec+0x468>
  104978:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10497b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10497e:	89 50 30             	mov    %edx,0x30(%eax)
  104981:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  104985:	74 34                	je     1049bb <vfs_exec+0x4a2>
  104987:	83 ec 0c             	sub    $0xc,%esp
  10498a:	ff 75 1c             	pushl  0x1c(%ebp)
  10498d:	e8 36 fb ff ff       	call   1044c8 <vfs_exists>
  104992:	83 c4 10             	add    $0x10,%esp
  104995:	85 c0                	test   %eax,%eax
  104997:	74 22                	je     1049bb <vfs_exec+0x4a2>
  104999:	83 ec 08             	sub    $0x8,%esp
  10499c:	6a 01                	push   $0x1
  10499e:	ff 75 1c             	pushl  0x1c(%ebp)
  1049a1:	e8 15 f9 ff ff       	call   1042bb <vfs_open>
  1049a6:	83 c4 10             	add    $0x10,%esp
  1049a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1049ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1049b0:	74 09                	je     1049bb <vfs_exec+0x4a2>
  1049b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1049b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1049b8:	89 50 34             	mov    %edx,0x34(%eax)
  1049bb:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1049be:	8b 55 cc             	mov    -0x34(%ebp),%edx
  1049c1:	89 50 20             	mov    %edx,0x20(%eax)
  1049c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1049c7:	8b 55 08             	mov    0x8(%ebp),%edx
  1049ca:	89 50 24             	mov    %edx,0x24(%eax)
  1049cd:	83 ec 0c             	sub    $0xc,%esp
  1049d0:	ff 75 bc             	pushl  -0x44(%ebp)
  1049d3:	e8 dc 09 00 00       	call   1053b4 <vmm_activate_pagedir>
  1049d8:	83 c4 10             	add    $0x10,%esp
  1049db:	83 ec 0c             	sub    $0xc,%esp
  1049de:	ff 75 b4             	pushl  -0x4c(%ebp)
  1049e1:	e8 06 f0 ff ff       	call   1039ec <free>
  1049e6:	83 c4 10             	add    $0x10,%esp
  1049e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1049ec:	8b 00                	mov    (%eax),%eax
  1049ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1049f1:	c9                   	leave  
  1049f2:	c3                   	ret    

001049f3 <vfs_resolve_path>:
  1049f3:	55                   	push   %ebp
  1049f4:	89 e5                	mov    %esp,%ebp
  1049f6:	83 ec 18             	sub    $0x18,%esp
  1049f9:	83 ec 0c             	sub    $0xc,%esp
  1049fc:	ff 75 08             	pushl  0x8(%ebp)
  1049ff:	e8 c2 f6 ff ff       	call   1040c6 <vfs_get_node>
  104a04:	83 c4 10             	add    $0x10,%esp
  104a07:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104a0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104a0e:	75 07                	jne    104a17 <vfs_resolve_path+0x24>
  104a10:	b8 00 00 00 00       	mov    $0x0,%eax
  104a15:	eb 0e                	jmp    104a25 <vfs_resolve_path+0x32>
  104a17:	83 ec 0c             	sub    $0xc,%esp
  104a1a:	ff 75 f4             	pushl  -0xc(%ebp)
  104a1d:	e8 bb f3 ff ff       	call   103ddd <vfs_construct_absolute_path_for_node>
  104a22:	83 c4 10             	add    $0x10,%esp
  104a25:	c9                   	leave  
  104a26:	c3                   	ret    

00104a27 <vfs_init_root>:
  104a27:	55                   	push   %ebp
  104a28:	89 e5                	mov    %esp,%ebp
  104a2a:	83 ec 08             	sub    $0x8,%esp
  104a2d:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104a32:	85 c0                	test   %eax,%eax
  104a34:	75 69                	jne    104a9f <vfs_init_root+0x78>
  104a36:	83 ec 0c             	sub    $0xc,%esp
  104a39:	68 10 01 00 00       	push   $0x110
  104a3e:	e8 63 ed ff ff       	call   1037a6 <malloc>
  104a43:	83 c4 10             	add    $0x10,%esp
  104a46:	a3 6c 85 12 00       	mov    %eax,0x12856c
  104a4b:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104a50:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  104a57:	00 00 00 
  104a5a:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104a5f:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  104a66:	00 00 00 
  104a69:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104a6e:	83 ec 04             	sub    $0x4,%esp
  104a71:	6a 02                	push   $0x2
  104a73:	68 f6 78 10 00       	push   $0x1078f6
  104a78:	50                   	push   %eax
  104a79:	e8 f0 ef ff ff       	call   103a6e <memcpy>
  104a7e:	83 c4 10             	add    $0x10,%esp
  104a81:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104a86:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  104a8d:	00 00 00 
  104a90:	a1 6c 85 12 00       	mov    0x12856c,%eax
  104a95:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  104a9c:	00 00 00 
  104a9f:	c9                   	leave  
  104aa0:	c3                   	ret    

00104aa1 <vfs_debug_ls>:
  104aa1:	55                   	push   %ebp
  104aa2:	89 e5                	mov    %esp,%ebp
  104aa4:	83 ec 18             	sub    $0x18,%esp
  104aa7:	83 ec 0c             	sub    $0xc,%esp
  104aaa:	ff 75 08             	pushl  0x8(%ebp)
  104aad:	e8 14 f6 ff ff       	call   1040c6 <vfs_get_node>
  104ab2:	83 c4 10             	add    $0x10,%esp
  104ab5:	a3 78 85 12 00       	mov    %eax,0x128578
  104aba:	a1 78 85 12 00       	mov    0x128578,%eax
  104abf:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104ac5:	a3 78 85 12 00       	mov    %eax,0x128578
  104aca:	eb 6a                	jmp    104b36 <vfs_debug_ls+0x95>
  104acc:	c7 45 f4 f8 78 10 00 	movl   $0x1078f8,-0xc(%ebp)
  104ad3:	a1 78 85 12 00       	mov    0x128578,%eax
  104ad8:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104ade:	85 c0                	test   %eax,%eax
  104ae0:	75 07                	jne    104ae9 <vfs_debug_ls+0x48>
  104ae2:	c7 45 f4 fc 78 10 00 	movl   $0x1078fc,-0xc(%ebp)
  104ae9:	a1 78 85 12 00       	mov    0x128578,%eax
  104aee:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104af4:	83 f8 01             	cmp    $0x1,%eax
  104af7:	75 14                	jne    104b0d <vfs_debug_ls+0x6c>
  104af9:	a1 78 85 12 00       	mov    0x128578,%eax
  104afe:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104b04:	8b 40 04             	mov    0x4(%eax),%eax
  104b07:	8b 40 18             	mov    0x18(%eax),%eax
  104b0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104b0d:	a1 78 85 12 00       	mov    0x128578,%eax
  104b12:	ff 75 f4             	pushl  -0xc(%ebp)
  104b15:	50                   	push   %eax
  104b16:	ff 75 08             	pushl  0x8(%ebp)
  104b19:	68 00 79 10 00       	push   $0x107900
  104b1e:	e8 4a ba ff ff       	call   10056d <kprintf>
  104b23:	83 c4 10             	add    $0x10,%esp
  104b26:	a1 78 85 12 00       	mov    0x128578,%eax
  104b2b:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  104b31:	a3 78 85 12 00       	mov    %eax,0x128578
  104b36:	a1 78 85 12 00       	mov    0x128578,%eax
  104b3b:	85 c0                	test   %eax,%eax
  104b3d:	75 8d                	jne    104acc <vfs_debug_ls+0x2b>
  104b3f:	c9                   	leave  
  104b40:	c3                   	ret    
  104b41:	00 00                	add    %al,(%eax)
	...

00104b44 <vmm_create_vpdraw>:

struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
    char* stderr;
  104b44:	55                   	push   %ebp
  104b45:	89 e5                	mov    %esp,%ebp
  104b47:	53                   	push   %ebx
  104b48:	83 ec 34             	sub    $0x34,%esp
};
  104b4b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  104b52:	83 ec 0c             	sub    $0xc,%esp
  104b55:	8d 45 dc             	lea    -0x24(%ebp),%eax
  104b58:	50                   	push   %eax
  104b59:	e8 92 07 00 00       	call   1052f0 <vmm_alloc>
  104b5e:	83 c4 10             	add    $0x10,%esp
  104b61:	89 45 e0             	mov    %eax,-0x20(%ebp)
struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);
  104b64:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

  104b6b:	83 ec 0c             	sub    $0xc,%esp
  104b6e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  104b71:	50                   	push   %eax
  104b72:	e8 79 07 00 00       	call   1052f0 <vmm_alloc>
  104b77:	83 c4 10             	add    $0x10,%esp
  104b7a:	89 c2                	mov    %eax,%edx
  104b7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104b7f:	89 10                	mov    %edx,(%eax)
	switch (cpu->eax) {
  104b81:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104b85:	74 08                	je     104b8f <vmm_create_vpdraw+0x4b>
	case 1: /* exit */
  104b87:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104b8a:	8b 45 08             	mov    0x8(%ebp),%eax
  104b8d:	89 10                	mov    %edx,(%eax)
		return terminate_current(cpu);

  104b8f:	83 ec 0c             	sub    $0xc,%esp
  104b92:	6a 00                	push   $0x0
  104b94:	e8 57 07 00 00       	call   1052f0 <vmm_alloc>
  104b99:	83 c4 10             	add    $0x10,%esp
  104b9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  104b9f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104ba6:	e9 f9 00 00 00       	jmp    104ca4 <vmm_create_vpdraw+0x160>

  104bab:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bae:	c1 e0 02             	shl    $0x2,%eax
  104bb1:	89 c3                	mov    %eax,%ebx
  104bb3:	03 5d e4             	add    -0x1c(%ebp),%ebx
  104bb6:	83 ec 0c             	sub    $0xc,%esp
  104bb9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  104bbc:	50                   	push   %eax
  104bbd:	e8 2e 07 00 00       	call   1052f0 <vmm_alloc>
  104bc2:	83 c4 10             	add    $0x10,%esp
  104bc5:	89 03                	mov    %eax,(%ebx)
        struct exec_info* einp = (void*) cpu->edx;

  104bc7:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
  104bcb:	77 48                	ja     104c15 <vmm_create_vpdraw+0xd1>
        struct exec_info ein = {
  104bcd:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bd0:	c1 e0 02             	shl    $0x2,%eax
  104bd3:	03 45 e4             	add    -0x1c(%ebp),%eax
  104bd6:	8b 00                	mov    (%eax),%eax
  104bd8:	83 ec 0c             	sub    $0xc,%esp
  104bdb:	50                   	push   %eax
  104bdc:	e8 18 05 00 00       	call   1050f9 <vmm_free>
  104be1:	83 c4 10             	add    $0x10,%esp
            .execPath = 0,
  104be4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104be7:	8b 14 85 00 8c 18 00 	mov    0x188c00(,%eax,4),%edx
  104bee:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bf1:	c1 e0 02             	shl    $0x2,%eax
  104bf4:	03 45 e4             	add    -0x1c(%ebp),%eax
  104bf7:	8b 00                	mov    (%eax),%eax
  104bf9:	83 ec 04             	sub    $0x4,%esp
  104bfc:	6a 00                	push   $0x0
  104bfe:	52                   	push   %edx
  104bff:	50                   	push   %eax
  104c00:	e8 9f 04 00 00       	call   1050a4 <map_address_active>
  104c05:	83 c4 10             	add    $0x10,%esp
            .stdin = 0,
  104c08:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c0b:	8b 04 85 00 8c 18 00 	mov    0x188c00(,%eax,4),%eax
  104c12:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            .stdout = 0,
            .stderr = 0
        };
  104c15:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104c18:	8b 00                	mov    (%eax),%eax
  104c1a:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104c1d:	c1 e2 02             	shl    $0x2,%edx
  104c20:	01 d0                	add    %edx,%eax
  104c22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  104c25:	83 ca 07             	or     $0x7,%edx
  104c28:	89 10                	mov    %edx,(%eax)

        if(einp != 0) {
  104c2a:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
  104c2e:	76 71                	jbe    104ca1 <vmm_create_vpdraw+0x15d>
            ein.execPath = strclone(einp->execPath);
  104c30:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  104c37:	eb 5f                	jmp    104c98 <vmm_create_vpdraw+0x154>
            ein.stdin = strclone(einp->stdin);
  104c39:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c3c:	89 c2                	mov    %eax,%edx
  104c3e:	c1 e2 16             	shl    $0x16,%edx
  104c41:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c44:	c1 e0 0c             	shl    $0xc,%eax
  104c47:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104c4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
            ein.stdout = strclone(einp->stdout);
            ein.stderr = strclone(einp->stderr);
  104c4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c50:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  104c57:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c5a:	c1 e0 02             	shl    $0x2,%eax
  104c5d:	03 45 e4             	add    -0x1c(%ebp),%eax
  104c60:	8b 00                	mov    (%eax),%eax
  104c62:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104c65:	89 c1                	mov    %eax,%ecx
  104c67:	81 7d f4 00 10 40 01 	cmpl   $0x1401000,-0xc(%ebp)
  104c6e:	76 07                	jbe    104c77 <vmm_create_vpdraw+0x133>
  104c70:	ba 00 02 00 00       	mov    $0x200,%edx
  104c75:	eb 05                	jmp    104c7c <vmm_create_vpdraw+0x138>
  104c77:	ba 00 00 00 00       	mov    $0x0,%edx
  104c7c:	81 7d f4 00 10 40 01 	cmpl   $0x1401000,-0xc(%ebp)
  104c83:	76 07                	jbe    104c8c <vmm_create_vpdraw+0x148>
  104c85:	b8 04 00 00 00       	mov    $0x4,%eax
  104c8a:	eb 05                	jmp    104c91 <vmm_create_vpdraw+0x14d>
  104c8c:	b8 00 00 00 00       	mov    $0x0,%eax
  104c91:	09 d0                	or     %edx,%eax
  104c93:	89 01                	mov    %eax,(%ecx)
            .stdout = 0,
            .stderr = 0
        };

        if(einp != 0) {
            ein.execPath = strclone(einp->execPath);
  104c95:	ff 45 ec             	incl   -0x14(%ebp)
  104c98:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
  104c9f:	76 98                	jbe    104c39 <vmm_create_vpdraw+0xf5>
	case 1: /* exit */
		return terminate_current(cpu);

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  104ca1:	ff 45 e8             	incl   -0x18(%ebp)
  104ca4:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  104cab:	0f 86 fa fe ff ff    	jbe    104bab <vmm_create_vpdraw+0x67>

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);

        if(einp != 0) {
            free(ein.execPath);
            free(ein.stdin);
  104cb1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104cb8:	eb 3d                	jmp    104cf7 <vmm_create_vpdraw+0x1b3>
            free(ein.stdout);
  104cba:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104cbd:	8b 00                	mov    (%eax),%eax
  104cbf:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104cc2:	c1 e2 02             	shl    $0x2,%edx
  104cc5:	01 d0                	add    %edx,%eax
  104cc7:	8b 00                	mov    (%eax),%eax
  104cc9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104cce:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            free(ein.stderr);
  104cd1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
        }
  104cd4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104cd7:	89 d1                	mov    %edx,%ecx
  104cd9:	c1 e1 0c             	shl    $0xc,%ecx

        if(einp != 0) {
            free(ein.execPath);
            free(ein.stdin);
            free(ein.stdout);
            free(ein.stderr);
  104cdc:	8b 15 fc 62 10 00    	mov    0x1062fc,%edx
  104ce2:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  104ce5:	6a 00                	push   $0x0
  104ce7:	50                   	push   %eax
  104ce8:	52                   	push   %edx
  104ce9:	ff 75 e4             	pushl  -0x1c(%ebp)
  104cec:	e8 2f 03 00 00       	call   105020 <map_address_context>
  104cf1:	83 c4 10             	add    $0x10,%esp

        cpu->eax = vfs_exec(path, (char**) cpu->ecx, ein.execPath, ein.stdin, ein.stdout, ein.stderr);

        if(einp != 0) {
            free(ein.execPath);
            free(ein.stdin);
  104cf4:	ff 45 e8             	incl   -0x18(%ebp)
  104cf7:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  104cfe:	76 ba                	jbe    104cba <vmm_create_vpdraw+0x176>
            free(ein.stdout);
            free(ein.stderr);
        }

        free(path);
    }
  104d00:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104d03:	a1 00 63 10 00       	mov    0x106300,%eax
  104d08:	6a 00                	push   $0x0
  104d0a:	52                   	push   %edx
  104d0b:	50                   	push   %eax
  104d0c:	ff 75 e4             	pushl  -0x1c(%ebp)
  104d0f:	e8 0c 03 00 00       	call   105020 <map_address_context>
  104d14:	83 c4 10             	add    $0x10,%esp
        break;

    case 4: /* getargs */
  104d17:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
  104d1e:	eb 1a                	jmp    104d3a <vmm_create_vpdraw+0x1f6>
    {
  104d20:	6a 00                	push   $0x0
  104d22:	ff 75 e8             	pushl  -0x18(%ebp)
  104d25:	ff 75 e8             	pushl  -0x18(%ebp)
  104d28:	ff 75 e4             	pushl  -0x1c(%ebp)
  104d2b:	e8 f0 02 00 00       	call   105020 <map_address_context>
  104d30:	83 c4 10             	add    $0x10,%esp

        free(path);
    }
        break;

    case 4: /* getargs */
  104d33:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
  104d3a:	b8 00 90 18 00       	mov    $0x189000,%eax
  104d3f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  104d42:	72 dc                	jb     104d20 <vmm_create_vpdraw+0x1dc>
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;
  104d44:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104d47:	8b 00                	mov    (%eax),%eax
  104d49:	89 45 f0             	mov    %eax,-0x10(%ebp)

  104d4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104d4f:	89 c2                	mov    %eax,%edx
  104d51:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104d54:	89 10                	mov    %edx,(%eax)
    case 5: /* yield */
    {
  104d56:	83 ec 0c             	sub    $0xc,%esp
  104d59:	ff 75 f0             	pushl  -0x10(%ebp)
  104d5c:	e8 18 04 00 00       	call   105179 <vmm_unmap>
  104d61:	83 c4 10             	add    $0x10,%esp
        cpu = schedule(cpu);
  104d64:	83 ec 0c             	sub    $0xc,%esp
  104d67:	ff 75 e0             	pushl  -0x20(%ebp)
  104d6a:	e8 0a 04 00 00       	call   105179 <vmm_unmap>
  104d6f:	83 c4 10             	add    $0x10,%esp
    }
        break;
  104d72:	8b 45 e4             	mov    -0x1c(%ebp),%eax

  104d75:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104d78:	c9                   	leave  
  104d79:	c3                   	ret    

00104d7a <vmm_free_pdptr>:
    case 6: /* getExecPath */
    {
  104d7a:	55                   	push   %ebp
  104d7b:	89 e5                	mov    %esp,%ebp
  104d7d:	83 ec 18             	sub    $0x18,%esp
        char* dest = (char*)cpu->ebx;
  104d80:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104d87:	eb 1a                	jmp    104da3 <vmm_free_pdptr+0x29>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  104d89:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d8c:	c1 e0 02             	shl    $0x2,%eax
  104d8f:	03 45 08             	add    0x8(%ebp),%eax
  104d92:	8b 00                	mov    (%eax),%eax
  104d94:	83 ec 0c             	sub    $0xc,%esp
  104d97:	50                   	push   %eax
  104d98:	e8 dc 03 00 00       	call   105179 <vmm_unmap>
  104d9d:	83 c4 10             	add    $0x10,%esp
    }
        break;

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  104da0:	ff 45 f4             	incl   -0xc(%ebp)
  104da3:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  104daa:	76 dd                	jbe    104d89 <vmm_free_pdptr+0xf>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;

  104dac:	83 ec 0c             	sub    $0xc,%esp
  104daf:	ff 75 08             	pushl  0x8(%ebp)
  104db2:	e8 c2 03 00 00       	call   105179 <vmm_unmap>
  104db7:	83 c4 10             	add    $0x10,%esp
    case 7: /* changeExecPath */
  104dba:	c9                   	leave  
  104dbb:	c3                   	ret    

00104dbc <vmm_get_current_pagedir>:
    {
        vfs_reset_error();
  104dbc:	55                   	push   %ebp
  104dbd:	89 e5                	mov    %esp,%ebp
        char* path = strclone((char*) cpu->ebx);
  104dbf:	a1 84 85 12 00       	mov    0x128584,%eax

  104dc4:	5d                   	pop    %ebp
  104dc5:	c3                   	ret    

00104dc6 <vmm_create_pagedir>:
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

  104dc6:	55                   	push   %ebp
  104dc7:	89 e5                	mov    %esp,%ebp
  104dc9:	83 ec 18             	sub    $0x18,%esp
        char* new = vfs_resolve_path(path);

  104dcc:	83 ec 0c             	sub    $0xc,%esp
  104dcf:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104dd2:	50                   	push   %eax
  104dd3:	e8 6c fd ff ff       	call   104b44 <vmm_create_vpdraw>
  104dd8:	83 c4 10             	add    $0x10,%esp
  104ddb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cpu->eax = 0;
  104dde:	83 ec 0c             	sub    $0xc,%esp
  104de1:	ff 75 f4             	pushl  -0xc(%ebp)
  104de4:	e8 91 ff ff ff       	call   104d7a <vmm_free_pdptr>
  104de9:	83 c4 10             	add    $0x10,%esp
        if(new) {
            get_current_task()->execPath = new;
  104dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
            cpu->eax = 1;
  104def:	c9                   	leave  
  104df0:	c3                   	ret    

00104df1 <vmm_free_current_pagetables>:
        }

  104df1:	55                   	push   %ebp
  104df2:	89 e5                	mov    %esp,%ebp
  104df4:	83 ec 18             	sub    $0x18,%esp
        free(path);
  104df7:	83 ec 0c             	sub    $0xc,%esp
  104dfa:	6a 00                	push   $0x0
  104dfc:	e8 ef 04 00 00       	call   1052f0 <vmm_alloc>
  104e01:	83 c4 10             	add    $0x10,%esp
  104e04:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }
  104e07:	83 ec 0c             	sub    $0xc,%esp
  104e0a:	6a 00                	push   $0x0
  104e0c:	e8 df 04 00 00       	call   1052f0 <vmm_alloc>
  104e11:	83 c4 10             	add    $0x10,%esp
  104e14:	89 45 ec             	mov    %eax,-0x14(%ebp)
        break;
  104e17:	83 ec 0c             	sub    $0xc,%esp
  104e1a:	ff 75 e8             	pushl  -0x18(%ebp)
  104e1d:	e8 d7 02 00 00       	call   1050f9 <vmm_free>
  104e22:	83 c4 10             	add    $0x10,%esp

  104e25:	83 ec 0c             	sub    $0xc,%esp
  104e28:	ff 75 ec             	pushl  -0x14(%ebp)
  104e2b:	e8 c9 02 00 00       	call   1050f9 <vmm_free>
  104e30:	83 c4 10             	add    $0x10,%esp
	case 10: /* fopen */
	{
  104e33:	e8 71 de ff ff       	call   102ca9 <get_current_task>
  104e38:	8b 50 14             	mov    0x14(%eax),%edx
  104e3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104e3e:	83 ec 04             	sub    $0x4,%esp
  104e41:	6a 00                	push   $0x0
  104e43:	52                   	push   %edx
  104e44:	50                   	push   %eax
  104e45:	e8 5a 02 00 00       	call   1050a4 <map_address_active>
  104e4a:	83 c4 10             	add    $0x10,%esp
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  104e4d:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
  104e54:	e9 99 00 00 00       	jmp    104ef2 <vmm_free_current_pagetables+0x101>
	    uint32_t fmode = (uint32_t) cpu->ecx;
  104e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e5c:	c1 e0 02             	shl    $0x2,%eax
  104e5f:	03 45 e8             	add    -0x18(%ebp),%eax
  104e62:	8b 00                	mov    (%eax),%eax
  104e64:	89 c2                	mov    %eax,%edx
  104e66:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  104e6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104e6f:	83 ec 04             	sub    $0x4,%esp
  104e72:	6a 00                	push   $0x0
  104e74:	52                   	push   %edx
  104e75:	50                   	push   %eax
  104e76:	e8 29 02 00 00       	call   1050a4 <map_address_active>
  104e7b:	83 c4 10             	add    $0x10,%esp

	    struct res_handle* handle = vfs_open(name, fmode);
  104e7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104e85:	eb 31                	jmp    104eb8 <vmm_free_current_pagetables+0xc7>
	    if(handle) {
  104e87:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e8a:	c1 e0 02             	shl    $0x2,%eax
  104e8d:	03 45 ec             	add    -0x14(%ebp),%eax
  104e90:	8b 00                	mov    (%eax),%eax
  104e92:	83 e0 01             	and    $0x1,%eax
  104e95:	84 c0                	test   %al,%al
  104e97:	74 1c                	je     104eb5 <vmm_free_current_pagetables+0xc4>
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
	    }
	    else
  104e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e9c:	c1 e0 02             	shl    $0x2,%eax
  104e9f:	03 45 ec             	add    -0x14(%ebp),%eax
  104ea2:	8b 00                	mov    (%eax),%eax
  104ea4:	25 00 f0 ff 0f       	and    $0xffff000,%eax
  104ea9:	83 ec 0c             	sub    $0xc,%esp
  104eac:	50                   	push   %eax
  104ead:	e8 00 d1 ff ff       	call   101fb2 <pmm_free>
  104eb2:	83 c4 10             	add    $0x10,%esp
	{
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
  104eb5:	ff 45 f4             	incl   -0xc(%ebp)
  104eb8:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  104ebf:	76 c6                	jbe    104e87 <vmm_free_current_pagetables+0x96>
	    }
	    else
	    {
	        cpu->eax = 0;
	    }

  104ec1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104ec4:	c1 e0 02             	shl    $0x2,%eax
  104ec7:	03 45 e8             	add    -0x18(%ebp),%eax
  104eca:	8b 00                	mov    (%eax),%eax
  104ecc:	83 e0 01             	and    $0x1,%eax
  104ecf:	84 c0                	test   %al,%al
  104ed1:	74 1c                	je     104eef <vmm_free_current_pagetables+0xfe>
	    free(name);
  104ed3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104ed6:	c1 e0 02             	shl    $0x2,%eax
  104ed9:	03 45 e8             	add    -0x18(%ebp),%eax
  104edc:	8b 00                	mov    (%eax),%eax
  104ede:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104ee3:	83 ec 0c             	sub    $0xc,%esp
  104ee6:	50                   	push   %eax
  104ee7:	e8 c6 d0 ff ff       	call   101fb2 <pmm_free>
  104eec:	83 c4 10             	add    $0x10,%esp
        break;

	case 10: /* fopen */
	{
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  104eef:	ff 45 f0             	incl   -0x10(%ebp)
  104ef2:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
  104ef9:	0f 86 5a ff ff ff    	jbe    104e59 <vmm_free_current_pagetables+0x68>
	    }

	    free(name);
	}
	    break;

  104eff:	e8 a5 dd ff ff       	call   102ca9 <get_current_task>
  104f04:	8b 40 14             	mov    0x14(%eax),%eax
  104f07:	83 ec 0c             	sub    $0xc,%esp
  104f0a:	50                   	push   %eax
  104f0b:	e8 a2 d0 ff ff       	call   101fb2 <pmm_free>
  104f10:	83 c4 10             	add    $0x10,%esp
	case 11: /* fclose */
  104f13:	c9                   	leave  
  104f14:	c3                   	ret    

00104f15 <vmm_resolve>:
	{
        vfs_reset_error();
  104f15:	55                   	push   %ebp
  104f16:	89 e5                	mov    %esp,%ebp
	    struct res_handle* handle = (void*) cpu->ebx;
  104f18:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  104f1d:	8b 55 08             	mov    0x8(%ebp),%edx
  104f20:	c1 ea 0c             	shr    $0xc,%edx
  104f23:	c1 e2 02             	shl    $0x2,%edx
  104f26:	01 d0                	add    %edx,%eax
  104f28:	8b 00                	mov    (%eax),%eax
  104f2a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	    if(!unregister_handle(handle)) {
  104f2f:	5d                   	pop    %ebp
  104f30:	c3                   	ret    

00104f31 <vmm_resolve_ppd>:
	        vfs_close(handle);

  104f31:	55                   	push   %ebp
  104f32:	89 e5                	mov    %esp,%ebp
  104f34:	83 ec 28             	sub    $0x28,%esp
	        cpu->eax = 0;
  104f37:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f3a:	c1 e8 16             	shr    $0x16,%eax
  104f3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    }
  104f40:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f43:	c1 e8 0c             	shr    $0xc,%eax
  104f46:	25 ff 03 00 00       	and    $0x3ff,%eax
  104f4b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	    else
	    {
  104f4e:	83 ec 0c             	sub    $0xc,%esp
  104f51:	6a 00                	push   $0x0
  104f53:	e8 98 03 00 00       	call   1052f0 <vmm_alloc>
  104f58:	83 c4 10             	add    $0x10,%esp
  104f5b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	        cpu->eax = (uint32_t) -1;
  104f5e:	83 ec 0c             	sub    $0xc,%esp
  104f61:	ff 75 ec             	pushl  -0x14(%ebp)
  104f64:	e8 90 01 00 00       	call   1050f9 <vmm_free>
  104f69:	83 c4 10             	add    $0x10,%esp
	    }
	}
  104f6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f6f:	83 ec 04             	sub    $0x4,%esp
  104f72:	6a 00                	push   $0x0
  104f74:	ff 75 08             	pushl  0x8(%ebp)
  104f77:	50                   	push   %eax
  104f78:	e8 27 01 00 00       	call   1050a4 <map_address_active>
  104f7d:	83 c4 10             	add    $0x10,%esp
	    break;
  104f80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104f83:	c1 e0 02             	shl    $0x2,%eax
  104f86:	03 45 ec             	add    -0x14(%ebp),%eax
  104f89:	8b 00                	mov    (%eax),%eax
  104f8b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104f90:	89 45 f0             	mov    %eax,-0x10(%ebp)

	case 12: /* fwrite */
  104f93:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f96:	83 ec 04             	sub    $0x4,%esp
  104f99:	6a 00                	push   $0x0
  104f9b:	ff 75 f0             	pushl  -0x10(%ebp)
  104f9e:	50                   	push   %eax
  104f9f:	e8 00 01 00 00       	call   1050a4 <map_address_active>
  104fa4:	83 c4 10             	add    $0x10,%esp
	{
  104fa7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104faa:	c1 e0 02             	shl    $0x2,%eax
  104fad:	03 45 ec             	add    -0x14(%ebp),%eax
  104fb0:	8b 00                	mov    (%eax),%eax
  104fb2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104fb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
  104fba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104fbd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	    if(handle != 0) {
  104fc2:	c9                   	leave  
  104fc3:	c3                   	ret    

00104fc4 <vmm_map_range>:
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
  104fc4:	55                   	push   %ebp
  104fc5:	89 e5                	mov    %esp,%ebp
  104fc7:	83 ec 18             	sub    $0x18,%esp
	    else
  104fca:	8b 45 08             	mov    0x8(%ebp),%eax
  104fcd:	25 ff 0f 00 00       	and    $0xfff,%eax
  104fd2:	85 c0                	test   %eax,%eax
  104fd4:	75 44                	jne    10501a <vmm_map_range+0x56>
	    {
            cpu->eax = RW_ERR_VFS;
  104fd6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fd9:	25 ff 0f 00 00       	and    $0xfff,%eax
  104fde:	85 c0                	test   %eax,%eax
  104fe0:	75 3b                	jne    10501d <vmm_map_range+0x59>
	    }
	}
	    break;
  104fe2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104fe9:	eb 25                	jmp    105010 <vmm_map_range+0x4c>

  104feb:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fee:	89 c2                	mov    %eax,%edx
  104ff0:	03 55 f4             	add    -0xc(%ebp),%edx
  104ff3:	8b 45 08             	mov    0x8(%ebp),%eax
  104ff6:	03 45 f4             	add    -0xc(%ebp),%eax
  104ff9:	83 ec 04             	sub    $0x4,%esp
  104ffc:	ff 75 14             	pushl  0x14(%ebp)
  104fff:	52                   	push   %edx
  105000:	50                   	push   %eax
  105001:	e8 9e 00 00 00       	call   1050a4 <map_address_active>
  105006:	83 c4 10             	add    $0x10,%esp
	    else
	    {
            cpu->eax = RW_ERR_VFS;
	    }
	}
	    break;
  105009:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  105010:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105013:	3b 45 10             	cmp    0x10(%ebp),%eax
  105016:	72 d3                	jb     104feb <vmm_map_range+0x27>
  105018:	eb 04                	jmp    10501e <vmm_map_range+0x5a>
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
	    else
	    {
  10501a:	90                   	nop    
  10501b:	eb 01                	jmp    10501e <vmm_map_range+0x5a>
            cpu->eax = RW_ERR_VFS;
	    }
  10501d:	90                   	nop    
	}
	    break;

	case 13: /* fread */
	{
  10501e:	c9                   	leave  
  10501f:	c3                   	ret    

00105020 <map_address_context>:
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
  105020:	55                   	push   %ebp
  105021:	89 e5                	mov    %esp,%ebp
  105023:	53                   	push   %ebx
  105024:	83 ec 10             	sub    $0x10,%esp
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  105027:	8b 45 0c             	mov    0xc(%ebp),%eax
  10502a:	c1 e8 16             	shr    $0x16,%eax
  10502d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }
  105030:	8b 45 0c             	mov    0xc(%ebp),%eax
  105033:	c1 e8 0c             	shr    $0xc,%eax
  105036:	25 ff 03 00 00       	and    $0x3ff,%eax
  10503b:	89 45 f8             	mov    %eax,-0x8(%ebp)
        else
        {
  10503e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105041:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  105048:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10504b:	c1 e0 02             	shl    $0x2,%eax
  10504e:	03 45 08             	add    0x8(%ebp),%eax
  105051:	8b 00                	mov    (%eax),%eax
  105053:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105058:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10505b:	8b 55 10             	mov    0x10(%ebp),%edx
  10505e:	89 d1                	mov    %edx,%ecx
  105060:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
            cpu->eax = RW_ERR_VFS;
  105066:	8b 55 14             	mov    0x14(%ebp),%edx
  105069:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
        {
  10506f:	09 d1                	or     %edx,%ecx
            cpu->eax = RW_ERR_VFS;
        }
  105071:	8b 55 f8             	mov    -0x8(%ebp),%edx
  105074:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
  10507b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10507e:	c1 e2 02             	shl    $0x2,%edx
  105081:	03 55 08             	add    0x8(%ebp),%edx
  105084:	8b 12                	mov    (%edx),%edx
  105086:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  10508c:	8d 14 13             	lea    (%ebx,%edx,1),%edx
  10508f:	8b 12                	mov    (%edx),%edx
  105091:	81 e2 04 02 00 00    	and    $0x204,%edx
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
        {
  105097:	09 ca                	or     %ecx,%edx
  105099:	83 ca 03             	or     $0x3,%edx
  10509c:	89 10                	mov    %edx,(%eax)
            cpu->eax = RW_ERR_VFS;
        }
	}
	    break;
  10509e:	83 c4 10             	add    $0x10,%esp
  1050a1:	5b                   	pop    %ebx
  1050a2:	5d                   	pop    %ebp
  1050a3:	c3                   	ret    

001050a4 <map_address_active>:

	case 14: /* fmkfifo */
  1050a4:	55                   	push   %ebp
  1050a5:	89 e5                	mov    %esp,%ebp
  1050a7:	53                   	push   %ebx
	{
  1050a8:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  1050ad:	8b 55 08             	mov    0x8(%ebp),%edx
  1050b0:	c1 ea 0c             	shr    $0xc,%edx
  1050b3:	c1 e2 02             	shl    $0x2,%edx
  1050b6:	01 d0                	add    %edx,%eax
  1050b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1050bb:	89 d1                	mov    %edx,%ecx
  1050bd:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
        vfs_reset_error();
  1050c3:	8b 55 10             	mov    0x10(%ebp),%edx
  1050c6:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
        }
	}
	    break;

	case 14: /* fmkfifo */
	{
  1050cc:	89 cb                	mov    %ecx,%ebx
  1050ce:	09 d3                	or     %edx,%ebx
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
  1050d0:	8b 15 fc 62 10 00    	mov    0x1062fc,%edx
  1050d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1050d9:	c1 e9 0c             	shr    $0xc,%ecx
  1050dc:	c1 e1 02             	shl    $0x2,%ecx
  1050df:	01 ca                	add    %ecx,%edx
  1050e1:	8b 12                	mov    (%edx),%edx
  1050e3:	81 e2 04 02 00 00    	and    $0x204,%edx
        }
	}
	    break;

	case 14: /* fmkfifo */
	{
  1050e9:	09 da                	or     %ebx,%edx
  1050eb:	83 ca 03             	or     $0x3,%edx
  1050ee:	89 10                	mov    %edx,(%eax)
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  1050f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1050f3:	0f 01 38             	invlpg (%eax)

  1050f6:	5b                   	pop    %ebx
  1050f7:	5d                   	pop    %ebp
  1050f8:	c3                   	ret    

001050f9 <vmm_free>:
        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
  1050f9:	55                   	push   %ebp
  1050fa:	89 e5                	mov    %esp,%ebp
  1050fc:	83 ec 18             	sub    $0x18,%esp
            register_handle(handle);
  1050ff:	8b 45 08             	mov    0x8(%ebp),%eax
  105102:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = (uint32_t) handle;
        }
  105105:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  10510a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10510d:	c1 ea 0c             	shr    $0xc,%edx
  105110:	c1 e2 02             	shl    $0x2,%edx
  105113:	01 d0                	add    %edx,%eax
  105115:	8b 00                	mov    (%eax),%eax
  105117:	25 01 02 00 00       	and    $0x201,%eax
  10511c:	3d 01 02 00 00       	cmp    $0x201,%eax
  105121:	75 54                	jne    105177 <vmm_free+0x7e>
        else
        {
  105123:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  105128:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10512b:	c1 ea 0c             	shr    $0xc,%edx
  10512e:	c1 e2 02             	shl    $0x2,%edx
  105131:	01 d0                	add    %edx,%eax
  105133:	8b 00                	mov    (%eax),%eax
  105135:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10513a:	83 ec 0c             	sub    $0xc,%esp
  10513d:	50                   	push   %eax
  10513e:	e8 6f ce ff ff       	call   101fb2 <pmm_free>
  105143:	83 c4 10             	add    $0x10,%esp
            cpu->eax = 0;
        }
  105146:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  10514b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10514e:	c1 ea 0c             	shr    $0xc,%edx
  105151:	c1 e2 02             	shl    $0x2,%edx
  105154:	01 d0                	add    %edx,%eax

  105156:	8b 15 fc 62 10 00    	mov    0x1062fc,%edx
  10515c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10515f:	c1 e9 0c             	shr    $0xc,%ecx
  105162:	c1 e1 02             	shl    $0x2,%ecx
  105165:	01 ca                	add    %ecx,%edx
  105167:	8b 12                	mov    (%edx),%edx
  105169:	83 e2 04             	and    $0x4,%edx
            cpu->eax = (uint32_t) handle;
        }
        else
        {
            cpu->eax = 0;
        }
  10516c:	80 ce 02             	or     $0x2,%dh
  10516f:	89 10                	mov    %edx,(%eax)

        free(name);
  105171:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105174:	0f 01 38             	invlpg (%eax)
	}
	    break;
  105177:	c9                   	leave  
  105178:	c3                   	ret    

00105179 <vmm_unmap>:

	case 15: /* getLastVFSErr */
  105179:	55                   	push   %ebp
  10517a:	89 e5                	mov    %esp,%ebp
  10517c:	83 ec 10             	sub    $0x10,%esp
	{
  10517f:	8b 45 08             	mov    0x8(%ebp),%eax
  105182:	89 45 fc             	mov    %eax,-0x4(%ebp)
	    cpu->eax = get_current_task()->vfserr;
        vfs_reset_error();
  105185:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  10518a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10518d:	c1 ea 0c             	shr    $0xc,%edx
  105190:	c1 e2 02             	shl    $0x2,%edx
  105193:	01 d0                	add    %edx,%eax
  105195:	8b 00                	mov    (%eax),%eax
  105197:	25 01 02 00 00       	and    $0x201,%eax
  10519c:	3d 01 02 00 00       	cmp    $0x201,%eax
  1051a1:	75 31                	jne    1051d4 <vmm_unmap+0x5b>
	}
	    break;
  1051a3:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  1051a8:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1051ab:	c1 ea 0c             	shr    $0xc,%edx
  1051ae:	c1 e2 02             	shl    $0x2,%edx
  1051b1:	01 d0                	add    %edx,%eax

  1051b3:	8b 15 fc 62 10 00    	mov    0x1062fc,%edx
  1051b9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1051bc:	c1 e9 0c             	shr    $0xc,%ecx
  1051bf:	c1 e1 02             	shl    $0x2,%ecx
  1051c2:	01 ca                	add    %ecx,%edx
  1051c4:	8b 12                	mov    (%edx),%edx
  1051c6:	83 e2 04             	and    $0x4,%edx
	case 15: /* getLastVFSErr */
	{
	    cpu->eax = get_current_task()->vfserr;
        vfs_reset_error();
	}
	    break;
  1051c9:	80 ce 02             	or     $0x2,%dh
  1051cc:	89 10                	mov    %edx,(%eax)

	case 20: /* getpmhandle */
  1051ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1051d1:	0f 01 38             	invlpg (%eax)
	{
	    struct res_handle* handle = 0;
  1051d4:	c9                   	leave  
  1051d5:	c3                   	ret    

001051d6 <vmm_alloc_in_range>:

	    switch(cpu->ebx) {
	    case PMID_STDOUT:
  1051d6:	55                   	push   %ebp
  1051d7:	89 e5                	mov    %esp,%ebp
  1051d9:	83 ec 18             	sub    $0x18,%esp
	        handle = get_current_task()->stdout;
  1051dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	        break;
  1051e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        case PMID_STDIN:
  1051ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            handle = get_current_task()->stdin;
            break;
  1051f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1051f4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1051f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1051fc:	eb 48                	jmp    105246 <vmm_alloc_in_range+0x70>
        case PMID_STDERR:
  1051fe:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  105203:	8b 55 ec             	mov    -0x14(%ebp),%edx
  105206:	c1 ea 0c             	shr    $0xc,%edx
  105209:	c1 e2 02             	shl    $0x2,%edx
  10520c:	01 d0                	add    %edx,%eax
  10520e:	8b 00                	mov    (%eax),%eax
  105210:	25 01 02 00 00       	and    $0x201,%eax
  105215:	3d 00 02 00 00       	cmp    $0x200,%eax
  10521a:	75 19                	jne    105235 <vmm_alloc_in_range+0x5f>
            handle = get_current_task()->stderr;
            break;
  10521c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  105220:	75 06                	jne    105228 <vmm_alloc_in_range+0x52>
        default:
  105222:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105225:	89 45 e8             	mov    %eax,-0x18(%ebp)
            handle = get_current_task()->stdout;
  105228:	ff 45 f0             	incl   -0x10(%ebp)
            break;
  10522b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10522e:	3b 45 14             	cmp    0x14(%ebp),%eax
  105231:	72 0b                	jb     10523e <vmm_alloc_in_range+0x68>
	    }
  105233:	eb 19                	jmp    10524e <vmm_alloc_in_range+0x78>

	    cpu->eax = (uint32_t) handle;
  105235:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10523c:	eb 01                	jmp    10523f <vmm_alloc_in_range+0x69>
            handle = get_current_task()->stderr;
            break;
        default:
            handle = get_current_task()->stdout;
            break;
	    }
  10523e:	90                   	nop    
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
	        break;
        case PMID_STDIN:
            handle = get_current_task()->stdin;
            break;
  10523f:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
  105246:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105249:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10524c:	72 b0                	jb     1051fe <vmm_alloc_in_range+0x28>

	    cpu->eax = (uint32_t) handle;
	}
	    break;

	case 21: /* fopenpmhandle */
  10524e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	{
	    vfs_reset_error();
  105255:	eb 29                	jmp    105280 <vmm_alloc_in_range+0xaa>
	    char* path = strclone((char*)cpu->ecx);
  105257:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10525b:	75 05                	jne    105262 <vmm_alloc_in_range+0x8c>
  10525d:	8b 45 10             	mov    0x10(%ebp),%eax
  105260:	eb 05                	jmp    105267 <vmm_alloc_in_range+0x91>
  105262:	b8 00 00 00 00       	mov    $0x0,%eax
  105267:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10526a:	c1 e2 0c             	shl    $0xc,%edx
  10526d:	03 55 e8             	add    -0x18(%ebp),%edx
  105270:	83 ec 08             	sub    $0x8,%esp
  105273:	50                   	push   %eax
  105274:	52                   	push   %edx
  105275:	e8 95 00 00 00       	call   10530f <vmm_alloc_addr>
  10527a:	83 c4 10             	add    $0x10,%esp

  10527d:	ff 45 f4             	incl   -0xc(%ebp)
	}
	    break;

	case 21: /* fopenpmhandle */
	{
	    vfs_reset_error();
  105280:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  105284:	0f 95 c0             	setne  %al
  105287:	ff 4d f0             	decl   -0x10(%ebp)
  10528a:	84 c0                	test   %al,%al
  10528c:	75 c9                	jne    105257 <vmm_alloc_in_range+0x81>
	    char* path = strclone((char*)cpu->ecx);

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;

  10528e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	    if(cpu->ebx == PMID_STDIN) {
  105291:	c9                   	leave  
  105292:	c3                   	ret    

00105293 <vmm_alloc_ucont>:
	        fm = FM_READ;
	    }
  105293:	55                   	push   %ebp
  105294:	89 e5                	mov    %esp,%ebp
  105296:	83 ec 08             	sub    $0x8,%esp

  105299:	ff 75 08             	pushl  0x8(%ebp)
  10529c:	6a 00                	push   $0x0
  10529e:	68 00 f0 ff ff       	push   $0xfffff000
  1052a3:	68 00 10 40 01       	push   $0x1401000
  1052a8:	e8 29 ff ff ff       	call   1051d6 <vmm_alloc_in_range>
  1052ad:	83 c4 10             	add    $0x10,%esp
	    open = vfs_open(path, fm);
  1052b0:	c9                   	leave  
  1052b1:	c3                   	ret    

001052b2 <vmm_alloc_user>:

	    free(path);
  1052b2:	55                   	push   %ebp
  1052b3:	89 e5                	mov    %esp,%ebp
  1052b5:	83 ec 08             	sub    $0x8,%esp

  1052b8:	6a 01                	push   $0x1
  1052ba:	ff 75 08             	pushl  0x8(%ebp)
  1052bd:	68 00 f0 ff ff       	push   $0xfffff000
  1052c2:	68 00 10 40 01       	push   $0x1401000
  1052c7:	e8 0a ff ff ff       	call   1051d6 <vmm_alloc_in_range>
  1052cc:	83 c4 10             	add    $0x10,%esp
	    if(!open) {
  1052cf:	c9                   	leave  
  1052d0:	c3                   	ret    

001052d1 <vmm_alloc_cont>:
	        cpu->eax = (uint32_t) -1;
	        break;
  1052d1:	55                   	push   %ebp
  1052d2:	89 e5                	mov    %esp,%ebp
  1052d4:	83 ec 08             	sub    $0x8,%esp
	    }
  1052d7:	ff 75 08             	pushl  0x8(%ebp)
  1052da:	6a 00                	push   $0x0
  1052dc:	68 00 00 00 20       	push   $0x20000000
  1052e1:	68 00 10 40 01       	push   $0x1401000
  1052e6:	e8 eb fe ff ff       	call   1051d6 <vmm_alloc_in_range>
  1052eb:	83 c4 10             	add    $0x10,%esp

  1052ee:	c9                   	leave  
  1052ef:	c3                   	ret    

001052f0 <vmm_alloc>:
	    struct res_handle* oldhandle = 0;

  1052f0:	55                   	push   %ebp
  1052f1:	89 e5                	mov    %esp,%ebp
  1052f3:	83 ec 08             	sub    $0x8,%esp
        switch(cpu->ebx) {
  1052f6:	6a 01                	push   $0x1
  1052f8:	ff 75 08             	pushl  0x8(%ebp)
  1052fb:	68 00 00 00 20       	push   $0x20000000
  105300:	68 00 10 40 01       	push   $0x1401000
  105305:	e8 cc fe ff ff       	call   1051d6 <vmm_alloc_in_range>
  10530a:	83 c4 10             	add    $0x10,%esp
        case PMID_STDOUT:
  10530d:	c9                   	leave  
  10530e:	c3                   	ret    

0010530f <vmm_alloc_addr>:
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
  10530f:	55                   	push   %ebp
  105310:	89 e5                	mov    %esp,%ebp
  105312:	83 ec 18             	sub    $0x18,%esp
            break;
  105315:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  105319:	75 1c                	jne    105337 <vmm_alloc_addr+0x28>
        case PMID_STDIN:
  10531b:	83 ec 04             	sub    $0x4,%esp
  10531e:	6a 00                	push   $0x0
  105320:	ff 75 08             	pushl  0x8(%ebp)
  105323:	68 10 79 10 00       	push   $0x107910
  105328:	e8 40 b2 ff ff       	call   10056d <kprintf>
  10532d:	83 c4 10             	add    $0x10,%esp
            oldhandle = get_current_task()->stdin;
            get_current_task()->stdin = open;
            break;
  105330:	b8 00 00 00 00       	mov    $0x0,%eax
  105335:	eb 7b                	jmp    1053b2 <vmm_alloc_addr+0xa3>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
            get_current_task()->stderr = open;
  105337:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  10533c:	8b 55 08             	mov    0x8(%ebp),%edx
  10533f:	c1 ea 0c             	shr    $0xc,%edx
  105342:	c1 e2 02             	shl    $0x2,%edx
  105345:	01 d0                	add    %edx,%eax
  105347:	8b 00                	mov    (%eax),%eax
  105349:	25 01 02 00 00       	and    $0x201,%eax
  10534e:	3d 00 02 00 00       	cmp    $0x200,%eax
  105353:	74 2d                	je     105382 <vmm_alloc_addr+0x73>
            break;
        default:
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
  105355:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  10535a:	8b 55 08             	mov    0x8(%ebp),%edx
  10535d:	c1 ea 0c             	shr    $0xc,%edx
  105360:	c1 e2 02             	shl    $0x2,%edx
  105363:	01 d0                	add    %edx,%eax
            break;
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
            get_current_task()->stderr = open;
            break;
        default:
  105365:	8b 00                	mov    (%eax),%eax
  105367:	83 ec 04             	sub    $0x4,%esp
  10536a:	50                   	push   %eax
  10536b:	ff 75 08             	pushl  0x8(%ebp)
  10536e:	68 10 79 10 00       	push   $0x107910
  105373:	e8 f5 b1 ff ff       	call   10056d <kprintf>
  105378:	83 c4 10             	add    $0x10,%esp
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
            break;
  10537b:	b8 00 00 00 00       	mov    $0x0,%eax
  105380:	eb 30                	jmp    1053b2 <vmm_alloc_addr+0xa3>
        }

        if(oldhandle != 0) {
  105382:	e8 b9 ca ff ff       	call   101e40 <pmm_alloc>
  105387:	89 45 f4             	mov    %eax,-0xc(%ebp)
            vfs_close(oldhandle);
  10538a:	8b 45 08             	mov    0x8(%ebp),%eax
  10538d:	83 ec 04             	sub    $0x4,%esp
  105390:	68 04 02 00 00       	push   $0x204
  105395:	ff 75 f4             	pushl  -0xc(%ebp)
  105398:	50                   	push   %eax
  105399:	e8 06 fd ff ff       	call   1050a4 <map_address_active>
  10539e:	83 c4 10             	add    $0x10,%esp
        }

  1053a1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1053a5:	74 08                	je     1053af <vmm_alloc_addr+0xa0>
        cpu->eax = 0;
  1053a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1053aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1053ad:	89 10                	mov    %edx,(%eax)
	}
	    break;
  1053af:	8b 45 08             	mov    0x8(%ebp),%eax

  1053b2:	c9                   	leave  
  1053b3:	c3                   	ret    

001053b4 <vmm_activate_pagedir>:
	case 30: /* return_rpc */
	{
  1053b4:	55                   	push   %ebp
  1053b5:	89 e5                	mov    %esp,%ebp
	    cpu = return_rpc_call(cpu);
  1053b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1053ba:	a3 84 85 12 00       	mov    %eax,0x128584
	}
  1053bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1053c2:	0f 22 d8             	mov    %eax,%cr3
	    break;
  1053c5:	5d                   	pop    %ebp
  1053c6:	c3                   	ret    

001053c7 <vmm_init>:

	case 31: /* call_rpc */
  1053c7:	55                   	push   %ebp
  1053c8:	89 e5                	mov    %esp,%ebp
  1053ca:	53                   	push   %ebx
  1053cb:	83 ec 24             	sub    $0x24,%esp
	{
	    int PID = cpu->ebx;

  1053ce:	e8 6d ca ff ff       	call   101e40 <pmm_alloc>
  1053d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    //TODO create RPC for U2U
	}
	    break;
  1053d6:	e8 65 ca ff ff       	call   101e40 <pmm_alloc>
  1053db:	89 c2                	mov    %eax,%edx
  1053dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053e0:	89 10                	mov    %edx,(%eax)

	case 32: /* set_rpc_handler */
  1053e2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1053e9:	e9 d3 00 00 00       	jmp    1054c1 <vmm_init+0xfa>
	{
  1053ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053f1:	8b 00                	mov    (%eax),%eax
  1053f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1053f6:	c1 e2 02             	shl    $0x2,%edx
  1053f9:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  1053fc:	e8 3f ca ff ff       	call   101e40 <pmm_alloc>
  105401:	89 03                	mov    %eax,(%ebx)
	    uint32_t handlerAddr = cpu->ebx;
  105403:	83 7d e4 7f          	cmpl   $0x7f,-0x1c(%ebp)
  105407:	77 19                	ja     105422 <vmm_init+0x5b>
	    if(get_current_task()->rpc_handler_addr == 0) {
  105409:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10540c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10540f:	8b 12                	mov    (%edx),%edx
  105411:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105414:	c1 e1 02             	shl    $0x2,%ecx
  105417:	01 ca                	add    %ecx,%edx
  105419:	8b 12                	mov    (%edx),%edx
  10541b:	89 14 85 00 8c 18 00 	mov    %edx,0x188c00(,%eax,4)
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
	}
  105422:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105425:	8b 00                	mov    (%eax),%eax
  105427:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10542a:	c1 e2 02             	shl    $0x2,%edx
  10542d:	8d 14 10             	lea    (%eax,%edx,1),%edx
  105430:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105433:	8b 00                	mov    (%eax),%eax
  105435:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105438:	c1 e1 02             	shl    $0x2,%ecx
  10543b:	01 c8                	add    %ecx,%eax
  10543d:	8b 00                	mov    (%eax),%eax
  10543f:	83 c8 07             	or     $0x7,%eax
  105442:	89 02                	mov    %eax,(%edx)
	    break;

  105444:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10544b:	eb 68                	jmp    1054b5 <vmm_init+0xee>
	case 33: /* fetch_rpc_data */
  10544d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105450:	89 c2                	mov    %eax,%edx
  105452:	c1 e2 16             	shl    $0x16,%edx
  105455:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105458:	c1 e0 0c             	shl    $0xc,%eax
  10545b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10545e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
	    cpu->eax = 0;
  105461:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105464:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  10546b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10546e:	8b 00                	mov    (%eax),%eax
  105470:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  105473:	c1 e2 02             	shl    $0x2,%edx
  105476:	01 d0                	add    %edx,%eax
  105478:	8b 00                	mov    (%eax),%eax
  10547a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10547f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  105482:	89 c1                	mov    %eax,%ecx
  105484:	81 7d f0 00 10 40 01 	cmpl   $0x1401000,-0x10(%ebp)
  10548b:	76 07                	jbe    105494 <vmm_init+0xcd>
  10548d:	ba 00 02 00 00       	mov    $0x200,%edx
  105492:	eb 05                	jmp    105499 <vmm_init+0xd2>
  105494:	ba 00 00 00 00       	mov    $0x0,%edx
  105499:	81 7d f0 00 10 40 01 	cmpl   $0x1401000,-0x10(%ebp)
  1054a0:	76 07                	jbe    1054a9 <vmm_init+0xe2>
  1054a2:	b8 04 00 00 00       	mov    $0x4,%eax
  1054a7:	eb 05                	jmp    1054ae <vmm_init+0xe7>
  1054a9:	b8 00 00 00 00       	mov    $0x0,%eax
  1054ae:	09 d0                	or     %edx,%eax
  1054b0:	89 01                	mov    %eax,(%ecx)
	    if(get_current_task()->rpc_handler_addr == 0) {
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
	}
	    break;

  1054b2:	ff 45 e8             	incl   -0x18(%ebp)
  1054b5:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  1054bc:	76 8f                	jbe    10544d <vmm_init+0x86>

	    //TODO create RPC for U2U
	}
	    break;

	case 32: /* set_rpc_handler */
  1054be:	ff 45 e4             	incl   -0x1c(%ebp)
  1054c1:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
  1054c8:	0f 86 20 ff ff ff    	jbe    1053ee <vmm_init+0x27>
	    void* dest = (void*) cpu->ebx;
	    if(get_current_task()->rpc != 0) {
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
  1054ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1054d5:	eb 3d                	jmp    105514 <vmm_init+0x14d>
	    break;
  1054d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1054da:	8b 00                	mov    (%eax),%eax
  1054dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1054df:	c1 e2 02             	shl    $0x2,%edx
  1054e2:	01 d0                	add    %edx,%eax
  1054e4:	8b 00                	mov    (%eax),%eax
  1054e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1054eb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	case 40:
  1054ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1054f1:	89 c2                	mov    %eax,%edx
  1054f3:	c1 e2 0c             	shl    $0xc,%edx
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
	    break;

  1054f6:	a1 fc 62 10 00       	mov    0x1062fc,%eax
  1054fb:	01 c2                	add    %eax,%edx
  1054fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105500:	8b 00                	mov    (%eax),%eax
  105502:	6a 00                	push   $0x0
  105504:	ff 75 f4             	pushl  -0xc(%ebp)
  105507:	52                   	push   %edx
  105508:	50                   	push   %eax
  105509:	e8 12 fb ff ff       	call   105020 <map_address_context>
  10550e:	83 c4 10             	add    $0x10,%esp
	    void* dest = (void*) cpu->ebx;
	    if(get_current_task()->rpc != 0) {
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
  105511:	ff 45 e4             	incl   -0x1c(%ebp)
  105514:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
  10551b:	76 ba                	jbe    1054d7 <vmm_init+0x110>
	    break;

	case 40:
	{
	    cpu->eax = register_irq_rpc(cpu->ebx);
	}
  10551d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105520:	a1 00 63 10 00       	mov    0x106300,%eax
  105525:	89 c2                	mov    %eax,%edx
  105527:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10552a:	8b 00                	mov    (%eax),%eax
  10552c:	6a 00                	push   $0x0
  10552e:	51                   	push   %ecx
  10552f:	52                   	push   %edx
  105530:	50                   	push   %eax
  105531:	e8 ea fa ff ff       	call   105020 <map_address_context>
  105536:	83 c4 10             	add    $0x10,%esp
	    break;

	case 201: /* kputc */
  105539:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
  105540:	eb 1d                	jmp    10555f <vmm_init+0x198>
		cpu->eax = kprintf("%c", cpu->ebx);
  105542:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105545:	8b 00                	mov    (%eax),%eax
  105547:	6a 00                	push   $0x0
  105549:	ff 75 e4             	pushl  -0x1c(%ebp)
  10554c:	ff 75 e4             	pushl  -0x1c(%ebp)
  10554f:	50                   	push   %eax
  105550:	e8 cb fa ff ff       	call   105020 <map_address_context>
  105555:	83 c4 10             	add    $0x10,%esp
	{
	    cpu->eax = register_irq_rpc(cpu->ebx);
	}
	    break;

	case 201: /* kputc */
  105558:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  10555f:	b8 00 90 18 00       	mov    $0x189000,%eax
  105564:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  105567:	72 d9                	jb     105542 <vmm_init+0x17b>
		cpu->eax = kprintf("%c", cpu->ebx);
		break;

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
		break;
  105569:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10556c:	8b 00                	mov    (%eax),%eax
  10556e:	83 ec 0c             	sub    $0xc,%esp
  105571:	50                   	push   %eax
  105572:	e8 3d fe ff ff       	call   1053b4 <vmm_activate_pagedir>
  105577:	83 c4 10             	add    $0x10,%esp

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
		break;
  10557a:	0f 20 c0             	mov    %cr0,%eax
  10557d:	89 45 ec             	mov    %eax,-0x14(%ebp)

  105580:	81 4d ec 00 00 00 80 	orl    $0x80000000,-0x14(%ebp)
	case 204: /* vmm_free */
  105587:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10558a:	0f 22 c0             	mov    %eax,%cr0
		cpu->eax = 0;
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  10558d:	a1 00 63 10 00       	mov    0x106300,%eax
  105592:	8b 00                	mov    (%eax),%eax
			vmm_free((void*) cpu->ebx);
  105594:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  105597:	c9                   	leave  
  105598:	c3                   	ret    
