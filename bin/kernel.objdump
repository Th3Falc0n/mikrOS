
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <intr_stub_0-0xc>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 6a                	in     $0x6a,%al

0010000c <intr_stub_0>:
  10000c:	6a 00                	push   $0x0
  10000e:	6a 00                	push   $0x0
  100010:	e9 eb 00 00 00       	jmp    100100 <intr_common_handler>

00100015 <intr_stub_1>:
  100015:	6a 00                	push   $0x0
  100017:	6a 01                	push   $0x1
  100019:	e9 e2 00 00 00       	jmp    100100 <intr_common_handler>

0010001e <intr_stub_2>:
  10001e:	6a 00                	push   $0x0
  100020:	6a 02                	push   $0x2
  100022:	e9 d9 00 00 00       	jmp    100100 <intr_common_handler>

00100027 <intr_stub_3>:
  100027:	6a 00                	push   $0x0
  100029:	6a 03                	push   $0x3
  10002b:	e9 d0 00 00 00       	jmp    100100 <intr_common_handler>

00100030 <intr_stub_4>:
  100030:	6a 00                	push   $0x0
  100032:	6a 04                	push   $0x4
  100034:	e9 c7 00 00 00       	jmp    100100 <intr_common_handler>

00100039 <intr_stub_5>:
  100039:	6a 00                	push   $0x0
  10003b:	6a 05                	push   $0x5
  10003d:	e9 be 00 00 00       	jmp    100100 <intr_common_handler>

00100042 <intr_stub_6>:
  100042:	6a 00                	push   $0x0
  100044:	6a 06                	push   $0x6
  100046:	e9 b5 00 00 00       	jmp    100100 <intr_common_handler>

0010004b <intr_stub_7>:
  10004b:	6a 00                	push   $0x0
  10004d:	6a 07                	push   $0x7
  10004f:	e9 ac 00 00 00       	jmp    100100 <intr_common_handler>

00100054 <intr_stub_8>:
  100054:	6a 08                	push   $0x8
  100056:	e9 a5 00 00 00       	jmp    100100 <intr_common_handler>

0010005b <intr_stub_9>:
  10005b:	6a 00                	push   $0x0
  10005d:	6a 09                	push   $0x9
  10005f:	e9 9c 00 00 00       	jmp    100100 <intr_common_handler>

00100064 <intr_stub_10>:
  100064:	6a 0a                	push   $0xa
  100066:	e9 95 00 00 00       	jmp    100100 <intr_common_handler>

0010006b <intr_stub_11>:
  10006b:	6a 0b                	push   $0xb
  10006d:	e9 8e 00 00 00       	jmp    100100 <intr_common_handler>

00100072 <intr_stub_12>:
  100072:	6a 0c                	push   $0xc
  100074:	e9 87 00 00 00       	jmp    100100 <intr_common_handler>

00100079 <intr_stub_13>:
  100079:	6a 0d                	push   $0xd
  10007b:	e9 80 00 00 00       	jmp    100100 <intr_common_handler>

00100080 <intr_stub_14>:
  100080:	6a 0e                	push   $0xe
  100082:	eb 7c                	jmp    100100 <intr_common_handler>

00100084 <intr_stub_15>:
  100084:	6a 00                	push   $0x0
  100086:	6a 0f                	push   $0xf
  100088:	eb 76                	jmp    100100 <intr_common_handler>

0010008a <intr_stub_16>:
  10008a:	6a 00                	push   $0x0
  10008c:	6a 10                	push   $0x10
  10008e:	eb 70                	jmp    100100 <intr_common_handler>

00100090 <intr_stub_17>:
  100090:	6a 11                	push   $0x11
  100092:	eb 6c                	jmp    100100 <intr_common_handler>

00100094 <intr_stub_18>:
  100094:	6a 00                	push   $0x0
  100096:	6a 12                	push   $0x12
  100098:	eb 66                	jmp    100100 <intr_common_handler>

0010009a <intr_stub_32>:
  10009a:	6a 00                	push   $0x0
  10009c:	6a 20                	push   $0x20
  10009e:	eb 60                	jmp    100100 <intr_common_handler>

001000a0 <intr_stub_33>:
  1000a0:	6a 00                	push   $0x0
  1000a2:	6a 21                	push   $0x21
  1000a4:	eb 5a                	jmp    100100 <intr_common_handler>

001000a6 <intr_stub_34>:
  1000a6:	6a 00                	push   $0x0
  1000a8:	6a 22                	push   $0x22
  1000aa:	eb 54                	jmp    100100 <intr_common_handler>

001000ac <intr_stub_35>:
  1000ac:	6a 00                	push   $0x0
  1000ae:	6a 23                	push   $0x23
  1000b0:	eb 4e                	jmp    100100 <intr_common_handler>

001000b2 <intr_stub_36>:
  1000b2:	6a 00                	push   $0x0
  1000b4:	6a 24                	push   $0x24
  1000b6:	eb 48                	jmp    100100 <intr_common_handler>

001000b8 <intr_stub_37>:
  1000b8:	6a 00                	push   $0x0
  1000ba:	6a 25                	push   $0x25
  1000bc:	eb 42                	jmp    100100 <intr_common_handler>

001000be <intr_stub_38>:
  1000be:	6a 00                	push   $0x0
  1000c0:	6a 26                	push   $0x26
  1000c2:	eb 3c                	jmp    100100 <intr_common_handler>

001000c4 <intr_stub_39>:
  1000c4:	6a 00                	push   $0x0
  1000c6:	6a 27                	push   $0x27
  1000c8:	eb 36                	jmp    100100 <intr_common_handler>

001000ca <intr_stub_40>:
  1000ca:	6a 00                	push   $0x0
  1000cc:	6a 28                	push   $0x28
  1000ce:	eb 30                	jmp    100100 <intr_common_handler>

001000d0 <intr_stub_41>:
  1000d0:	6a 00                	push   $0x0
  1000d2:	6a 29                	push   $0x29
  1000d4:	eb 2a                	jmp    100100 <intr_common_handler>

001000d6 <intr_stub_42>:
  1000d6:	6a 00                	push   $0x0
  1000d8:	6a 2a                	push   $0x2a
  1000da:	eb 24                	jmp    100100 <intr_common_handler>

001000dc <intr_stub_43>:
  1000dc:	6a 00                	push   $0x0
  1000de:	6a 2b                	push   $0x2b
  1000e0:	eb 1e                	jmp    100100 <intr_common_handler>

001000e2 <intr_stub_44>:
  1000e2:	6a 00                	push   $0x0
  1000e4:	6a 2c                	push   $0x2c
  1000e6:	eb 18                	jmp    100100 <intr_common_handler>

001000e8 <intr_stub_45>:
  1000e8:	6a 00                	push   $0x0
  1000ea:	6a 2d                	push   $0x2d
  1000ec:	eb 12                	jmp    100100 <intr_common_handler>

001000ee <intr_stub_46>:
  1000ee:	6a 00                	push   $0x0
  1000f0:	6a 2e                	push   $0x2e
  1000f2:	eb 0c                	jmp    100100 <intr_common_handler>

001000f4 <intr_stub_47>:
  1000f4:	6a 00                	push   $0x0
  1000f6:	6a 2f                	push   $0x2f
  1000f8:	eb 06                	jmp    100100 <intr_common_handler>

001000fa <intr_stub_48>:
  1000fa:	6a 00                	push   $0x0
  1000fc:	6a 30                	push   $0x30
  1000fe:	eb 00                	jmp    100100 <intr_common_handler>

00100100 <intr_common_handler>:
  100100:	55                   	push   %ebp
  100101:	57                   	push   %edi
  100102:	56                   	push   %esi
  100103:	52                   	push   %edx
  100104:	51                   	push   %ecx
  100105:	53                   	push   %ebx
  100106:	50                   	push   %eax
  100107:	54                   	push   %esp
  100108:	66 b8 10 00          	mov    $0x10,%ax
  10010c:	8e d8                	mov    %eax,%ds
  10010e:	8e c0                	mov    %eax,%es
  100110:	e8 8c 0e 00 00       	call   100fa1 <handle_interrupt>
  100115:	89 c4                	mov    %eax,%esp
  100117:	66 b8 23 00          	mov    $0x23,%ax
  10011b:	8e d8                	mov    %eax,%ds
  10011d:	8e c0                	mov    %eax,%es
  10011f:	58                   	pop    %eax
  100120:	5b                   	pop    %ebx
  100121:	59                   	pop    %ecx
  100122:	5a                   	pop    %edx
  100123:	5e                   	pop    %esi
  100124:	5f                   	pop    %edi
  100125:	5d                   	pop    %ebp
  100126:	83 c4 08             	add    $0x8,%esp
  100129:	cf                   	iret   
	...

0010012c <_start>:
  10012c:	bc 00 80 11 00       	mov    $0x118000,%esp
  100131:	53                   	push   %ebx
  100132:	e8 05 00 00 00       	call   10013c <init>

00100137 <_stop>:
  100137:	fa                   	cli    
  100138:	f4                   	hlt    
  100139:	eb fc                	jmp    100137 <_stop>
	...

0010013c <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
  10013c:	55                   	push   %ebp
  10013d:	89 e5                	mov    %esp,%ebp
  10013f:	83 ec 08             	sub    $0x8,%esp
	clrscr();
  100142:	e8 c9 03 00 00       	call   100510 <clrscr>
	pmm_init(mb_info);
  100147:	83 ec 0c             	sub    $0xc,%esp
  10014a:	ff 75 08             	pushl  0x8(%ebp)
  10014d:	e8 fa 1a 00 00       	call   101c4c <pmm_init>
  100152:	83 c4 10             	add    $0x10,%esp

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100155:	83 ec 08             	sub    $0x8,%esp
  100158:	68 00 70 10 00       	push   $0x107000
  10015d:	68 14 70 10 00       	push   $0x107014
  100162:	e8 06 04 00 00       	call   10056d <kprintf>
  100167:	83 c4 10             	add    $0x10,%esp
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10016a:	83 ec 0c             	sub    $0xc,%esp
  10016d:	68 38 70 10 00       	push   $0x107038
  100172:	e8 f6 03 00 00       	call   10056d <kprintf>
  100177:	83 c4 10             	add    $0x10,%esp

	kprintf("Initializing GDT...\n");
  10017a:	83 ec 0c             	sub    $0xc,%esp
  10017d:	68 77 70 10 00       	push   $0x107077
  100182:	e8 e6 03 00 00       	call   10056d <kprintf>
  100187:	83 c4 10             	add    $0x10,%esp

	init_gdt();
  10018a:	e8 67 07 00 00       	call   1008f6 <init_gdt>

	kprintf("Initializing IDT...\n");
  10018f:	83 ec 0c             	sub    $0xc,%esp
  100192:	68 8c 70 10 00       	push   $0x10708c
  100197:	e8 d1 03 00 00       	call   10056d <kprintf>
  10019c:	83 c4 10             	add    $0x10,%esp

	init_idt();
  10019f:	e8 eb 08 00 00       	call   100a8f <init_idt>

	kprintf("Initializing Kernel...\n");
  1001a4:	83 ec 0c             	sub    $0xc,%esp
  1001a7:	68 a1 70 10 00       	push   $0x1070a1
  1001ac:	e8 bc 03 00 00       	call   10056d <kprintf>
  1001b1:	83 c4 10             	add    $0x10,%esp

	pmm_print_stats();
  1001b4:	e8 20 19 00 00       	call   101ad9 <pmm_print_stats>

	kernel_main(mb_info);
  1001b9:	83 ec 0c             	sub    $0xc,%esp
  1001bc:	ff 75 08             	pushl  0x8(%ebp)
  1001bf:	e8 aa 16 00 00       	call   10186e <kernel_main>
  1001c4:	83 c4 10             	add    $0x10,%esp

	return;
}
  1001c7:	c9                   	leave  
  1001c8:	c3                   	ret    
  1001c9:	00 00                	add    %al,(%eax)
	...

001001cc <in_cod>:
#include "console.h"
#include "gdt.h"
#include "idt.h"
#include "kernel.h"
#include "multiboot.h"
  1001cc:	55                   	push   %ebp
  1001cd:	89 e5                	mov    %esp,%ebp
#include "pmm.h"
  1001cf:	a1 00 80 12 00       	mov    0x128000,%eax
#include "vfs.h"
  1001d4:	5d                   	pop    %ebp
  1001d5:	c3                   	ret    

001001d6 <show_cod>:

#define _VERSION "alphaUSpaceDev 1.02"
  1001d6:	55                   	push   %ebp
  1001d7:	89 e5                	mov    %esp,%ebp
  1001d9:	83 ec 08             	sub    $0x8,%esp

  1001dc:	c7 05 00 80 12 00 01 	movl   $0x1,0x128000
  1001e3:	00 00 00 
	kprintf("Initializing Kernel...\n");

	pmm_print_stats();

	kernel_main(mb_info);

  1001e6:	83 ec 0c             	sub    $0xc,%esp
  1001e9:	6a 04                	push   $0x4
  1001eb:	e8 67 03 00 00       	call   100557 <setclr>
  1001f0:	83 c4 10             	add    $0x10,%esp
	return;
  1001f3:	83 ec 0c             	sub    $0xc,%esp
  1001f6:	ff 75 0c             	pushl  0xc(%ebp)
  1001f9:	e8 6f 03 00 00       	call   10056d <kprintf>
  1001fe:	83 c4 10             	add    $0x10,%esp
}
  100201:	8b 45 08             	mov    0x8(%ebp),%eax
  100204:	8b 50 20             	mov    0x20(%eax),%edx
  100207:	8b 45 08             	mov    0x8(%ebp),%eax
  10020a:	8b 40 1c             	mov    0x1c(%eax),%eax
  10020d:	83 ec 04             	sub    $0x4,%esp
  100210:	52                   	push   %edx
  100211:	50                   	push   %eax
  100212:	68 bc 70 10 00       	push   $0x1070bc
  100217:	e8 51 03 00 00       	call   10056d <kprintf>
  10021c:	83 c4 10             	add    $0x10,%esp
  10021f:	83 ec 0c             	sub    $0xc,%esp
  100222:	ff 75 08             	pushl  0x8(%ebp)
  100225:	e8 07 00 00 00       	call   100231 <show_dump>
  10022a:	83 c4 10             	add    $0x10,%esp
  10022d:	fa                   	cli    
  10022e:	f4                   	hlt    
  10022f:	eb fc                	jmp    10022d <show_cod+0x57>

00100231 <show_dump>:
  100231:	55                   	push   %ebp
  100232:	89 e5                	mov    %esp,%ebp
  100234:	53                   	push   %ebx
  100235:	83 ec 14             	sub    $0x14,%esp
  100238:	8b 45 08             	mov    0x8(%ebp),%eax
  10023b:	8b 58 0c             	mov    0xc(%eax),%ebx
  10023e:	8b 45 08             	mov    0x8(%ebp),%eax
  100241:	8b 48 08             	mov    0x8(%eax),%ecx
  100244:	8b 45 08             	mov    0x8(%ebp),%eax
  100247:	8b 50 04             	mov    0x4(%eax),%edx
  10024a:	8b 45 08             	mov    0x8(%ebp),%eax
  10024d:	8b 00                	mov    (%eax),%eax
  10024f:	83 ec 0c             	sub    $0xc,%esp
  100252:	53                   	push   %ebx
  100253:	51                   	push   %ecx
  100254:	52                   	push   %edx
  100255:	50                   	push   %eax
  100256:	68 e4 70 10 00       	push   $0x1070e4
  10025b:	e8 0d 03 00 00       	call   10056d <kprintf>
  100260:	83 c4 20             	add    $0x20,%esp
  100263:	8b 45 08             	mov    0x8(%ebp),%eax
  100266:	8b 58 24             	mov    0x24(%eax),%ebx
  100269:	8b 45 08             	mov    0x8(%ebp),%eax
  10026c:	8b 48 18             	mov    0x18(%eax),%ecx
  10026f:	8b 45 08             	mov    0x8(%ebp),%eax
  100272:	8b 50 14             	mov    0x14(%eax),%edx
  100275:	8b 45 08             	mov    0x8(%ebp),%eax
  100278:	8b 40 10             	mov    0x10(%eax),%eax
  10027b:	83 ec 0c             	sub    $0xc,%esp
  10027e:	53                   	push   %ebx
  10027f:	51                   	push   %ecx
  100280:	52                   	push   %edx
  100281:	50                   	push   %eax
  100282:	68 08 71 10 00       	push   $0x107108
  100287:	e8 e1 02 00 00       	call   10056d <kprintf>
  10028c:	83 c4 20             	add    $0x20,%esp
  10028f:	8b 45 08             	mov    0x8(%ebp),%eax
  100292:	8b 58 34             	mov    0x34(%eax),%ebx
  100295:	8b 45 08             	mov    0x8(%ebp),%eax
  100298:	8b 48 30             	mov    0x30(%eax),%ecx
  10029b:	8b 45 08             	mov    0x8(%ebp),%eax
  10029e:	8b 50 2c             	mov    0x2c(%eax),%edx
  1002a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002a4:	8b 40 28             	mov    0x28(%eax),%eax
  1002a7:	83 ec 0c             	sub    $0xc,%esp
  1002aa:	53                   	push   %ebx
  1002ab:	51                   	push   %ecx
  1002ac:	52                   	push   %edx
  1002ad:	50                   	push   %eax
  1002ae:	68 2c 71 10 00       	push   $0x10712c
  1002b3:	e8 b5 02 00 00       	call   10056d <kprintf>
  1002b8:	83 c4 20             	add    $0x20,%esp
  1002bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1002c2:	0f 20 d0             	mov    %cr2,%eax
  1002c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1002c8:	83 ec 08             	sub    $0x8,%esp
  1002cb:	ff 75 f4             	pushl  -0xc(%ebp)
  1002ce:	68 4e 71 10 00       	push   $0x10714e
  1002d3:	e8 95 02 00 00       	call   10056d <kprintf>
  1002d8:	83 c4 10             	add    $0x10,%esp
  1002db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1002de:	c9                   	leave  
  1002df:	c3                   	ret    

001002e0 <kputc>:
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
	clrscr();
  1002e0:	55                   	push   %ebp
  1002e1:	89 e5                	mov    %esp,%ebp
  1002e3:	83 ec 28             	sub    $0x28,%esp
  1002e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002e9:	88 45 e4             	mov    %al,-0x1c(%ebp)
	pmm_init(mb_info);
  1002ec:	e8 db fe ff ff       	call   1001cc <in_cod>
  1002f1:	85 c0                	test   %eax,%eax
  1002f3:	75 79                	jne    10036e <kputc+0x8e>

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");

  1002f5:	e8 3b 28 00 00       	call   102b35 <get_current_task>
  1002fa:	85 c0                	test   %eax,%eax
  1002fc:	74 61                	je     10035f <kputc+0x7f>
	kprintf("Initializing GDT...\n");
  1002fe:	e8 32 28 00 00       	call   102b35 <get_current_task>
  100303:	8b 40 30             	mov    0x30(%eax),%eax
  100306:	85 c0                	test   %eax,%eax
  100308:	74 55                	je     10035f <kputc+0x7f>

  10030a:	c6 45 f3 11          	movb   $0x11,-0xd(%ebp)
  10030e:	e8 22 28 00 00       	call   102b35 <get_current_task>
  100313:	8b 40 30             	mov    0x30(%eax),%eax
  100316:	6a 01                	push   $0x1
  100318:	6a 01                	push   $0x1
  10031a:	8d 55 f3             	lea    -0xd(%ebp),%edx
  10031d:	52                   	push   %edx
  10031e:	50                   	push   %eax
  10031f:	e8 63 40 00 00       	call   104387 <vfs_write>
  100324:	83 c4 10             	add    $0x10,%esp
	init_gdt();
  100327:	e8 09 28 00 00       	call   102b35 <get_current_task>
  10032c:	8b 40 30             	mov    0x30(%eax),%eax
  10032f:	6a 01                	push   $0x1
  100331:	6a 01                	push   $0x1
  100333:	68 00 60 10 00       	push   $0x106000
  100338:	50                   	push   %eax
  100339:	e8 49 40 00 00       	call   104387 <vfs_write>
  10033e:	83 c4 10             	add    $0x10,%esp

  100341:	e8 ef 27 00 00       	call   102b35 <get_current_task>
  100346:	8b 40 30             	mov    0x30(%eax),%eax
  100349:	6a 01                	push   $0x1
  10034b:	6a 01                	push   $0x1
  10034d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  100350:	52                   	push   %edx
  100351:	50                   	push   %eax
  100352:	e8 30 40 00 00       	call   104387 <vfs_write>
  100357:	83 c4 10             	add    $0x10,%esp
	kprintf("Initializing IDT...\n");

  10035a:	e9 1a 01 00 00       	jmp    100479 <kputc+0x199>
	init_idt();

	kprintf("Initializing Kernel...\n");

  10035f:	e8 d2 25 00 00       	call   102936 <ramfs_vga_writers>
  100364:	85 c0                	test   %eax,%eax
  100366:	0f 85 09 01 00 00    	jne    100475 <kputc+0x195>
  10036c:	eb 01                	jmp    10036f <kputc+0x8f>
#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
	clrscr();
	pmm_init(mb_info);

  10036e:	90                   	nop    
	pmm_print_stats();

	kernel_main(mb_info);

	return;
}
  10036f:	8a 45 e4             	mov    -0x1c(%ebp),%al
  100372:	3c 0a                	cmp    $0xa,%al
  100374:	74 0a                	je     100380 <kputc+0xa0>
  100376:	a1 04 80 12 00       	mov    0x128004,%eax
  10037b:	83 f8 4f             	cmp    $0x4f,%eax
  10037e:	7e 15                	jle    100395 <kputc+0xb5>
  100380:	c7 05 04 80 12 00 00 	movl   $0x0,0x128004
  100387:	00 00 00 
  10038a:	a1 08 80 12 00       	mov    0x128008,%eax
  10038f:	40                   	inc    %eax
  100390:	a3 08 80 12 00       	mov    %eax,0x128008
  100395:	8a 45 e4             	mov    -0x1c(%ebp),%al
  100398:	3c 0a                	cmp    $0xa,%al
  10039a:	0f 84 d8 00 00 00    	je     100478 <kputc+0x198>
  1003a0:	a1 08 80 12 00       	mov    0x128008,%eax
  1003a5:	83 f8 18             	cmp    $0x18,%eax
  1003a8:	7e 5c                	jle    100406 <kputc+0x126>
  1003aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1003b1:	eb 22                	jmp    1003d5 <kputc+0xf5>
  1003b3:	8b 15 04 60 10 00    	mov    0x106004,%edx
  1003b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003bc:	01 c2                	add    %eax,%edx
  1003be:	a1 04 60 10 00       	mov    0x106004,%eax
  1003c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1003c6:	81 c1 a0 00 00 00    	add    $0xa0,%ecx
  1003cc:	01 c8                	add    %ecx,%eax
  1003ce:	8a 00                	mov    (%eax),%al
  1003d0:	88 02                	mov    %al,(%edx)
  1003d2:	ff 45 f4             	incl   -0xc(%ebp)
  1003d5:	81 7d f4 ff 0e 00 00 	cmpl   $0xeff,-0xc(%ebp)
  1003dc:	7e d5                	jle    1003b3 <kputc+0xd3>
  1003de:	eb 12                	jmp    1003f2 <kputc+0x112>
  1003e0:	8b 15 04 60 10 00    	mov    0x106004,%edx
  1003e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003e9:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1003ec:	c6 00 00             	movb   $0x0,(%eax)
  1003ef:	ff 45 f4             	incl   -0xc(%ebp)
  1003f2:	81 7d f4 9f 0f 00 00 	cmpl   $0xf9f,-0xc(%ebp)
  1003f9:	7e e5                	jle    1003e0 <kputc+0x100>
  1003fb:	a1 08 80 12 00       	mov    0x128008,%eax
  100400:	48                   	dec    %eax
  100401:	a3 08 80 12 00       	mov    %eax,0x128008
  100406:	8b 0d 04 60 10 00    	mov    0x106004,%ecx
  10040c:	8b 15 08 80 12 00    	mov    0x128008,%edx
  100412:	89 d0                	mov    %edx,%eax
  100414:	c1 e0 02             	shl    $0x2,%eax
  100417:	01 d0                	add    %edx,%eax
  100419:	c1 e0 04             	shl    $0x4,%eax
  10041c:	89 c2                	mov    %eax,%edx
  10041e:	a1 04 80 12 00       	mov    0x128004,%eax
  100423:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100426:	01 c0                	add    %eax,%eax
  100428:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  10042b:	8a 45 e4             	mov    -0x1c(%ebp),%al
  10042e:	88 02                	mov    %al,(%edx)
  100430:	8b 0d 04 60 10 00    	mov    0x106004,%ecx
  100436:	8b 15 08 80 12 00    	mov    0x128008,%edx
  10043c:	89 d0                	mov    %edx,%eax
  10043e:	c1 e0 02             	shl    $0x2,%eax
  100441:	01 d0                	add    %edx,%eax
  100443:	c1 e0 04             	shl    $0x4,%eax
  100446:	89 c2                	mov    %eax,%edx
  100448:	a1 04 80 12 00       	mov    0x128004,%eax
  10044d:	8d 04 02             	lea    (%edx,%eax,1),%eax
  100450:	01 c0                	add    %eax,%eax
  100452:	40                   	inc    %eax
  100453:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  100456:	a0 00 60 10 00       	mov    0x106000,%al
  10045b:	88 02                	mov    %al,(%edx)
  10045d:	a1 04 80 12 00       	mov    0x128004,%eax
  100462:	40                   	inc    %eax
  100463:	a3 04 80 12 00       	mov    %eax,0x128004
  100468:	a1 0c 80 12 00       	mov    0x12800c,%eax
  10046d:	40                   	inc    %eax
  10046e:	a3 0c 80 12 00       	mov    %eax,0x12800c
  100473:	eb 04                	jmp    100479 <kputc+0x199>

	init_idt();

	kprintf("Initializing Kernel...\n");

	pmm_print_stats();
  100475:	90                   	nop    
  100476:	eb 01                	jmp    100479 <kputc+0x199>
  100478:	90                   	nop    
  100479:	c9                   	leave  
  10047a:	c3                   	ret    

0010047b <kputs>:
  10047b:	55                   	push   %ebp
  10047c:	89 e5                	mov    %esp,%ebp
  10047e:	83 ec 08             	sub    $0x8,%esp
  100481:	eb 17                	jmp    10049a <kputs+0x1f>
  100483:	8b 45 08             	mov    0x8(%ebp),%eax
  100486:	8a 00                	mov    (%eax),%al
  100488:	0f be c0             	movsbl %al,%eax
  10048b:	ff 45 08             	incl   0x8(%ebp)
  10048e:	83 ec 0c             	sub    $0xc,%esp
  100491:	50                   	push   %eax
  100492:	e8 49 fe ff ff       	call   1002e0 <kputc>
  100497:	83 c4 10             	add    $0x10,%esp
  10049a:	8b 45 08             	mov    0x8(%ebp),%eax
  10049d:	8a 00                	mov    (%eax),%al
  10049f:	84 c0                	test   %al,%al
  1004a1:	75 e0                	jne    100483 <kputs+0x8>
  1004a3:	c9                   	leave  
  1004a4:	c3                   	ret    

001004a5 <kputn>:
  1004a5:	55                   	push   %ebp
  1004a6:	89 e5                	mov    %esp,%ebp
  1004a8:	83 ec 58             	sub    $0x58,%esp
  1004ab:	c7 45 f0 58 71 10 00 	movl   $0x107158,-0x10(%ebp)
  1004b2:	83 7d 0c 24          	cmpl   $0x24,0xc(%ebp)
  1004b6:	7f 55                	jg     10050d <kputn+0x68>
  1004b8:	8d 45 af             	lea    -0x51(%ebp),%eax
  1004bb:	83 c0 40             	add    $0x40,%eax
  1004be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1004c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1004c4:	c6 00 00             	movb   $0x0,(%eax)
  1004c7:	ff 4d f4             	decl   -0xc(%ebp)
  1004ca:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1004d0:	89 d1                	mov    %edx,%ecx
  1004d2:	ba 00 00 00 00       	mov    $0x0,%edx
  1004d7:	f7 f1                	div    %ecx
  1004d9:	89 d0                	mov    %edx,%eax
  1004db:	03 45 f0             	add    -0x10(%ebp),%eax
  1004de:	8a 10                	mov    (%eax),%dl
  1004e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1004e3:	88 10                	mov    %dl,(%eax)
  1004e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1004e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1004eb:	89 d1                	mov    %edx,%ecx
  1004ed:	ba 00 00 00 00       	mov    $0x0,%edx
  1004f2:	f7 f1                	div    %ecx
  1004f4:	89 45 08             	mov    %eax,0x8(%ebp)
  1004f7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1004fb:	75 ca                	jne    1004c7 <kputn+0x22>
  1004fd:	83 ec 0c             	sub    $0xc,%esp
  100500:	ff 75 f4             	pushl  -0xc(%ebp)
  100503:	e8 73 ff ff ff       	call   10047b <kputs>
  100508:	83 c4 10             	add    $0x10,%esp
  10050b:	eb 01                	jmp    10050e <kputn+0x69>
  10050d:	90                   	nop    
  10050e:	c9                   	leave  
  10050f:	c3                   	ret    

00100510 <clrscr>:
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	83 ec 10             	sub    $0x10,%esp
  100516:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10051d:	eb 12                	jmp    100531 <clrscr+0x21>
  10051f:	8b 15 04 60 10 00    	mov    0x106004,%edx
  100525:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100528:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10052b:	c6 00 00             	movb   $0x0,(%eax)
  10052e:	ff 45 fc             	incl   -0x4(%ebp)
  100531:	81 7d fc 9f 0f 00 00 	cmpl   $0xf9f,-0x4(%ebp)
  100538:	7e e5                	jle    10051f <clrscr+0xf>
  10053a:	c6 05 00 60 10 00 07 	movb   $0x7,0x106000
  100541:	c7 05 08 80 12 00 00 	movl   $0x0,0x128008
  100548:	00 00 00 
  10054b:	a1 08 80 12 00       	mov    0x128008,%eax
  100550:	a3 04 80 12 00       	mov    %eax,0x128004
  100555:	c9                   	leave  
  100556:	c3                   	ret    

00100557 <setclr>:
  100557:	55                   	push   %ebp
  100558:	89 e5                	mov    %esp,%ebp
  10055a:	83 ec 04             	sub    $0x4,%esp
  10055d:	8b 45 08             	mov    0x8(%ebp),%eax
  100560:	88 45 fc             	mov    %al,-0x4(%ebp)
  100563:	8a 45 fc             	mov    -0x4(%ebp),%al
  100566:	a2 00 60 10 00       	mov    %al,0x106000
  10056b:	c9                   	leave  
  10056c:	c3                   	ret    

0010056d <kprintf>:
  10056d:	55                   	push   %ebp
  10056e:	89 e5                	mov    %esp,%ebp
  100570:	83 ec 18             	sub    $0x18,%esp
  100573:	8d 45 0c             	lea    0xc(%ebp),%eax
  100576:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100579:	c7 05 0c 80 12 00 00 	movl   $0x0,0x12800c
  100580:	00 00 00 
  100583:	e9 35 01 00 00       	jmp    1006bd <kprintf+0x150>
  100588:	8b 45 08             	mov    0x8(%ebp),%eax
  10058b:	8a 00                	mov    (%eax),%al
  10058d:	3c 25                	cmp    $0x25,%al
  10058f:	0f 85 11 01 00 00    	jne    1006a6 <kprintf+0x139>
  100595:	ff 45 08             	incl   0x8(%ebp)
  100598:	8b 45 08             	mov    0x8(%ebp),%eax
  10059b:	8a 00                	mov    (%eax),%al
  10059d:	0f be c0             	movsbl %al,%eax
  1005a0:	83 f8 70             	cmp    $0x70,%eax
  1005a3:	0f 84 8a 00 00 00    	je     100633 <kprintf+0xc6>
  1005a9:	83 f8 70             	cmp    $0x70,%eax
  1005ac:	7f 2e                	jg     1005dc <kprintf+0x6f>
  1005ae:	83 f8 63             	cmp    $0x63,%eax
  1005b1:	0f 84 9c 00 00 00    	je     100653 <kprintf+0xe6>
  1005b7:	83 f8 63             	cmp    $0x63,%eax
  1005ba:	7f 16                	jg     1005d2 <kprintf+0x65>
  1005bc:	85 c0                	test   %eax,%eax
  1005be:	0f 84 08 01 00 00    	je     1006cc <kprintf+0x15f>
  1005c4:	83 f8 25             	cmp    $0x25,%eax
  1005c7:	0f 84 a6 00 00 00    	je     100673 <kprintf+0x106>
  1005cd:	e9 b1 00 00 00       	jmp    100683 <kprintf+0x116>
  1005d2:	83 f8 64             	cmp    $0x64,%eax
  1005d5:	74 39                	je     100610 <kprintf+0xa3>
  1005d7:	e9 a7 00 00 00       	jmp    100683 <kprintf+0x116>
  1005dc:	83 f8 75             	cmp    $0x75,%eax
  1005df:	74 2f                	je     100610 <kprintf+0xa3>
  1005e1:	83 f8 78             	cmp    $0x78,%eax
  1005e4:	74 4d                	je     100633 <kprintf+0xc6>
  1005e6:	83 f8 73             	cmp    $0x73,%eax
  1005e9:	0f 85 94 00 00 00    	jne    100683 <kprintf+0x116>
  1005ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005f2:	8d 50 04             	lea    0x4(%eax),%edx
  1005f5:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1005f8:	8b 00                	mov    (%eax),%eax
  1005fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1005fd:	83 ec 0c             	sub    $0xc,%esp
  100600:	ff 75 ec             	pushl  -0x14(%ebp)
  100603:	e8 73 fe ff ff       	call   10047b <kputs>
  100608:	83 c4 10             	add    $0x10,%esp
  10060b:	e9 aa 00 00 00       	jmp    1006ba <kprintf+0x14d>
  100610:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100613:	8d 50 04             	lea    0x4(%eax),%edx
  100616:	89 55 e8             	mov    %edx,-0x18(%ebp)
  100619:	8b 00                	mov    (%eax),%eax
  10061b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10061e:	83 ec 08             	sub    $0x8,%esp
  100621:	6a 0a                	push   $0xa
  100623:	ff 75 f0             	pushl  -0x10(%ebp)
  100626:	e8 7a fe ff ff       	call   1004a5 <kputn>
  10062b:	83 c4 10             	add    $0x10,%esp
  10062e:	e9 87 00 00 00       	jmp    1006ba <kprintf+0x14d>
  100633:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100636:	8d 50 04             	lea    0x4(%eax),%edx
  100639:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10063c:	8b 00                	mov    (%eax),%eax
  10063e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100641:	83 ec 08             	sub    $0x8,%esp
  100644:	6a 10                	push   $0x10
  100646:	ff 75 f0             	pushl  -0x10(%ebp)
  100649:	e8 57 fe ff ff       	call   1004a5 <kputn>
  10064e:	83 c4 10             	add    $0x10,%esp
  100651:	eb 67                	jmp    1006ba <kprintf+0x14d>
  100653:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100656:	8d 50 04             	lea    0x4(%eax),%edx
  100659:	89 55 e8             	mov    %edx,-0x18(%ebp)
  10065c:	8b 00                	mov    (%eax),%eax
  10065e:	88 45 f7             	mov    %al,-0x9(%ebp)
  100661:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
  100665:	83 ec 0c             	sub    $0xc,%esp
  100668:	50                   	push   %eax
  100669:	e8 72 fc ff ff       	call   1002e0 <kputc>
  10066e:	83 c4 10             	add    $0x10,%esp
  100671:	eb 47                	jmp    1006ba <kprintf+0x14d>
  100673:	83 ec 0c             	sub    $0xc,%esp
  100676:	6a 25                	push   $0x25
  100678:	e8 63 fc ff ff       	call   1002e0 <kputc>
  10067d:	83 c4 10             	add    $0x10,%esp
  100680:	90                   	nop    
  100681:	eb 37                	jmp    1006ba <kprintf+0x14d>
  100683:	83 ec 0c             	sub    $0xc,%esp
  100686:	6a 25                	push   $0x25
  100688:	e8 53 fc ff ff       	call   1002e0 <kputc>
  10068d:	83 c4 10             	add    $0x10,%esp
  100690:	8b 45 08             	mov    0x8(%ebp),%eax
  100693:	8a 00                	mov    (%eax),%al
  100695:	0f be c0             	movsbl %al,%eax
  100698:	83 ec 0c             	sub    $0xc,%esp
  10069b:	50                   	push   %eax
  10069c:	e8 3f fc ff ff       	call   1002e0 <kputc>
  1006a1:	83 c4 10             	add    $0x10,%esp
  1006a4:	eb 14                	jmp    1006ba <kprintf+0x14d>
  1006a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1006a9:	8a 00                	mov    (%eax),%al
  1006ab:	0f be c0             	movsbl %al,%eax
  1006ae:	83 ec 0c             	sub    $0xc,%esp
  1006b1:	50                   	push   %eax
  1006b2:	e8 29 fc ff ff       	call   1002e0 <kputc>
  1006b7:	83 c4 10             	add    $0x10,%esp
  1006ba:	ff 45 08             	incl   0x8(%ebp)
  1006bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1006c0:	8a 00                	mov    (%eax),%al
  1006c2:	84 c0                	test   %al,%al
  1006c4:	0f 85 be fe ff ff    	jne    100588 <kprintf+0x1b>
  1006ca:	eb 01                	jmp    1006cd <kprintf+0x160>
  1006cc:	90                   	nop    
  1006cd:	a1 0c 80 12 00       	mov    0x12800c,%eax
  1006d2:	c9                   	leave  
  1006d3:	c3                   	ret    

001006d4 <load_gdt>:
#include "idt.h"
#include "kernel.h"
#include "multiboot.h"
#include "pmm.h"
#include "vfs.h"

  1006d4:	55                   	push   %ebp
  1006d5:	89 e5                	mov    %esp,%ebp
  1006d7:	83 ec 10             	sub    $0x10,%esp
#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
	clrscr();
	pmm_init(mb_info);
  1006da:	66 c7 45 fa 2f 00    	movw   $0x2f,-0x6(%ebp)
  1006e0:	c7 45 fc 80 85 16 00 	movl   $0x168580,-0x4(%ebp)

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  1006e7:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");

  1006eb:	66 b8 10 00          	mov    $0x10,%ax
	kprintf("Initializing GDT...\n");
  1006ef:	8e d8                	mov    %eax,%ds

  1006f1:	8e c0                	mov    %eax,%es
	init_gdt();
  1006f3:	8e e0                	mov    %eax,%fs

  1006f5:	8e e8                	mov    %eax,%gs
	kprintf("Initializing IDT...\n");
  1006f7:	8e d0                	mov    %eax,%ss

	init_idt();

  1006f9:	c9                   	leave  
  1006fa:	c3                   	ret    

001006fb <set_gdt_entry>:
	kprintf("Initializing Kernel...\n");

  1006fb:	55                   	push   %ebp
  1006fc:	89 e5                	mov    %esp,%ebp
  1006fe:	57                   	push   %edi
  1006ff:	56                   	push   %esi
  100700:	53                   	push   %ebx
  100701:	83 ec 4c             	sub    $0x4c,%esp
	pmm_print_stats();
  100704:	8b 45 08             	mov    0x8(%ebp),%eax
  100707:	89 45 a8             	mov    %eax,-0x58(%ebp)
  10070a:	8b 45 10             	mov    0x10(%ebp),%eax
  10070d:	ba 00 00 00 00       	mov    $0x0,%edx
  100712:	0f b7 c8             	movzwl %ax,%ecx
  100715:	89 d3                	mov    %edx,%ebx
  100717:	83 e3 00             	and    $0x0,%ebx
  10071a:	8b 55 a8             	mov    -0x58(%ebp),%edx
  10071d:	89 0c d5 80 85 16 00 	mov    %ecx,0x168580(,%edx,8)
  100724:	89 1c d5 84 85 16 00 	mov    %ebx,0x168584(,%edx,8)

  10072b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10072e:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  100731:	8b 45 08             	mov    0x8(%ebp),%eax
  100734:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  10073b:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  100742:	8b 45 0c             	mov    0xc(%ebp),%eax
  100745:	ba 00 00 00 00       	mov    $0x0,%edx
  10074a:	89 c6                	mov    %eax,%esi
  10074c:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
  100752:	89 d7                	mov    %edx,%edi
  100754:	83 e7 00             	and    $0x0,%edi
  100757:	89 f0                	mov    %esi,%eax
  100759:	89 fa                	mov    %edi,%edx
  10075b:	0f a4 c2 10          	shld   $0x10,%eax,%edx
  10075f:	c1 e0 10             	shl    $0x10,%eax
  100762:	89 ce                	mov    %ecx,%esi
  100764:	09 c6                	or     %eax,%esi
  100766:	89 75 b0             	mov    %esi,-0x50(%ebp)
  100769:	89 df                	mov    %ebx,%edi
  10076b:	09 d7                	or     %edx,%edi
  10076d:	89 7d b4             	mov    %edi,-0x4c(%ebp)
  100770:	8b 45 b0             	mov    -0x50(%ebp),%eax
  100773:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  100776:	8b 4d ac             	mov    -0x54(%ebp),%ecx
  100779:	89 04 cd 80 85 16 00 	mov    %eax,0x168580(,%ecx,8)
  100780:	89 14 cd 84 85 16 00 	mov    %edx,0x168584(,%ecx,8)
	kernel_main(mb_info);
  100787:	8b 75 08             	mov    0x8(%ebp),%esi
  10078a:	8b 45 08             	mov    0x8(%ebp),%eax
  10078d:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  100794:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  10079b:	8b 45 14             	mov    0x14(%ebp),%eax
  10079e:	89 c2                	mov    %eax,%edx
  1007a0:	c1 fa 1f             	sar    $0x1f,%edx
  1007a3:	0f b6 f8             	movzbl %al,%edi
  1007a6:	89 7d b8             	mov    %edi,-0x48(%ebp)
  1007a9:	89 d7                	mov    %edx,%edi
  1007ab:	83 e7 00             	and    $0x0,%edi
  1007ae:	89 7d bc             	mov    %edi,-0x44(%ebp)
  1007b1:	8b 45 b8             	mov    -0x48(%ebp),%eax
  1007b4:	8b 55 bc             	mov    -0x44(%ebp),%edx
  1007b7:	89 c2                	mov    %eax,%edx
  1007b9:	b8 00 00 00 00       	mov    $0x0,%eax
  1007be:	c1 e2 08             	shl    $0x8,%edx
  1007c1:	89 cf                	mov    %ecx,%edi
  1007c3:	09 c7                	or     %eax,%edi
  1007c5:	89 7d c0             	mov    %edi,-0x40(%ebp)
  1007c8:	89 df                	mov    %ebx,%edi
  1007ca:	09 d7                	or     %edx,%edi
  1007cc:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  1007cf:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1007d2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1007d5:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  1007dc:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)

  1007e3:	8b 75 08             	mov    0x8(%ebp),%esi
  1007e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1007e9:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  1007f0:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  1007f7:	8b 45 10             	mov    0x10(%ebp),%eax
  1007fa:	c1 e8 10             	shr    $0x10,%eax
  1007fd:	ba 00 00 00 00       	mov    $0x0,%edx
  100802:	89 c7                	mov    %eax,%edi
  100804:	83 e7 0f             	and    $0xf,%edi
  100807:	89 7d c8             	mov    %edi,-0x38(%ebp)
  10080a:	89 d7                	mov    %edx,%edi
  10080c:	83 e7 00             	and    $0x0,%edi
  10080f:	89 7d cc             	mov    %edi,-0x34(%ebp)
  100812:	8b 45 c8             	mov    -0x38(%ebp),%eax
  100815:	8b 55 cc             	mov    -0x34(%ebp),%edx
  100818:	89 c2                	mov    %eax,%edx
  10081a:	b8 00 00 00 00       	mov    $0x0,%eax
  10081f:	c1 e2 10             	shl    $0x10,%edx
  100822:	89 cf                	mov    %ecx,%edi
  100824:	09 c7                	or     %eax,%edi
  100826:	89 7d d0             	mov    %edi,-0x30(%ebp)
  100829:	89 df                	mov    %ebx,%edi
  10082b:	09 d7                	or     %edx,%edi
  10082d:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  100830:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100833:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100836:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  10083d:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)
	return;
  100844:	8b 75 08             	mov    0x8(%ebp),%esi
  100847:	8b 45 08             	mov    0x8(%ebp),%eax
  10084a:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  100851:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  100858:	8b 45 14             	mov    0x14(%ebp),%eax
  10085b:	c1 f8 08             	sar    $0x8,%eax
  10085e:	89 c2                	mov    %eax,%edx
  100860:	c1 fa 1f             	sar    $0x1f,%edx
  100863:	0f b6 f8             	movzbl %al,%edi
  100866:	89 7d d8             	mov    %edi,-0x28(%ebp)
  100869:	89 d7                	mov    %edx,%edi
  10086b:	83 e7 00             	and    $0x0,%edi
  10086e:	89 7d dc             	mov    %edi,-0x24(%ebp)
  100871:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100874:	8b 55 dc             	mov    -0x24(%ebp),%edx
  100877:	89 c2                	mov    %eax,%edx
  100879:	b8 00 00 00 00       	mov    $0x0,%eax
  10087e:	c1 e2 14             	shl    $0x14,%edx
  100881:	89 cf                	mov    %ecx,%edi
  100883:	09 c7                	or     %eax,%edi
  100885:	89 7d e0             	mov    %edi,-0x20(%ebp)
  100888:	89 df                	mov    %ebx,%edi
  10088a:	09 d7                	or     %edx,%edi
  10088c:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  10088f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  100892:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  100895:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  10089c:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)
}
  1008a3:	8b 75 08             	mov    0x8(%ebp),%esi
  1008a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1008a9:	8b 0c c5 80 85 16 00 	mov    0x168580(,%eax,8),%ecx
  1008b0:	8b 1c c5 84 85 16 00 	mov    0x168584(,%eax,8),%ebx
  1008b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1008ba:	c1 e8 18             	shr    $0x18,%eax
  1008bd:	ba 00 00 00 00       	mov    $0x0,%edx
  1008c2:	89 c2                	mov    %eax,%edx
  1008c4:	b8 00 00 00 00       	mov    $0x0,%eax
  1008c9:	c1 e2 18             	shl    $0x18,%edx
  1008cc:	89 cf                	mov    %ecx,%edi
  1008ce:	09 c7                	or     %eax,%edi
  1008d0:	89 7d e8             	mov    %edi,-0x18(%ebp)
  1008d3:	89 df                	mov    %ebx,%edi
  1008d5:	09 d7                	or     %edx,%edi
  1008d7:	89 7d ec             	mov    %edi,-0x14(%ebp)
  1008da:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1008dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1008e0:	89 04 f5 80 85 16 00 	mov    %eax,0x168580(,%esi,8)
  1008e7:	89 14 f5 84 85 16 00 	mov    %edx,0x168584(,%esi,8)
  1008ee:	83 c4 4c             	add    $0x4c,%esp
  1008f1:	5b                   	pop    %ebx
  1008f2:	5e                   	pop    %esi
  1008f3:	5f                   	pop    %edi
  1008f4:	5d                   	pop    %ebp
  1008f5:	c3                   	ret    

001008f6 <init_gdt>:
  1008f6:	55                   	push   %ebp
  1008f7:	89 e5                	mov    %esp,%ebp
  1008f9:	6a 00                	push   $0x0
  1008fb:	6a 00                	push   $0x0
  1008fd:	6a 00                	push   $0x0
  1008ff:	6a 00                	push   $0x0
  100901:	e8 f5 fd ff ff       	call   1006fb <set_gdt_entry>
  100906:	83 c4 10             	add    $0x10,%esp
  100909:	68 9a 0c 00 00       	push   $0xc9a
  10090e:	68 ff ff 0f 00       	push   $0xfffff
  100913:	6a 00                	push   $0x0
  100915:	6a 01                	push   $0x1
  100917:	e8 df fd ff ff       	call   1006fb <set_gdt_entry>
  10091c:	83 c4 10             	add    $0x10,%esp
  10091f:	68 92 0c 00 00       	push   $0xc92
  100924:	68 ff ff 0f 00       	push   $0xfffff
  100929:	6a 00                	push   $0x0
  10092b:	6a 02                	push   $0x2
  10092d:	e8 c9 fd ff ff       	call   1006fb <set_gdt_entry>
  100932:	83 c4 10             	add    $0x10,%esp
  100935:	68 fa 0c 00 00       	push   $0xcfa
  10093a:	68 ff ff 0f 00       	push   $0xfffff
  10093f:	6a 00                	push   $0x0
  100941:	6a 03                	push   $0x3
  100943:	e8 b3 fd ff ff       	call   1006fb <set_gdt_entry>
  100948:	83 c4 10             	add    $0x10,%esp
  10094b:	68 f2 0c 00 00       	push   $0xcf2
  100950:	68 ff ff 0f 00       	push   $0xfffff
  100955:	6a 00                	push   $0x0
  100957:	6a 04                	push   $0x4
  100959:	e8 9d fd ff ff       	call   1006fb <set_gdt_entry>
  10095e:	83 c4 10             	add    $0x10,%esp
  100961:	e8 6e fd ff ff       	call   1006d4 <load_gdt>
  100966:	c9                   	leave  
  100967:	c3                   	ret    

00100968 <idt_set_entry>:
  100968:	55                   	push   %ebp
  100969:	89 e5                	mov    %esp,%ebp
  10096b:	57                   	push   %edi
  10096c:	56                   	push   %esi
  10096d:	53                   	push   %ebx
  10096e:	83 ec 34             	sub    $0x34,%esp
  100971:	8b 45 10             	mov    0x10(%ebp),%eax
  100974:	8b 55 14             	mov    0x14(%ebp),%edx
  100977:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  10097b:	88 55 d8             	mov    %dl,-0x28(%ebp)
  10097e:	8b 45 0c             	mov    0xc(%ebp),%eax
  100981:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100984:	8b 75 08             	mov    0x8(%ebp),%esi
  100987:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10098a:	ba 00 00 00 00       	mov    $0x0,%edx
  10098f:	0f b7 c8             	movzwl %ax,%ecx
  100992:	89 d3                	mov    %edx,%ebx
  100994:	83 e3 00             	and    $0x0,%ebx
  100997:	89 0c f5 20 80 12 00 	mov    %ecx,0x128020(,%esi,8)
  10099e:	89 1c f5 24 80 12 00 	mov    %ebx,0x128024(,%esi,8)
  1009a5:	8b 75 08             	mov    0x8(%ebp),%esi
  1009a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1009ab:	8b 0c c5 20 80 12 00 	mov    0x128020(,%eax,8),%ecx
  1009b2:	8b 1c c5 24 80 12 00 	mov    0x128024(,%eax,8),%ebx
  1009b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1009bc:	25 ff ff 00 00       	and    $0xffff,%eax
  1009c1:	ba 00 00 00 00       	mov    $0x0,%edx
  1009c6:	0f a4 c2 10          	shld   $0x10,%eax,%edx
  1009ca:	c1 e0 10             	shl    $0x10,%eax
  1009cd:	89 cf                	mov    %ecx,%edi
  1009cf:	09 c7                	or     %eax,%edi
  1009d1:	89 7d c0             	mov    %edi,-0x40(%ebp)
  1009d4:	89 df                	mov    %ebx,%edi
  1009d6:	09 d7                	or     %edx,%edi
  1009d8:	89 7d c4             	mov    %edi,-0x3c(%ebp)
  1009db:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1009de:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  1009e1:	89 04 f5 20 80 12 00 	mov    %eax,0x128020(,%esi,8)
  1009e8:	89 14 f5 24 80 12 00 	mov    %edx,0x128024(,%esi,8)
  1009ef:	8b 75 08             	mov    0x8(%ebp),%esi
  1009f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1009f5:	8b 0c c5 20 80 12 00 	mov    0x128020(,%eax,8),%ecx
  1009fc:	8b 1c c5 24 80 12 00 	mov    0x128024(,%eax,8),%ebx
  100a03:	b8 00 00 00 00       	mov    $0x0,%eax
  100a08:	8a 45 d8             	mov    -0x28(%ebp),%al
  100a0b:	ba 00 00 00 00       	mov    $0x0,%edx
  100a10:	89 c2                	mov    %eax,%edx
  100a12:	b8 00 00 00 00       	mov    $0x0,%eax
  100a17:	c1 e2 08             	shl    $0x8,%edx
  100a1a:	89 cf                	mov    %ecx,%edi
  100a1c:	09 c7                	or     %eax,%edi
  100a1e:	89 7d c8             	mov    %edi,-0x38(%ebp)
  100a21:	89 df                	mov    %ebx,%edi
  100a23:	09 d7                	or     %edx,%edi
  100a25:	89 7d cc             	mov    %edi,-0x34(%ebp)
  100a28:	8b 45 c8             	mov    -0x38(%ebp),%eax
  100a2b:	8b 55 cc             	mov    -0x34(%ebp),%edx
  100a2e:	89 04 f5 20 80 12 00 	mov    %eax,0x128020(,%esi,8)
  100a35:	89 14 f5 24 80 12 00 	mov    %edx,0x128024(,%esi,8)
  100a3c:	8b 75 08             	mov    0x8(%ebp),%esi
  100a3f:	8b 45 08             	mov    0x8(%ebp),%eax
  100a42:	8b 0c c5 20 80 12 00 	mov    0x128020(,%eax,8),%ecx
  100a49:	8b 1c c5 24 80 12 00 	mov    0x128024(,%eax,8),%ebx
  100a50:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100a53:	c1 e8 10             	shr    $0x10,%eax
  100a56:	ba 00 00 00 00       	mov    $0x0,%edx
  100a5b:	89 c2                	mov    %eax,%edx
  100a5d:	b8 00 00 00 00       	mov    $0x0,%eax
  100a62:	c1 e2 10             	shl    $0x10,%edx
  100a65:	89 cf                	mov    %ecx,%edi
  100a67:	09 c7                	or     %eax,%edi
  100a69:	89 7d d0             	mov    %edi,-0x30(%ebp)
  100a6c:	89 df                	mov    %ebx,%edi
  100a6e:	09 d7                	or     %edx,%edi
  100a70:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  100a73:	8b 45 d0             	mov    -0x30(%ebp),%eax
  100a76:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  100a79:	89 04 f5 20 80 12 00 	mov    %eax,0x128020(,%esi,8)
  100a80:	89 14 f5 24 80 12 00 	mov    %edx,0x128024(,%esi,8)
  100a87:	83 c4 34             	add    $0x34,%esp
  100a8a:	5b                   	pop    %ebx
  100a8b:	5e                   	pop    %esi
  100a8c:	5f                   	pop    %edi
  100a8d:	5d                   	pop    %ebp
  100a8e:	c3                   	ret    

00100a8f <init_idt>:
  100a8f:	55                   	push   %ebp
  100a90:	89 e5                	mov    %esp,%ebp
  100a92:	83 ec 18             	sub    $0x18,%esp
  100a95:	66 c7 45 ee ff 01    	movw   $0x1ff,-0x12(%ebp)
  100a9b:	c7 45 f0 20 80 12 00 	movl   $0x128020,-0x10(%ebp)
  100aa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  100aa9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  100ab0:	eb 1f                	jmp    100ad1 <init_idt+0x42>
  100ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ab5:	c7 04 85 20 83 12 00 	movl   $0x0,0x128320(,%eax,4)
  100abc:	00 00 00 00 
  100ac0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ac3:	c7 04 85 20 84 12 00 	movl   $0x0,0x128420(,%eax,4)
  100aca:	00 00 00 00 
  100ace:	ff 45 f4             	incl   -0xc(%ebp)
  100ad1:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
  100ad5:	7e db                	jle    100ab2 <init_idt+0x23>
  100ad7:	83 ec 08             	sub    $0x8,%esp
  100ada:	6a 11                	push   $0x11
  100adc:	6a 20                	push   $0x20
  100ade:	e8 30 15 00 00       	call   102013 <outb>
  100ae3:	83 c4 10             	add    $0x10,%esp
  100ae6:	83 ec 08             	sub    $0x8,%esp
  100ae9:	6a 20                	push   $0x20
  100aeb:	6a 21                	push   $0x21
  100aed:	e8 21 15 00 00       	call   102013 <outb>
  100af2:	83 c4 10             	add    $0x10,%esp
  100af5:	83 ec 08             	sub    $0x8,%esp
  100af8:	6a 04                	push   $0x4
  100afa:	6a 21                	push   $0x21
  100afc:	e8 12 15 00 00       	call   102013 <outb>
  100b01:	83 c4 10             	add    $0x10,%esp
  100b04:	83 ec 08             	sub    $0x8,%esp
  100b07:	6a 01                	push   $0x1
  100b09:	6a 21                	push   $0x21
  100b0b:	e8 03 15 00 00       	call   102013 <outb>
  100b10:	83 c4 10             	add    $0x10,%esp
  100b13:	83 ec 08             	sub    $0x8,%esp
  100b16:	6a 11                	push   $0x11
  100b18:	68 a0 00 00 00       	push   $0xa0
  100b1d:	e8 f1 14 00 00       	call   102013 <outb>
  100b22:	83 c4 10             	add    $0x10,%esp
  100b25:	83 ec 08             	sub    $0x8,%esp
  100b28:	6a 28                	push   $0x28
  100b2a:	68 a1 00 00 00       	push   $0xa1
  100b2f:	e8 df 14 00 00       	call   102013 <outb>
  100b34:	83 c4 10             	add    $0x10,%esp
  100b37:	83 ec 08             	sub    $0x8,%esp
  100b3a:	6a 02                	push   $0x2
  100b3c:	68 a1 00 00 00       	push   $0xa1
  100b41:	e8 cd 14 00 00       	call   102013 <outb>
  100b46:	83 c4 10             	add    $0x10,%esp
  100b49:	83 ec 08             	sub    $0x8,%esp
  100b4c:	6a 01                	push   $0x1
  100b4e:	68 a1 00 00 00       	push   $0xa1
  100b53:	e8 bb 14 00 00       	call   102013 <outb>
  100b58:	83 c4 10             	add    $0x10,%esp
  100b5b:	83 ec 08             	sub    $0x8,%esp
  100b5e:	6a 00                	push   $0x0
  100b60:	6a 20                	push   $0x20
  100b62:	e8 ac 14 00 00       	call   102013 <outb>
  100b67:	83 c4 10             	add    $0x10,%esp
  100b6a:	83 ec 08             	sub    $0x8,%esp
  100b6d:	6a 00                	push   $0x0
  100b6f:	68 a0 00 00 00       	push   $0xa0
  100b74:	e8 9a 14 00 00       	call   102013 <outb>
  100b79:	83 c4 10             	add    $0x10,%esp
  100b7c:	b8 0c 00 10 00       	mov    $0x10000c,%eax
  100b81:	68 8e 00 00 00       	push   $0x8e
  100b86:	6a 08                	push   $0x8
  100b88:	50                   	push   %eax
  100b89:	6a 00                	push   $0x0
  100b8b:	e8 d8 fd ff ff       	call   100968 <idt_set_entry>
  100b90:	83 c4 10             	add    $0x10,%esp
  100b93:	b8 15 00 10 00       	mov    $0x100015,%eax
  100b98:	68 8e 00 00 00       	push   $0x8e
  100b9d:	6a 08                	push   $0x8
  100b9f:	50                   	push   %eax
  100ba0:	6a 01                	push   $0x1
  100ba2:	e8 c1 fd ff ff       	call   100968 <idt_set_entry>
  100ba7:	83 c4 10             	add    $0x10,%esp
  100baa:	b8 1e 00 10 00       	mov    $0x10001e,%eax
  100baf:	68 8e 00 00 00       	push   $0x8e
  100bb4:	6a 08                	push   $0x8
  100bb6:	50                   	push   %eax
  100bb7:	6a 02                	push   $0x2
  100bb9:	e8 aa fd ff ff       	call   100968 <idt_set_entry>
  100bbe:	83 c4 10             	add    $0x10,%esp
  100bc1:	b8 27 00 10 00       	mov    $0x100027,%eax
  100bc6:	68 8e 00 00 00       	push   $0x8e
  100bcb:	6a 08                	push   $0x8
  100bcd:	50                   	push   %eax
  100bce:	6a 03                	push   $0x3
  100bd0:	e8 93 fd ff ff       	call   100968 <idt_set_entry>
  100bd5:	83 c4 10             	add    $0x10,%esp
  100bd8:	b8 30 00 10 00       	mov    $0x100030,%eax
  100bdd:	68 8e 00 00 00       	push   $0x8e
  100be2:	6a 08                	push   $0x8
  100be4:	50                   	push   %eax
  100be5:	6a 04                	push   $0x4
  100be7:	e8 7c fd ff ff       	call   100968 <idt_set_entry>
  100bec:	83 c4 10             	add    $0x10,%esp
  100bef:	b8 39 00 10 00       	mov    $0x100039,%eax
  100bf4:	68 8e 00 00 00       	push   $0x8e
  100bf9:	6a 08                	push   $0x8
  100bfb:	50                   	push   %eax
  100bfc:	6a 05                	push   $0x5
  100bfe:	e8 65 fd ff ff       	call   100968 <idt_set_entry>
  100c03:	83 c4 10             	add    $0x10,%esp
  100c06:	b8 42 00 10 00       	mov    $0x100042,%eax
  100c0b:	68 8e 00 00 00       	push   $0x8e
  100c10:	6a 08                	push   $0x8
  100c12:	50                   	push   %eax
  100c13:	6a 06                	push   $0x6
  100c15:	e8 4e fd ff ff       	call   100968 <idt_set_entry>
  100c1a:	83 c4 10             	add    $0x10,%esp
  100c1d:	b8 4b 00 10 00       	mov    $0x10004b,%eax
  100c22:	68 8e 00 00 00       	push   $0x8e
  100c27:	6a 08                	push   $0x8
  100c29:	50                   	push   %eax
  100c2a:	6a 07                	push   $0x7
  100c2c:	e8 37 fd ff ff       	call   100968 <idt_set_entry>
  100c31:	83 c4 10             	add    $0x10,%esp
  100c34:	b8 54 00 10 00       	mov    $0x100054,%eax
  100c39:	68 8e 00 00 00       	push   $0x8e
  100c3e:	6a 08                	push   $0x8
  100c40:	50                   	push   %eax
  100c41:	6a 08                	push   $0x8
  100c43:	e8 20 fd ff ff       	call   100968 <idt_set_entry>
  100c48:	83 c4 10             	add    $0x10,%esp
  100c4b:	b8 5b 00 10 00       	mov    $0x10005b,%eax
  100c50:	68 8e 00 00 00       	push   $0x8e
  100c55:	6a 08                	push   $0x8
  100c57:	50                   	push   %eax
  100c58:	6a 09                	push   $0x9
  100c5a:	e8 09 fd ff ff       	call   100968 <idt_set_entry>
  100c5f:	83 c4 10             	add    $0x10,%esp
  100c62:	b8 64 00 10 00       	mov    $0x100064,%eax
  100c67:	68 8e 00 00 00       	push   $0x8e
  100c6c:	6a 08                	push   $0x8
  100c6e:	50                   	push   %eax
  100c6f:	6a 0a                	push   $0xa
  100c71:	e8 f2 fc ff ff       	call   100968 <idt_set_entry>
  100c76:	83 c4 10             	add    $0x10,%esp
  100c79:	b8 6b 00 10 00       	mov    $0x10006b,%eax
  100c7e:	68 8e 00 00 00       	push   $0x8e
  100c83:	6a 08                	push   $0x8
  100c85:	50                   	push   %eax
  100c86:	6a 0b                	push   $0xb
  100c88:	e8 db fc ff ff       	call   100968 <idt_set_entry>
  100c8d:	83 c4 10             	add    $0x10,%esp
  100c90:	b8 72 00 10 00       	mov    $0x100072,%eax
  100c95:	68 8e 00 00 00       	push   $0x8e
  100c9a:	6a 08                	push   $0x8
  100c9c:	50                   	push   %eax
  100c9d:	6a 0c                	push   $0xc
  100c9f:	e8 c4 fc ff ff       	call   100968 <idt_set_entry>
  100ca4:	83 c4 10             	add    $0x10,%esp
  100ca7:	b8 79 00 10 00       	mov    $0x100079,%eax
  100cac:	68 8e 00 00 00       	push   $0x8e
  100cb1:	6a 08                	push   $0x8
  100cb3:	50                   	push   %eax
  100cb4:	6a 0d                	push   $0xd
  100cb6:	e8 ad fc ff ff       	call   100968 <idt_set_entry>
  100cbb:	83 c4 10             	add    $0x10,%esp
  100cbe:	b8 80 00 10 00       	mov    $0x100080,%eax
  100cc3:	68 8e 00 00 00       	push   $0x8e
  100cc8:	6a 08                	push   $0x8
  100cca:	50                   	push   %eax
  100ccb:	6a 0e                	push   $0xe
  100ccd:	e8 96 fc ff ff       	call   100968 <idt_set_entry>
  100cd2:	83 c4 10             	add    $0x10,%esp
  100cd5:	b8 84 00 10 00       	mov    $0x100084,%eax
  100cda:	68 8e 00 00 00       	push   $0x8e
  100cdf:	6a 08                	push   $0x8
  100ce1:	50                   	push   %eax
  100ce2:	6a 0f                	push   $0xf
  100ce4:	e8 7f fc ff ff       	call   100968 <idt_set_entry>
  100ce9:	83 c4 10             	add    $0x10,%esp
  100cec:	b8 8a 00 10 00       	mov    $0x10008a,%eax
  100cf1:	68 8e 00 00 00       	push   $0x8e
  100cf6:	6a 08                	push   $0x8
  100cf8:	50                   	push   %eax
  100cf9:	6a 10                	push   $0x10
  100cfb:	e8 68 fc ff ff       	call   100968 <idt_set_entry>
  100d00:	83 c4 10             	add    $0x10,%esp
  100d03:	b8 90 00 10 00       	mov    $0x100090,%eax
  100d08:	68 8e 00 00 00       	push   $0x8e
  100d0d:	6a 08                	push   $0x8
  100d0f:	50                   	push   %eax
  100d10:	6a 11                	push   $0x11
  100d12:	e8 51 fc ff ff       	call   100968 <idt_set_entry>
  100d17:	83 c4 10             	add    $0x10,%esp
  100d1a:	b8 94 00 10 00       	mov    $0x100094,%eax
  100d1f:	68 8e 00 00 00       	push   $0x8e
  100d24:	6a 08                	push   $0x8
  100d26:	50                   	push   %eax
  100d27:	6a 12                	push   $0x12
  100d29:	e8 3a fc ff ff       	call   100968 <idt_set_entry>
  100d2e:	83 c4 10             	add    $0x10,%esp
  100d31:	b8 9a 00 10 00       	mov    $0x10009a,%eax
  100d36:	68 8e 00 00 00       	push   $0x8e
  100d3b:	6a 08                	push   $0x8
  100d3d:	50                   	push   %eax
  100d3e:	6a 20                	push   $0x20
  100d40:	e8 23 fc ff ff       	call   100968 <idt_set_entry>
  100d45:	83 c4 10             	add    $0x10,%esp
  100d48:	b8 a0 00 10 00       	mov    $0x1000a0,%eax
  100d4d:	68 8e 00 00 00       	push   $0x8e
  100d52:	6a 08                	push   $0x8
  100d54:	50                   	push   %eax
  100d55:	6a 21                	push   $0x21
  100d57:	e8 0c fc ff ff       	call   100968 <idt_set_entry>
  100d5c:	83 c4 10             	add    $0x10,%esp
  100d5f:	b8 a6 00 10 00       	mov    $0x1000a6,%eax
  100d64:	68 8e 00 00 00       	push   $0x8e
  100d69:	6a 08                	push   $0x8
  100d6b:	50                   	push   %eax
  100d6c:	6a 22                	push   $0x22
  100d6e:	e8 f5 fb ff ff       	call   100968 <idt_set_entry>
  100d73:	83 c4 10             	add    $0x10,%esp
  100d76:	b8 ac 00 10 00       	mov    $0x1000ac,%eax
  100d7b:	68 8e 00 00 00       	push   $0x8e
  100d80:	6a 08                	push   $0x8
  100d82:	50                   	push   %eax
  100d83:	6a 23                	push   $0x23
  100d85:	e8 de fb ff ff       	call   100968 <idt_set_entry>
  100d8a:	83 c4 10             	add    $0x10,%esp
  100d8d:	b8 b2 00 10 00       	mov    $0x1000b2,%eax
  100d92:	68 8e 00 00 00       	push   $0x8e
  100d97:	6a 08                	push   $0x8
  100d99:	50                   	push   %eax
  100d9a:	6a 24                	push   $0x24
  100d9c:	e8 c7 fb ff ff       	call   100968 <idt_set_entry>
  100da1:	83 c4 10             	add    $0x10,%esp
  100da4:	b8 b8 00 10 00       	mov    $0x1000b8,%eax
  100da9:	68 8e 00 00 00       	push   $0x8e
  100dae:	6a 08                	push   $0x8
  100db0:	50                   	push   %eax
  100db1:	6a 25                	push   $0x25
  100db3:	e8 b0 fb ff ff       	call   100968 <idt_set_entry>
  100db8:	83 c4 10             	add    $0x10,%esp
  100dbb:	b8 be 00 10 00       	mov    $0x1000be,%eax
  100dc0:	68 8e 00 00 00       	push   $0x8e
  100dc5:	6a 08                	push   $0x8
  100dc7:	50                   	push   %eax
  100dc8:	6a 26                	push   $0x26
  100dca:	e8 99 fb ff ff       	call   100968 <idt_set_entry>
  100dcf:	83 c4 10             	add    $0x10,%esp
  100dd2:	b8 c4 00 10 00       	mov    $0x1000c4,%eax
  100dd7:	68 8e 00 00 00       	push   $0x8e
  100ddc:	6a 08                	push   $0x8
  100dde:	50                   	push   %eax
  100ddf:	6a 27                	push   $0x27
  100de1:	e8 82 fb ff ff       	call   100968 <idt_set_entry>
  100de6:	83 c4 10             	add    $0x10,%esp
  100de9:	b8 ca 00 10 00       	mov    $0x1000ca,%eax
  100dee:	68 8e 00 00 00       	push   $0x8e
  100df3:	6a 08                	push   $0x8
  100df5:	50                   	push   %eax
  100df6:	6a 28                	push   $0x28
  100df8:	e8 6b fb ff ff       	call   100968 <idt_set_entry>
  100dfd:	83 c4 10             	add    $0x10,%esp
  100e00:	b8 d0 00 10 00       	mov    $0x1000d0,%eax
  100e05:	68 8e 00 00 00       	push   $0x8e
  100e0a:	6a 08                	push   $0x8
  100e0c:	50                   	push   %eax
  100e0d:	6a 29                	push   $0x29
  100e0f:	e8 54 fb ff ff       	call   100968 <idt_set_entry>
  100e14:	83 c4 10             	add    $0x10,%esp
  100e17:	b8 d6 00 10 00       	mov    $0x1000d6,%eax
  100e1c:	68 8e 00 00 00       	push   $0x8e
  100e21:	6a 08                	push   $0x8
  100e23:	50                   	push   %eax
  100e24:	6a 2a                	push   $0x2a
  100e26:	e8 3d fb ff ff       	call   100968 <idt_set_entry>
  100e2b:	83 c4 10             	add    $0x10,%esp
  100e2e:	b8 dc 00 10 00       	mov    $0x1000dc,%eax
  100e33:	68 8e 00 00 00       	push   $0x8e
  100e38:	6a 08                	push   $0x8
  100e3a:	50                   	push   %eax
  100e3b:	6a 2b                	push   $0x2b
  100e3d:	e8 26 fb ff ff       	call   100968 <idt_set_entry>
  100e42:	83 c4 10             	add    $0x10,%esp
  100e45:	b8 e2 00 10 00       	mov    $0x1000e2,%eax
  100e4a:	68 8e 00 00 00       	push   $0x8e
  100e4f:	6a 08                	push   $0x8
  100e51:	50                   	push   %eax
  100e52:	6a 2c                	push   $0x2c
  100e54:	e8 0f fb ff ff       	call   100968 <idt_set_entry>
  100e59:	83 c4 10             	add    $0x10,%esp
  100e5c:	b8 e8 00 10 00       	mov    $0x1000e8,%eax
  100e61:	68 8e 00 00 00       	push   $0x8e
  100e66:	6a 08                	push   $0x8
  100e68:	50                   	push   %eax
  100e69:	6a 2d                	push   $0x2d
  100e6b:	e8 f8 fa ff ff       	call   100968 <idt_set_entry>
  100e70:	83 c4 10             	add    $0x10,%esp
  100e73:	b8 ee 00 10 00       	mov    $0x1000ee,%eax
  100e78:	68 8e 00 00 00       	push   $0x8e
  100e7d:	6a 08                	push   $0x8
  100e7f:	50                   	push   %eax
  100e80:	6a 2e                	push   $0x2e
  100e82:	e8 e1 fa ff ff       	call   100968 <idt_set_entry>
  100e87:	83 c4 10             	add    $0x10,%esp
  100e8a:	b8 f4 00 10 00       	mov    $0x1000f4,%eax
  100e8f:	68 8e 00 00 00       	push   $0x8e
  100e94:	6a 08                	push   $0x8
  100e96:	50                   	push   %eax
  100e97:	6a 2f                	push   $0x2f
  100e99:	e8 ca fa ff ff       	call   100968 <idt_set_entry>
  100e9e:	83 c4 10             	add    $0x10,%esp
  100ea1:	b8 fa 00 10 00       	mov    $0x1000fa,%eax
  100ea6:	68 ee 00 00 00       	push   $0xee
  100eab:	6a 08                	push   $0x8
  100ead:	50                   	push   %eax
  100eae:	6a 30                	push   $0x30
  100eb0:	e8 b3 fa ff ff       	call   100968 <idt_set_entry>
  100eb5:	83 c4 10             	add    $0x10,%esp
  100eb8:	b8 20 60 10 00       	mov    $0x106020,%eax
  100ebd:	68 e9 00 00 00       	push   $0xe9
  100ec2:	68 80 00 00 00       	push   $0x80
  100ec7:	50                   	push   %eax
  100ec8:	6a 05                	push   $0x5
  100eca:	e8 2c f8 ff ff       	call   1006fb <set_gdt_entry>
  100ecf:	83 c4 10             	add    $0x10,%esp
  100ed2:	b8 28 00 00 00       	mov    $0x28,%eax
  100ed7:	0f 00 d8             	ltr    %ax
  100eda:	0f 01 5d ee          	lidtl  -0x12(%ebp)
  100ede:	fb                   	sti    
  100edf:	c9                   	leave  
  100ee0:	c3                   	ret    

00100ee1 <register_intr_handler>:
  100ee1:	55                   	push   %ebp
  100ee2:	89 e5                	mov    %esp,%ebp
  100ee4:	8b 45 08             	mov    0x8(%ebp),%eax
  100ee7:	8b 55 0c             	mov    0xc(%ebp),%edx
  100eea:	89 14 85 20 82 12 00 	mov    %edx,0x128220(,%eax,4)
  100ef1:	8b 45 08             	mov    0x8(%ebp),%eax
  100ef4:	c7 04 85 20 83 12 00 	movl   $0x1,0x128320(,%eax,4)
  100efb:	01 00 00 00 
  100eff:	5d                   	pop    %ebp
  100f00:	c3                   	ret    

00100f01 <register_irq_rpc>:
  100f01:	55                   	push   %ebp
  100f02:	89 e5                	mov    %esp,%ebp
  100f04:	53                   	push   %ebx
  100f05:	83 ec 04             	sub    $0x4,%esp
  100f08:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100f0c:	76 1e                	jbe    100f2c <register_irq_rpc+0x2b>
  100f0e:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100f12:	77 18                	ja     100f2c <register_irq_rpc+0x2b>
  100f14:	8b 5d 08             	mov    0x8(%ebp),%ebx
  100f17:	e8 19 1c 00 00       	call   102b35 <get_current_task>
  100f1c:	8b 00                	mov    (%eax),%eax
  100f1e:	89 04 9d 20 84 12 00 	mov    %eax,0x128420(,%ebx,4)
  100f25:	b8 01 00 00 00       	mov    $0x1,%eax
  100f2a:	eb 05                	jmp    100f31 <register_irq_rpc+0x30>
  100f2c:	b8 00 00 00 00       	mov    $0x0,%eax
  100f31:	83 c4 04             	add    $0x4,%esp
  100f34:	5b                   	pop    %ebx
  100f35:	5d                   	pop    %ebp
  100f36:	c3                   	ret    

00100f37 <disable_irq_rpc>:
  100f37:	55                   	push   %ebp
  100f38:	89 e5                	mov    %esp,%ebp
  100f3a:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100f3e:	76 2a                	jbe    100f6a <disable_irq_rpc+0x33>
  100f40:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100f44:	77 24                	ja     100f6a <disable_irq_rpc+0x33>
  100f46:	8b 45 08             	mov    0x8(%ebp),%eax
  100f49:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  100f50:	85 c0                	test   %eax,%eax
  100f52:	7e 16                	jle    100f6a <disable_irq_rpc+0x33>
  100f54:	8b 45 08             	mov    0x8(%ebp),%eax
  100f57:	8b 55 08             	mov    0x8(%ebp),%edx
  100f5a:	8b 14 95 20 84 12 00 	mov    0x128420(,%edx,4),%edx
  100f61:	f7 da                	neg    %edx
  100f63:	89 14 85 20 84 12 00 	mov    %edx,0x128420(,%eax,4)
  100f6a:	5d                   	pop    %ebp
  100f6b:	c3                   	ret    

00100f6c <enable_irq_rpc>:
  100f6c:	55                   	push   %ebp
  100f6d:	89 e5                	mov    %esp,%ebp
  100f6f:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  100f73:	76 2a                	jbe    100f9f <enable_irq_rpc+0x33>
  100f75:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
  100f79:	77 24                	ja     100f9f <enable_irq_rpc+0x33>
  100f7b:	8b 45 08             	mov    0x8(%ebp),%eax
  100f7e:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  100f85:	85 c0                	test   %eax,%eax
  100f87:	79 16                	jns    100f9f <enable_irq_rpc+0x33>
  100f89:	8b 45 08             	mov    0x8(%ebp),%eax
  100f8c:	8b 55 08             	mov    0x8(%ebp),%edx
  100f8f:	8b 14 95 20 84 12 00 	mov    0x128420(,%edx,4),%edx
  100f96:	f7 da                	neg    %edx
  100f98:	89 14 85 20 84 12 00 	mov    %edx,0x128420(,%eax,4)
  100f9f:	5d                   	pop    %ebp
  100fa0:	c3                   	ret    

00100fa1 <handle_interrupt>:
  100fa1:	55                   	push   %ebp
  100fa2:	89 e5                	mov    %esp,%ebp
  100fa4:	83 ec 18             	sub    $0x18,%esp
  100fa7:	8b 45 08             	mov    0x8(%ebp),%eax
  100faa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100fad:	8b 45 08             	mov    0x8(%ebp),%eax
  100fb0:	8b 40 1c             	mov    0x1c(%eax),%eax
  100fb3:	83 f8 1f             	cmp    $0x1f,%eax
  100fb6:	77 37                	ja     100fef <handle_interrupt+0x4e>
  100fb8:	e8 6e 1b 00 00       	call   102b2b <isSchedulingEnabled>
  100fbd:	85 c0                	test   %eax,%eax
  100fbf:	75 18                	jne    100fd9 <handle_interrupt+0x38>
  100fc1:	83 ec 08             	sub    $0x8,%esp
  100fc4:	68 7d 71 10 00       	push   $0x10717d
  100fc9:	ff 75 08             	pushl  0x8(%ebp)
  100fcc:	e8 05 f2 ff ff       	call   1001d6 <show_cod>
  100fd1:	83 c4 10             	add    $0x10,%esp
  100fd4:	e9 08 01 00 00       	jmp    1010e1 <handle_interrupt+0x140>
  100fd9:	83 ec 0c             	sub    $0xc,%esp
  100fdc:	ff 75 08             	pushl  0x8(%ebp)
  100fdf:	e8 88 1c 00 00       	call   102c6c <schedule_exception>
  100fe4:	83 c4 10             	add    $0x10,%esp
  100fe7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100fea:	e9 f2 00 00 00       	jmp    1010e1 <handle_interrupt+0x140>
  100fef:	8b 45 08             	mov    0x8(%ebp),%eax
  100ff2:	8b 40 1c             	mov    0x1c(%eax),%eax
  100ff5:	83 f8 1f             	cmp    $0x1f,%eax
  100ff8:	0f 86 b2 00 00 00    	jbe    1010b0 <handle_interrupt+0x10f>
  100ffe:	8b 45 08             	mov    0x8(%ebp),%eax
  101001:	8b 40 1c             	mov    0x1c(%eax),%eax
  101004:	83 f8 2f             	cmp    $0x2f,%eax
  101007:	0f 87 a3 00 00 00    	ja     1010b0 <handle_interrupt+0x10f>
  10100d:	8b 45 08             	mov    0x8(%ebp),%eax
  101010:	8b 40 1c             	mov    0x1c(%eax),%eax
  101013:	83 f8 27             	cmp    $0x27,%eax
  101016:	76 12                	jbe    10102a <handle_interrupt+0x89>
  101018:	83 ec 08             	sub    $0x8,%esp
  10101b:	6a 20                	push   $0x20
  10101d:	68 a0 00 00 00       	push   $0xa0
  101022:	e8 ec 0f 00 00       	call   102013 <outb>
  101027:	83 c4 10             	add    $0x10,%esp
  10102a:	8b 45 08             	mov    0x8(%ebp),%eax
  10102d:	8b 40 1c             	mov    0x1c(%eax),%eax
  101030:	83 f8 20             	cmp    $0x20,%eax
  101033:	75 13                	jne    101048 <handle_interrupt+0xa7>
  101035:	83 ec 0c             	sub    $0xc,%esp
  101038:	ff 75 08             	pushl  0x8(%ebp)
  10103b:	e8 6d 20 00 00       	call   1030ad <schedule>
  101040:	83 c4 10             	add    $0x10,%esp
  101043:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101046:	eb 57                	jmp    10109f <handle_interrupt+0xfe>
  101048:	8b 45 08             	mov    0x8(%ebp),%eax
  10104b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10104e:	8b 04 85 20 83 12 00 	mov    0x128320(,%eax,4),%eax
  101055:	85 c0                	test   %eax,%eax
  101057:	74 0f                	je     101068 <handle_interrupt+0xc7>
  101059:	8b 45 08             	mov    0x8(%ebp),%eax
  10105c:	8b 40 1c             	mov    0x1c(%eax),%eax
  10105f:	8b 04 85 20 82 12 00 	mov    0x128220(,%eax,4),%eax
  101066:	ff d0                	call   *%eax
  101068:	8b 45 08             	mov    0x8(%ebp),%eax
  10106b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10106e:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  101075:	85 c0                	test   %eax,%eax
  101077:	7e 26                	jle    10109f <handle_interrupt+0xfe>
  101079:	8b 45 08             	mov    0x8(%ebp),%eax
  10107c:	8b 50 1c             	mov    0x1c(%eax),%edx
  10107f:	8b 45 08             	mov    0x8(%ebp),%eax
  101082:	8b 40 1c             	mov    0x1c(%eax),%eax
  101085:	8b 04 85 20 84 12 00 	mov    0x128420(,%eax,4),%eax
  10108c:	83 ec 0c             	sub    $0xc,%esp
  10108f:	6a 00                	push   $0x0
  101091:	6a 00                	push   $0x0
  101093:	52                   	push   %edx
  101094:	6a 00                	push   $0x0
  101096:	50                   	push   %eax
  101097:	e8 7b 21 00 00       	call   103217 <create_rpc_call>
  10109c:	83 c4 20             	add    $0x20,%esp
  10109f:	83 ec 08             	sub    $0x8,%esp
  1010a2:	6a 20                	push   $0x20
  1010a4:	6a 20                	push   $0x20
  1010a6:	e8 68 0f 00 00       	call   102013 <outb>
  1010ab:	83 c4 10             	add    $0x10,%esp
  1010ae:	eb 31                	jmp    1010e1 <handle_interrupt+0x140>
  1010b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1010b3:	8b 40 1c             	mov    0x1c(%eax),%eax
  1010b6:	83 f8 30             	cmp    $0x30,%eax
  1010b9:	75 13                	jne    1010ce <handle_interrupt+0x12d>
  1010bb:	83 ec 0c             	sub    $0xc,%esp
  1010be:	ff 75 f4             	pushl  -0xc(%ebp)
  1010c1:	e8 22 00 00 00       	call   1010e8 <syscall>
  1010c6:	83 c4 10             	add    $0x10,%esp
  1010c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1010cc:	eb 13                	jmp    1010e1 <handle_interrupt+0x140>
  1010ce:	83 ec 08             	sub    $0x8,%esp
  1010d1:	68 8b 71 10 00       	push   $0x10718b
  1010d6:	ff 75 08             	pushl  0x8(%ebp)
  1010d9:	e8 f8 f0 ff ff       	call   1001d6 <show_cod>
  1010de:	83 c4 10             	add    $0x10,%esp
  1010e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1010e4:	c9                   	leave  
  1010e5:	c3                   	ret    
	...

001010e8 <syscall>:
    char* stdin;
    char* stdout;
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
  1010e8:	55                   	push   %ebp
  1010e9:	89 e5                	mov    %esp,%ebp
  1010eb:	53                   	push   %ebx
  1010ec:	83 ec 64             	sub    $0x64,%esp
    cpu = save_cpu_state(cpu);
  1010ef:	83 ec 0c             	sub    $0xc,%esp
  1010f2:	ff 75 08             	pushl  0x8(%ebp)
  1010f5:	e8 ee 1e 00 00       	call   102fe8 <save_cpu_state>
  1010fa:	83 c4 10             	add    $0x10,%esp
  1010fd:	89 45 08             	mov    %eax,0x8(%ebp)

	switch (cpu->eax) {
  101100:	8b 45 08             	mov    0x8(%ebp),%eax
  101103:	8b 00                	mov    (%eax),%eax
  101105:	3d cd 00 00 00       	cmp    $0xcd,%eax
  10110a:	0f 87 31 07 00 00    	ja     101841 <syscall+0x759>
  101110:	8b 04 85 bc 71 10 00 	mov    0x1071bc(,%eax,4),%eax
  101117:	ff e0                	jmp    *%eax
	case 1: /* exit */
		return terminate_current(cpu);
  101119:	83 ec 0c             	sub    $0xc,%esp
  10111c:	ff 75 08             	pushl  0x8(%ebp)
  10111f:	e8 3a 1c 00 00       	call   102d5e <terminate_current>
  101124:	83 c4 10             	add    $0x10,%esp
  101127:	e9 3d 07 00 00       	jmp    101869 <syscall+0x781>

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  10112c:	8b 45 08             	mov    0x8(%ebp),%eax
  10112f:	8b 40 04             	mov    0x4(%eax),%eax
  101132:	83 ec 0c             	sub    $0xc,%esp
  101135:	50                   	push   %eax
  101136:	e8 04 1a 00 00       	call   102b3f <get_task_by_pid>
  10113b:	83 c4 10             	add    $0x10,%esp
  10113e:	89 c2                	mov    %eax,%edx
  101140:	8b 45 08             	mov    0x8(%ebp),%eax
  101143:	89 10                	mov    %edx,(%eax)
	}
	    break;
  101145:	e9 1c 07 00 00       	jmp    101866 <syscall+0x77e>

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  10114a:	8b 45 08             	mov    0x8(%ebp),%eax
  10114d:	8b 40 04             	mov    0x4(%eax),%eax
  101150:	83 ec 0c             	sub    $0xc,%esp
  101153:	50                   	push   %eax
  101154:	e8 9b 29 00 00       	call   103af4 <strclone>
  101159:	83 c4 10             	add    $0x10,%esp
  10115c:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);
  10115f:	8b 45 08             	mov    0x8(%ebp),%eax
  101162:	8b 40 0c             	mov    0xc(%eax),%eax
  101165:	89 c2                	mov    %eax,%edx
  101167:	8b 45 08             	mov    0x8(%ebp),%eax
  10116a:	8b 40 08             	mov    0x8(%eax),%eax
  10116d:	83 ec 04             	sub    $0x4,%esp
  101170:	52                   	push   %edx
  101171:	6a 00                	push   $0x0
  101173:	6a 00                	push   $0x0
  101175:	6a 00                	push   $0x0
  101177:	6a 00                	push   $0x0
  101179:	50                   	push   %eax
  10117a:	ff 75 a4             	pushl  -0x5c(%ebp)
  10117d:	e8 23 33 00 00       	call   1044a5 <vfs_exec>
  101182:	83 c4 20             	add    $0x20,%esp
  101185:	8b 55 08             	mov    0x8(%ebp),%edx
  101188:	89 02                	mov    %eax,(%edx)

        free(path);
  10118a:	83 ec 0c             	sub    $0xc,%esp
  10118d:	ff 75 a4             	pushl  -0x5c(%ebp)
  101190:	e8 5b 27 00 00       	call   1038f0 <free>
  101195:	83 c4 10             	add    $0x10,%esp

		if(cpu->edx) {
  101198:	8b 45 08             	mov    0x8(%ebp),%eax
  10119b:	8b 40 0c             	mov    0xc(%eax),%eax
  10119e:	85 c0                	test   %eax,%eax
  1011a0:	0f 84 b3 06 00 00    	je     101859 <syscall+0x771>
			cpu = schedule(cpu);
  1011a6:	83 ec 0c             	sub    $0xc,%esp
  1011a9:	ff 75 08             	pushl  0x8(%ebp)
  1011ac:	e8 fc 1e 00 00       	call   1030ad <schedule>
  1011b1:	83 c4 10             	add    $0x10,%esp
  1011b4:	89 45 08             	mov    %eax,0x8(%ebp)
		}
    }
        break;
  1011b7:	e9 aa 06 00 00       	jmp    101866 <syscall+0x77e>

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  1011bc:	e8 74 19 00 00       	call   102b35 <get_current_task>
  1011c1:	8b 40 20             	mov    0x20(%eax),%eax
  1011c4:	89 c2                	mov    %eax,%edx
  1011c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1011c9:	89 10                	mov    %edx,(%eax)
    }
        break;
  1011cb:	e9 96 06 00 00       	jmp    101866 <syscall+0x77e>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
  1011d0:	83 ec 0c             	sub    $0xc,%esp
  1011d3:	ff 75 08             	pushl  0x8(%ebp)
  1011d6:	e8 d2 1e 00 00       	call   1030ad <schedule>
  1011db:	83 c4 10             	add    $0x10,%esp
  1011de:	89 45 08             	mov    %eax,0x8(%ebp)
    }
        break;
  1011e1:	e9 80 06 00 00       	jmp    101866 <syscall+0x77e>

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  1011e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1011e9:	8b 40 04             	mov    0x4(%eax),%eax
  1011ec:	89 45 a8             	mov    %eax,-0x58(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  1011ef:	e8 41 19 00 00       	call   102b35 <get_current_task>
  1011f4:	8b 40 28             	mov    0x28(%eax),%eax
  1011f7:	85 c0                	test   %eax,%eax
  1011f9:	0f 84 5d 06 00 00    	je     10185c <syscall+0x774>
  1011ff:	e8 31 19 00 00       	call   102b35 <get_current_task>
  101204:	8b 40 28             	mov    0x28(%eax),%eax
  101207:	83 ec 08             	sub    $0x8,%esp
  10120a:	50                   	push   %eax
  10120b:	ff 75 a8             	pushl  -0x58(%ebp)
  10120e:	e8 be 28 00 00       	call   103ad1 <strcpy>
  101213:	83 c4 10             	add    $0x10,%esp
    }
        break;
  101216:	e9 4b 06 00 00       	jmp    101866 <syscall+0x77e>

    case 7: /* changeExecPath */
    {
        vfs_reset_error();
  10121b:	e8 a4 2a 00 00       	call   103cc4 <vfs_reset_error>
        char* path = strclone((char*) cpu->ebx);
  101220:	8b 45 08             	mov    0x8(%ebp),%eax
  101223:	8b 40 04             	mov    0x4(%eax),%eax
  101226:	83 ec 0c             	sub    $0xc,%esp
  101229:	50                   	push   %eax
  10122a:	e8 c5 28 00 00       	call   103af4 <strclone>
  10122f:	83 c4 10             	add    $0x10,%esp
  101232:	89 45 ac             	mov    %eax,-0x54(%ebp)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  101235:	e8 fb 18 00 00       	call   102b35 <get_current_task>
  10123a:	8b 40 28             	mov    0x28(%eax),%eax
  10123d:	85 c0                	test   %eax,%eax
  10123f:	74 14                	je     101255 <syscall+0x16d>
  101241:	e8 ef 18 00 00       	call   102b35 <get_current_task>
  101246:	8b 40 28             	mov    0x28(%eax),%eax
  101249:	83 ec 0c             	sub    $0xc,%esp
  10124c:	50                   	push   %eax
  10124d:	e8 9e 26 00 00       	call   1038f0 <free>
  101252:	83 c4 10             	add    $0x10,%esp

        char* new = vfs_resolve_path(path);
  101255:	83 ec 0c             	sub    $0xc,%esp
  101258:	ff 75 ac             	pushl  -0x54(%ebp)
  10125b:	e8 53 37 00 00       	call   1049b3 <vfs_resolve_path>
  101260:	83 c4 10             	add    $0x10,%esp
  101263:	89 45 b0             	mov    %eax,-0x50(%ebp)

        cpu->eax = 0;
  101266:	8b 45 08             	mov    0x8(%ebp),%eax
  101269:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        if(new) {
  10126f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  101273:	74 14                	je     101289 <syscall+0x1a1>
            get_current_task()->execPath = new;
  101275:	e8 bb 18 00 00       	call   102b35 <get_current_task>
  10127a:	8b 55 b0             	mov    -0x50(%ebp),%edx
  10127d:	89 50 28             	mov    %edx,0x28(%eax)
            cpu->eax = 1;
  101280:	8b 45 08             	mov    0x8(%ebp),%eax
  101283:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        }

        free(path);
  101289:	83 ec 0c             	sub    $0xc,%esp
  10128c:	ff 75 ac             	pushl  -0x54(%ebp)
  10128f:	e8 5c 26 00 00       	call   1038f0 <free>
  101294:	83 c4 10             	add    $0x10,%esp
    }
        break;
  101297:	e9 ca 05 00 00       	jmp    101866 <syscall+0x77e>

	case 10: /* fopen */
	{
        vfs_reset_error();
  10129c:	e8 23 2a 00 00       	call   103cc4 <vfs_reset_error>
	    char* name = strclone((char*) cpu->ebx);
  1012a1:	8b 45 08             	mov    0x8(%ebp),%eax
  1012a4:	8b 40 04             	mov    0x4(%eax),%eax
  1012a7:	83 ec 0c             	sub    $0xc,%esp
  1012aa:	50                   	push   %eax
  1012ab:	e8 44 28 00 00       	call   103af4 <strclone>
  1012b0:	83 c4 10             	add    $0x10,%esp
  1012b3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  1012b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1012b9:	8b 40 08             	mov    0x8(%eax),%eax
  1012bc:	89 45 b8             	mov    %eax,-0x48(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  1012bf:	83 ec 08             	sub    $0x8,%esp
  1012c2:	ff 75 b8             	pushl  -0x48(%ebp)
  1012c5:	ff 75 b4             	pushl  -0x4c(%ebp)
  1012c8:	e8 9e 2f 00 00       	call   10426b <vfs_open>
  1012cd:	83 c4 10             	add    $0x10,%esp
  1012d0:	89 45 bc             	mov    %eax,-0x44(%ebp)
	    if(handle) {
  1012d3:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  1012d7:	74 18                	je     1012f1 <syscall+0x209>
	        register_handle(handle);
  1012d9:	83 ec 0c             	sub    $0xc,%esp
  1012dc:	ff 75 bc             	pushl  -0x44(%ebp)
  1012df:	e8 90 18 00 00       	call   102b74 <register_handle>
  1012e4:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = (uint32_t) handle;
  1012e7:	8b 55 bc             	mov    -0x44(%ebp),%edx
  1012ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1012ed:	89 10                	mov    %edx,(%eax)
  1012ef:	eb 09                	jmp    1012fa <syscall+0x212>
	    }
	    else
	    {
	        cpu->eax = 0;
  1012f1:	8b 45 08             	mov    0x8(%ebp),%eax
  1012f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }

	    free(name);
  1012fa:	83 ec 0c             	sub    $0xc,%esp
  1012fd:	ff 75 b4             	pushl  -0x4c(%ebp)
  101300:	e8 eb 25 00 00       	call   1038f0 <free>
  101305:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  101308:	e9 59 05 00 00       	jmp    101866 <syscall+0x77e>

	case 11: /* fclose */
	{
        vfs_reset_error();
  10130d:	e8 b2 29 00 00       	call   103cc4 <vfs_reset_error>
	    struct res_handle* handle = (void*) cpu->ebx;
  101312:	8b 45 08             	mov    0x8(%ebp),%eax
  101315:	8b 40 04             	mov    0x4(%eax),%eax
  101318:	89 45 c0             	mov    %eax,-0x40(%ebp)
	    if(!unregister_handle(handle)) {
  10131b:	83 ec 0c             	sub    $0xc,%esp
  10131e:	ff 75 c0             	pushl  -0x40(%ebp)
  101321:	e8 9b 18 00 00       	call   102bc1 <unregister_handle>
  101326:	83 c4 10             	add    $0x10,%esp
  101329:	85 c0                	test   %eax,%eax
  10132b:	75 1c                	jne    101349 <syscall+0x261>
	        vfs_close(handle);
  10132d:	83 ec 0c             	sub    $0xc,%esp
  101330:	ff 75 c0             	pushl  -0x40(%ebp)
  101333:	e8 90 2f 00 00       	call   1042c8 <vfs_close>
  101338:	83 c4 10             	add    $0x10,%esp

	        cpu->eax = 0;
  10133b:	8b 45 08             	mov    0x8(%ebp),%eax
  10133e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    else
	    {
	        cpu->eax = (uint32_t) -1;
	    }
	}
	    break;
  101344:	e9 1d 05 00 00       	jmp    101866 <syscall+0x77e>

	        cpu->eax = 0;
	    }
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  101349:	8b 45 08             	mov    0x8(%ebp),%eax
  10134c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  101352:	e9 0f 05 00 00       	jmp    101866 <syscall+0x77e>

	case 12: /* fwrite */
	{
        vfs_reset_error();
  101357:	e8 68 29 00 00       	call   103cc4 <vfs_reset_error>
	    struct res_handle* handle = (void*) cpu->ebx;
  10135c:	8b 45 08             	mov    0x8(%ebp),%eax
  10135f:	8b 40 04             	mov    0x4(%eax),%eax
  101362:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	    if(handle != 0) {
  101365:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  101369:	74 25                	je     101390 <syscall+0x2a8>
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  10136b:	8b 45 08             	mov    0x8(%ebp),%eax
  10136e:	8b 50 0c             	mov    0xc(%eax),%edx
  101371:	8b 45 08             	mov    0x8(%ebp),%eax
  101374:	8b 40 08             	mov    0x8(%eax),%eax
  101377:	6a 01                	push   $0x1
  101379:	52                   	push   %edx
  10137a:	50                   	push   %eax
  10137b:	ff 75 c4             	pushl  -0x3c(%ebp)
  10137e:	e8 04 30 00 00       	call   104387 <vfs_write>
  101383:	83 c4 10             	add    $0x10,%esp
  101386:	8b 55 08             	mov    0x8(%ebp),%edx
  101389:	89 02                	mov    %eax,(%edx)
	    else
	    {
            cpu->eax = RW_ERR_VFS;
	    }
	}
	    break;
  10138b:	e9 d6 04 00 00       	jmp    101866 <syscall+0x77e>
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  101390:	8b 45 08             	mov    0x8(%ebp),%eax
  101393:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  101399:	e9 c8 04 00 00       	jmp    101866 <syscall+0x77e>

	case 13: /* fread */
	{
        vfs_reset_error();
  10139e:	e8 21 29 00 00       	call   103cc4 <vfs_reset_error>
        struct res_handle* handle = (void*) cpu->ebx;
  1013a3:	8b 45 08             	mov    0x8(%ebp),%eax
  1013a6:	8b 40 04             	mov    0x4(%eax),%eax
  1013a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(handle != 0) {
  1013ac:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  1013b0:	74 25                	je     1013d7 <syscall+0x2ef>
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  1013b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1013b5:	8b 50 0c             	mov    0xc(%eax),%edx
  1013b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1013bb:	8b 40 08             	mov    0x8(%eax),%eax
  1013be:	6a 01                	push   $0x1
  1013c0:	52                   	push   %edx
  1013c1:	50                   	push   %eax
  1013c2:	ff 75 c8             	pushl  -0x38(%ebp)
  1013c5:	e8 34 2f 00 00       	call   1042fe <vfs_read>
  1013ca:	83 c4 10             	add    $0x10,%esp
  1013cd:	8b 55 08             	mov    0x8(%ebp),%edx
  1013d0:	89 02                	mov    %eax,(%edx)
        else
        {
            cpu->eax = RW_ERR_VFS;
        }
	}
	    break;
  1013d2:	e9 8f 04 00 00       	jmp    101866 <syscall+0x77e>
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
        {
            cpu->eax = RW_ERR_VFS;
  1013d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1013da:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  1013e0:	e9 81 04 00 00       	jmp    101866 <syscall+0x77e>

	case 14: /* fmkfifo */
	{
        vfs_reset_error();
  1013e5:	e8 da 28 00 00       	call   103cc4 <vfs_reset_error>
        char* name = strclone((char*) cpu->ebx);
  1013ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1013ed:	8b 40 04             	mov    0x4(%eax),%eax
  1013f0:	83 ec 0c             	sub    $0xc,%esp
  1013f3:	50                   	push   %eax
  1013f4:	e8 fb 26 00 00       	call   103af4 <strclone>
  1013f9:	83 c4 10             	add    $0x10,%esp
  1013fc:	89 45 cc             	mov    %eax,-0x34(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  1013ff:	c7 45 a0 00 10 00 00 	movl   $0x1000,-0x60(%ebp)
  101406:	e8 a4 0f 00 00       	call   1023af <ramfs_fifo_driver_struct>
  10140b:	83 ec 04             	sub    $0x4,%esp
  10140e:	8d 55 a0             	lea    -0x60(%ebp),%edx
  101411:	52                   	push   %edx
  101412:	50                   	push   %eax
  101413:	ff 75 cc             	pushl  -0x34(%ebp)
  101416:	e8 b1 2d 00 00       	call   1041cc <vfs_create_kfile>
  10141b:	83 c4 10             	add    $0x10,%esp

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  10141e:	83 ec 08             	sub    $0x8,%esp
  101421:	6a 03                	push   $0x3
  101423:	ff 75 cc             	pushl  -0x34(%ebp)
  101426:	e8 40 2e 00 00       	call   10426b <vfs_open>
  10142b:	83 c4 10             	add    $0x10,%esp
  10142e:	89 45 d0             	mov    %eax,-0x30(%ebp)
        if(handle) {
  101431:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  101435:	74 18                	je     10144f <syscall+0x367>
            register_handle(handle);
  101437:	83 ec 0c             	sub    $0xc,%esp
  10143a:	ff 75 d0             	pushl  -0x30(%ebp)
  10143d:	e8 32 17 00 00       	call   102b74 <register_handle>
  101442:	83 c4 10             	add    $0x10,%esp
            cpu->eax = (uint32_t) handle;
  101445:	8b 55 d0             	mov    -0x30(%ebp),%edx
  101448:	8b 45 08             	mov    0x8(%ebp),%eax
  10144b:	89 10                	mov    %edx,(%eax)
  10144d:	eb 09                	jmp    101458 <syscall+0x370>
        }
        else
        {
            cpu->eax = 0;
  10144f:	8b 45 08             	mov    0x8(%ebp),%eax
  101452:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        free(name);
  101458:	83 ec 0c             	sub    $0xc,%esp
  10145b:	ff 75 cc             	pushl  -0x34(%ebp)
  10145e:	e8 8d 24 00 00       	call   1038f0 <free>
  101463:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  101466:	e9 fb 03 00 00       	jmp    101866 <syscall+0x77e>

	case 15: /* getLastVFSErr */
	{
	    cpu->eax = get_current_task()->vfserr;
  10146b:	e8 c5 16 00 00       	call   102b35 <get_current_task>
  101470:	8b 50 2c             	mov    0x2c(%eax),%edx
  101473:	8b 45 08             	mov    0x8(%ebp),%eax
  101476:	89 10                	mov    %edx,(%eax)
        vfs_reset_error();
  101478:	e8 47 28 00 00       	call   103cc4 <vfs_reset_error>
	}
	    break;
  10147d:	e9 e4 03 00 00       	jmp    101866 <syscall+0x77e>

	case 16: /* favailable */
	{
	    cpu->eax = vfs_available((void*)cpu->ebx);
  101482:	8b 45 08             	mov    0x8(%ebp),%eax
  101485:	8b 40 04             	mov    0x4(%eax),%eax
  101488:	83 ec 0c             	sub    $0xc,%esp
  10148b:	50                   	push   %eax
  10148c:	e8 80 2f 00 00       	call   104411 <vfs_available>
  101491:	83 c4 10             	add    $0x10,%esp
  101494:	8b 55 08             	mov    0x8(%ebp),%edx
  101497:	89 02                	mov    %eax,(%edx)
	}
	    break;
  101499:	e9 c8 03 00 00       	jmp    101866 <syscall+0x77e>

	case 17: /* getPathChild */
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);
  10149e:	8b 45 08             	mov    0x8(%ebp),%eax
  1014a1:	8b 40 04             	mov    0x4(%eax),%eax
  1014a4:	89 c2                	mov    %eax,%edx
  1014a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1014a9:	8b 40 0c             	mov    0xc(%eax),%eax
  1014ac:	83 ec 08             	sub    $0x8,%esp
  1014af:	52                   	push   %edx
  1014b0:	50                   	push   %eax
  1014b1:	e8 83 2c 00 00       	call   104139 <vfs_get_child_of_path>
  1014b6:	83 c4 10             	add    $0x10,%esp
  1014b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)

		if(path != 0 && cpu->ecx != 0) {
  1014bc:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  1014c0:	74 3e                	je     101500 <syscall+0x418>
  1014c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1014c5:	8b 40 08             	mov    0x8(%eax),%eax
  1014c8:	85 c0                	test   %eax,%eax
  1014ca:	74 34                	je     101500 <syscall+0x418>
			strcpy((char*)cpu->ecx, path);
  1014cc:	8b 45 08             	mov    0x8(%ebp),%eax
  1014cf:	8b 40 08             	mov    0x8(%eax),%eax
  1014d2:	83 ec 08             	sub    $0x8,%esp
  1014d5:	ff 75 d4             	pushl  -0x2c(%ebp)
  1014d8:	50                   	push   %eax
  1014d9:	e8 f3 25 00 00       	call   103ad1 <strcpy>
  1014de:	83 c4 10             	add    $0x10,%esp
			free(path);
  1014e1:	83 ec 0c             	sub    $0xc,%esp
  1014e4:	ff 75 d4             	pushl  -0x2c(%ebp)
  1014e7:	e8 04 24 00 00       	call   1038f0 <free>
  1014ec:	83 c4 10             	add    $0x10,%esp

			cpu->eax = cpu->ecx;
  1014ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1014f2:	8b 50 08             	mov    0x8(%eax),%edx
  1014f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1014f8:	89 10                	mov    %edx,(%eax)

	case 17: /* getPathChild */
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);

		if(path != 0 && cpu->ecx != 0) {
  1014fa:	90                   	nop    
		else
		{
			cpu->eax = 0;
		}
	}
		break;
  1014fb:	e9 66 03 00 00       	jmp    101866 <syscall+0x77e>

			cpu->eax = cpu->ecx;
		}
		else
		{
			cpu->eax = 0;
  101500:	8b 45 08             	mov    0x8(%ebp),%eax
  101503:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		}
	}
		break;
  101509:	e9 58 03 00 00       	jmp    101866 <syscall+0x77e>

	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  10150e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	    switch(cpu->ebx) {
  101515:	8b 45 08             	mov    0x8(%ebp),%eax
  101518:	8b 40 04             	mov    0x4(%eax),%eax
  10151b:	83 f8 02             	cmp    $0x2,%eax
  10151e:	74 17                	je     101537 <syscall+0x44f>
  101520:	83 f8 03             	cmp    $0x3,%eax
  101523:	74 1f                	je     101544 <syscall+0x45c>
  101525:	83 f8 01             	cmp    $0x1,%eax
  101528:	75 27                	jne    101551 <syscall+0x469>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
  10152a:	e8 06 16 00 00       	call   102b35 <get_current_task>
  10152f:	8b 40 30             	mov    0x30(%eax),%eax
  101532:	89 45 d8             	mov    %eax,-0x28(%ebp)
	        break;
  101535:	eb 25                	jmp    10155c <syscall+0x474>
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  101537:	e8 f9 15 00 00       	call   102b35 <get_current_task>
  10153c:	8b 40 38             	mov    0x38(%eax),%eax
  10153f:	89 45 d8             	mov    %eax,-0x28(%ebp)
            break;
  101542:	eb 18                	jmp    10155c <syscall+0x474>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  101544:	e8 ec 15 00 00       	call   102b35 <get_current_task>
  101549:	8b 40 34             	mov    0x34(%eax),%eax
  10154c:	89 45 d8             	mov    %eax,-0x28(%ebp)
            break;
  10154f:	eb 0b                	jmp    10155c <syscall+0x474>
        default:
            handle = get_current_task()->stdout;
  101551:	e8 df 15 00 00       	call   102b35 <get_current_task>
  101556:	8b 40 30             	mov    0x30(%eax),%eax
  101559:	89 45 d8             	mov    %eax,-0x28(%ebp)
            break;
	    }

	    cpu->eax = (uint32_t) handle;
  10155c:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10155f:	8b 45 08             	mov    0x8(%ebp),%eax
  101562:	89 10                	mov    %edx,(%eax)
	}
	    break;
  101564:	e9 fd 02 00 00       	jmp    101866 <syscall+0x77e>

	case 21: /* fopenpmhandle */
	{
	    vfs_reset_error();
  101569:	e8 56 27 00 00       	call   103cc4 <vfs_reset_error>
	    char* path = strclone((char*)cpu->ecx);
  10156e:	8b 45 08             	mov    0x8(%ebp),%eax
  101571:	8b 40 08             	mov    0x8(%eax),%eax
  101574:	83 ec 0c             	sub    $0xc,%esp
  101577:	50                   	push   %eax
  101578:	e8 77 25 00 00       	call   103af4 <strclone>
  10157d:	83 c4 10             	add    $0x10,%esp
  101580:	89 45 dc             	mov    %eax,-0x24(%ebp)

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  101583:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)

	    if(cpu->ebx == PMID_STDIN) {
  10158a:	8b 45 08             	mov    0x8(%ebp),%eax
  10158d:	8b 40 04             	mov    0x4(%eax),%eax
  101590:	83 f8 02             	cmp    $0x2,%eax
  101593:	75 07                	jne    10159c <syscall+0x4b4>
	        fm = FM_READ;
  101595:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
	    }

	    open = vfs_open(path, fm);
  10159c:	83 ec 08             	sub    $0x8,%esp
  10159f:	ff 75 e4             	pushl  -0x1c(%ebp)
  1015a2:	ff 75 dc             	pushl  -0x24(%ebp)
  1015a5:	e8 c1 2c 00 00       	call   10426b <vfs_open>
  1015aa:	83 c4 10             	add    $0x10,%esp
  1015ad:	89 45 e0             	mov    %eax,-0x20(%ebp)

	    free(path);
  1015b0:	83 ec 0c             	sub    $0xc,%esp
  1015b3:	ff 75 dc             	pushl  -0x24(%ebp)
  1015b6:	e8 35 23 00 00       	call   1038f0 <free>
  1015bb:	83 c4 10             	add    $0x10,%esp

	    if(!open) {
  1015be:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  1015c2:	75 0e                	jne    1015d2 <syscall+0x4ea>
	        cpu->eax = (uint32_t) -1;
  1015c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1015c7:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	        break;
  1015cd:	e9 94 02 00 00       	jmp    101866 <syscall+0x77e>
	    }

	    struct res_handle* oldhandle = 0;
  1015d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

        switch(cpu->ebx) {
  1015d9:	8b 45 08             	mov    0x8(%ebp),%eax
  1015dc:	8b 40 04             	mov    0x4(%eax),%eax
  1015df:	83 f8 02             	cmp    $0x2,%eax
  1015e2:	74 22                	je     101606 <syscall+0x51e>
  1015e4:	83 f8 03             	cmp    $0x3,%eax
  1015e7:	74 35                	je     10161e <syscall+0x536>
  1015e9:	83 f8 01             	cmp    $0x1,%eax
  1015ec:	75 48                	jne    101636 <syscall+0x54e>
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  1015ee:	e8 42 15 00 00       	call   102b35 <get_current_task>
  1015f3:	8b 40 30             	mov    0x30(%eax),%eax
  1015f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stdout = open;
  1015f9:	e8 37 15 00 00       	call   102b35 <get_current_task>
  1015fe:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101601:	89 50 30             	mov    %edx,0x30(%eax)
            break;
  101604:	eb 46                	jmp    10164c <syscall+0x564>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  101606:	e8 2a 15 00 00       	call   102b35 <get_current_task>
  10160b:	8b 40 38             	mov    0x38(%eax),%eax
  10160e:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stdin = open;
  101611:	e8 1f 15 00 00       	call   102b35 <get_current_task>
  101616:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101619:	89 50 38             	mov    %edx,0x38(%eax)
            break;
  10161c:	eb 2e                	jmp    10164c <syscall+0x564>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  10161e:	e8 12 15 00 00       	call   102b35 <get_current_task>
  101623:	8b 40 34             	mov    0x34(%eax),%eax
  101626:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stderr = open;
  101629:	e8 07 15 00 00       	call   102b35 <get_current_task>
  10162e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101631:	89 50 34             	mov    %edx,0x34(%eax)
            break;
  101634:	eb 16                	jmp    10164c <syscall+0x564>
        default:
            oldhandle = get_current_task()->stdout;
  101636:	e8 fa 14 00 00       	call   102b35 <get_current_task>
  10163b:	8b 40 30             	mov    0x30(%eax),%eax
  10163e:	89 45 e8             	mov    %eax,-0x18(%ebp)
            get_current_task()->stdout = open;
  101641:	e8 ef 14 00 00       	call   102b35 <get_current_task>
  101646:	8b 55 e0             	mov    -0x20(%ebp),%edx
  101649:	89 50 30             	mov    %edx,0x30(%eax)
            break;
        }

        if(oldhandle != 0) {
  10164c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  101650:	74 0e                	je     101660 <syscall+0x578>
            vfs_close(oldhandle);
  101652:	83 ec 0c             	sub    $0xc,%esp
  101655:	ff 75 e8             	pushl  -0x18(%ebp)
  101658:	e8 6b 2c 00 00       	call   1042c8 <vfs_close>
  10165d:	83 c4 10             	add    $0x10,%esp
        }

        cpu->eax = 0;
  101660:	8b 45 08             	mov    0x8(%ebp),%eax
  101663:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	    break;
  101669:	e9 f8 01 00 00       	jmp    101866 <syscall+0x77e>

	case 30: /* return_rpc */
	{
	    cpu = return_rpc_call(cpu);
  10166e:	83 ec 0c             	sub    $0xc,%esp
  101671:	ff 75 08             	pushl  0x8(%ebp)
  101674:	e8 09 1d 00 00       	call   103382 <return_rpc_call>
  101679:	83 c4 10             	add    $0x10,%esp
  10167c:	89 45 08             	mov    %eax,0x8(%ebp)
	}
	    break;
  10167f:	e9 e2 01 00 00       	jmp    101866 <syscall+0x77e>

	case 31: /* call_rpc */
	{
	    int PID = cpu->ebx;
  101684:	8b 45 08             	mov    0x8(%ebp),%eax
  101687:	8b 40 04             	mov    0x4(%eax),%eax
  10168a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	    //TODO create RPC for U2U
	}
	    break;
  10168d:	e9 d4 01 00 00       	jmp    101866 <syscall+0x77e>

	case 32: /* set_rpc_handler */
	{
	    uint32_t handlerAddr = cpu->ebx;
  101692:	8b 45 08             	mov    0x8(%ebp),%eax
  101695:	8b 40 04             	mov    0x4(%eax),%eax
  101698:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    if(get_current_task()->rpc_handler_addr == 0) {
  10169b:	e8 95 14 00 00       	call   102b35 <get_current_task>
  1016a0:	8b 40 1c             	mov    0x1c(%eax),%eax
  1016a3:	85 c0                	test   %eax,%eax
  1016a5:	0f 85 b4 01 00 00    	jne    10185f <syscall+0x777>
	        get_current_task()->rpc_handler_addr = handlerAddr;
  1016ab:	e8 85 14 00 00       	call   102b35 <get_current_task>
  1016b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1016b3:	89 50 1c             	mov    %edx,0x1c(%eax)
	    }
	}
	    break;
  1016b6:	e9 ab 01 00 00       	jmp    101866 <syscall+0x77e>

	case 33: /* fetch_rpc_data */
	{
	    cpu->eax = 0;
  1016bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1016be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    void* dest = (void*) cpu->ebx;
  1016c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1016c7:	8b 40 04             	mov    0x4(%eax),%eax
  1016ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    if(get_current_task()->rpc != 0) {
  1016cd:	e8 63 14 00 00       	call   102b35 <get_current_task>
  1016d2:	8b 40 18             	mov    0x18(%eax),%eax
  1016d5:	85 c0                	test   %eax,%eax
  1016d7:	0f 84 85 01 00 00    	je     101862 <syscall+0x77a>
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
  1016dd:	e8 53 14 00 00       	call   102b35 <get_current_task>
  1016e2:	8b 40 18             	mov    0x18(%eax),%eax
  1016e5:	8b 58 10             	mov    0x10(%eax),%ebx
  1016e8:	e8 48 14 00 00       	call   102b35 <get_current_task>
  1016ed:	8b 40 18             	mov    0x18(%eax),%eax
  1016f0:	8b 40 0c             	mov    0xc(%eax),%eax
  1016f3:	83 ec 04             	sub    $0x4,%esp
  1016f6:	53                   	push   %ebx
  1016f7:	50                   	push   %eax
  1016f8:	ff 75 f4             	pushl  -0xc(%ebp)
  1016fb:	e8 72 22 00 00       	call   103972 <memcpy>
  101700:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = get_current_task()->rpc->dataSize;
  101703:	e8 2d 14 00 00       	call   102b35 <get_current_task>
  101708:	8b 40 18             	mov    0x18(%eax),%eax
  10170b:	8b 50 10             	mov    0x10(%eax),%edx
  10170e:	8b 45 08             	mov    0x8(%ebp),%eax
  101711:	89 10                	mov    %edx,(%eax)
	    }
	}
	    break;
  101713:	e9 4e 01 00 00       	jmp    101866 <syscall+0x77e>

	case 40:
	{
	    cpu->eax = register_irq_rpc(cpu->ebx);
  101718:	8b 45 08             	mov    0x8(%ebp),%eax
  10171b:	8b 40 04             	mov    0x4(%eax),%eax
  10171e:	83 ec 0c             	sub    $0xc,%esp
  101721:	50                   	push   %eax
  101722:	e8 da f7 ff ff       	call   100f01 <register_irq_rpc>
  101727:	83 c4 10             	add    $0x10,%esp
  10172a:	8b 55 08             	mov    0x8(%ebp),%edx
  10172d:	89 02                	mov    %eax,(%edx)
	}
	    break;
  10172f:	e9 32 01 00 00       	jmp    101866 <syscall+0x77e>

	case 50:
	{
	    cpu->eax = require_port((uint16_t)cpu->ebx);
  101734:	8b 45 08             	mov    0x8(%ebp),%eax
  101737:	8b 40 04             	mov    0x4(%eax),%eax
  10173a:	25 ff ff 00 00       	and    $0xffff,%eax
  10173f:	83 ec 0c             	sub    $0xc,%esp
  101742:	50                   	push   %eax
  101743:	e8 9a 06 00 00       	call   101de2 <require_port>
  101748:	83 c4 10             	add    $0x10,%esp
  10174b:	8b 55 08             	mov    0x8(%ebp),%edx
  10174e:	89 02                	mov    %eax,(%edx)
	}
	    break;
  101750:	e9 11 01 00 00       	jmp    101866 <syscall+0x77e>

	case 51:
	{
	    cpu->eax = port_out(cpu->ebx, (uint16_t)cpu->ecx, cpu->edx);
  101755:	8b 45 08             	mov    0x8(%ebp),%eax
  101758:	8b 48 0c             	mov    0xc(%eax),%ecx
  10175b:	8b 45 08             	mov    0x8(%ebp),%eax
  10175e:	8b 40 08             	mov    0x8(%eax),%eax
  101761:	89 c2                	mov    %eax,%edx
  101763:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  101769:	8b 45 08             	mov    0x8(%ebp),%eax
  10176c:	8b 40 04             	mov    0x4(%eax),%eax
  10176f:	83 ec 04             	sub    $0x4,%esp
  101772:	51                   	push   %ecx
  101773:	52                   	push   %edx
  101774:	50                   	push   %eax
  101775:	e8 6c 07 00 00       	call   101ee6 <port_out>
  10177a:	83 c4 10             	add    $0x10,%esp
  10177d:	8b 55 08             	mov    0x8(%ebp),%edx
  101780:	89 02                	mov    %eax,(%edx)
	}
	    break;
  101782:	e9 df 00 00 00       	jmp    101866 <syscall+0x77e>

	case 52:
	{
	    cpu->eax = port_in(cpu->ebx, (uint16_t)cpu->ecx);
  101787:	8b 45 08             	mov    0x8(%ebp),%eax
  10178a:	8b 40 08             	mov    0x8(%eax),%eax
  10178d:	89 c2                	mov    %eax,%edx
  10178f:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  101795:	8b 45 08             	mov    0x8(%ebp),%eax
  101798:	8b 40 04             	mov    0x4(%eax),%eax
  10179b:	83 ec 08             	sub    $0x8,%esp
  10179e:	52                   	push   %edx
  10179f:	50                   	push   %eax
  1017a0:	e8 89 06 00 00       	call   101e2e <port_in>
  1017a5:	83 c4 10             	add    $0x10,%esp
  1017a8:	8b 55 08             	mov    0x8(%ebp),%edx
  1017ab:	89 02                	mov    %eax,(%edx)
	}
	    break;
  1017ad:	e9 b4 00 00 00       	jmp    101866 <syscall+0x77e>

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  1017b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1017b5:	8b 40 04             	mov    0x4(%eax),%eax
  1017b8:	83 ec 08             	sub    $0x8,%esp
  1017bb:	50                   	push   %eax
  1017bc:	68 a0 71 10 00       	push   $0x1071a0
  1017c1:	e8 a7 ed ff ff       	call   10056d <kprintf>
  1017c6:	83 c4 10             	add    $0x10,%esp
  1017c9:	89 c2                	mov    %eax,%edx
  1017cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1017ce:	89 10                	mov    %edx,(%eax)
		break;
  1017d0:	e9 91 00 00 00       	jmp    101866 <syscall+0x77e>

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  1017d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1017d8:	8b 40 04             	mov    0x4(%eax),%eax
  1017db:	83 ec 08             	sub    $0x8,%esp
  1017de:	50                   	push   %eax
  1017df:	68 a3 71 10 00       	push   $0x1071a3
  1017e4:	e8 84 ed ff ff       	call   10056d <kprintf>
  1017e9:	83 c4 10             	add    $0x10,%esp
  1017ec:	89 c2                	mov    %eax,%edx
  1017ee:	8b 45 08             	mov    0x8(%ebp),%eax
  1017f1:	89 10                	mov    %edx,(%eax)
		break;
  1017f3:	eb 71                	jmp    101866 <syscall+0x77e>

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  1017f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1017f8:	8b 40 04             	mov    0x4(%eax),%eax
  1017fb:	83 ec 0c             	sub    $0xc,%esp
  1017fe:	50                   	push   %eax
  1017ff:	e8 4f 3a 00 00       	call   105253 <vmm_alloc_ucont>
  101804:	83 c4 10             	add    $0x10,%esp
  101807:	89 c2                	mov    %eax,%edx
  101809:	8b 45 08             	mov    0x8(%ebp),%eax
  10180c:	89 10                	mov    %edx,(%eax)
		break;
  10180e:	eb 56                	jmp    101866 <syscall+0x77e>

	case 204: /* vmm_free */
		cpu->eax = 0;
  101810:	8b 45 08             	mov    0x8(%ebp),%eax
  101813:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  101819:	8b 45 08             	mov    0x8(%ebp),%eax
  10181c:	8b 40 04             	mov    0x4(%eax),%eax
  10181f:	3d ff 0f 40 01       	cmp    $0x1400fff,%eax
  101824:	76 3f                	jbe    101865 <syscall+0x77d>
			vmm_free((void*) cpu->ebx);
  101826:	8b 45 08             	mov    0x8(%ebp),%eax
  101829:	8b 40 04             	mov    0x4(%eax),%eax
  10182c:	83 ec 0c             	sub    $0xc,%esp
  10182f:	50                   	push   %eax
  101830:	e8 84 38 00 00       	call   1050b9 <vmm_free>
  101835:	83 c4 10             	add    $0x10,%esp
		}
		break;
  101838:	eb 2c                	jmp    101866 <syscall+0x77e>

	case 205: /* pmm_print_stats */
		pmm_print_stats();
  10183a:	e8 9a 02 00 00       	call   101ad9 <pmm_print_stats>
		break;
  10183f:	eb 25                	jmp    101866 <syscall+0x77e>

	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  101841:	8b 45 08             	mov    0x8(%ebp),%eax
  101844:	8b 00                	mov    (%eax),%eax
  101846:	83 ec 08             	sub    $0x8,%esp
  101849:	50                   	push   %eax
  10184a:	68 a6 71 10 00       	push   $0x1071a6
  10184f:	e8 19 ed ff ff       	call   10056d <kprintf>
  101854:	83 c4 10             	add    $0x10,%esp
  101857:	eb 0d                	jmp    101866 <syscall+0x77e>

		if(cpu->edx) {
			cpu = schedule(cpu);
		}
    }
        break;
  101859:	90                   	nop    
  10185a:	eb 0a                	jmp    101866 <syscall+0x77e>
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;
  10185c:	90                   	nop    
  10185d:	eb 07                	jmp    101866 <syscall+0x77e>
	    uint32_t handlerAddr = cpu->ebx;
	    if(get_current_task()->rpc_handler_addr == 0) {
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
	}
	    break;
  10185f:	90                   	nop    
  101860:	eb 04                	jmp    101866 <syscall+0x77e>
	    if(get_current_task()->rpc != 0) {
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
	    break;
  101862:	90                   	nop    
  101863:	eb 01                	jmp    101866 <syscall+0x77e>
	case 204: /* vmm_free */
		cpu->eax = 0;
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
			vmm_free((void*) cpu->ebx);
		}
		break;
  101865:	90                   	nop    
	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
		break;
	}

	return cpu;
  101866:	8b 45 08             	mov    0x8(%ebp),%eax
}
  101869:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10186c:	c9                   	leave  
  10186d:	c3                   	ret    

0010186e <kernel_main>:

void kernel_main(struct multiboot_info* mb_info) {
  10186e:	55                   	push   %ebp
  10186f:	89 e5                	mov    %esp,%ebp
  101871:	83 ec 18             	sub    $0x18,%esp
	uint32_t kernel_init_pdir = vmm_init();
  101874:	e8 0e 3b 00 00       	call   105387 <vmm_init>
  101879:	89 45 f4             	mov    %eax,-0xc(%ebp)

	kprintf("Setting PIT interval...\n");
  10187c:	83 ec 0c             	sub    $0xc,%esp
  10187f:	68 f4 74 10 00       	push   $0x1074f4
  101884:	e8 e4 ec ff ff       	call   10056d <kprintf>
  101889:	83 c4 10             	add    $0x10,%esp

    outb(0x43, 0b00110100);
  10188c:	83 ec 08             	sub    $0x8,%esp
  10188f:	6a 34                	push   $0x34
  101891:	6a 43                	push   $0x43
  101893:	e8 7b 07 00 00       	call   102013 <outb>
  101898:	83 c4 10             	add    $0x10,%esp
    outb(0x40, 0x00);
  10189b:	83 ec 08             	sub    $0x8,%esp
  10189e:	6a 00                	push   $0x0
  1018a0:	6a 40                	push   $0x40
  1018a2:	e8 6c 07 00 00       	call   102013 <outb>
  1018a7:	83 c4 10             	add    $0x10,%esp
    outb(0x40, 0x08);
  1018aa:	83 ec 08             	sub    $0x8,%esp
  1018ad:	6a 08                	push   $0x8
  1018af:	6a 40                	push   $0x40
  1018b1:	e8 5d 07 00 00       	call   102013 <outb>
  1018b6:	83 c4 10             	add    $0x10,%esp

    kprintf("Initializing vfs...\n");
  1018b9:	83 ec 0c             	sub    $0xc,%esp
  1018bc:	68 0d 75 10 00       	push   $0x10750d
  1018c1:	e8 a7 ec ff ff       	call   10056d <kprintf>
  1018c6:	83 c4 10             	add    $0x10,%esp

    vfs_init_root();
  1018c9:	e8 19 31 00 00       	call   1049e7 <vfs_init_root>
    ramfs_fifo_init();
  1018ce:	e8 bd 0a 00 00       	call   102390 <ramfs_fifo_init>
    ramfs_block_init();
  1018d3:	e8 90 07 00 00       	call   102068 <ramfs_block_init>

    //driver_keyboard_init();


    map_address_active((uint32_t) mb_info,
  1018d8:	8b 55 08             	mov    0x8(%ebp),%edx
  1018db:	8b 45 08             	mov    0x8(%ebp),%eax
  1018de:	83 ec 04             	sub    $0x4,%esp
  1018e1:	6a 00                	push   $0x0
  1018e3:	52                   	push   %edx
  1018e4:	50                   	push   %eax
  1018e5:	e8 7a 37 00 00       	call   105064 <map_address_active>
  1018ea:	83 c4 10             	add    $0x10,%esp
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  1018ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1018f0:	8b 40 18             	mov    0x18(%eax),%eax
  1018f3:	89 c2                	mov    %eax,%edx
  1018f5:	8b 45 08             	mov    0x8(%ebp),%eax
  1018f8:	8b 40 18             	mov    0x18(%eax),%eax
  1018fb:	83 ec 04             	sub    $0x4,%esp
  1018fe:	6a 00                	push   $0x0
  101900:	52                   	push   %edx
  101901:	50                   	push   %eax
  101902:	e8 5d 37 00 00       	call   105064 <map_address_active>
  101907:	83 c4 10             	add    $0x10,%esp
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  10190a:	8b 45 08             	mov    0x8(%ebp),%eax
  10190d:	8b 00                	mov    (%eax),%eax
  10190f:	83 e0 08             	and    $0x8,%eax
  101912:	85 c0                	test   %eax,%eax
  101914:	0f 84 9b 00 00 00    	je     1019b5 <kernel_main+0x147>
        vmm_map_range(mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
  10191a:	8b 45 08             	mov    0x8(%ebp),%eax
  10191d:	8b 40 18             	mov    0x18(%eax),%eax
  101920:	8b 40 04             	mov    0x4(%eax),%eax
  101923:	89 c2                	mov    %eax,%edx
  101925:	8b 45 08             	mov    0x8(%ebp),%eax
  101928:	8b 40 18             	mov    0x18(%eax),%eax
  10192b:	8b 00                	mov    (%eax),%eax
  10192d:	89 d1                	mov    %edx,%ecx
  10192f:	29 c1                	sub    %eax,%ecx
  101931:	89 c8                	mov    %ecx,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  101933:	89 c1                	mov    %eax,%ecx
                      mb_info->mi_mods_addr[0].start,
  101935:	8b 45 08             	mov    0x8(%ebp),%eax
  101938:	8b 40 18             	mov    0x18(%eax),%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  10193b:	8b 10                	mov    (%eax),%edx
  10193d:	8b 45 08             	mov    0x8(%ebp),%eax
  101940:	8b 40 18             	mov    0x18(%eax),%eax
  101943:	8b 00                	mov    (%eax),%eax
  101945:	6a 00                	push   $0x0
  101947:	51                   	push   %ecx
  101948:	52                   	push   %edx
  101949:	50                   	push   %eax
  10194a:	e8 35 36 00 00       	call   104f84 <vmm_map_range>
  10194f:	83 c4 10             	add    $0x10,%esp
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  101952:	8b 45 08             	mov    0x8(%ebp),%eax
  101955:	8b 40 18             	mov    0x18(%eax),%eax
  101958:	8b 40 04             	mov    0x4(%eax),%eax
  10195b:	89 c2                	mov    %eax,%edx
  10195d:	8b 45 08             	mov    0x8(%ebp),%eax
  101960:	8b 40 18             	mov    0x18(%eax),%eax
  101963:	8b 00                	mov    (%eax),%eax
  101965:	89 d1                	mov    %edx,%ecx
  101967:	29 c1                	sub    %eax,%ecx
  101969:	89 c8                	mov    %ecx,%eax
  10196b:	83 ec 08             	sub    $0x8,%esp
  10196e:	50                   	push   %eax
  10196f:	68 24 75 10 00       	push   $0x107524
  101974:	e8 f4 eb ff ff       	call   10056d <kprintf>
  101979:	83 c4 10             	add    $0x10,%esp
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);
  10197c:	8b 45 08             	mov    0x8(%ebp),%eax
  10197f:	8b 40 18             	mov    0x18(%eax),%eax
  101982:	8b 50 04             	mov    0x4(%eax),%edx
  101985:	8b 45 08             	mov    0x8(%ebp),%eax
  101988:	8b 40 18             	mov    0x18(%eax),%eax
  10198b:	8b 00                	mov    (%eax),%eax
  10198d:	83 ec 04             	sub    $0x4,%esp
  101990:	52                   	push   %edx
  101991:	50                   	push   %eax
  101992:	68 64 75 10 00       	push   $0x107564
  101997:	e8 d1 eb ff ff       	call   10056d <kprintf>
  10199c:	83 c4 10             	add    $0x10,%esp

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  10199f:	8b 45 08             	mov    0x8(%ebp),%eax
  1019a2:	8b 40 18             	mov    0x18(%eax),%eax
  1019a5:	8b 00                	mov    (%eax),%eax
  1019a7:	83 ec 0c             	sub    $0xc,%esp
  1019aa:	50                   	push   %eax
  1019ab:	e8 39 0e 00 00       	call   1027e9 <tar_load_ramfs>
  1019b0:	83 c4 10             	add    $0x10,%esp
  1019b3:	eb 10                	jmp    1019c5 <kernel_main+0x157>
    } else {
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  1019b5:	83 ec 0c             	sub    $0xc,%esp
  1019b8:	68 80 75 10 00       	push   $0x107580
  1019bd:	e8 ab eb ff ff       	call   10056d <kprintf>
  1019c2:	83 c4 10             	add    $0x10,%esp
    }

    kprintf("[kernel_res] Creating /dev/vga\n");
  1019c5:	83 ec 0c             	sub    $0xc,%esp
  1019c8:	68 b4 75 10 00       	push   $0x1075b4
  1019cd:	e8 9b eb ff ff       	call   10056d <kprintf>
  1019d2:	83 c4 10             	add    $0x10,%esp
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  1019d5:	e8 52 0f 00 00       	call   10292c <ramfs_vga_driver_struct>
  1019da:	83 ec 04             	sub    $0x4,%esp
  1019dd:	6a 00                	push   $0x0
  1019df:	50                   	push   %eax
  1019e0:	68 d4 75 10 00       	push   $0x1075d4
  1019e5:	e8 e2 27 00 00       	call   1041cc <vfs_create_kfile>
  1019ea:	83 c4 10             	add    $0x10,%esp

    if(vfs_exists("/ibin/init")) {
  1019ed:	83 ec 0c             	sub    $0xc,%esp
  1019f0:	68 dd 75 10 00       	push   $0x1075dd
  1019f5:	e8 5a 2a 00 00       	call   104454 <vfs_exists>
  1019fa:	83 c4 10             	add    $0x10,%esp
  1019fd:	85 c0                	test   %eax,%eax
  1019ff:	74 31                	je     101a32 <kernel_main+0x1c4>
        kprintf("[init] /ibin/init found. Executing...\n");
  101a01:	83 ec 0c             	sub    $0xc,%esp
  101a04:	68 e8 75 10 00       	push   $0x1075e8
  101a09:	e8 5f eb ff ff       	call   10056d <kprintf>
  101a0e:	83 c4 10             	add    $0x10,%esp

        vfs_exec("/ibin/init", 0, 0, 0, 0, 0, 0);
  101a11:	83 ec 04             	sub    $0x4,%esp
  101a14:	6a 00                	push   $0x0
  101a16:	6a 00                	push   $0x0
  101a18:	6a 00                	push   $0x0
  101a1a:	6a 00                	push   $0x0
  101a1c:	6a 00                	push   $0x0
  101a1e:	6a 00                	push   $0x0
  101a20:	68 dd 75 10 00       	push   $0x1075dd
  101a25:	e8 7b 2a 00 00       	call   1044a5 <vfs_exec>
  101a2a:	83 c4 20             	add    $0x20,%esp
        enableScheduling();
  101a2d:	e8 ea 10 00 00       	call   102b1c <enableScheduling>
    }

	while(1);
  101a32:	eb fe                	jmp    101a32 <kernel_main+0x1c4>

00101a34 <pmm_alloc>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct exec_info {
  101a34:	55                   	push   %ebp
  101a35:	89 e5                	mov    %esp,%ebp
  101a37:	57                   	push   %edi
  101a38:	56                   	push   %esi
  101a39:	53                   	push   %ebx
  101a3a:	83 ec 10             	sub    $0x10,%esp
    char* execPath;
    char* stdin;
  101a3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101a44:	eb 79                	jmp    101abf <pmm_alloc+0x8b>
    char* stdout;
  101a46:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101a49:	8b 04 85 c0 85 16 00 	mov    0x1685c0(,%eax,4),%eax
  101a50:	85 c0                	test   %eax,%eax
  101a52:	74 68                	je     101abc <pmm_alloc+0x88>
    char* stderr;
};
  101a54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101a5b:	eb 59                	jmp    101ab6 <pmm_alloc+0x82>

  101a5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101a60:	8b 14 85 c0 85 16 00 	mov    0x1685c0(,%eax,4),%edx
  101a67:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101a6a:	bb 01 00 00 00       	mov    $0x1,%ebx
  101a6f:	89 de                	mov    %ebx,%esi
  101a71:	88 c1                	mov    %al,%cl
  101a73:	d3 e6                	shl    %cl,%esi
  101a75:	89 f0                	mov    %esi,%eax
  101a77:	21 d0                	and    %edx,%eax
  101a79:	85 c0                	test   %eax,%eax
  101a7b:	74 36                	je     101ab3 <pmm_alloc+0x7f>
struct cpu_state* syscall(struct cpu_state* cpu) {
  101a7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101a80:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101a83:	8b 1c 95 c0 85 16 00 	mov    0x1685c0(,%edx,4),%ebx
  101a8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101a8d:	be 01 00 00 00       	mov    $0x1,%esi
  101a92:	89 f7                	mov    %esi,%edi
  101a94:	88 d1                	mov    %dl,%cl
  101a96:	d3 e7                	shl    %cl,%edi
  101a98:	89 fa                	mov    %edi,%edx
  101a9a:	f7 d2                	not    %edx
  101a9c:	21 da                	and    %ebx,%edx
  101a9e:	89 14 85 c0 85 16 00 	mov    %edx,0x1685c0(,%eax,4)
    cpu = save_cpu_state(cpu);
  101aa5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101aa8:	c1 e0 05             	shl    $0x5,%eax
  101aab:	03 45 f0             	add    -0x10(%ebp),%eax
  101aae:	c1 e0 0c             	shl    $0xc,%eax
  101ab1:	eb 1e                	jmp    101ad1 <pmm_alloc+0x9d>
struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
    char* stderr;
};
  101ab3:	ff 45 f0             	incl   -0x10(%ebp)
  101ab6:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
  101aba:	7e a1                	jle    101a5d <pmm_alloc+0x29>
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct exec_info {
    char* execPath;
    char* stdin;
  101abc:	ff 45 ec             	incl   -0x14(%ebp)
  101abf:	81 7d ec ff 7f 00 00 	cmpl   $0x7fff,-0x14(%ebp)
  101ac6:	0f 8e 7a ff ff ff    	jle    101a46 <pmm_alloc+0x12>
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
		return terminate_current(cpu);

  101acc:	b8 00 00 00 00       	mov    $0x0,%eax
	case 2: /* pexists */
  101ad1:	83 c4 10             	add    $0x10,%esp
  101ad4:	5b                   	pop    %ebx
  101ad5:	5e                   	pop    %esi
  101ad6:	5f                   	pop    %edi
  101ad7:	5d                   	pop    %ebp
  101ad8:	c3                   	ret    

00101ad9 <pmm_print_stats>:
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  101ad9:	55                   	push   %ebp
  101ada:	89 e5                	mov    %esp,%ebp
  101adc:	57                   	push   %edi
  101add:	56                   	push   %esi
  101ade:	53                   	push   %ebx
  101adf:	83 ec 0c             	sub    $0xc,%esp
	}
  101ae2:	a1 20 85 12 00       	mov    0x128520,%eax
  101ae7:	89 c7                	mov    %eax,%edi
  101ae9:	c1 ef 0a             	shr    $0xa,%edi
  101aec:	83 ec 0c             	sub    $0xc,%esp
  101aef:	68 00 04 00 00       	push   $0x400
  101af4:	e8 3e 00 00 00       	call   101b37 <pmm_get_free_space>
  101af9:	83 c4 10             	add    $0x10,%esp
  101afc:	89 c3                	mov    %eax,%ebx
  101afe:	a1 20 85 12 00       	mov    0x128520,%eax
  101b03:	89 c6                	mov    %eax,%esi
  101b05:	c1 ee 14             	shr    $0x14,%esi
  101b08:	83 ec 0c             	sub    $0xc,%esp
  101b0b:	68 00 00 10 00       	push   $0x100000
  101b10:	e8 22 00 00 00       	call   101b37 <pmm_get_free_space>
  101b15:	83 c4 10             	add    $0x10,%esp
  101b18:	83 ec 0c             	sub    $0xc,%esp
  101b1b:	57                   	push   %edi
  101b1c:	53                   	push   %ebx
  101b1d:	56                   	push   %esi
  101b1e:	50                   	push   %eax
  101b1f:	68 10 76 10 00       	push   $0x107610
  101b24:	e8 44 ea ff ff       	call   10056d <kprintf>
  101b29:	83 c4 20             	add    $0x20,%esp
	    break;

    case 3: /* exec */
  101b2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  101b2f:	83 c4 00             	add    $0x0,%esp
  101b32:	5b                   	pop    %ebx
  101b33:	5e                   	pop    %esi
  101b34:	5f                   	pop    %edi
  101b35:	5d                   	pop    %ebp
  101b36:	c3                   	ret    

00101b37 <pmm_get_free_space>:
    {
        char* path = strclone((char*) cpu->ebx);
  101b37:	55                   	push   %ebp
  101b38:	89 e5                	mov    %esp,%ebp
  101b3a:	56                   	push   %esi
  101b3b:	53                   	push   %ebx
  101b3c:	83 ec 10             	sub    $0x10,%esp

  101b3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

  101b46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101b4d:	eb 3c                	jmp    101b8b <pmm_get_free_space+0x54>
        free(path);
  101b4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  101b56:	eb 2a                	jmp    101b82 <pmm_get_free_space+0x4b>

  101b58:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101b5b:	8b 14 85 c0 85 16 00 	mov    0x1685c0(,%eax,4),%edx
  101b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101b65:	bb 01 00 00 00       	mov    $0x1,%ebx
  101b6a:	89 de                	mov    %ebx,%esi
  101b6c:	88 c1                	mov    %al,%cl
  101b6e:	d3 e6                	shl    %cl,%esi
  101b70:	89 f0                	mov    %esi,%eax
  101b72:	21 d0                	and    %edx,%eax
  101b74:	85 c0                	test   %eax,%eax
  101b76:	74 07                	je     101b7f <pmm_get_free_space+0x48>
		if(cpu->edx) {
  101b78:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
    {
        char* path = strclone((char*) cpu->ebx);

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);
  101b7f:	ff 45 f4             	incl   -0xc(%ebp)
  101b82:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
  101b86:	76 d0                	jbe    101b58 <pmm_get_free_space+0x21>
    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

  101b88:	ff 45 f0             	incl   -0x10(%ebp)
  101b8b:	81 7d f0 ff 7f 00 00 	cmpl   $0x7fff,-0x10(%ebp)
  101b92:	76 bb                	jbe    101b4f <pmm_get_free_space+0x18>

		if(cpu->edx) {
			cpu = schedule(cpu);
		}
    }
        break;
  101b94:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101b97:	ba 00 00 00 00       	mov    $0x0,%edx
  101b9c:	f7 75 08             	divl   0x8(%ebp)

  101b9f:	83 c4 10             	add    $0x10,%esp
  101ba2:	5b                   	pop    %ebx
  101ba3:	5e                   	pop    %esi
  101ba4:	5d                   	pop    %ebp
  101ba5:	c3                   	ret    

00101ba6 <pmm_free>:
    case 4: /* getargs */
    {
  101ba6:	55                   	push   %ebp
  101ba7:	89 e5                	mov    %esp,%ebp
  101ba9:	57                   	push   %edi
  101baa:	56                   	push   %esi
  101bab:	53                   	push   %ebx
  101bac:	83 ec 10             	sub    $0x10,%esp
        cpu->eax = (uint32_t) get_current_task()->args;
  101baf:	8b 45 08             	mov    0x8(%ebp),%eax
  101bb2:	c1 e8 0c             	shr    $0xc,%eax
  101bb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }
        break;
  101bb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101bbb:	83 e0 1f             	and    $0x1f,%eax
  101bbe:	89 45 ec             	mov    %eax,-0x14(%ebp)

  101bc1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101bc4:	c1 e8 05             	shr    $0x5,%eax
  101bc7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    case 5: /* yield */
    {
  101bca:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101bcd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101bd0:	8b 1c 95 c0 85 16 00 	mov    0x1685c0(,%edx,4),%ebx
  101bd7:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101bda:	be 01 00 00 00       	mov    $0x1,%esi
  101bdf:	89 f7                	mov    %esi,%edi
  101be1:	88 d1                	mov    %dl,%cl
  101be3:	d3 e7                	shl    %cl,%edi
  101be5:	89 fa                	mov    %edi,%edx
  101be7:	09 da                	or     %ebx,%edx
  101be9:	89 14 85 c0 85 16 00 	mov    %edx,0x1685c0(,%eax,4)
        cpu = schedule(cpu);
  101bf0:	83 c4 10             	add    $0x10,%esp
  101bf3:	5b                   	pop    %ebx
  101bf4:	5e                   	pop    %esi
  101bf5:	5f                   	pop    %edi
  101bf6:	5d                   	pop    %ebp
  101bf7:	c3                   	ret    

00101bf8 <pmm_mark_used>:
    }
        break;
  101bf8:	55                   	push   %ebp
  101bf9:	89 e5                	mov    %esp,%ebp
  101bfb:	57                   	push   %edi
  101bfc:	56                   	push   %esi
  101bfd:	53                   	push   %ebx
  101bfe:	83 ec 10             	sub    $0x10,%esp

  101c01:	8b 45 08             	mov    0x8(%ebp),%eax
  101c04:	c1 e8 0c             	shr    $0xc,%eax
  101c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
    case 6: /* getExecPath */
    {
  101c0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101c0d:	83 e0 1f             	and    $0x1f,%eax
  101c10:	89 45 ec             	mov    %eax,-0x14(%ebp)
        char* dest = (char*)cpu->ebx;
  101c13:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101c16:	c1 e8 05             	shr    $0x5,%eax
  101c19:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  101c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101c1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  101c22:	8b 1c 95 c0 85 16 00 	mov    0x1685c0(,%edx,4),%ebx
  101c29:	8b 55 ec             	mov    -0x14(%ebp),%edx
  101c2c:	be 01 00 00 00       	mov    $0x1,%esi
  101c31:	89 f7                	mov    %esi,%edi
  101c33:	88 d1                	mov    %dl,%cl
  101c35:	d3 e7                	shl    %cl,%edi
  101c37:	89 fa                	mov    %edi,%edx
  101c39:	f7 d2                	not    %edx
  101c3b:	21 da                	and    %ebx,%edx
  101c3d:	89 14 85 c0 85 16 00 	mov    %edx,0x1685c0(,%eax,4)
        break;
  101c44:	83 c4 10             	add    $0x10,%esp
  101c47:	5b                   	pop    %ebx
  101c48:	5e                   	pop    %esi
  101c49:	5f                   	pop    %edi
  101c4a:	5d                   	pop    %ebp
  101c4b:	c3                   	ret    

00101c4c <pmm_init>:

    case 7: /* changeExecPath */
  101c4c:	55                   	push   %ebp
  101c4d:	89 e5                	mov    %esp,%ebp
  101c4f:	83 ec 28             	sub    $0x28,%esp
    {
  101c52:	8b 45 08             	mov    0x8(%ebp),%eax
  101c55:	8b 40 30             	mov    0x30(%eax),%eax
  101c58:	89 45 dc             	mov    %eax,-0x24(%ebp)
        vfs_reset_error();
  101c5b:	8b 45 08             	mov    0x8(%ebp),%eax
  101c5e:	8b 40 30             	mov    0x30(%eax),%eax
  101c61:	89 c2                	mov    %eax,%edx
  101c63:	8b 45 08             	mov    0x8(%ebp),%eax
  101c66:	8b 40 2c             	mov    0x2c(%eax),%eax
  101c69:	8d 04 02             	lea    (%edx,%eax,1),%eax
        char* path = strclone((char*) cpu->ebx);
  101c6c:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  101c6f:	83 ec 04             	sub    $0x4,%esp
  101c72:	68 00 00 02 00       	push   $0x20000
  101c77:	6a 00                	push   $0x0
  101c79:	68 c0 85 16 00       	push   $0x1685c0
  101c7e:	e8 c1 1c 00 00       	call   103944 <memset>
  101c83:	83 c4 10             	add    $0x10,%esp

        char* new = vfs_resolve_path(path);
  101c86:	b8 c0 85 18 00       	mov    $0x1885c0,%eax
  101c8b:	83 ec 04             	sub    $0x4,%esp
  101c8e:	50                   	push   %eax
  101c8f:	68 c0 85 16 00       	push   $0x1685c0
  101c94:	68 4d 76 10 00       	push   $0x10764d
  101c99:	e8 cf e8 ff ff       	call   10056d <kprintf>
  101c9e:	83 c4 10             	add    $0x10,%esp

        cpu->eax = 0;
  101ca1:	eb 5c                	jmp    101cff <pmm_init+0xb3>
        if(new) {
  101ca3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101ca6:	8b 40 14             	mov    0x14(%eax),%eax
  101ca9:	83 f8 01             	cmp    $0x1,%eax
  101cac:	75 4d                	jne    101cfb <pmm_init+0xaf>
            get_current_task()->execPath = new;
  101cae:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101cb1:	8b 50 08             	mov    0x8(%eax),%edx
  101cb4:	8b 40 04             	mov    0x4(%eax),%eax
  101cb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cpu->eax = 1;
  101cba:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101cbd:	8b 50 10             	mov    0x10(%eax),%edx
  101cc0:	8b 40 0c             	mov    0xc(%eax),%eax
  101cc3:	03 45 f0             	add    -0x10(%ebp),%eax
  101cc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

  101cc9:	eb 28                	jmp    101cf3 <pmm_init+0xa7>
        free(path);
  101ccb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cce:	83 ec 0c             	sub    $0xc,%esp
  101cd1:	50                   	push   %eax
  101cd2:	e8 cf fe ff ff       	call   101ba6 <pmm_free>
  101cd7:	83 c4 10             	add    $0x10,%esp
    }
  101cda:	a1 20 85 12 00       	mov    0x128520,%eax
  101cdf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  101ce2:	76 08                	jbe    101cec <pmm_init+0xa0>
        break;
  101ce4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101ce7:	a3 20 85 12 00       	mov    %eax,0x128520

  101cec:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
        cpu->eax = 0;
        if(new) {
            get_current_task()->execPath = new;
            cpu->eax = 1;
        }

  101cf3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cf6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  101cf9:	72 d0                	jb     101ccb <pmm_init+0x7f>
    }
        break;

	case 10: /* fopen */
	{
        vfs_reset_error();
  101cfb:	83 45 dc 18          	addl   $0x18,-0x24(%ebp)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);

        cpu->eax = 0;
  101cff:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101d02:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  101d05:	72 9c                	jb     101ca3 <pmm_init+0x57>
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
	        register_handle(handle);
  101d07:	c7 45 e4 00 00 10 00 	movl   $0x100000,-0x1c(%ebp)
	        cpu->eax = (uint32_t) handle;
  101d0e:	eb 16                	jmp    101d26 <pmm_init+0xda>
	    }
  101d10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101d13:	83 ec 0c             	sub    $0xc,%esp
  101d16:	50                   	push   %eax
  101d17:	e8 dc fe ff ff       	call   101bf8 <pmm_mark_used>
  101d1c:	83 c4 10             	add    $0x10,%esp
	    else
  101d1f:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
  101d26:	b8 00 90 1c 00       	mov    $0x1c9000,%eax
  101d2b:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  101d2e:	72 e0                	jb     101d10 <pmm_init+0xc4>
	    }
	    else
	    {
	        cpu->eax = 0;
	    }
  101d30:	8b 45 08             	mov    0x8(%ebp),%eax
  101d33:	8b 40 18             	mov    0x18(%eax),%eax
  101d36:	89 45 e8             	mov    %eax,-0x18(%ebp)

	    free(name);
  101d39:	83 ec 0c             	sub    $0xc,%esp
  101d3c:	ff 75 08             	pushl  0x8(%ebp)
  101d3f:	e8 b4 fe ff ff       	call   101bf8 <pmm_mark_used>
  101d44:	83 c4 10             	add    $0x10,%esp
	}
  101d47:	83 ec 0c             	sub    $0xc,%esp
  101d4a:	ff 75 e8             	pushl  -0x18(%ebp)
  101d4d:	e8 a6 fe ff ff       	call   101bf8 <pmm_mark_used>
  101d52:	83 c4 10             	add    $0x10,%esp
	    break;

	case 11: /* fclose */
  101d55:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  101d5c:	eb 3a                	jmp    101d98 <pmm_init+0x14c>
	{
  101d5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101d61:	c1 e0 04             	shl    $0x4,%eax
  101d64:	03 45 e8             	add    -0x18(%ebp),%eax
  101d67:	8b 00                	mov    (%eax),%eax
  101d69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        vfs_reset_error();
  101d6c:	eb 16                	jmp    101d84 <pmm_init+0x138>
	    struct res_handle* handle = (void*) cpu->ebx;
  101d6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101d71:	83 ec 0c             	sub    $0xc,%esp
  101d74:	50                   	push   %eax
  101d75:	e8 7e fe ff ff       	call   101bf8 <pmm_mark_used>
  101d7a:	83 c4 10             	add    $0x10,%esp
	    if(!unregister_handle(handle)) {
  101d7d:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
	}
	    break;

	case 11: /* fclose */
	{
        vfs_reset_error();
  101d84:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101d87:	c1 e0 04             	shl    $0x4,%eax
  101d8a:	03 45 e8             	add    -0x18(%ebp),%eax
  101d8d:	8b 40 04             	mov    0x4(%eax),%eax
  101d90:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  101d93:	77 d9                	ja     101d6e <pmm_init+0x122>

	    free(name);
	}
	    break;

	case 11: /* fclose */
  101d95:	ff 45 ec             	incl   -0x14(%ebp)
  101d98:	8b 45 08             	mov    0x8(%ebp),%eax
  101d9b:	8b 40 14             	mov    0x14(%eax),%eax
  101d9e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  101da1:	77 bb                	ja     101d5e <pmm_init+0x112>
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

	        cpu->eax = 0;
  101da3:	c9                   	leave  
  101da4:	c3                   	ret    
  101da5:	00 00                	add    %al,(%eax)
	...

00101da8 <free_ports_for_pid>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
  101da8:	55                   	push   %ebp
  101da9:	89 e5                	mov    %esp,%ebp
  101dab:	83 ec 10             	sub    $0x10,%esp
#include "ramfs/tar.h"
  101dae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  101db5:	eb 20                	jmp    101dd7 <free_ports_for_pid+0x2f>
#include "ramfs/vgacntrl.h"
  101db7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101dba:	8b 04 85 80 85 12 00 	mov    0x128580(,%eax,4),%eax
  101dc1:	3b 45 08             	cmp    0x8(%ebp),%eax
  101dc4:	75 0e                	jne    101dd4 <free_ports_for_pid+0x2c>

  101dc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101dc9:	c7 04 85 80 85 12 00 	movl   $0x0,0x128580(,%eax,4)
  101dd0:	00 00 00 00 
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  101dd4:	ff 45 fc             	incl   -0x4(%ebp)
  101dd7:	81 7d fc ff ff 00 00 	cmpl   $0xffff,-0x4(%ebp)
  101dde:	7e d7                	jle    101db7 <free_ports_for_pid+0xf>
#include "ramfs/vgacntrl.h"

struct exec_info {
    char* execPath;
    char* stdin;
  101de0:	c9                   	leave  
  101de1:	c3                   	ret    

00101de2 <require_port>:
    char* stdout;
    char* stderr;
  101de2:	55                   	push   %ebp
  101de3:	89 e5                	mov    %esp,%ebp
  101de5:	53                   	push   %ebx
  101de6:	83 ec 14             	sub    $0x14,%esp
  101de9:	8b 45 08             	mov    0x8(%ebp),%eax
  101dec:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
};
  101df0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101df3:	25 ff ff 00 00       	and    $0xffff,%eax
  101df8:	8b 04 85 80 85 12 00 	mov    0x128580(,%eax,4),%eax
  101dff:	85 c0                	test   %eax,%eax
  101e01:	74 07                	je     101e0a <require_port+0x28>
  101e03:	b8 00 00 00 00       	mov    $0x0,%eax
  101e08:	eb 1e                	jmp    101e28 <require_port+0x46>

  101e0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e0d:	89 c3                	mov    %eax,%ebx
  101e0f:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  101e15:	e8 1b 0d 00 00       	call   102b35 <get_current_task>
  101e1a:	8b 00                	mov    (%eax),%eax
  101e1c:	89 04 9d 80 85 12 00 	mov    %eax,0x128580(,%ebx,4)
struct cpu_state* syscall(struct cpu_state* cpu) {
  101e23:	b8 01 00 00 00       	mov    $0x1,%eax
    cpu = save_cpu_state(cpu);
  101e28:	83 c4 14             	add    $0x14,%esp
  101e2b:	5b                   	pop    %ebx
  101e2c:	5d                   	pop    %ebp
  101e2d:	c3                   	ret    

00101e2e <port_in>:

	switch (cpu->eax) {
  101e2e:	55                   	push   %ebp
  101e2f:	89 e5                	mov    %esp,%ebp
  101e31:	53                   	push   %ebx
  101e32:	83 ec 14             	sub    $0x14,%esp
  101e35:	8b 45 0c             	mov    0xc(%ebp),%eax
  101e38:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
	case 1: /* exit */
  101e3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e3f:	25 ff ff 00 00       	and    $0xffff,%eax
  101e44:	8b 1c 85 80 85 12 00 	mov    0x128580(,%eax,4),%ebx
  101e4b:	e8 e5 0c 00 00       	call   102b35 <get_current_task>
  101e50:	8b 00                	mov    (%eax),%eax
  101e52:	39 c3                	cmp    %eax,%ebx
  101e54:	74 26                	je     101e7c <port_in+0x4e>
		return terminate_current(cpu);
  101e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e59:	89 c3                	mov    %eax,%ebx
  101e5b:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  101e61:	e8 cf 0c 00 00       	call   102b35 <get_current_task>
  101e66:	8b 00                	mov    (%eax),%eax
  101e68:	83 ec 04             	sub    $0x4,%esp
  101e6b:	53                   	push   %ebx
  101e6c:	50                   	push   %eax
  101e6d:	68 64 76 10 00       	push   $0x107664
  101e72:	e8 f6 e6 ff ff       	call   10056d <kprintf>
  101e77:	83 c4 10             	add    $0x10,%esp

  101e7a:	eb fe                	jmp    101e7a <port_in+0x4c>
	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
	}
  101e7c:	8b 45 08             	mov    0x8(%ebp),%eax
  101e7f:	83 f8 01             	cmp    $0x1,%eax
  101e82:	74 27                	je     101eab <port_in+0x7d>
  101e84:	83 f8 01             	cmp    $0x1,%eax
  101e87:	72 07                	jb     101e90 <port_in+0x62>
  101e89:	83 f8 02             	cmp    $0x2,%eax
  101e8c:	74 38                	je     101ec6 <port_in+0x98>
  101e8e:	eb 4c                	jmp    101edc <port_in+0xae>
	    break;

  101e90:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e93:	25 ff ff 00 00       	and    $0xffff,%eax
  101e98:	83 ec 0c             	sub    $0xc,%esp
  101e9b:	50                   	push   %eax
  101e9c:	e8 1e 01 00 00       	call   101fbf <inb>
  101ea1:	83 c4 10             	add    $0x10,%esp
  101ea4:	25 ff 00 00 00       	and    $0xff,%eax
  101ea9:	eb 36                	jmp    101ee1 <port_in+0xb3>
    case 3: /* exec */
    {
  101eab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101eae:	25 ff ff 00 00       	and    $0xffff,%eax
  101eb3:	83 ec 0c             	sub    $0xc,%esp
  101eb6:	50                   	push   %eax
  101eb7:	e8 e5 00 00 00       	call   101fa1 <inw>
  101ebc:	83 c4 10             	add    $0x10,%esp
  101ebf:	25 ff ff 00 00       	and    $0xffff,%eax
  101ec4:	eb 1b                	jmp    101ee1 <port_in+0xb3>
        char* path = strclone((char*) cpu->ebx);

  101ec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ec9:	25 ff ff 00 00       	and    $0xffff,%eax
  101ece:	83 ec 0c             	sub    $0xc,%esp
  101ed1:	50                   	push   %eax
  101ed2:	e8 03 01 00 00       	call   101fda <inl>
  101ed7:	83 c4 10             	add    $0x10,%esp
  101eda:	eb 05                	jmp    101ee1 <port_in+0xb3>
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);
  101edc:	b8 00 00 00 00       	mov    $0x0,%eax

  101ee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101ee4:	c9                   	leave  
  101ee5:	c3                   	ret    

00101ee6 <port_out>:
		if(cpu->edx) {
			cpu = schedule(cpu);
  101ee6:	55                   	push   %ebp
  101ee7:	89 e5                	mov    %esp,%ebp
  101ee9:	53                   	push   %ebx
  101eea:	83 ec 14             	sub    $0x14,%esp
  101eed:	8b 45 0c             	mov    0xc(%ebp),%eax
  101ef0:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
		}
  101ef4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ef7:	25 ff ff 00 00       	and    $0xffff,%eax
  101efc:	8b 1c 85 80 85 12 00 	mov    0x128580(,%eax,4),%ebx
  101f03:	e8 2d 0c 00 00       	call   102b35 <get_current_task>
  101f08:	8b 00                	mov    (%eax),%eax
  101f0a:	39 c3                	cmp    %eax,%ebx
  101f0c:	74 0a                	je     101f18 <port_out+0x32>
    }
  101f0e:	b8 00 00 00 00       	mov    $0x0,%eax
  101f13:	e9 84 00 00 00       	jmp    101f9c <port_out+0xb6>
        break;

    case 4: /* getargs */
  101f18:	8b 45 08             	mov    0x8(%ebp),%eax
  101f1b:	83 f8 01             	cmp    $0x1,%eax
  101f1e:	74 32                	je     101f52 <port_out+0x6c>
  101f20:	83 f8 01             	cmp    $0x1,%eax
  101f23:	72 07                	jb     101f2c <port_out+0x46>
  101f25:	83 f8 02             	cmp    $0x2,%eax
  101f28:	74 4f                	je     101f79 <port_out+0x93>
  101f2a:	eb 6b                	jmp    101f97 <port_out+0xb1>
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  101f2c:	8b 45 10             	mov    0x10(%ebp),%eax
  101f2f:	ba 00 00 00 00       	mov    $0x0,%edx
  101f34:	88 c2                	mov    %al,%dl
  101f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f39:	25 ff ff 00 00       	and    $0xffff,%eax
  101f3e:	83 ec 08             	sub    $0x8,%esp
  101f41:	52                   	push   %edx
  101f42:	50                   	push   %eax
  101f43:	e8 cb 00 00 00       	call   102013 <outb>
  101f48:	83 c4 10             	add    $0x10,%esp
    }
  101f4b:	b8 01 00 00 00       	mov    $0x1,%eax
  101f50:	eb 4a                	jmp    101f9c <port_out+0xb6>
        break;

  101f52:	8b 45 10             	mov    0x10(%ebp),%eax
  101f55:	89 c2                	mov    %eax,%edx
  101f57:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  101f5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f60:	25 ff ff 00 00       	and    $0xffff,%eax
  101f65:	83 ec 08             	sub    $0x8,%esp
  101f68:	52                   	push   %edx
  101f69:	50                   	push   %eax
  101f6a:	e8 86 00 00 00       	call   101ff5 <outw>
  101f6f:	83 c4 10             	add    $0x10,%esp
    case 5: /* yield */
  101f72:	b8 01 00 00 00       	mov    $0x1,%eax
  101f77:	eb 23                	jmp    101f9c <port_out+0xb6>
    {
        cpu = schedule(cpu);
  101f79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f7c:	25 ff ff 00 00       	and    $0xffff,%eax
  101f81:	83 ec 08             	sub    $0x8,%esp
  101f84:	ff 75 10             	pushl  0x10(%ebp)
  101f87:	50                   	push   %eax
  101f88:	e8 a2 00 00 00       	call   10202f <outl>
  101f8d:	83 c4 10             	add    $0x10,%esp
    }
  101f90:	b8 01 00 00 00       	mov    $0x1,%eax
  101f95:	eb 05                	jmp    101f9c <port_out+0xb6>
        break;

    case 6: /* getExecPath */
  101f97:	b8 00 00 00 00       	mov    $0x0,%eax
    {
  101f9c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101f9f:	c9                   	leave  
  101fa0:	c3                   	ret    

00101fa1 <inw>:
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  101fa1:	55                   	push   %ebp
  101fa2:	89 e5                	mov    %esp,%ebp
  101fa4:	83 ec 14             	sub    $0x14,%esp
  101fa7:	8b 45 08             	mov    0x8(%ebp),%eax
  101faa:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    }
        break;
  101fae:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fb1:	89 c2                	mov    %eax,%edx
  101fb3:	66 ed                	in     (%dx),%ax
  101fb5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  101fb9:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
    case 7: /* changeExecPath */
  101fbd:	c9                   	leave  
  101fbe:	c3                   	ret    

00101fbf <inb>:
    {
        vfs_reset_error();
  101fbf:	55                   	push   %ebp
  101fc0:	89 e5                	mov    %esp,%ebp
  101fc2:	83 ec 14             	sub    $0x14,%esp
  101fc5:	8b 45 08             	mov    0x8(%ebp),%eax
  101fc8:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
        char* path = strclone((char*) cpu->ebx);

  101fcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fcf:	89 c2                	mov    %eax,%edx
  101fd1:	ec                   	in     (%dx),%al
  101fd2:	88 45 ff             	mov    %al,-0x1(%ebp)
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  101fd5:	8a 45 ff             	mov    -0x1(%ebp),%al

  101fd8:	c9                   	leave  
  101fd9:	c3                   	ret    

00101fda <inl>:
        char* new = vfs_resolve_path(path);

  101fda:	55                   	push   %ebp
  101fdb:	89 e5                	mov    %esp,%ebp
  101fdd:	83 ec 14             	sub    $0x14,%esp
  101fe0:	8b 45 08             	mov    0x8(%ebp),%eax
  101fe3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
        cpu->eax = 0;
        if(new) {
  101fe7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101fea:	89 c2                	mov    %eax,%edx
  101fec:	ed                   	in     (%dx),%eax
  101fed:	89 45 fc             	mov    %eax,-0x4(%ebp)
            get_current_task()->execPath = new;
  101ff0:	8b 45 fc             	mov    -0x4(%ebp),%eax
            cpu->eax = 1;
  101ff3:	c9                   	leave  
  101ff4:	c3                   	ret    

00101ff5 <outw>:
        }

  101ff5:	55                   	push   %ebp
  101ff6:	89 e5                	mov    %esp,%ebp
  101ff8:	83 ec 08             	sub    $0x8,%esp
  101ffb:	8b 55 08             	mov    0x8(%ebp),%edx
  101ffe:	8b 45 0c             	mov    0xc(%ebp),%eax
  102001:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
  102005:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
        free(path);
  102009:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10200c:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10200f:	66 ef                	out    %ax,(%dx)
    }
  102011:	c9                   	leave  
  102012:	c3                   	ret    

00102013 <outb>:
        break;

  102013:	55                   	push   %ebp
  102014:	89 e5                	mov    %esp,%ebp
  102016:	83 ec 08             	sub    $0x8,%esp
  102019:	8b 45 08             	mov    0x8(%ebp),%eax
  10201c:	8b 55 0c             	mov    0xc(%ebp),%edx
  10201f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  102023:	88 55 f8             	mov    %dl,-0x8(%ebp)
	case 10: /* fopen */
  102026:	8a 45 f8             	mov    -0x8(%ebp),%al
  102029:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10202c:	ee                   	out    %al,(%dx)
	{
  10202d:	c9                   	leave  
  10202e:	c3                   	ret    

0010202f <outl>:
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  10202f:	55                   	push   %ebp
  102030:	89 e5                	mov    %esp,%ebp
  102032:	83 ec 04             	sub    $0x4,%esp
  102035:	8b 45 08             	mov    0x8(%ebp),%eax
  102038:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  10203c:	8b 45 0c             	mov    0xc(%ebp),%eax
  10203f:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102042:	ef                   	out    %eax,(%dx)

  102043:	c9                   	leave  
  102044:	c3                   	ret    

00102045 <outb_wait>:
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
  102045:	55                   	push   %ebp
  102046:	89 e5                	mov    %esp,%ebp
  102048:	83 ec 08             	sub    $0x8,%esp
  10204b:	8b 45 08             	mov    0x8(%ebp),%eax
  10204e:	8b 55 0c             	mov    0xc(%ebp),%edx
  102051:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  102055:	88 55 f8             	mov    %dl,-0x8(%ebp)
	        register_handle(handle);
  102058:	8a 45 f8             	mov    -0x8(%ebp),%al
  10205b:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10205e:	ee                   	out    %al,(%dx)
  10205f:	eb 00                	jmp    102061 <outb_wait+0x1c>
  102061:	eb 00                	jmp    102063 <outb_wait+0x1e>
	        cpu->eax = (uint32_t) handle;
  102063:	c9                   	leave  
  102064:	c3                   	ret    
  102065:	00 00                	add    %al,(%eax)
	...

00102068 <ramfs_block_init>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  102068:	55                   	push   %ebp
  102069:	89 e5                	mov    %esp,%ebp
  10206b:	83 ec 08             	sub    $0x8,%esp
#include "ramfs/vgacntrl.h"
  10206e:	83 ec 04             	sub    $0x4,%esp
  102071:	68 00 00 04 00       	push   $0x40000
  102076:	6a 00                	push   $0x0
  102078:	68 c0 85 18 00       	push   $0x1885c0
  10207d:	e8 c2 18 00 00       	call   103944 <memset>
  102082:	83 c4 10             	add    $0x10,%esp

  102085:	c9                   	leave  
  102086:	c3                   	ret    

00102087 <ramfs_block_driver_struct>:

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
  102087:	55                   	push   %ebp
  102088:	89 e5                	mov    %esp,%ebp
		return terminate_current(cpu);
  10208a:	b8 a0 60 10 00       	mov    $0x1060a0,%eax

  10208f:	5d                   	pop    %ebp
  102090:	c3                   	ret    

00102091 <ramfs_block_available>:
	case 2: /* pexists */
	{
  102091:	55                   	push   %ebp
  102092:	89 e5                	mov    %esp,%ebp
  102094:	83 ec 10             	sub    $0x10,%esp
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  102097:	8b 45 08             	mov    0x8(%ebp),%eax
  10209a:	8b 40 04             	mov    0x4(%eax),%eax
  10209d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}
	    break;
  1020a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020a3:	8b 00                	mov    (%eax),%eax
  1020a5:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1020ac:	85 c0                	test   %eax,%eax
  1020ae:	74 1d                	je     1020cd <ramfs_block_available+0x3c>

  1020b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1020b3:	8b 00                	mov    (%eax),%eax
  1020b5:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1020bc:	8b 50 04             	mov    0x4(%eax),%edx
  1020bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1020c2:	8b 40 08             	mov    0x8(%eax),%eax
  1020c5:	89 d1                	mov    %edx,%ecx
  1020c7:	29 c1                	sub    %eax,%ecx
  1020c9:	89 c8                	mov    %ecx,%eax
  1020cb:	eb 05                	jmp    1020d2 <ramfs_block_available+0x41>
    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  1020cd:	b8 00 00 00 00       	mov    $0x0,%eax

  1020d2:	c9                   	leave  
  1020d3:	c3                   	ret    

001020d4 <ramfs_block_create>:
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

  1020d4:	55                   	push   %ebp
  1020d5:	89 e5                	mov    %esp,%ebp
  1020d7:	53                   	push   %ebx
  1020d8:	83 ec 14             	sub    $0x14,%esp
        free(path);
  1020db:	83 ec 0c             	sub    $0xc,%esp
  1020de:	6a 08                	push   $0x8
  1020e0:	e8 c5 15 00 00       	call   1036aa <malloc>
  1020e5:	83 c4 10             	add    $0x10,%esp
  1020e8:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(cpu->edx) {
  1020eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1020f2:	e9 86 00 00 00       	jmp    10217d <ramfs_block_create+0xa9>
			cpu = schedule(cpu);
  1020f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1020fa:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102101:	85 c0                	test   %eax,%eax
  102103:	75 75                	jne    10217a <ramfs_block_create+0xa6>
		}
  102105:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  102108:	83 ec 0c             	sub    $0xc,%esp
  10210b:	6a 10                	push   $0x10
  10210d:	e8 98 15 00 00       	call   1036aa <malloc>
  102112:	83 c4 10             	add    $0x10,%esp
  102115:	89 04 9d c0 85 18 00 	mov    %eax,0x1885c0(,%ebx,4)
    }
  10211c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10211f:	8b 1c 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%ebx
  102126:	8b 45 08             	mov    0x8(%ebp),%eax
  102129:	8b 00                	mov    (%eax),%eax
  10212b:	83 ec 0c             	sub    $0xc,%esp
  10212e:	50                   	push   %eax
  10212f:	e8 76 15 00 00       	call   1036aa <malloc>
  102134:	83 c4 10             	add    $0x10,%esp
  102137:	89 03                	mov    %eax,(%ebx)
        break;
  102139:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10213c:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102143:	8b 55 08             	mov    0x8(%ebp),%edx
  102146:	8b 12                	mov    (%edx),%edx
  102148:	89 50 04             	mov    %edx,0x4(%eax)

    case 4: /* getargs */
  10214b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10214e:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102155:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    {
  10215c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10215f:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102166:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        cpu->eax = (uint32_t) get_current_task()->args;
    }
  10216d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102170:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102173:	89 10                	mov    %edx,(%eax)
        break;

  102175:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102178:	eb 15                	jmp    10218f <ramfs_block_create+0xbb>

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);

		if(cpu->edx) {
  10217a:	ff 45 f4             	incl   -0xc(%ebp)
  10217d:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
  102184:	0f 8e 6d ff ff ff    	jle    1020f7 <ramfs_block_create+0x23>
        break;

    case 5: /* yield */
    {
        cpu = schedule(cpu);
    }
  10218a:	b8 00 00 00 00       	mov    $0x0,%eax
        break;
  10218f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102192:	c9                   	leave  
  102193:	c3                   	ret    

00102194 <ramfs_block_read>:

    case 6: /* getExecPath */
  102194:	55                   	push   %ebp
  102195:	89 e5                	mov    %esp,%ebp
  102197:	83 ec 18             	sub    $0x18,%esp
    {
  10219a:	8b 45 08             	mov    0x8(%ebp),%eax
  10219d:	8b 40 04             	mov    0x4(%eax),%eax
  1021a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  1021a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021a6:	8b 00                	mov    (%eax),%eax
  1021a8:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1021af:	85 c0                	test   %eax,%eax
  1021b1:	74 55                	je     102208 <ramfs_block_read+0x74>
    }
  1021b3:	8b 45 08             	mov    0x8(%ebp),%eax
  1021b6:	8b 40 08             	mov    0x8(%eax),%eax
  1021b9:	89 c2                	mov    %eax,%edx
  1021bb:	03 55 10             	add    0x10(%ebp),%edx
  1021be:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021c1:	8b 00                	mov    (%eax),%eax
  1021c3:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1021ca:	8b 40 04             	mov    0x4(%eax),%eax
  1021cd:	39 c2                	cmp    %eax,%edx
  1021cf:	76 07                	jbe    1021d8 <ramfs_block_read+0x44>
  1021d1:	b8 06 00 00 00       	mov    $0x6,%eax
  1021d6:	eb 35                	jmp    10220d <ramfs_block_read+0x79>
        break;

  1021d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021db:	8b 00                	mov    (%eax),%eax
  1021dd:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1021e4:	8b 10                	mov    (%eax),%edx
  1021e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1021e9:	8b 40 08             	mov    0x8(%eax),%eax
  1021ec:	8d 04 02             	lea    (%edx,%eax,1),%eax
  1021ef:	83 ec 04             	sub    $0x4,%esp
  1021f2:	ff 75 10             	pushl  0x10(%ebp)
  1021f5:	50                   	push   %eax
  1021f6:	ff 75 0c             	pushl  0xc(%ebp)
  1021f9:	e8 74 17 00 00       	call   103972 <memcpy>
  1021fe:	83 c4 10             	add    $0x10,%esp
    case 7: /* changeExecPath */
    {
  102201:	b8 00 00 00 00       	mov    $0x0,%eax
  102206:	eb 05                	jmp    10220d <ramfs_block_read+0x79>
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);

  102208:	b8 03 00 00 00       	mov    $0x3,%eax
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  10220d:	c9                   	leave  
  10220e:	c3                   	ret    

0010220f <ramfs_block_write>:

        char* new = vfs_resolve_path(path);
  10220f:	55                   	push   %ebp
  102210:	89 e5                	mov    %esp,%ebp
  102212:	83 ec 18             	sub    $0x18,%esp

  102215:	8b 45 08             	mov    0x8(%ebp),%eax
  102218:	8b 40 04             	mov    0x4(%eax),%eax
  10221b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cpu->eax = 0;
        if(new) {
  10221e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102221:	8b 00                	mov    (%eax),%eax
  102223:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10222a:	85 c0                	test   %eax,%eax
  10222c:	74 55                	je     102283 <ramfs_block_write+0x74>
            get_current_task()->execPath = new;
  10222e:	8b 45 08             	mov    0x8(%ebp),%eax
  102231:	8b 40 08             	mov    0x8(%eax),%eax
  102234:	89 c2                	mov    %eax,%edx
  102236:	03 55 10             	add    0x10(%ebp),%edx
  102239:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10223c:	8b 00                	mov    (%eax),%eax
  10223e:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102245:	8b 40 04             	mov    0x4(%eax),%eax
  102248:	39 c2                	cmp    %eax,%edx
  10224a:	76 07                	jbe    102253 <ramfs_block_write+0x44>
  10224c:	b8 06 00 00 00       	mov    $0x6,%eax
  102251:	eb 35                	jmp    102288 <ramfs_block_write+0x79>
            cpu->eax = 1;
        }
  102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102256:	8b 00                	mov    (%eax),%eax
  102258:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10225f:	8b 10                	mov    (%eax),%edx
  102261:	8b 45 08             	mov    0x8(%ebp),%eax
  102264:	8b 40 08             	mov    0x8(%eax),%eax
  102267:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10226a:	83 ec 04             	sub    $0x4,%esp
  10226d:	ff 75 10             	pushl  0x10(%ebp)
  102270:	ff 75 0c             	pushl  0xc(%ebp)
  102273:	50                   	push   %eax
  102274:	e8 f9 16 00 00       	call   103972 <memcpy>
  102279:	83 c4 10             	add    $0x10,%esp

        free(path);
  10227c:	b8 00 00 00 00       	mov    $0x0,%eax
  102281:	eb 05                	jmp    102288 <ramfs_block_write+0x79>
    }
        break;

  102283:	b8 03 00 00 00       	mov    $0x3,%eax
	case 10: /* fopen */
  102288:	c9                   	leave  
  102289:	c3                   	ret    

0010228a <ramfs_block_open>:
	{
        vfs_reset_error();
  10228a:	55                   	push   %ebp
  10228b:	89 e5                	mov    %esp,%ebp
  10228d:	83 ec 18             	sub    $0x18,%esp
	    char* name = strclone((char*) cpu->ebx);
  102290:	8b 45 08             	mov    0x8(%ebp),%eax
  102293:	8b 00                	mov    (%eax),%eax
  102295:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10229c:	85 c0                	test   %eax,%eax
  10229e:	74 74                	je     102314 <ramfs_block_open+0x8a>
	    uint32_t fmode = (uint32_t) cpu->ecx;
  1022a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1022a3:	83 e0 01             	and    $0x1,%eax
  1022a6:	84 c0                	test   %al,%al
  1022a8:	74 13                	je     1022bd <ramfs_block_open+0x33>
  1022aa:	8b 45 08             	mov    0x8(%ebp),%eax
  1022ad:	8b 00                	mov    (%eax),%eax
  1022af:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1022b6:	8b 50 08             	mov    0x8(%eax),%edx
  1022b9:	42                   	inc    %edx
  1022ba:	89 50 08             	mov    %edx,0x8(%eax)

  1022bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1022c0:	83 e0 02             	and    $0x2,%eax
  1022c3:	85 c0                	test   %eax,%eax
  1022c5:	74 13                	je     1022da <ramfs_block_open+0x50>
  1022c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1022ca:	8b 00                	mov    (%eax),%eax
  1022cc:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1022d3:	8b 50 0c             	mov    0xc(%eax),%edx
  1022d6:	42                   	inc    %edx
  1022d7:	89 50 0c             	mov    %edx,0xc(%eax)
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
  1022da:	83 ec 0c             	sub    $0xc,%esp
  1022dd:	6a 10                	push   $0x10
  1022df:	e8 c6 13 00 00       	call   1036aa <malloc>
  1022e4:	83 c4 10             	add    $0x10,%esp
  1022e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
  1022ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  1022f0:	89 50 0c             	mov    %edx,0xc(%eax)
	    }
  1022f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022f6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	    else
  1022fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102300:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	    {
  102306:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102309:	8b 55 08             	mov    0x8(%ebp),%edx
  10230c:	89 50 04             	mov    %edx,0x4(%eax)
	        cpu->eax = 0;
	    }
  10230f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102312:	eb 05                	jmp    102319 <ramfs_block_open+0x8f>

	    free(name);
	}
  102314:	b8 01 00 00 00       	mov    $0x1,%eax
	    break;
  102319:	c9                   	leave  
  10231a:	c3                   	ret    

0010231b <ramfs_block_close>:

	case 11: /* fclose */
  10231b:	55                   	push   %ebp
  10231c:	89 e5                	mov    %esp,%ebp
  10231e:	83 ec 18             	sub    $0x18,%esp
	{
  102321:	8b 45 08             	mov    0x8(%ebp),%eax
  102324:	8b 40 04             	mov    0x4(%eax),%eax
  102327:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
  10232a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10232d:	8b 00                	mov    (%eax),%eax
  10232f:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102336:	85 c0                	test   %eax,%eax
  102338:	74 40                	je     10237a <ramfs_block_close+0x5f>
	    if(!unregister_handle(handle)) {
  10233a:	8b 45 08             	mov    0x8(%ebp),%eax
  10233d:	8b 40 0c             	mov    0xc(%eax),%eax
  102340:	83 e0 01             	and    $0x1,%eax
  102343:	84 c0                	test   %al,%al
  102345:	74 13                	je     10235a <ramfs_block_close+0x3f>
  102347:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10234a:	8b 00                	mov    (%eax),%eax
  10234c:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102353:	8b 50 08             	mov    0x8(%eax),%edx
  102356:	4a                   	dec    %edx
  102357:	89 50 08             	mov    %edx,0x8(%eax)
	        vfs_close(handle);
  10235a:	8b 45 08             	mov    0x8(%ebp),%eax
  10235d:	8b 40 0c             	mov    0xc(%eax),%eax
  102360:	83 e0 02             	and    $0x2,%eax
  102363:	85 c0                	test   %eax,%eax
  102365:	74 13                	je     10237a <ramfs_block_close+0x5f>
  102367:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10236a:	8b 00                	mov    (%eax),%eax
  10236c:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102373:	8b 50 0c             	mov    0xc(%eax),%edx
  102376:	4a                   	dec    %edx
  102377:	89 50 0c             	mov    %edx,0xc(%eax)

	        cpu->eax = 0;
	    }
  10237a:	83 ec 0c             	sub    $0xc,%esp
  10237d:	ff 75 08             	pushl  0x8(%ebp)
  102380:	e8 6b 15 00 00       	call   1038f0 <free>
  102385:	83 c4 10             	add    $0x10,%esp
	    else
	    {
  102388:	b8 00 00 00 00       	mov    $0x0,%eax
	        cpu->eax = (uint32_t) -1;
  10238d:	c9                   	leave  
  10238e:	c3                   	ret    
	...

00102390 <ramfs_fifo_init>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  102390:	55                   	push   %ebp
  102391:	89 e5                	mov    %esp,%ebp
  102393:	83 ec 08             	sub    $0x8,%esp
#include "ramfs/vgacntrl.h"
  102396:	83 ec 04             	sub    $0x4,%esp
  102399:	68 00 00 04 00       	push   $0x40000
  10239e:	6a 00                	push   $0x0
  1023a0:	68 c0 85 18 00       	push   $0x1885c0
  1023a5:	e8 9a 15 00 00       	call   103944 <memset>
  1023aa:	83 c4 10             	add    $0x10,%esp

  1023ad:	c9                   	leave  
  1023ae:	c3                   	ret    

001023af <ramfs_fifo_driver_struct>:

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
  1023af:	55                   	push   %ebp
  1023b0:	89 e5                	mov    %esp,%ebp
		return terminate_current(cpu);
  1023b2:	b8 bc 60 10 00       	mov    $0x1060bc,%eax

  1023b7:	5d                   	pop    %ebp
  1023b8:	c3                   	ret    

001023b9 <ramfs_fifo_available>:
	case 2: /* pexists */
	{
  1023b9:	55                   	push   %ebp
  1023ba:	89 e5                	mov    %esp,%ebp
  1023bc:	83 ec 10             	sub    $0x10,%esp
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  1023bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1023c2:	8b 40 04             	mov    0x4(%eax),%eax
  1023c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}
	    break;
  1023c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1023cb:	8b 00                	mov    (%eax),%eax
  1023cd:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1023d4:	85 c0                	test   %eax,%eax
  1023d6:	74 11                	je     1023e9 <ramfs_fifo_available+0x30>

  1023d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1023db:	8b 00                	mov    (%eax),%eax
  1023dd:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1023e4:	8b 40 08             	mov    0x8(%eax),%eax
  1023e7:	eb 05                	jmp    1023ee <ramfs_fifo_available+0x35>
    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  1023e9:	b8 00 00 00 00       	mov    $0x0,%eax

  1023ee:	c9                   	leave  
  1023ef:	c3                   	ret    

001023f0 <ramfs_fifo_create>:
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

  1023f0:	55                   	push   %ebp
  1023f1:	89 e5                	mov    %esp,%ebp
  1023f3:	53                   	push   %ebx
  1023f4:	83 ec 14             	sub    $0x14,%esp
        free(path);
  1023f7:	83 ec 0c             	sub    $0xc,%esp
  1023fa:	6a 08                	push   $0x8
  1023fc:	e8 a9 12 00 00       	call   1036aa <malloc>
  102401:	83 c4 10             	add    $0x10,%esp
  102404:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(cpu->edx) {
  102407:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10240e:	e9 9b 00 00 00       	jmp    1024ae <ramfs_fifo_create+0xbe>
			cpu = schedule(cpu);
  102413:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102416:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10241d:	85 c0                	test   %eax,%eax
  10241f:	0f 85 86 00 00 00    	jne    1024ab <ramfs_fifo_create+0xbb>
		}
  102425:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  102428:	83 ec 0c             	sub    $0xc,%esp
  10242b:	6a 14                	push   $0x14
  10242d:	e8 78 12 00 00       	call   1036aa <malloc>
  102432:	83 c4 10             	add    $0x10,%esp
  102435:	89 04 9d c0 85 18 00 	mov    %eax,0x1885c0(,%ebx,4)
    }
  10243c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10243f:	8b 1c 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%ebx
  102446:	8b 45 08             	mov    0x8(%ebp),%eax
  102449:	8b 00                	mov    (%eax),%eax
  10244b:	83 ec 0c             	sub    $0xc,%esp
  10244e:	50                   	push   %eax
  10244f:	e8 56 12 00 00       	call   1036aa <malloc>
  102454:	83 c4 10             	add    $0x10,%esp
  102457:	89 03                	mov    %eax,(%ebx)
        break;
  102459:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10245c:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102463:	8b 55 08             	mov    0x8(%ebp),%edx
  102466:	8b 12                	mov    (%edx),%edx
  102468:	89 50 04             	mov    %edx,0x4(%eax)

    case 4: /* getargs */
  10246b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10246e:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102475:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    {
  10247c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10247f:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102486:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
        cpu->eax = (uint32_t) get_current_task()->args;
  10248d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102490:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102497:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    }
        break;
  10249e:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1024a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1024a4:	89 10                	mov    %edx,(%eax)

    case 5: /* yield */
  1024a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1024a9:	eb 15                	jmp    1024c0 <ramfs_fifo_create+0xd0>

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);

		if(cpu->edx) {
  1024ab:	ff 45 f4             	incl   -0xc(%ebp)
  1024ae:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
  1024b5:	0f 8e 58 ff ff ff    	jle    102413 <ramfs_fifo_create+0x23>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
    }
        break;
  1024bb:	b8 00 00 00 00       	mov    $0x0,%eax

  1024c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1024c3:	c9                   	leave  
  1024c4:	c3                   	ret    

001024c5 <ramfs_fifo_read>:
    case 6: /* getExecPath */
    {
  1024c5:	55                   	push   %ebp
  1024c6:	89 e5                	mov    %esp,%ebp
  1024c8:	83 ec 18             	sub    $0x18,%esp
        char* dest = (char*)cpu->ebx;
  1024cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1024ce:	8b 40 04             	mov    0x4(%eax),%eax
  1024d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  1024d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024d7:	8b 00                	mov    (%eax),%eax
  1024d9:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1024e0:	85 c0                	test   %eax,%eax
  1024e2:	0f 84 c7 00 00 00    	je     1025af <ramfs_fifo_read+0xea>
        break;
  1024e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024eb:	8b 00                	mov    (%eax),%eax
  1024ed:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1024f4:	8b 40 04             	mov    0x4(%eax),%eax
  1024f7:	3b 45 10             	cmp    0x10(%ebp),%eax
  1024fa:	73 0a                	jae    102506 <ramfs_fifo_read+0x41>
  1024fc:	b8 03 00 00 00       	mov    $0x3,%eax
  102501:	e9 ae 00 00 00       	jmp    1025b4 <ramfs_fifo_read+0xef>

  102506:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102509:	8b 00                	mov    (%eax),%eax
  10250b:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102512:	8b 40 08             	mov    0x8(%eax),%eax
  102515:	3b 45 10             	cmp    0x10(%ebp),%eax
  102518:	73 0a                	jae    102524 <ramfs_fifo_read+0x5f>
  10251a:	b8 01 00 00 00       	mov    $0x1,%eax
  10251f:	e9 90 00 00 00       	jmp    1025b4 <ramfs_fifo_read+0xef>
    case 7: /* changeExecPath */
    {
  102524:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102527:	8b 00                	mov    (%eax),%eax
  102529:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102530:	8b 00                	mov    (%eax),%eax
  102532:	83 ec 04             	sub    $0x4,%esp
  102535:	ff 75 10             	pushl  0x10(%ebp)
  102538:	50                   	push   %eax
  102539:	ff 75 0c             	pushl  0xc(%ebp)
  10253c:	e8 31 14 00 00       	call   103972 <memcpy>
  102541:	83 c4 10             	add    $0x10,%esp
        vfs_reset_error();
  102544:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102547:	8b 00                	mov    (%eax),%eax
  102549:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102550:	8b 40 08             	mov    0x8(%eax),%eax
  102553:	89 c1                	mov    %eax,%ecx
  102555:	2b 4d 10             	sub    0x10(%ebp),%ecx
  102558:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10255b:	8b 00                	mov    (%eax),%eax
  10255d:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102564:	8b 00                	mov    (%eax),%eax
  102566:	89 c2                	mov    %eax,%edx
  102568:	03 55 10             	add    0x10(%ebp),%edx
  10256b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10256e:	8b 00                	mov    (%eax),%eax
  102570:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102577:	8b 00                	mov    (%eax),%eax
  102579:	83 ec 04             	sub    $0x4,%esp
  10257c:	51                   	push   %ecx
  10257d:	52                   	push   %edx
  10257e:	50                   	push   %eax
  10257f:	e8 ee 13 00 00       	call   103972 <memcpy>
  102584:	83 c4 10             	add    $0x10,%esp
        char* path = strclone((char*) cpu->ebx);
  102587:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10258a:	8b 00                	mov    (%eax),%eax
  10258c:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102593:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102596:	8b 12                	mov    (%edx),%edx
  102598:	8b 14 95 c0 85 18 00 	mov    0x1885c0(,%edx,4),%edx
  10259f:	8b 52 08             	mov    0x8(%edx),%edx
  1025a2:	2b 55 10             	sub    0x10(%ebp),%edx
  1025a5:	89 50 08             	mov    %edx,0x8(%eax)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  1025a8:	b8 00 00 00 00       	mov    $0x0,%eax
  1025ad:	eb 05                	jmp    1025b4 <ramfs_fifo_read+0xef>

        char* new = vfs_resolve_path(path);

  1025af:	b8 03 00 00 00       	mov    $0x3,%eax
        cpu->eax = 0;
  1025b4:	c9                   	leave  
  1025b5:	c3                   	ret    

001025b6 <ramfs_fifo_write>:
        if(new) {
            get_current_task()->execPath = new;
  1025b6:	55                   	push   %ebp
  1025b7:	89 e5                	mov    %esp,%ebp
  1025b9:	83 ec 18             	sub    $0x18,%esp
            cpu->eax = 1;
  1025bc:	8b 45 08             	mov    0x8(%ebp),%eax
  1025bf:	8b 40 04             	mov    0x4(%eax),%eax
  1025c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

  1025c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025c8:	8b 00                	mov    (%eax),%eax
  1025ca:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1025d1:	85 c0                	test   %eax,%eax
  1025d3:	0f 84 a8 00 00 00    	je     102681 <ramfs_fifo_write+0xcb>
        free(path);
  1025d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025dc:	8b 00                	mov    (%eax),%eax
  1025de:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1025e5:	8b 40 04             	mov    0x4(%eax),%eax
  1025e8:	3b 45 10             	cmp    0x10(%ebp),%eax
  1025eb:	73 0a                	jae    1025f7 <ramfs_fifo_write+0x41>
  1025ed:	b8 03 00 00 00       	mov    $0x3,%eax
  1025f2:	e9 8f 00 00 00       	jmp    102686 <ramfs_fifo_write+0xd0>
    }
  1025f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025fa:	8b 00                	mov    (%eax),%eax
  1025fc:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102603:	8b 50 04             	mov    0x4(%eax),%edx
  102606:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102609:	8b 00                	mov    (%eax),%eax
  10260b:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102612:	8b 40 08             	mov    0x8(%eax),%eax
  102615:	89 d1                	mov    %edx,%ecx
  102617:	29 c1                	sub    %eax,%ecx
  102619:	89 c8                	mov    %ecx,%eax
  10261b:	3b 45 10             	cmp    0x10(%ebp),%eax
  10261e:	73 07                	jae    102627 <ramfs_fifo_write+0x71>
  102620:	b8 01 00 00 00       	mov    $0x1,%eax
  102625:	eb 5f                	jmp    102686 <ramfs_fifo_write+0xd0>
        break;

  102627:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10262a:	8b 00                	mov    (%eax),%eax
  10262c:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102633:	8b 10                	mov    (%eax),%edx
  102635:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102638:	8b 00                	mov    (%eax),%eax
  10263a:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102641:	8b 40 08             	mov    0x8(%eax),%eax
  102644:	8d 04 02             	lea    (%edx,%eax,1),%eax
  102647:	83 ec 04             	sub    $0x4,%esp
  10264a:	ff 75 10             	pushl  0x10(%ebp)
  10264d:	ff 75 0c             	pushl  0xc(%ebp)
  102650:	50                   	push   %eax
  102651:	e8 1c 13 00 00       	call   103972 <memcpy>
  102656:	83 c4 10             	add    $0x10,%esp
	case 10: /* fopen */
  102659:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10265c:	8b 00                	mov    (%eax),%eax
  10265e:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102665:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102668:	8b 12                	mov    (%edx),%edx
  10266a:	8b 14 95 c0 85 18 00 	mov    0x1885c0(,%edx,4),%edx
  102671:	8b 52 08             	mov    0x8(%edx),%edx
  102674:	03 55 10             	add    0x10(%ebp),%edx
  102677:	89 50 08             	mov    %edx,0x8(%eax)
	{
        vfs_reset_error();
  10267a:	b8 00 00 00 00       	mov    $0x0,%eax
  10267f:	eb 05                	jmp    102686 <ramfs_fifo_write+0xd0>
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

  102681:	b8 03 00 00 00       	mov    $0x3,%eax
	    struct res_handle* handle = vfs_open(name, fmode);
  102686:	c9                   	leave  
  102687:	c3                   	ret    

00102688 <ramfs_fifo_open>:
	    if(handle) {
	        register_handle(handle);
  102688:	55                   	push   %ebp
  102689:	89 e5                	mov    %esp,%ebp
  10268b:	83 ec 18             	sub    $0x18,%esp
	        cpu->eax = (uint32_t) handle;
  10268e:	8b 45 08             	mov    0x8(%ebp),%eax
  102691:	8b 00                	mov    (%eax),%eax
  102693:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  10269a:	85 c0                	test   %eax,%eax
  10269c:	0f 84 85 00 00 00    	je     102727 <ramfs_fifo_open+0x9f>
	    }
  1026a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026a5:	83 e0 04             	and    $0x4,%eax
  1026a8:	85 c0                	test   %eax,%eax
  1026aa:	74 07                	je     1026b3 <ramfs_fifo_open+0x2b>
  1026ac:	b8 00 00 00 00       	mov    $0x0,%eax
  1026b1:	eb 79                	jmp    10272c <ramfs_fifo_open+0xa4>
	    else
	    {
  1026b3:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026b6:	83 e0 01             	and    $0x1,%eax
  1026b9:	84 c0                	test   %al,%al
  1026bb:	74 13                	je     1026d0 <ramfs_fifo_open+0x48>
  1026bd:	8b 45 08             	mov    0x8(%ebp),%eax
  1026c0:	8b 00                	mov    (%eax),%eax
  1026c2:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1026c9:	8b 50 0c             	mov    0xc(%eax),%edx
  1026cc:	42                   	inc    %edx
  1026cd:	89 50 0c             	mov    %edx,0xc(%eax)
	        cpu->eax = 0;
  1026d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  1026d3:	83 e0 02             	and    $0x2,%eax
  1026d6:	85 c0                	test   %eax,%eax
  1026d8:	74 13                	je     1026ed <ramfs_fifo_open+0x65>
  1026da:	8b 45 08             	mov    0x8(%ebp),%eax
  1026dd:	8b 00                	mov    (%eax),%eax
  1026df:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  1026e6:	8b 50 10             	mov    0x10(%eax),%edx
  1026e9:	42                   	inc    %edx
  1026ea:	89 50 10             	mov    %edx,0x10(%eax)
	    }

  1026ed:	83 ec 0c             	sub    $0xc,%esp
  1026f0:	6a 10                	push   $0x10
  1026f2:	e8 b3 0f 00 00       	call   1036aa <malloc>
  1026f7:	83 c4 10             	add    $0x10,%esp
  1026fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    free(name);
	}
  1026fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102700:	8b 55 0c             	mov    0xc(%ebp),%edx
  102703:	89 50 0c             	mov    %edx,0xc(%eax)
	    break;
  102706:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102709:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  102710:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102713:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	case 11: /* fclose */
  102719:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10271c:	8b 55 08             	mov    0x8(%ebp),%edx
  10271f:	89 50 04             	mov    %edx,0x4(%eax)
	{
        vfs_reset_error();
  102722:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102725:	eb 05                	jmp    10272c <ramfs_fifo_open+0xa4>
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);
  102727:	b8 00 00 00 00       	mov    $0x0,%eax

  10272c:	c9                   	leave  
  10272d:	c3                   	ret    

0010272e <ramfs_fifo_close>:
	        cpu->eax = 0;
	    }
  10272e:	55                   	push   %ebp
  10272f:	89 e5                	mov    %esp,%ebp
  102731:	83 ec 18             	sub    $0x18,%esp
	    else
  102734:	8b 45 08             	mov    0x8(%ebp),%eax
  102737:	8b 40 04             	mov    0x4(%eax),%eax
  10273a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    {
	        cpu->eax = (uint32_t) -1;
  10273d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102740:	8b 00                	mov    (%eax),%eax
  102742:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102749:	85 c0                	test   %eax,%eax
  10274b:	74 40                	je     10278d <ramfs_fifo_close+0x5f>
	    }
  10274d:	8b 45 08             	mov    0x8(%ebp),%eax
  102750:	8b 40 0c             	mov    0xc(%eax),%eax
  102753:	83 e0 01             	and    $0x1,%eax
  102756:	84 c0                	test   %al,%al
  102758:	74 13                	je     10276d <ramfs_fifo_close+0x3f>
  10275a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10275d:	8b 00                	mov    (%eax),%eax
  10275f:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102766:	8b 50 0c             	mov    0xc(%eax),%edx
  102769:	4a                   	dec    %edx
  10276a:	89 50 0c             	mov    %edx,0xc(%eax)
	}
  10276d:	8b 45 08             	mov    0x8(%ebp),%eax
  102770:	8b 40 0c             	mov    0xc(%eax),%eax
  102773:	83 e0 02             	and    $0x2,%eax
  102776:	85 c0                	test   %eax,%eax
  102778:	74 13                	je     10278d <ramfs_fifo_close+0x5f>
  10277a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10277d:	8b 00                	mov    (%eax),%eax
  10277f:	8b 04 85 c0 85 18 00 	mov    0x1885c0(,%eax,4),%eax
  102786:	8b 50 10             	mov    0x10(%eax),%edx
  102789:	4a                   	dec    %edx
  10278a:	89 50 10             	mov    %edx,0x10(%eax)
	    break;

	case 12: /* fwrite */
  10278d:	83 ec 0c             	sub    $0xc,%esp
  102790:	ff 75 08             	pushl  0x8(%ebp)
  102793:	e8 58 11 00 00       	call   1038f0 <free>
  102798:	83 c4 10             	add    $0x10,%esp
	{
        vfs_reset_error();
  10279b:	b8 00 00 00 00       	mov    $0x0,%eax
	    struct res_handle* handle = (void*) cpu->ebx;
  1027a0:	c9                   	leave  
  1027a1:	c3                   	ret    
	...

001027a4 <tar_parse_number>:
  1027a4:	55                   	push   %ebp
  1027a5:	89 e5                	mov    %esp,%ebp
  1027a7:	83 ec 10             	sub    $0x10,%esp
  1027aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1027b1:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1027b8:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
  1027bf:	eb 1d                	jmp    1027de <tar_parse_number+0x3a>
  1027c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1027c4:	48                   	dec    %eax
  1027c5:	03 45 08             	add    0x8(%ebp),%eax
  1027c8:	8a 00                	mov    (%eax),%al
  1027ca:	0f be c0             	movsbl %al,%eax
  1027cd:	83 e8 30             	sub    $0x30,%eax
  1027d0:	0f af 45 fc          	imul   -0x4(%ebp),%eax
  1027d4:	01 45 f4             	add    %eax,-0xc(%ebp)
  1027d7:	ff 4d f8             	decl   -0x8(%ebp)
  1027da:	c1 65 fc 03          	shll   $0x3,-0x4(%ebp)
  1027de:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1027e2:	75 dd                	jne    1027c1 <tar_parse_number+0x1d>
  1027e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027e7:	c9                   	leave  
  1027e8:	c3                   	ret    

001027e9 <tar_load_ramfs>:

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
  1027e9:	55                   	push   %ebp
  1027ea:	89 e5                	mov    %esp,%ebp
  1027ec:	83 ec 28             	sub    $0x28,%esp
		return terminate_current(cpu);
  1027ef:	8b 45 08             	mov    0x8(%ebp),%eax
  1027f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  1027f5:	83 ec 08             	sub    $0x8,%esp
  1027f8:	ff 75 e4             	pushl  -0x1c(%ebp)
  1027fb:	68 94 76 10 00       	push   $0x107694
  102800:	e8 68 dd ff ff       	call   10056d <kprintf>
  102805:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  102808:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

    case 3: /* exec */
    {
  10280f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102812:	89 45 ec             	mov    %eax,-0x14(%ebp)
        char* path = strclone((char*) cpu->ebx);

  102815:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102818:	8a 00                	mov    (%eax),%al
  10281a:	84 c0                	test   %al,%al
  10281c:	75 12                	jne    102830 <tar_load_ramfs+0x47>
    }
        break;

    case 7: /* changeExecPath */
    {
        vfs_reset_error();
  10281e:	83 ec 0c             	sub    $0xc,%esp
  102821:	68 c0 76 10 00       	push   $0x1076c0
  102826:	e8 42 dd ff ff       	call   10056d <kprintf>
  10282b:	83 c4 10             	add    $0x10,%esp
        char* path = strclone((char*) cpu->ebx);
  10282e:	c9                   	leave  
  10282f:	c3                   	ret    
    {
        char* path = strclone((char*) cpu->ebx);

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);
  102830:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102833:	83 c0 7c             	add    $0x7c,%eax
  102836:	83 ec 0c             	sub    $0xc,%esp
  102839:	50                   	push   %eax
  10283a:	e8 65 ff ff ff       	call   1027a4 <tar_parse_number>
  10283f:	83 c4 10             	add    $0x10,%esp
  102842:	89 45 e0             	mov    %eax,-0x20(%ebp)

  102845:	81 45 e4 00 02 00 00 	addl   $0x200,-0x1c(%ebp)
		if(cpu->edx) {
			cpu = schedule(cpu);
  10284c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10284f:	85 c0                	test   %eax,%eax
  102851:	0f 84 85 00 00 00    	je     1028dc <tar_load_ramfs+0xf3>
		}
  102857:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10285a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10285d:	83 ec 04             	sub    $0x4,%esp
  102860:	52                   	push   %edx
  102861:	50                   	push   %eax
  102862:	68 e8 76 10 00       	push   $0x1076e8
  102867:	e8 01 dd ff ff       	call   10056d <kprintf>
  10286c:	83 c4 10             	add    $0x10,%esp
    }
        break;
  10286f:	e8 13 f8 ff ff       	call   102087 <ramfs_block_driver_struct>
  102874:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102877:	83 ec 04             	sub    $0x4,%esp
  10287a:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  10287d:	51                   	push   %ecx
  10287e:	50                   	push   %eax
  10287f:	52                   	push   %edx
  102880:	e8 47 19 00 00       	call   1041cc <vfs_create_kfile>
  102885:	83 c4 10             	add    $0x10,%esp

  102888:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10288b:	83 ec 08             	sub    $0x8,%esp
  10288e:	6a 02                	push   $0x2
  102890:	50                   	push   %eax
  102891:	e8 d5 19 00 00       	call   10426b <vfs_open>
  102896:	83 c4 10             	add    $0x10,%esp
  102899:	89 45 f0             	mov    %eax,-0x10(%ebp)
    case 4: /* getargs */
    {
  10289c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10289f:	6a 01                	push   $0x1
  1028a1:	50                   	push   %eax
  1028a2:	ff 75 e4             	pushl  -0x1c(%ebp)
  1028a5:	ff 75 f0             	pushl  -0x10(%ebp)
  1028a8:	e8 da 1a 00 00       	call   104387 <vfs_write>
  1028ad:	83 c4 10             	add    $0x10,%esp
  1028b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cpu->eax = (uint32_t) get_current_task()->args;
  1028b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1028b7:	74 13                	je     1028cc <tar_load_ramfs+0xe3>
    }
  1028b9:	83 ec 08             	sub    $0x8,%esp
  1028bc:	ff 75 f4             	pushl  -0xc(%ebp)
  1028bf:	68 0c 77 10 00       	push   $0x10770c
  1028c4:	e8 a4 dc ff ff       	call   10056d <kprintf>
  1028c9:	83 c4 10             	add    $0x10,%esp
        break;

    case 5: /* yield */
  1028cc:	83 ec 0c             	sub    $0xc,%esp
  1028cf:	ff 75 f0             	pushl  -0x10(%ebp)
  1028d2:	e8 f1 19 00 00       	call   1042c8 <vfs_close>
  1028d7:	83 c4 10             	add    $0x10,%esp
  1028da:	eb 27                	jmp    102903 <tar_load_ramfs+0x11a>
    {
        cpu = schedule(cpu);
    }
        break;
  1028dc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1028df:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1028e2:	83 ec 04             	sub    $0x4,%esp
  1028e5:	52                   	push   %edx
  1028e6:	50                   	push   %eax
  1028e7:	68 28 77 10 00       	push   $0x107728
  1028ec:	e8 7c dc ff ff       	call   10056d <kprintf>
  1028f1:	83 c4 10             	add    $0x10,%esp

  1028f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1028f7:	83 ec 0c             	sub    $0xc,%esp
  1028fa:	50                   	push   %eax
  1028fb:	e8 b6 18 00 00       	call   1041b6 <vfs_create_dir>
  102900:	83 c4 10             	add    $0x10,%esp
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  102903:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102906:	c1 e8 09             	shr    $0x9,%eax
  102909:	c1 e0 09             	shl    $0x9,%eax
  10290c:	01 45 e4             	add    %eax,-0x1c(%ebp)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  10290f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102912:	25 ff 01 00 00       	and    $0x1ff,%eax
  102917:	85 c0                	test   %eax,%eax
  102919:	74 07                	je     102922 <tar_load_ramfs+0x139>
        break;
  10291b:	81 45 e4 00 02 00 00 	addl   $0x200,-0x1c(%ebp)

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
	}
	    break;
  102922:	ff 45 e8             	incl   -0x18(%ebp)
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;

    case 7: /* changeExecPath */
  102925:	e9 e5 fe ff ff       	jmp    10280f <tar_load_ramfs+0x26>
	...

0010292c <ramfs_vga_driver_struct>:
    char* stdout;
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);
  10292c:	55                   	push   %ebp
  10292d:	89 e5                	mov    %esp,%ebp

  10292f:	b8 dc 60 10 00       	mov    $0x1060dc,%eax
	switch (cpu->eax) {
  102934:	5d                   	pop    %ebp
  102935:	c3                   	ret    

00102936 <ramfs_vga_writers>:
	case 1: /* exit */
		return terminate_current(cpu);
  102936:	55                   	push   %ebp
  102937:	89 e5                	mov    %esp,%ebp

  102939:	a1 24 85 12 00       	mov    0x128524,%eax
	case 2: /* pexists */
  10293e:	5d                   	pop    %ebp
  10293f:	c3                   	ret    

00102940 <ramfs_vga_available>:
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  102940:	55                   	push   %ebp
  102941:	89 e5                	mov    %esp,%ebp
	}
  102943:	b8 06 00 00 00       	mov    $0x6,%eax
	    break;
  102948:	5d                   	pop    %ebp
  102949:	c3                   	ret    

0010294a <ramfs_vga_create>:

    case 3: /* exec */
  10294a:	55                   	push   %ebp
  10294b:	89 e5                	mov    %esp,%ebp
  10294d:	83 ec 08             	sub    $0x8,%esp
    {
  102950:	83 ec 0c             	sub    $0xc,%esp
  102953:	6a 08                	push   $0x8
  102955:	e8 50 0d 00 00       	call   1036aa <malloc>
  10295a:	83 c4 10             	add    $0x10,%esp
        char* path = strclone((char*) cpu->ebx);
  10295d:	c9                   	leave  
  10295e:	c3                   	ret    

0010295f <ramfs_vga_read>:

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);
  10295f:	55                   	push   %ebp
  102960:	89 e5                	mov    %esp,%ebp

  102962:	b8 03 00 00 00       	mov    $0x3,%eax
        free(path);
  102967:	5d                   	pop    %ebp
  102968:	c3                   	ret    

00102969 <ramfs_vga_write>:

		if(cpu->edx) {
  102969:	55                   	push   %ebp
  10296a:	89 e5                	mov    %esp,%ebp
  10296c:	83 ec 10             	sub    $0x10,%esp
			cpu = schedule(cpu);
  10296f:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
  102973:	74 0a                	je     10297f <ramfs_vga_write+0x16>
  102975:	b8 03 00 00 00       	mov    $0x3,%eax
  10297a:	e9 d7 00 00 00       	jmp    102a56 <ramfs_vga_write+0xed>
		}
    }
  10297f:	8b 45 0c             	mov    0xc(%ebp),%eax
  102982:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;

  102985:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102988:	66 8b 00             	mov    (%eax),%ax
  10298b:	66 85 c0             	test   %ax,%ax
  10298e:	75 2d                	jne    1029bd <ramfs_vga_write+0x54>
    case 4: /* getargs */
  102990:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102993:	66 8b 40 02          	mov    0x2(%eax),%ax
  102997:	66 3d cf 07          	cmp    $0x7cf,%ax
  10299b:	77 20                	ja     1029bd <ramfs_vga_write+0x54>
  10299d:	8b 15 d8 60 10 00    	mov    0x1060d8,%edx
  1029a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029a6:	66 8b 40 02          	mov    0x2(%eax),%ax
  1029aa:	25 ff ff 00 00       	and    $0xffff,%eax
  1029af:	01 c0                	add    %eax,%eax
  1029b1:	01 c2                	add    %eax,%edx
  1029b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029b6:	66 8b 40 04          	mov    0x4(%eax),%ax
  1029ba:	66 89 02             	mov    %ax,(%edx)
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
  1029bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029c0:	66 8b 00             	mov    (%eax),%ax
  1029c3:	66 83 f8 01          	cmp    $0x1,%ax
  1029c7:	75 26                	jne    1029ef <ramfs_vga_write+0x86>
        break;
  1029c9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1029d0:	eb 14                	jmp    1029e6 <ramfs_vga_write+0x7d>

  1029d2:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  1029d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1029da:	01 d2                	add    %edx,%edx
  1029dc:	01 d0                	add    %edx,%eax
  1029de:	66 c7 00 00 00       	movw   $0x0,(%eax)

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;
  1029e3:	ff 45 f8             	incl   -0x8(%ebp)
  1029e6:	81 7d f8 cf 07 00 00 	cmpl   $0x7cf,-0x8(%ebp)
  1029ed:	7e e3                	jle    1029d2 <ramfs_vga_write+0x69>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
    }
  1029ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029f2:	66 8b 00             	mov    (%eax),%ax
  1029f5:	66 83 f8 02          	cmp    $0x2,%ax
  1029f9:	75 56                	jne    102a51 <ramfs_vga_write+0xe8>
        break;

  1029fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102a02:	eb 25                	jmp    102a29 <ramfs_vga_write+0xc0>
    case 6: /* getExecPath */
  102a04:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  102a09:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102a0c:	01 d2                	add    %edx,%edx
  102a0e:	8d 14 10             	lea    (%eax,%edx,1),%edx
  102a11:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  102a16:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  102a19:	83 c1 50             	add    $0x50,%ecx
  102a1c:	01 c9                	add    %ecx,%ecx
  102a1e:	01 c8                	add    %ecx,%eax
  102a20:	66 8b 00             	mov    (%eax),%ax
  102a23:	66 89 02             	mov    %ax,(%edx)
    case 5: /* yield */
    {
        cpu = schedule(cpu);
    }
        break;

  102a26:	ff 45 fc             	incl   -0x4(%ebp)
  102a29:	81 7d fc 7f 07 00 00 	cmpl   $0x77f,-0x4(%ebp)
  102a30:	7e d2                	jle    102a04 <ramfs_vga_write+0x9b>
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  102a32:	eb 14                	jmp    102a48 <ramfs_vga_write+0xdf>
    }
  102a34:	a1 d8 60 10 00       	mov    0x1060d8,%eax
  102a39:	8b 55 fc             	mov    -0x4(%ebp),%edx
  102a3c:	01 d2                	add    %edx,%edx
  102a3e:	01 d0                	add    %edx,%eax
  102a40:	66 c7 00 00 00       	movw   $0x0,(%eax)
        break;

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  102a45:	ff 45 fc             	incl   -0x4(%ebp)
  102a48:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
  102a4f:	7e e3                	jle    102a34 <ramfs_vga_write+0xcb>
    }
        break;

    case 7: /* changeExecPath */
    {
  102a51:	b8 00 00 00 00       	mov    $0x0,%eax
        vfs_reset_error();
  102a56:	c9                   	leave  
  102a57:	c3                   	ret    

00102a58 <ramfs_vga_open>:
        char* path = strclone((char*) cpu->ebx);

  102a58:	55                   	push   %ebp
  102a59:	89 e5                	mov    %esp,%ebp
  102a5b:	83 ec 18             	sub    $0x18,%esp
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  102a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a61:	83 e0 04             	and    $0x4,%eax
  102a64:	85 c0                	test   %eax,%eax
  102a66:	74 07                	je     102a6f <ramfs_vga_open+0x17>
  102a68:	b8 00 00 00 00       	mov    $0x0,%eax
  102a6d:	eb 78                	jmp    102ae7 <ramfs_vga_open+0x8f>

  102a6f:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a72:	83 e0 01             	and    $0x1,%eax
  102a75:	84 c0                	test   %al,%al
  102a77:	74 07                	je     102a80 <ramfs_vga_open+0x28>
  102a79:	b8 00 00 00 00       	mov    $0x0,%eax
  102a7e:	eb 67                	jmp    102ae7 <ramfs_vga_open+0x8f>
        char* new = vfs_resolve_path(path);

  102a80:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a83:	83 e0 02             	and    $0x2,%eax
  102a86:	85 c0                	test   %eax,%eax
  102a88:	74 10                	je     102a9a <ramfs_vga_open+0x42>
  102a8a:	a1 24 85 12 00       	mov    0x128524,%eax
  102a8f:	85 c0                	test   %eax,%eax
  102a91:	74 07                	je     102a9a <ramfs_vga_open+0x42>
  102a93:	b8 00 00 00 00       	mov    $0x0,%eax
  102a98:	eb 4d                	jmp    102ae7 <ramfs_vga_open+0x8f>
        cpu->eax = 0;
  102a9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  102a9d:	83 e0 02             	and    $0x2,%eax
  102aa0:	85 c0                	test   %eax,%eax
  102aa2:	74 0b                	je     102aaf <ramfs_vga_open+0x57>
  102aa4:	a1 24 85 12 00       	mov    0x128524,%eax
  102aa9:	40                   	inc    %eax
  102aaa:	a3 24 85 12 00       	mov    %eax,0x128524
        if(new) {
            get_current_task()->execPath = new;
  102aaf:	83 ec 0c             	sub    $0xc,%esp
  102ab2:	6a 10                	push   $0x10
  102ab4:	e8 f1 0b 00 00       	call   1036aa <malloc>
  102ab9:	83 c4 10             	add    $0x10,%esp
  102abc:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = 1;
        }
  102abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ac2:	8b 55 0c             	mov    0xc(%ebp),%edx
  102ac5:	89 50 0c             	mov    %edx,0xc(%eax)

  102ac8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102acb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        free(path);
  102ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ad5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    }
  102adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ade:	8b 55 08             	mov    0x8(%ebp),%edx
  102ae1:	89 50 04             	mov    %edx,0x4(%eax)
        break;

  102ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
	case 10: /* fopen */
  102ae7:	c9                   	leave  
  102ae8:	c3                   	ret    

00102ae9 <ramfs_vga_close>:
	{
        vfs_reset_error();
  102ae9:	55                   	push   %ebp
  102aea:	89 e5                	mov    %esp,%ebp
  102aec:	83 ec 08             	sub    $0x8,%esp
	    char* name = strclone((char*) cpu->ebx);
  102aef:	8b 45 08             	mov    0x8(%ebp),%eax
  102af2:	8b 40 0c             	mov    0xc(%eax),%eax
  102af5:	83 e0 02             	and    $0x2,%eax
  102af8:	85 c0                	test   %eax,%eax
  102afa:	74 0b                	je     102b07 <ramfs_vga_close+0x1e>
  102afc:	a1 24 85 12 00       	mov    0x128524,%eax
  102b01:	48                   	dec    %eax
  102b02:	a3 24 85 12 00       	mov    %eax,0x128524
	    uint32_t fmode = (uint32_t) cpu->ecx;

  102b07:	83 ec 0c             	sub    $0xc,%esp
  102b0a:	ff 75 08             	pushl  0x8(%ebp)
  102b0d:	e8 de 0d 00 00       	call   1038f0 <free>
  102b12:	83 c4 10             	add    $0x10,%esp
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
  102b15:	b8 00 00 00 00       	mov    $0x0,%eax
	        register_handle(handle);
  102b1a:	c9                   	leave  
  102b1b:	c3                   	ret    

00102b1c <enableScheduling>:
    char* stdin;
    char* stdout;
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
  102b1c:	55                   	push   %ebp
  102b1d:	89 e5                	mov    %esp,%ebp
    cpu = save_cpu_state(cpu);
  102b1f:	c7 05 28 85 12 00 01 	movl   $0x1,0x128528
  102b26:	00 00 00 

  102b29:	5d                   	pop    %ebp
  102b2a:	c3                   	ret    

00102b2b <isSchedulingEnabled>:
	switch (cpu->eax) {
	case 1: /* exit */
  102b2b:	55                   	push   %ebp
  102b2c:	89 e5                	mov    %esp,%ebp
		return terminate_current(cpu);
  102b2e:	a1 28 85 12 00       	mov    0x128528,%eax

  102b33:	5d                   	pop    %ebp
  102b34:	c3                   	ret    

00102b35 <get_current_task>:
	case 2: /* pexists */
	{
  102b35:	55                   	push   %ebp
  102b36:	89 e5                	mov    %esp,%ebp
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  102b38:	a1 30 85 12 00       	mov    0x128530,%eax
	}
  102b3d:	5d                   	pop    %ebp
  102b3e:	c3                   	ret    

00102b3f <get_task_by_pid>:
	    break;

  102b3f:	55                   	push   %ebp
  102b40:	89 e5                	mov    %esp,%ebp
  102b42:	83 ec 10             	sub    $0x10,%esp
    case 3: /* exec */
  102b45:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102b4a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    {
        char* path = strclone((char*) cpu->ebx);
  102b4d:	eb 18                	jmp    102b67 <get_task_by_pid+0x28>

  102b4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102b52:	8b 00                	mov    (%eax),%eax
  102b54:	3b 45 08             	cmp    0x8(%ebp),%eax
  102b57:	75 05                	jne    102b5e <get_task_by_pid+0x1f>
  102b59:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102b5c:	eb 14                	jmp    102b72 <get_task_by_pid+0x33>
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);
  102b5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102b61:	8b 40 08             	mov    0x8(%eax),%eax
  102b64:	89 45 fc             	mov    %eax,-0x4(%ebp)
	}
	    break;

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);
  102b67:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  102b6b:	75 e2                	jne    102b4f <get_task_by_pid+0x10>

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);

  102b6d:	b8 00 00 00 00       	mov    $0x0,%eax
		if(cpu->edx) {
  102b72:	c9                   	leave  
  102b73:	c3                   	ret    

00102b74 <register_handle>:
			cpu = schedule(cpu);
		}
  102b74:	55                   	push   %ebp
  102b75:	89 e5                	mov    %esp,%ebp
  102b77:	53                   	push   %ebx
  102b78:	83 ec 14             	sub    $0x14,%esp
    }
  102b7b:	a1 30 85 12 00       	mov    0x128530,%eax
  102b80:	8b 40 3c             	mov    0x3c(%eax),%eax
  102b83:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;

  102b86:	8b 1d 30 85 12 00    	mov    0x128530,%ebx
  102b8c:	83 ec 0c             	sub    $0xc,%esp
  102b8f:	6a 08                	push   $0x8
  102b91:	e8 14 0b 00 00       	call   1036aa <malloc>
  102b96:	83 c4 10             	add    $0x10,%esp
  102b99:	89 43 3c             	mov    %eax,0x3c(%ebx)
    case 4: /* getargs */
  102b9c:	a1 30 85 12 00       	mov    0x128530,%eax
  102ba1:	8b 40 3c             	mov    0x3c(%eax),%eax
  102ba4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102ba7:	89 50 04             	mov    %edx,0x4(%eax)
    {
  102baa:	a1 30 85 12 00       	mov    0x128530,%eax
  102baf:	8b 40 3c             	mov    0x3c(%eax),%eax
  102bb2:	8b 55 08             	mov    0x8(%ebp),%edx
  102bb5:	89 10                	mov    %edx,(%eax)
        cpu->eax = (uint32_t) get_current_task()->args;
    }
  102bb7:	b8 00 00 00 00       	mov    $0x0,%eax
        break;
  102bbc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102bbf:	c9                   	leave  
  102bc0:	c3                   	ret    

00102bc1 <unregister_handle>:

    case 5: /* yield */
  102bc1:	55                   	push   %ebp
  102bc2:	89 e5                	mov    %esp,%ebp
  102bc4:	83 ec 18             	sub    $0x18,%esp
    {
  102bc7:	a1 30 85 12 00       	mov    0x128530,%eax
  102bcc:	8b 40 3c             	mov    0x3c(%eax),%eax
  102bcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cpu = schedule(cpu);
    }
  102bd2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102bd6:	75 0a                	jne    102be2 <unregister_handle+0x21>
  102bd8:	b8 02 00 00 00       	mov    $0x2,%eax
  102bdd:	e9 88 00 00 00       	jmp    102c6a <unregister_handle+0xa9>
        break;
  102be2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102be6:	75 07                	jne    102bef <unregister_handle+0x2e>
  102be8:	b8 01 00 00 00       	mov    $0x1,%eax
  102bed:	eb 7b                	jmp    102c6a <unregister_handle+0xa9>

    case 6: /* getExecPath */
  102bef:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102bf2:	8b 00                	mov    (%eax),%eax
  102bf4:	3b 45 08             	cmp    0x8(%ebp),%eax
  102bf7:	75 66                	jne    102c5f <unregister_handle+0x9e>
    {
  102bf9:	a1 30 85 12 00       	mov    0x128530,%eax
  102bfe:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102c01:	8b 52 04             	mov    0x4(%edx),%edx
  102c04:	89 50 3c             	mov    %edx,0x3c(%eax)
        char* dest = (char*)cpu->ebx;
  102c07:	83 ec 0c             	sub    $0xc,%esp
  102c0a:	ff 75 f0             	pushl  -0x10(%ebp)
  102c0d:	e8 de 0c 00 00       	call   1038f0 <free>
  102c12:	83 c4 10             	add    $0x10,%esp
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  102c15:	b8 00 00 00 00       	mov    $0x0,%eax
  102c1a:	eb 4e                	jmp    102c6a <unregister_handle+0xa9>
        break;

    case 7: /* changeExecPath */
    {
  102c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c1f:	8b 40 04             	mov    0x4(%eax),%eax
  102c22:	8b 00                	mov    (%eax),%eax
  102c24:	3b 45 08             	cmp    0x8(%ebp),%eax
  102c27:	75 2d                	jne    102c56 <unregister_handle+0x95>
        vfs_reset_error();
  102c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c2c:	8b 40 04             	mov    0x4(%eax),%eax
  102c2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        char* path = strclone((char*) cpu->ebx);
  102c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c35:	8b 40 04             	mov    0x4(%eax),%eax
  102c38:	8b 50 04             	mov    0x4(%eax),%edx
  102c3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c3e:	89 50 04             	mov    %edx,0x4(%eax)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  102c41:	83 ec 0c             	sub    $0xc,%esp
  102c44:	ff 75 f4             	pushl  -0xc(%ebp)
  102c47:	e8 a4 0c 00 00       	call   1038f0 <free>
  102c4c:	83 c4 10             	add    $0x10,%esp

        char* new = vfs_resolve_path(path);
  102c4f:	b8 00 00 00 00       	mov    $0x0,%eax
  102c54:	eb 14                	jmp    102c6a <unregister_handle+0xa9>

        cpu->eax = 0;
        if(new) {
  102c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c59:	8b 40 04             	mov    0x4(%eax),%eax
  102c5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;

    case 7: /* changeExecPath */
  102c5f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102c63:	75 b7                	jne    102c1c <unregister_handle+0x5b>

        cpu->eax = 0;
        if(new) {
            get_current_task()->execPath = new;
            cpu->eax = 1;
        }
  102c65:	b8 03 00 00 00       	mov    $0x3,%eax

  102c6a:	c9                   	leave  
  102c6b:	c3                   	ret    

00102c6c <schedule_exception>:
        free(path);
    }
  102c6c:	55                   	push   %ebp
  102c6d:	89 e5                	mov    %esp,%ebp
  102c6f:	53                   	push   %ebx
  102c70:	83 ec 04             	sub    $0x4,%esp
        break;
  102c73:	8b 15 30 85 12 00    	mov    0x128530,%edx
  102c79:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102c7e:	39 c2                	cmp    %eax,%edx
  102c80:	75 62                	jne    102ce4 <schedule_exception+0x78>
  102c82:	a1 30 85 12 00       	mov    0x128530,%eax
  102c87:	8b 40 08             	mov    0x8(%eax),%eax
  102c8a:	85 c0                	test   %eax,%eax
  102c8c:	75 56                	jne    102ce4 <schedule_exception+0x78>

	case 10: /* fopen */
  102c8e:	83 ec 0c             	sub    $0xc,%esp
  102c91:	6a 04                	push   $0x4
  102c93:	e8 bf d8 ff ff       	call   100557 <setclr>
  102c98:	83 c4 10             	add    $0x10,%esp
	{
  102c9b:	8b 45 08             	mov    0x8(%ebp),%eax
  102c9e:	8b 58 20             	mov    0x20(%eax),%ebx
  102ca1:	8b 45 08             	mov    0x8(%ebp),%eax
  102ca4:	8b 48 1c             	mov    0x1c(%eax),%ecx
  102ca7:	a1 30 85 12 00       	mov    0x128530,%eax
  102cac:	8b 50 24             	mov    0x24(%eax),%edx
  102caf:	a1 30 85 12 00       	mov    0x128530,%eax
  102cb4:	8b 00                	mov    (%eax),%eax
  102cb6:	83 ec 0c             	sub    $0xc,%esp
  102cb9:	53                   	push   %ebx
  102cba:	51                   	push   %ecx
  102cbb:	52                   	push   %edx
  102cbc:	50                   	push   %eax
  102cbd:	68 5c 77 10 00       	push   $0x10775c
  102cc2:	e8 a6 d8 ff ff       	call   10056d <kprintf>
  102cc7:	83 c4 20             	add    $0x20,%esp
        vfs_reset_error();
  102cca:	83 ec 08             	sub    $0x8,%esp
  102ccd:	68 9c 77 10 00       	push   $0x10779c
  102cd2:	ff 75 08             	pushl  0x8(%ebp)
  102cd5:	e8 fc d4 ff ff       	call   1001d6 <show_cod>
  102cda:	83 c4 10             	add    $0x10,%esp
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

  102cdd:	b8 00 00 00 00       	mov    $0x0,%eax
  102ce2:	eb 75                	jmp    102d59 <schedule_exception+0xed>
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
	        register_handle(handle);
  102ce4:	83 ec 0c             	sub    $0xc,%esp
  102ce7:	6a 04                	push   $0x4
  102ce9:	e8 69 d8 ff ff       	call   100557 <setclr>
  102cee:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = (uint32_t) handle;
  102cf1:	8b 45 08             	mov    0x8(%ebp),%eax
  102cf4:	8b 58 20             	mov    0x20(%eax),%ebx
  102cf7:	8b 45 08             	mov    0x8(%ebp),%eax
  102cfa:	8b 48 1c             	mov    0x1c(%eax),%ecx
  102cfd:	a1 30 85 12 00       	mov    0x128530,%eax
  102d02:	8b 50 24             	mov    0x24(%eax),%edx
  102d05:	a1 30 85 12 00       	mov    0x128530,%eax
  102d0a:	8b 00                	mov    (%eax),%eax
  102d0c:	83 ec 0c             	sub    $0xc,%esp
  102d0f:	53                   	push   %ebx
  102d10:	51                   	push   %ecx
  102d11:	52                   	push   %edx
  102d12:	50                   	push   %eax
  102d13:	68 5c 77 10 00       	push   $0x10775c
  102d18:	e8 50 d8 ff ff       	call   10056d <kprintf>
  102d1d:	83 c4 20             	add    $0x20,%esp
	    }
  102d20:	83 ec 0c             	sub    $0xc,%esp
  102d23:	68 c5 77 10 00       	push   $0x1077c5
  102d28:	e8 40 d8 ff ff       	call   10056d <kprintf>
  102d2d:	83 c4 10             	add    $0x10,%esp
	    else
  102d30:	83 ec 0c             	sub    $0xc,%esp
  102d33:	ff 75 08             	pushl  0x8(%ebp)
  102d36:	e8 f6 d4 ff ff       	call   100231 <show_dump>
  102d3b:	83 c4 10             	add    $0x10,%esp
	    {
  102d3e:	83 ec 0c             	sub    $0xc,%esp
  102d41:	6a 07                	push   $0x7
  102d43:	e8 0f d8 ff ff       	call   100557 <setclr>
  102d48:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = 0;
	    }
  102d4b:	83 ec 0c             	sub    $0xc,%esp
  102d4e:	ff 75 08             	pushl  0x8(%ebp)
  102d51:	e8 08 00 00 00       	call   102d5e <terminate_current>
  102d56:	83 c4 10             	add    $0x10,%esp

	    free(name);
  102d59:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102d5c:	c9                   	leave  
  102d5d:	c3                   	ret    

00102d5e <terminate_current>:
	}
	    break;
  102d5e:	55                   	push   %ebp
  102d5f:	89 e5                	mov    %esp,%ebp
  102d61:	83 ec 18             	sub    $0x18,%esp

  102d64:	a1 30 85 12 00       	mov    0x128530,%eax
  102d69:	8b 40 08             	mov    0x8(%eax),%eax
  102d6c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	case 11: /* fclose */
  102d6f:	a1 30 85 12 00       	mov    0x128530,%eax
  102d74:	8b 40 0c             	mov    0xc(%eax),%eax
  102d77:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
  102d7a:	a1 30 85 12 00       	mov    0x128530,%eax
  102d7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
  102d82:	a1 30 85 12 00       	mov    0x128530,%eax
  102d87:	8b 40 40             	mov    0x40(%eax),%eax
  102d8a:	85 c0                	test   %eax,%eax
  102d8c:	74 3a                	je     102dc8 <terminate_current+0x6a>
	    if(!unregister_handle(handle)) {
  102d8e:	a1 30 85 12 00       	mov    0x128530,%eax
  102d93:	8b 40 40             	mov    0x40(%eax),%eax
  102d96:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	        cpu->eax = 0;
	    }
	    else
	    {
	        cpu->eax = (uint32_t) -1;
	    }
  102d9d:	a1 30 85 12 00       	mov    0x128530,%eax
  102da2:	8b 40 40             	mov    0x40(%eax),%eax
  102da5:	8b 40 28             	mov    0x28(%eax),%eax
  102da8:	83 ec 0c             	sub    $0xc,%esp
  102dab:	50                   	push   %eax
  102dac:	e8 3f 0b 00 00       	call   1038f0 <free>
  102db1:	83 c4 10             	add    $0x10,%esp
	}
  102db4:	a1 30 85 12 00       	mov    0x128530,%eax
  102db9:	8b 40 40             	mov    0x40(%eax),%eax
  102dbc:	8b 15 30 85 12 00    	mov    0x128530,%edx
  102dc2:	8b 52 28             	mov    0x28(%edx),%edx
  102dc5:	89 50 28             	mov    %edx,0x28(%eax)
	    break;

	case 12: /* fwrite */
  102dc8:	e8 e4 1f 00 00       	call   104db1 <vmm_free_current_pagetables>
	{
        vfs_reset_error();
  102dcd:	8b 15 30 85 12 00    	mov    0x128530,%edx
  102dd3:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102dd8:	39 c2                	cmp    %eax,%edx
  102dda:	75 0d                	jne    102de9 <terminate_current+0x8b>
	    struct res_handle* handle = (void*) cpu->ebx;
  102ddc:	a1 30 85 12 00       	mov    0x128530,%eax
  102de1:	8b 40 08             	mov    0x8(%eax),%eax
  102de4:	a3 2c 85 12 00       	mov    %eax,0x12852c
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
  102de9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102ded:	74 09                	je     102df8 <terminate_current+0x9a>
	    else
  102def:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102df2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102df5:	89 50 0c             	mov    %edx,0xc(%eax)
	    {
            cpu->eax = RW_ERR_VFS;
	    }
  102df8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102dfc:	74 09                	je     102e07 <terminate_current+0xa9>
	}
  102dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102e01:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102e04:	89 50 08             	mov    %edx,0x8(%eax)
	    break;

	case 13: /* fread */
  102e07:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  102e0b:	75 08                	jne    102e15 <terminate_current+0xb7>
	{
  102e0d:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102e12:	89 45 ec             	mov    %eax,-0x14(%ebp)
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
  102e15:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102e18:	a3 30 85 12 00       	mov    %eax,0x128530
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
  102e1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e20:	8b 40 04             	mov    0x4(%eax),%eax
  102e23:	83 ec 0c             	sub    $0xc,%esp
  102e26:	50                   	push   %eax
  102e27:	e8 c4 0a 00 00       	call   1038f0 <free>
  102e2c:	83 c4 10             	add    $0x10,%esp
        else
  102e2f:	83 ec 0c             	sub    $0xc,%esp
  102e32:	ff 75 f4             	pushl  -0xc(%ebp)
  102e35:	e8 b6 0a 00 00       	call   1038f0 <free>
  102e3a:	83 c4 10             	add    $0x10,%esp
        {
            cpu->eax = RW_ERR_VFS;
  102e3d:	a1 30 85 12 00       	mov    0x128530,%eax
  102e42:	85 c0                	test   %eax,%eax
  102e44:	75 13                	jne    102e59 <terminate_current+0xfb>
        }
  102e46:	83 ec 08             	sub    $0x8,%esp
  102e49:	68 c7 77 10 00       	push   $0x1077c7
  102e4e:	ff 75 08             	pushl  0x8(%ebp)
  102e51:	e8 80 d3 ff ff       	call   1001d6 <show_cod>
  102e56:	83 c4 10             	add    $0x10,%esp
	}
	    break;

  102e59:	a1 30 85 12 00       	mov    0x128530,%eax
  102e5e:	8b 40 14             	mov    0x14(%eax),%eax
  102e61:	83 ec 0c             	sub    $0xc,%esp
  102e64:	50                   	push   %eax
  102e65:	e8 0a 25 00 00       	call   105374 <vmm_activate_pagedir>
  102e6a:	83 c4 10             	add    $0x10,%esp
	case 14: /* fmkfifo */
  102e6d:	a1 30 85 12 00       	mov    0x128530,%eax
  102e72:	8b 40 04             	mov    0x4(%eax),%eax
	{
  102e75:	c9                   	leave  
  102e76:	c3                   	ret    

00102e77 <init_task>:
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
  102e77:	55                   	push   %ebp
  102e78:	89 e5                	mov    %esp,%ebp
  102e7a:	57                   	push   %edi
  102e7b:	56                   	push   %esi
  102e7c:	53                   	push   %ebx
  102e7d:	83 ec 6c             	sub    $0x6c,%esp
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  102e80:	83 ec 08             	sub    $0x8,%esp
  102e83:	6a 48                	push   $0x48
  102e85:	6a 01                	push   $0x1
  102e87:	e8 94 09 00 00       	call   103820 <calloc>
  102e8c:	83 c4 10             	add    $0x10,%esp
  102e8f:	89 45 dc             	mov    %eax,-0x24(%ebp)

  102e92:	83 ec 08             	sub    $0x8,%esp
  102e95:	6a 38                	push   $0x38
  102e97:	6a 01                	push   $0x1
  102e99:	e8 82 09 00 00       	call   103820 <calloc>
  102e9e:	83 c4 10             	add    $0x10,%esp
  102ea1:	89 c2                	mov    %eax,%edx
  102ea3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ea6:	89 50 04             	mov    %edx,0x4(%eax)
        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
  102ea9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102eac:	8b 55 08             	mov    0x8(%ebp),%edx
  102eaf:	89 50 14             	mov    %edx,0x14(%eax)
            register_handle(handle);
  102eb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102eb5:	c7 40 10 00 00 ff ff 	movl   $0xffff0000,0x10(%eax)
            cpu->eax = (uint32_t) handle;
  102ebc:	a1 f8 60 10 00       	mov    0x1060f8,%eax
  102ec1:	8b 55 dc             	mov    -0x24(%ebp),%edx
  102ec4:	89 02                	mov    %eax,(%edx)
  102ec6:	40                   	inc    %eax
  102ec7:	a3 f8 60 10 00       	mov    %eax,0x1060f8
        }
        else
  102ecc:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ecf:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
        {
  102ed6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ed9:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
            cpu->eax = 0;
  102ee0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ee3:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
        }

  102eea:	8b 15 2c 85 12 00    	mov    0x12852c,%edx
  102ef0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ef3:	89 50 08             	mov    %edx,0x8(%eax)
        free(name);
  102ef6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ef9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	    break;
  102f00:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f03:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)

  102f0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f0d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	case 15: /* getLastVFSErr */
	{
  102f14:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102f19:	85 c0                	test   %eax,%eax
  102f1b:	74 0b                	je     102f28 <init_task+0xb1>
	    cpu->eax = get_current_task()->vfserr;
  102f1d:	a1 2c 85 12 00       	mov    0x12852c,%eax
  102f22:	8b 55 dc             	mov    -0x24(%ebp),%edx
  102f25:	89 50 0c             	mov    %edx,0xc(%eax)
        vfs_reset_error();
	}
	    break;
  102f28:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f2b:	a3 2c 85 12 00       	mov    %eax,0x12852c

	case 16: /* favailable */
  102f30:	e8 47 1e 00 00       	call   104d7c <vmm_get_current_pagedir>
  102f35:	89 45 e0             	mov    %eax,-0x20(%ebp)
	{
  102f38:	83 ec 0c             	sub    $0xc,%esp
  102f3b:	ff 75 08             	pushl  0x8(%ebp)
  102f3e:	e8 31 24 00 00       	call   105374 <vmm_activate_pagedir>
  102f43:	83 c4 10             	add    $0x10,%esp
	    cpu->eax = vfs_available((void*)cpu->ebx);
	}
  102f46:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f49:	8b 40 10             	mov    0x10(%eax),%eax
  102f4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  102f4f:	eb 17                	jmp    102f68 <init_task+0xf1>
	    break;
  102f51:	83 ec 08             	sub    $0x8,%esp
  102f54:	6a 00                	push   $0x0
  102f56:	ff 75 e4             	pushl  -0x1c(%ebp)
  102f59:	e8 71 23 00 00       	call   1052cf <vmm_alloc_addr>
  102f5e:	83 c4 10             	add    $0x10,%esp
	    break;

	case 16: /* favailable */
	{
	    cpu->eax = vfs_available((void*)cpu->ebx);
	}
  102f61:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  102f68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102f6b:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
  102f70:	76 df                	jbe    102f51 <init_task+0xda>

	case 17: /* getPathChild */
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);

		if(path != 0 && cpu->ecx != 0) {
  102f72:	8b 75 0c             	mov    0xc(%ebp),%esi
	    break;

	case 17: /* getPathChild */
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);

  102f75:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102f78:	8b 40 10             	mov    0x10(%eax),%eax
  102f7b:	05 00 10 00 00       	add    $0x1000,%eax
  102f80:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if(path != 0 && cpu->ecx != 0) {
			strcpy((char*)cpu->ecx, path);
			free(path);

			cpu->eax = cpu->ecx;
		}
  102f83:	8d 5d a4             	lea    -0x5c(%ebp),%ebx
  102f86:	b8 00 00 00 00       	mov    $0x0,%eax
  102f8b:	ba 0e 00 00 00       	mov    $0xe,%edx
  102f90:	89 df                	mov    %ebx,%edi
  102f92:	89 d1                	mov    %edx,%ecx
  102f94:	f3 ab                	rep stos %eax,%es:(%edi)
  102f96:	89 75 c8             	mov    %esi,-0x38(%ebp)
  102f99:	c7 45 cc 1b 00 00 00 	movl   $0x1b,-0x34(%ebp)
  102fa0:	c7 45 d0 00 02 00 00 	movl   $0x200,-0x30(%ebp)
  102fa7:	8b 45 94             	mov    -0x6c(%ebp),%eax
  102faa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102fad:	c7 45 d8 23 00 00 00 	movl   $0x23,-0x28(%ebp)
		else
		{
  102fb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102fb7:	8b 40 04             	mov    0x4(%eax),%eax
  102fba:	83 ec 04             	sub    $0x4,%esp
  102fbd:	6a 38                	push   $0x38
  102fbf:	8d 55 a4             	lea    -0x5c(%ebp),%edx
  102fc2:	52                   	push   %edx
  102fc3:	50                   	push   %eax
  102fc4:	e8 a9 09 00 00       	call   103972 <memcpy>
  102fc9:	83 c4 10             	add    $0x10,%esp
			cpu->eax = 0;
		}
  102fcc:	83 ec 0c             	sub    $0xc,%esp
  102fcf:	ff 75 e0             	pushl  -0x20(%ebp)
  102fd2:	e8 9d 23 00 00       	call   105374 <vmm_activate_pagedir>
  102fd7:	83 c4 10             	add    $0x10,%esp
	}
		break;
  102fda:	8b 45 dc             	mov    -0x24(%ebp),%eax

  102fdd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102fe0:	83 c4 00             	add    $0x0,%esp
  102fe3:	5b                   	pop    %ebx
  102fe4:	5e                   	pop    %esi
  102fe5:	5f                   	pop    %edi
  102fe6:	5d                   	pop    %ebp
  102fe7:	c3                   	ret    

00102fe8 <save_cpu_state>:
	case 20: /* getpmhandle */
	{
  102fe8:	55                   	push   %ebp
  102fe9:	89 e5                	mov    %esp,%ebp
  102feb:	83 ec 08             	sub    $0x8,%esp
	    struct res_handle* handle = 0;
  102fee:	a1 30 85 12 00       	mov    0x128530,%eax
  102ff3:	8b 40 18             	mov    0x18(%eax),%eax
  102ff6:	85 c0                	test   %eax,%eax
  102ff8:	74 38                	je     103032 <save_cpu_state+0x4a>
  102ffa:	a1 30 85 12 00       	mov    0x128530,%eax
  102fff:	8b 40 18             	mov    0x18(%eax),%eax
  103002:	8a 40 14             	mov    0x14(%eax),%al
  103005:	84 c0                	test   %al,%al
  103007:	74 29                	je     103032 <save_cpu_state+0x4a>

  103009:	a1 30 85 12 00       	mov    0x128530,%eax
  10300e:	8b 40 18             	mov    0x18(%eax),%eax
  103011:	8b 40 18             	mov    0x18(%eax),%eax
  103014:	83 ec 04             	sub    $0x4,%esp
  103017:	6a 38                	push   $0x38
  103019:	ff 75 08             	pushl  0x8(%ebp)
  10301c:	50                   	push   %eax
  10301d:	e8 50 09 00 00       	call   103972 <memcpy>
  103022:	83 c4 10             	add    $0x10,%esp
	    switch(cpu->ebx) {
  103025:	a1 30 85 12 00       	mov    0x128530,%eax
  10302a:	8b 40 18             	mov    0x18(%eax),%eax
  10302d:	8b 40 18             	mov    0x18(%eax),%eax
  103030:	eb 21                	jmp    103053 <save_cpu_state+0x6b>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
	        break;
        case PMID_STDIN:
  103032:	a1 30 85 12 00       	mov    0x128530,%eax
  103037:	8b 40 04             	mov    0x4(%eax),%eax
  10303a:	83 ec 04             	sub    $0x4,%esp
  10303d:	6a 38                	push   $0x38
  10303f:	ff 75 08             	pushl  0x8(%ebp)
  103042:	50                   	push   %eax
  103043:	e8 2a 09 00 00       	call   103972 <memcpy>
  103048:	83 c4 10             	add    $0x10,%esp
            handle = get_current_task()->stdin;
  10304b:	a1 30 85 12 00       	mov    0x128530,%eax
  103050:	8b 40 04             	mov    0x4(%eax),%eax
            break;
        case PMID_STDERR:
  103053:	c9                   	leave  
  103054:	c3                   	ret    

00103055 <schedule_to_task>:
            handle = get_current_task()->stderr;
            break;
  103055:	55                   	push   %ebp
  103056:	89 e5                	mov    %esp,%ebp
  103058:	83 ec 08             	sub    $0x8,%esp
        default:
  10305b:	8b 45 08             	mov    0x8(%ebp),%eax
  10305e:	a3 30 85 12 00       	mov    %eax,0x128530
            handle = get_current_task()->stdout;
            break;
  103063:	8b 45 08             	mov    0x8(%ebp),%eax
  103066:	8b 40 14             	mov    0x14(%eax),%eax
  103069:	83 ec 0c             	sub    $0xc,%esp
  10306c:	50                   	push   %eax
  10306d:	e8 02 23 00 00       	call   105374 <vmm_activate_pagedir>
  103072:	83 c4 10             	add    $0x10,%esp
	    }

  103075:	8b 45 08             	mov    0x8(%ebp),%eax
  103078:	8b 40 18             	mov    0x18(%eax),%eax
  10307b:	85 c0                	test   %eax,%eax
  10307d:	75 08                	jne    103087 <schedule_to_task+0x32>
	    cpu->eax = (uint32_t) handle;
  10307f:	8b 45 08             	mov    0x8(%ebp),%eax
  103082:	8b 40 04             	mov    0x4(%eax),%eax
  103085:	eb 24                	jmp    1030ab <schedule_to_task+0x56>
	}
	    break;

	case 21: /* fopenpmhandle */
  103087:	8b 45 08             	mov    0x8(%ebp),%eax
  10308a:	8b 40 18             	mov    0x18(%eax),%eax
  10308d:	8a 40 14             	mov    0x14(%eax),%al
  103090:	84 c0                	test   %al,%al
  103092:	75 0e                	jne    1030a2 <schedule_to_task+0x4d>
	{
  103094:	83 ec 0c             	sub    $0xc,%esp
  103097:	ff 75 08             	pushl  0x8(%ebp)
  10309a:	e8 a9 00 00 00       	call   103148 <init_rpc_call>
  10309f:	83 c4 10             	add    $0x10,%esp
	    vfs_reset_error();
	    char* path = strclone((char*)cpu->ecx);
  1030a2:	8b 45 08             	mov    0x8(%ebp),%eax
  1030a5:	8b 40 18             	mov    0x18(%eax),%eax
  1030a8:	8b 40 18             	mov    0x18(%eax),%eax

	    struct res_handle* open;
  1030ab:	c9                   	leave  
  1030ac:	c3                   	ret    

001030ad <schedule>:
	    uint32_t fm = FM_WRITE;

  1030ad:	55                   	push   %ebp
  1030ae:	89 e5                	mov    %esp,%ebp
  1030b0:	83 ec 18             	sub    $0x18,%esp
	    if(cpu->ebx == PMID_STDIN) {
  1030b3:	a1 2c 85 12 00       	mov    0x12852c,%eax
  1030b8:	85 c0                	test   %eax,%eax
  1030ba:	0f 84 81 00 00 00    	je     103141 <schedule+0x94>
  1030c0:	a1 28 85 12 00       	mov    0x128528,%eax
  1030c5:	85 c0                	test   %eax,%eax
  1030c7:	74 78                	je     103141 <schedule+0x94>
	        fm = FM_READ;
  1030c9:	a1 30 85 12 00       	mov    0x128530,%eax
  1030ce:	85 c0                	test   %eax,%eax
  1030d0:	75 28                	jne    1030fa <schedule+0x4d>
	    }
  1030d2:	a1 2c 85 12 00       	mov    0x12852c,%eax
  1030d7:	a3 30 85 12 00       	mov    %eax,0x128530

  1030dc:	a1 30 85 12 00       	mov    0x128530,%eax
  1030e1:	8b 40 14             	mov    0x14(%eax),%eax
  1030e4:	83 ec 0c             	sub    $0xc,%esp
  1030e7:	50                   	push   %eax
  1030e8:	e8 87 22 00 00       	call   105374 <vmm_activate_pagedir>
  1030ed:	83 c4 10             	add    $0x10,%esp
	    open = vfs_open(path, fm);
  1030f0:	a1 30 85 12 00       	mov    0x128530,%eax
  1030f5:	8b 40 04             	mov    0x4(%eax),%eax
  1030f8:	eb 4a                	jmp    103144 <schedule+0x97>

	    free(path);

  1030fa:	a1 30 85 12 00       	mov    0x128530,%eax
  1030ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    if(!open) {
	        cpu->eax = (uint32_t) -1;
	        break;
  103102:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103105:	8b 40 08             	mov    0x8(%eax),%eax
  103108:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    }
  10310b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10310f:	75 08                	jne    103119 <schedule+0x6c>

  103111:	a1 2c 85 12 00       	mov    0x12852c,%eax
  103116:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    struct res_handle* oldhandle = 0;

  103119:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10311c:	8b 40 44             	mov    0x44(%eax),%eax
  10311f:	85 c0                	test   %eax,%eax
  103121:	75 df                	jne    103102 <schedule+0x55>
        switch(cpu->ebx) {
        case PMID_STDOUT:
  103123:	83 ec 0c             	sub    $0xc,%esp
  103126:	ff 75 08             	pushl  0x8(%ebp)
  103129:	e8 ba fe ff ff       	call   102fe8 <save_cpu_state>
  10312e:	83 c4 10             	add    $0x10,%esp
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
  103131:	83 ec 0c             	sub    $0xc,%esp
  103134:	ff 75 f4             	pushl  -0xc(%ebp)
  103137:	e8 19 ff ff ff       	call   103055 <schedule_to_task>
  10313c:	83 c4 10             	add    $0x10,%esp
  10313f:	eb 03                	jmp    103144 <schedule+0x97>
            break;
        case PMID_STDIN:
  103141:	8b 45 08             	mov    0x8(%ebp),%eax
            oldhandle = get_current_task()->stdin;
  103144:	c9                   	leave  
  103145:	c3                   	ret    
	...

00103148 <init_rpc_call>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct exec_info {
  103148:	55                   	push   %ebp
  103149:	89 e5                	mov    %esp,%ebp
  10314b:	57                   	push   %edi
  10314c:	56                   	push   %esi
  10314d:	53                   	push   %ebx
  10314e:	83 ec 5c             	sub    $0x5c,%esp
    char* execPath;
  103151:	8b 45 08             	mov    0x8(%ebp),%eax
  103154:	8b 40 18             	mov    0x18(%eax),%eax
  103157:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char* stdin;
    char* stdout;
  10315a:	83 ec 08             	sub    $0x8,%esp
  10315d:	6a 38                	push   $0x38
  10315f:	6a 01                	push   $0x1
  103161:	e8 ba 06 00 00       	call   103820 <calloc>
  103166:	83 c4 10             	add    $0x10,%esp
  103169:	89 c2                	mov    %eax,%edx
  10316b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10316e:	89 50 18             	mov    %edx,0x18(%eax)
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
  103171:	8b 45 08             	mov    0x8(%ebp),%eax
  103174:	8b 70 1c             	mov    0x1c(%eax),%esi
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

  103177:	8b 45 08             	mov    0x8(%ebp),%eax
  10317a:	8b 40 04             	mov    0x4(%eax),%eax
	switch (cpu->eax) {
	case 1: /* exit */
		return terminate_current(cpu);

	case 2: /* pexists */
	{
  10317d:	8b 40 30             	mov    0x30(%eax),%eax
    char* stderr;
};

struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

  103180:	83 e8 10             	sub    $0x10,%eax
  103183:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	switch (cpu->eax) {
	case 1: /* exit */
		return terminate_current(cpu);

	case 2: /* pexists */
	{
  103186:	8d 5d a8             	lea    -0x58(%ebp),%ebx
  103189:	b8 00 00 00 00       	mov    $0x0,%eax
  10318e:	ba 0e 00 00 00       	mov    $0xe,%edx
  103193:	89 df                	mov    %ebx,%edi
  103195:	89 d1                	mov    %edx,%ecx
  103197:	f3 ab                	rep stos %eax,%es:(%edi)
  103199:	89 75 cc             	mov    %esi,-0x34(%ebp)
  10319c:	c7 45 d0 1b 00 00 00 	movl   $0x1b,-0x30(%ebp)
  1031a3:	c7 45 d4 00 02 00 00 	movl   $0x200,-0x2c(%ebp)
  1031aa:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1031ad:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1031b0:	c7 45 dc 23 00 00 00 	movl   $0x23,-0x24(%ebp)
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
	}
  1031b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031ba:	8b 40 18             	mov    0x18(%eax),%eax
  1031bd:	83 ec 04             	sub    $0x4,%esp
  1031c0:	6a 38                	push   $0x38
  1031c2:	8d 55 a8             	lea    -0x58(%ebp),%edx
  1031c5:	52                   	push   %edx
  1031c6:	50                   	push   %eax
  1031c7:	e8 a6 07 00 00       	call   103972 <memcpy>
  1031cc:	83 c4 10             	add    $0x10,%esp
	    break;

  1031cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031d2:	8b 40 18             	mov    0x18(%eax),%eax
  1031d5:	8b 40 30             	mov    0x30(%eax),%eax
  1031d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    case 3: /* exec */
    {
  1031db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1031de:	8d 50 04             	lea    0x4(%eax),%edx
  1031e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031e4:	8b 40 04             	mov    0x4(%eax),%eax
  1031e7:	89 02                	mov    %eax,(%edx)
        char* path = strclone((char*) cpu->ebx);
  1031e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1031ec:	8d 50 08             	lea    0x8(%eax),%edx
  1031ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1031f2:	8b 40 08             	mov    0x8(%eax),%eax
  1031f5:	89 02                	mov    %eax,(%edx)

  1031f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1031fa:	8d 50 0c             	lea    0xc(%eax),%edx
  1031fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103200:	8b 40 10             	mov    0x10(%eax),%eax
  103203:	89 02                	mov    %eax,(%edx)
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

  103205:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103208:	c6 40 14 01          	movb   $0x1,0x14(%eax)
        free(path);
  10320c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10320f:	83 c4 00             	add    $0x0,%esp
  103212:	5b                   	pop    %ebx
  103213:	5e                   	pop    %esi
  103214:	5f                   	pop    %edi
  103215:	5d                   	pop    %ebp
  103216:	c3                   	ret    

00103217 <create_rpc_call>:

		if(cpu->edx) {
  103217:	55                   	push   %ebp
  103218:	89 e5                	mov    %esp,%ebp
  10321a:	83 ec 18             	sub    $0x18,%esp
			cpu = schedule(cpu);
  10321d:	83 ec 08             	sub    $0x8,%esp
  103220:	6a 20                	push   $0x20
  103222:	6a 01                	push   $0x1
  103224:	e8 f7 05 00 00       	call   103820 <calloc>
  103229:	83 c4 10             	add    $0x10,%esp
  10322c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		}
  10322f:	83 ec 0c             	sub    $0xc,%esp
  103232:	ff 75 08             	pushl  0x8(%ebp)
  103235:	e8 05 f9 ff ff       	call   102b3f <get_task_by_pid>
  10323a:	83 c4 10             	add    $0x10,%esp
  10323d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
        break;
  103240:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103244:	75 34                	jne    10327a <create_rpc_call+0x63>

  103246:	83 ec 0c             	sub    $0xc,%esp
  103249:	6a 0a                	push   $0xa
  10324b:	e8 07 d3 ff ff       	call   100557 <setclr>
  103250:	83 c4 10             	add    $0x10,%esp
    case 4: /* getargs */
  103253:	83 ec 0c             	sub    $0xc,%esp
  103256:	68 e0 77 10 00       	push   $0x1077e0
  10325b:	e8 0d d3 ff ff       	call   10056d <kprintf>
  103260:	83 c4 10             	add    $0x10,%esp
    {
  103263:	83 ec 0c             	sub    $0xc,%esp
  103266:	6a 07                	push   $0x7
  103268:	e8 ea d2 ff ff       	call   100557 <setclr>
  10326d:	83 c4 10             	add    $0x10,%esp
        cpu->eax = (uint32_t) get_current_task()->args;
  103270:	b8 02 00 00 00       	mov    $0x2,%eax
  103275:	e9 06 01 00 00       	jmp    103380 <create_rpc_call+0x169>
    }
        break;

  10327a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10327d:	8b 40 1c             	mov    0x1c(%eax),%eax
  103280:	85 c0                	test   %eax,%eax
  103282:	75 34                	jne    1032b8 <create_rpc_call+0xa1>
    case 5: /* yield */
  103284:	83 ec 0c             	sub    $0xc,%esp
  103287:	6a 0a                	push   $0xa
  103289:	e8 c9 d2 ff ff       	call   100557 <setclr>
  10328e:	83 c4 10             	add    $0x10,%esp
    {
  103291:	83 ec 0c             	sub    $0xc,%esp
  103294:	68 0c 78 10 00       	push   $0x10780c
  103299:	e8 cf d2 ff ff       	call   10056d <kprintf>
  10329e:	83 c4 10             	add    $0x10,%esp
        cpu = schedule(cpu);
  1032a1:	83 ec 0c             	sub    $0xc,%esp
  1032a4:	6a 07                	push   $0x7
  1032a6:	e8 ac d2 ff ff       	call   100557 <setclr>
  1032ab:	83 c4 10             	add    $0x10,%esp
    }
  1032ae:	b8 03 00 00 00       	mov    $0x3,%eax
  1032b3:	e9 c8 00 00 00       	jmp    103380 <create_rpc_call+0x169>
        break;

    case 6: /* getExecPath */
  1032b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  1032be:	89 50 04             	mov    %edx,0x4(%eax)
    {
  1032c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032c4:	8b 55 10             	mov    0x10(%ebp),%edx
  1032c7:	89 50 08             	mov    %edx,0x8(%eax)
        char* dest = (char*)cpu->ebx;
  1032ca:	e8 66 f8 ff ff       	call   102b35 <get_current_task>
  1032cf:	85 c0                	test   %eax,%eax
  1032d1:	74 09                	je     1032dc <create_rpc_call+0xc5>
  1032d3:	e8 5d f8 ff ff       	call   102b35 <get_current_task>
  1032d8:	8b 00                	mov    (%eax),%eax
  1032da:	eb 05                	jmp    1032e1 <create_rpc_call+0xca>
  1032dc:	b8 00 00 00 00       	mov    $0x0,%eax
  1032e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1032e4:	89 02                	mov    %eax,(%edx)
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  1032e6:	83 ec 0c             	sub    $0xc,%esp
  1032e9:	ff 75 14             	pushl  0x14(%ebp)
  1032ec:	e8 b9 03 00 00       	call   1036aa <malloc>
  1032f1:	83 c4 10             	add    $0x10,%esp
  1032f4:	89 c2                	mov    %eax,%edx
  1032f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032f9:	89 50 0c             	mov    %edx,0xc(%eax)
        break;
  1032fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1032ff:	8b 40 0c             	mov    0xc(%eax),%eax
  103302:	83 ec 04             	sub    $0x4,%esp
  103305:	ff 75 14             	pushl  0x14(%ebp)
  103308:	ff 75 18             	pushl  0x18(%ebp)
  10330b:	50                   	push   %eax
  10330c:	e8 61 06 00 00       	call   103972 <memcpy>
  103311:	83 c4 10             	add    $0x10,%esp

  103314:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103317:	8b 55 14             	mov    0x14(%ebp),%edx
  10331a:	89 50 10             	mov    %edx,0x10(%eax)
    case 7: /* changeExecPath */
    {
  10331d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103320:	8b 40 18             	mov    0x18(%eax),%eax
  103323:	85 c0                	test   %eax,%eax
  103325:	75 10                	jne    103337 <create_rpc_call+0x120>
        vfs_reset_error();
  103327:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10332a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10332d:	89 50 18             	mov    %edx,0x18(%eax)
        char* path = strclone((char*) cpu->ebx);
  103330:	b8 00 00 00 00       	mov    $0x0,%eax
  103335:	eb 49                	jmp    103380 <create_rpc_call+0x169>

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);
  103337:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10333a:	8b 40 18             	mov    0x18(%eax),%eax
  10333d:	89 45 f4             	mov    %eax,-0xc(%ebp)

        cpu->eax = 0;
  103340:	eb 33                	jmp    103375 <create_rpc_call+0x15e>
        if(new) {
  103342:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103345:	8b 40 1c             	mov    0x1c(%eax),%eax
  103348:	85 c0                	test   %eax,%eax
  10334a:	75 20                	jne    10336c <create_rpc_call+0x155>
            get_current_task()->execPath = new;
  10334c:	83 ec 0c             	sub    $0xc,%esp
  10334f:	68 3b 78 10 00       	push   $0x10783b
  103354:	e8 14 d2 ff ff       	call   10056d <kprintf>
  103359:	83 c4 10             	add    $0x10,%esp
            cpu->eax = 1;
        }
  10335c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10335f:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103362:	89 50 1c             	mov    %edx,0x1c(%eax)

  103365:	b8 00 00 00 00       	mov    $0x0,%eax
  10336a:	eb 14                	jmp    103380 <create_rpc_call+0x169>
        free(path);
    }
  10336c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10336f:	8b 40 1c             	mov    0x1c(%eax),%eax
  103372:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);

        cpu->eax = 0;
  103375:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103379:	75 c7                	jne    103342 <create_rpc_call+0x12b>
        free(path);
    }
        break;

	case 10: /* fopen */
	{
  10337b:	b8 01 00 00 00       	mov    $0x1,%eax
        vfs_reset_error();
  103380:	c9                   	leave  
  103381:	c3                   	ret    

00103382 <return_rpc_call>:
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;
  103382:	55                   	push   %ebp
  103383:	89 e5                	mov    %esp,%ebp
  103385:	83 ec 18             	sub    $0x18,%esp

  103388:	e8 a8 f7 ff ff       	call   102b35 <get_current_task>
  10338d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    struct res_handle* handle = vfs_open(name, fmode);
	    if(handle) {
  103390:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103393:	8b 40 18             	mov    0x18(%eax),%eax
  103396:	85 c0                	test   %eax,%eax
  103398:	75 68                	jne    103402 <return_rpc_call+0x80>
	        register_handle(handle);
  10339a:	83 ec 0c             	sub    $0xc,%esp
  10339d:	6a 04                	push   $0x4
  10339f:	e8 b3 d1 ff ff       	call   100557 <setclr>
  1033a4:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = (uint32_t) handle;
  1033a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033aa:	8b 50 24             	mov    0x24(%eax),%edx
  1033ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033b0:	8b 00                	mov    (%eax),%eax
  1033b2:	83 ec 04             	sub    $0x4,%esp
  1033b5:	52                   	push   %edx
  1033b6:	50                   	push   %eax
  1033b7:	68 50 78 10 00       	push   $0x107850
  1033bc:	e8 ac d1 ff ff       	call   10056d <kprintf>
  1033c1:	83 c4 10             	add    $0x10,%esp
	    }
  1033c4:	83 ec 0c             	sub    $0xc,%esp
  1033c7:	68 8e 78 10 00       	push   $0x10788e
  1033cc:	e8 9c d1 ff ff       	call   10056d <kprintf>
  1033d1:	83 c4 10             	add    $0x10,%esp
	    else
  1033d4:	83 ec 0c             	sub    $0xc,%esp
  1033d7:	ff 75 08             	pushl  0x8(%ebp)
  1033da:	e8 52 ce ff ff       	call   100231 <show_dump>
  1033df:	83 c4 10             	add    $0x10,%esp
	    {
  1033e2:	83 ec 0c             	sub    $0xc,%esp
  1033e5:	6a 07                	push   $0x7
  1033e7:	e8 6b d1 ff ff       	call   100557 <setclr>
  1033ec:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = 0;
	    }
  1033ef:	83 ec 0c             	sub    $0xc,%esp
  1033f2:	ff 75 08             	pushl  0x8(%ebp)
  1033f5:	e8 64 f9 ff ff       	call   102d5e <terminate_current>
  1033fa:	83 c4 10             	add    $0x10,%esp
  1033fd:	e9 b5 00 00 00       	jmp    1034b7 <return_rpc_call+0x135>

	    free(name);
	}
  103402:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103405:	8b 40 18             	mov    0x18(%eax),%eax
  103408:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    break;
  10340b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10340e:	8b 40 18             	mov    0x18(%eax),%eax
  103411:	8b 50 1c             	mov    0x1c(%eax),%edx
  103414:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103417:	89 50 18             	mov    %edx,0x18(%eax)

	case 11: /* fclose */
  10341a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10341d:	8b 00                	mov    (%eax),%eax
  10341f:	85 c0                	test   %eax,%eax
  103421:	0f 84 82 00 00 00    	je     1034a9 <return_rpc_call+0x127>
	{
  103427:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10342a:	8b 00                	mov    (%eax),%eax
  10342c:	83 ec 0c             	sub    $0xc,%esp
  10342f:	50                   	push   %eax
  103430:	e8 0a f7 ff ff       	call   102b3f <get_task_by_pid>
  103435:	83 c4 10             	add    $0x10,%esp
  103438:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
  10343b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10343e:	8b 40 04             	mov    0x4(%eax),%eax
  103441:	85 c0                	test   %eax,%eax
  103443:	75 12                	jne    103457 <return_rpc_call+0xd5>
	    if(!unregister_handle(handle)) {
  103445:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103448:	8b 40 08             	mov    0x8(%eax),%eax
  10344b:	83 ec 0c             	sub    $0xc,%esp
  10344e:	50                   	push   %eax
  10344f:	e8 18 db ff ff       	call   100f6c <enable_irq_rpc>
  103454:	83 c4 10             	add    $0x10,%esp
	        vfs_close(handle);

	        cpu->eax = 0;
  103457:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10345a:	8b 40 18             	mov    0x18(%eax),%eax
  10345d:	83 ec 0c             	sub    $0xc,%esp
  103460:	50                   	push   %eax
  103461:	e8 8a 04 00 00       	call   1038f0 <free>
  103466:	83 c4 10             	add    $0x10,%esp
	    }
  103469:	83 ec 0c             	sub    $0xc,%esp
  10346c:	ff 75 f0             	pushl  -0x10(%ebp)
  10346f:	e8 7c 04 00 00       	call   1038f0 <free>
  103474:	83 c4 10             	add    $0x10,%esp
	    else
	    {
  103477:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10347b:	75 10                	jne    10348d <return_rpc_call+0x10b>
	        cpu->eax = (uint32_t) -1;
  10347d:	83 ec 0c             	sub    $0xc,%esp
  103480:	ff 75 ec             	pushl  -0x14(%ebp)
  103483:	e8 cd fb ff ff       	call   103055 <schedule_to_task>
  103488:	83 c4 10             	add    $0x10,%esp
  10348b:	eb 2a                	jmp    1034b7 <return_rpc_call+0x135>
	    }
	}
	    break;
  10348d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103490:	8b 40 04             	mov    0x4(%eax),%eax
  103493:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	case 12: /* fwrite */
  103499:	83 ec 0c             	sub    $0xc,%esp
  10349c:	ff 75 f4             	pushl  -0xc(%ebp)
  10349f:	e8 b1 fb ff ff       	call   103055 <schedule_to_task>
  1034a4:	83 c4 10             	add    $0x10,%esp
  1034a7:	eb 0e                	jmp    1034b7 <return_rpc_call+0x135>
	{
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
  1034a9:	83 ec 0c             	sub    $0xc,%esp
  1034ac:	ff 75 ec             	pushl  -0x14(%ebp)
  1034af:	e8 a1 fb ff ff       	call   103055 <schedule_to_task>
  1034b4:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
  1034b7:	c9                   	leave  
  1034b8:	c3                   	ret    
  1034b9:	00 00                	add    %al,(%eax)
	...

001034bc <remove_from_list>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct exec_info {
  1034bc:	55                   	push   %ebp
  1034bd:	89 e5                	mov    %esp,%ebp
  1034bf:	83 ec 10             	sub    $0x10,%esp
    char* execPath;
  1034c2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    char* stdin;
  1034c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1034cc:	8b 00                	mov    (%eax),%eax
  1034ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* stdout;
    char* stderr;
  1034d1:	eb 38                	jmp    10350b <remove_from_list+0x4f>
};
  1034d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034d6:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1034d9:	75 21                	jne    1034fc <remove_from_list+0x40>

  1034db:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  1034df:	75 0d                	jne    1034ee <remove_from_list+0x32>
struct cpu_state* syscall(struct cpu_state* cpu) {
  1034e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034e4:	8b 50 08             	mov    0x8(%eax),%edx
  1034e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1034ea:	89 10                	mov    %edx,(%eax)
    cpu = save_cpu_state(cpu);
  1034ec:	eb 23                	jmp    103511 <remove_from_list+0x55>

	switch (cpu->eax) {
  1034ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034f1:	8b 50 08             	mov    0x8(%eax),%edx
  1034f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1034f7:	89 50 08             	mov    %edx,0x8(%eax)
	case 1: /* exit */
  1034fa:	eb 15                	jmp    103511 <remove_from_list+0x55>
		return terminate_current(cpu);

	case 2: /* pexists */
  1034fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
	{
  103502:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103505:	8b 40 08             	mov    0x8(%eax),%eax
  103508:	89 45 fc             	mov    %eax,-0x4(%ebp)

struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
    char* stderr;
  10350b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10350f:	75 c2                	jne    1034d3 <remove_from_list+0x17>
		return terminate_current(cpu);

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
	}
  103511:	c9                   	leave  
  103512:	c3                   	ret    

00103513 <append_to_list>:
	    break;

    case 3: /* exec */
  103513:	55                   	push   %ebp
  103514:	89 e5                	mov    %esp,%ebp
    {
  103516:	8b 45 08             	mov    0x8(%ebp),%eax
  103519:	8b 10                	mov    (%eax),%edx
  10351b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10351e:	89 50 08             	mov    %edx,0x8(%eax)
        char* path = strclone((char*) cpu->ebx);
  103521:	8b 45 08             	mov    0x8(%ebp),%eax
  103524:	8b 55 0c             	mov    0xc(%ebp),%edx
  103527:	89 10                	mov    %edx,(%eax)

  103529:	5d                   	pop    %ebp
  10352a:	c3                   	ret    

0010352b <pop_from_list>:
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

  10352b:	55                   	push   %ebp
  10352c:	89 e5                	mov    %esp,%ebp
  10352e:	83 ec 10             	sub    $0x10,%esp
        free(path);
  103531:	8b 45 08             	mov    0x8(%ebp),%eax
  103534:	8b 00                	mov    (%eax),%eax
  103536:	85 c0                	test   %eax,%eax
  103538:	75 07                	jne    103541 <pop_from_list+0x16>

  10353a:	b8 00 00 00 00       	mov    $0x0,%eax
  10353f:	eb 19                	jmp    10355a <pop_from_list+0x2f>
		if(cpu->edx) {
  103541:	8b 45 08             	mov    0x8(%ebp),%eax
  103544:	8b 00                	mov    (%eax),%eax
  103546:	89 45 fc             	mov    %eax,-0x4(%ebp)
			cpu = schedule(cpu);
  103549:	ff 75 fc             	pushl  -0x4(%ebp)
  10354c:	ff 75 08             	pushl  0x8(%ebp)
  10354f:	e8 68 ff ff ff       	call   1034bc <remove_from_list>
  103554:	83 c4 08             	add    $0x8,%esp
		}
  103557:	8b 45 fc             	mov    -0x4(%ebp),%eax
    }
  10355a:	c9                   	leave  
  10355b:	c3                   	ret    

0010355c <allocate_unused_nodes>:
        break;

  10355c:	55                   	push   %ebp
  10355d:	89 e5                	mov    %esp,%ebp
  10355f:	83 ec 18             	sub    $0x18,%esp
    case 4: /* getargs */
  103562:	83 ec 0c             	sub    $0xc,%esp
  103565:	6a 01                	push   $0x1
  103567:	e8 25 1d 00 00       	call   105291 <vmm_alloc_cont>
  10356c:	83 c4 10             	add    $0x10,%esp
  10356f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    {
  103572:	83 ec 04             	sub    $0x4,%esp
  103575:	68 00 10 00 00       	push   $0x1000
  10357a:	6a 00                	push   $0x0
  10357c:	ff 75 f0             	pushl  -0x10(%ebp)
  10357f:	e8 c0 03 00 00       	call   103944 <memset>
  103584:	83 c4 10             	add    $0x10,%esp
        cpu->eax = (uint32_t) get_current_task()->args;
    }
  103587:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  10358e:	eb 23                	jmp    1035b3 <allocate_unused_nodes+0x57>
        break;
  103590:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103593:	89 d0                	mov    %edx,%eax
  103595:	01 c0                	add    %eax,%eax
  103597:	01 d0                	add    %edx,%eax
  103599:	c1 e0 02             	shl    $0x2,%eax
  10359c:	03 45 f0             	add    -0x10(%ebp),%eax
  10359f:	83 ec 08             	sub    $0x8,%esp
  1035a2:	50                   	push   %eax
  1035a3:	68 34 85 12 00       	push   $0x128534
  1035a8:	e8 66 ff ff ff       	call   103513 <append_to_list>
  1035ad:	83 c4 10             	add    $0x10,%esp
        break;

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
  1035b0:	ff 45 f4             	incl   -0xc(%ebp)
  1035b3:	81 7d f4 54 01 00 00 	cmpl   $0x154,-0xc(%ebp)
  1035ba:	76 d4                	jbe    103590 <allocate_unused_nodes+0x34>
        break;

    case 5: /* yield */
  1035bc:	c9                   	leave  
  1035bd:	c3                   	ret    

001035be <pop_unused_node>:
    {
        cpu = schedule(cpu);
  1035be:	55                   	push   %ebp
  1035bf:	89 e5                	mov    %esp,%ebp
  1035c1:	83 ec 18             	sub    $0x18,%esp
    }
  1035c4:	68 34 85 12 00       	push   $0x128534
  1035c9:	e8 5d ff ff ff       	call   10352b <pop_from_list>
  1035ce:	83 c4 04             	add    $0x4,%esp
  1035d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;

  1035d4:	eb 18                	jmp    1035ee <pop_unused_node+0x30>
    case 6: /* getExecPath */
  1035d6:	e8 81 ff ff ff       	call   10355c <allocate_unused_nodes>
    {
  1035db:	83 ec 0c             	sub    $0xc,%esp
  1035de:	68 34 85 12 00       	push   $0x128534
  1035e3:	e8 43 ff ff ff       	call   10352b <pop_from_list>
  1035e8:	83 c4 10             	add    $0x10,%esp
  1035eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    case 5: /* yield */
    {
        cpu = schedule(cpu);
    }
        break;

  1035ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1035f2:	74 e2                	je     1035d6 <pop_unused_node+0x18>
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  1035f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
        break;
  1035f7:	c9                   	leave  
  1035f8:	c3                   	ret    

001035f9 <merge_into_frees>:

    case 7: /* changeExecPath */
  1035f9:	55                   	push   %ebp
  1035fa:	89 e5                	mov    %esp,%ebp
  1035fc:	83 ec 10             	sub    $0x10,%esp
    {
  1035ff:	ff 75 08             	pushl  0x8(%ebp)
  103602:	68 38 85 12 00       	push   $0x128538
  103607:	e8 b0 fe ff ff       	call   1034bc <remove_from_list>
  10360c:	83 c4 08             	add    $0x8,%esp
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

  10360f:	a1 3c 85 12 00       	mov    0x12853c,%eax
  103614:	89 45 fc             	mov    %eax,-0x4(%ebp)
        char* new = vfs_resolve_path(path);

  103617:	eb 79                	jmp    103692 <merge_into_frees+0x99>
        cpu->eax = 0;
  103619:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10361c:	8b 50 04             	mov    0x4(%eax),%edx
  10361f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103622:	8b 00                	mov    (%eax),%eax
  103624:	01 c2                	add    %eax,%edx
  103626:	8b 45 08             	mov    0x8(%ebp),%eax
  103629:	8b 40 04             	mov    0x4(%eax),%eax
  10362c:	39 c2                	cmp    %eax,%edx
  10362e:	75 1e                	jne    10364e <merge_into_frees+0x55>
        if(new) {
  103630:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103633:	8b 50 04             	mov    0x4(%eax),%edx
  103636:	8b 45 08             	mov    0x8(%ebp),%eax
  103639:	89 50 04             	mov    %edx,0x4(%eax)
            get_current_task()->execPath = new;
  10363c:	ff 75 fc             	pushl  -0x4(%ebp)
  10363f:	68 3c 85 12 00       	push   $0x12853c
  103644:	e8 73 fe ff ff       	call   1034bc <remove_from_list>
  103649:	83 c4 08             	add    $0x8,%esp
            cpu->eax = 1;
  10364c:	eb c1                	jmp    10360f <merge_into_frees+0x16>
        }

        free(path);
  10364e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103651:	8b 50 04             	mov    0x4(%eax),%edx
  103654:	8b 45 08             	mov    0x8(%ebp),%eax
  103657:	8b 48 04             	mov    0x4(%eax),%ecx
  10365a:	8b 45 08             	mov    0x8(%ebp),%eax
  10365d:	8b 00                	mov    (%eax),%eax
  10365f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103662:	39 c2                	cmp    %eax,%edx
  103664:	75 23                	jne    103689 <merge_into_frees+0x90>
    }
  103666:	8b 45 08             	mov    0x8(%ebp),%eax
  103669:	8b 10                	mov    (%eax),%edx
  10366b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10366e:	8b 00                	mov    (%eax),%eax
  103670:	01 c2                	add    %eax,%edx
  103672:	8b 45 08             	mov    0x8(%ebp),%eax
  103675:	89 10                	mov    %edx,(%eax)
        break;
  103677:	ff 75 fc             	pushl  -0x4(%ebp)
  10367a:	68 3c 85 12 00       	push   $0x12853c
  10367f:	e8 38 fe ff ff       	call   1034bc <remove_from_list>
  103684:	83 c4 08             	add    $0x8,%esp

  103687:	eb 86                	jmp    10360f <merge_into_frees+0x16>
	case 10: /* fopen */
	{
        vfs_reset_error();
  103689:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10368c:	8b 40 08             	mov    0x8(%eax),%eax
  10368f:	89 45 fc             	mov    %eax,-0x4(%ebp)
        char* path = strclone((char*) cpu->ebx);

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);

  103692:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  103696:	75 81                	jne    103619 <merge_into_frees+0x20>
	case 10: /* fopen */
	{
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
	    uint32_t fmode = (uint32_t) cpu->ecx;

  103698:	ff 75 08             	pushl  0x8(%ebp)
  10369b:	68 3c 85 12 00       	push   $0x12853c
  1036a0:	e8 6e fe ff ff       	call   103513 <append_to_list>
  1036a5:	83 c4 08             	add    $0x8,%esp
	    struct res_handle* handle = vfs_open(name, fmode);
  1036a8:	c9                   	leave  
  1036a9:	c3                   	ret    

001036aa <malloc>:
	    if(handle) {
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
	    }
	    else
  1036aa:	55                   	push   %ebp
  1036ab:	89 e5                	mov    %esp,%ebp
  1036ad:	83 ec 28             	sub    $0x28,%esp
  1036b0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1036b4:	75 0a                	jne    1036c0 <malloc+0x16>
  1036b6:	b8 00 00 00 00       	mov    $0x0,%eax
  1036bb:	e9 5e 01 00 00       	jmp    10381e <malloc+0x174>
	    {
	        cpu->eax = 0;
  1036c0:	a1 40 85 12 00       	mov    0x128540,%eax
  1036c5:	03 45 08             	add    0x8(%ebp),%eax
  1036c8:	a3 40 85 12 00       	mov    %eax,0x128540
	    }

  1036cd:	a1 3c 85 12 00       	mov    0x12853c,%eax
  1036d2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    free(name);
	}
  1036d5:	eb 13                	jmp    1036ea <malloc+0x40>
	    break;
  1036d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1036da:	8b 00                	mov    (%eax),%eax
  1036dc:	3b 45 08             	cmp    0x8(%ebp),%eax
  1036df:	73 11                	jae    1036f2 <malloc+0x48>

	case 11: /* fclose */
	{
  1036e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1036e4:	8b 40 08             	mov    0x8(%eax),%eax
  1036e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    {
	        cpu->eax = 0;
	    }

	    free(name);
	}
  1036ea:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1036ee:	75 e7                	jne    1036d7 <malloc+0x2d>
  1036f0:	eb 01                	jmp    1036f3 <malloc+0x49>
	    break;

  1036f2:	90                   	nop    
	case 11: /* fclose */
	{
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
  1036f3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  1036f7:	0f 85 a6 00 00 00    	jne    1037a3 <malloc+0xf9>
	        vfs_close(handle);
  1036fd:	8b 45 08             	mov    0x8(%ebp),%eax
  103700:	c1 e8 0c             	shr    $0xc,%eax
  103703:	89 45 e0             	mov    %eax,-0x20(%ebp)

	        cpu->eax = 0;
  103706:	8b 45 08             	mov    0x8(%ebp),%eax
  103709:	25 ff 0f 00 00       	and    $0xfff,%eax
  10370e:	85 c0                	test   %eax,%eax
  103710:	74 03                	je     103715 <malloc+0x6b>
	    }
  103712:	ff 45 e0             	incl   -0x20(%ebp)
	    else
	    {
  103715:	83 ec 0c             	sub    $0xc,%esp
  103718:	ff 75 e0             	pushl  -0x20(%ebp)
  10371b:	e8 71 1b 00 00       	call   105291 <vmm_alloc_cont>
  103720:	83 c4 10             	add    $0x10,%esp
  103723:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	        cpu->eax = (uint32_t) -1;
	    }
  103726:	e8 93 fe ff ff       	call   1035be <pop_unused_node>
  10372b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
	    break;
  10372e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  103731:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103734:	89 50 04             	mov    %edx,0x4(%eax)

  103737:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10373a:	8b 55 08             	mov    0x8(%ebp),%edx
  10373d:	89 10                	mov    %edx,(%eax)
	case 12: /* fwrite */
	{
  10373f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103742:	c1 e0 0c             	shl    $0xc,%eax
  103745:	3b 45 08             	cmp    0x8(%ebp),%eax
  103748:	76 3e                	jbe    103788 <malloc+0xde>
        vfs_reset_error();
  10374a:	e8 6f fe ff ff       	call   1035be <pop_unused_node>
  10374f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
  103752:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103755:	8b 50 04             	mov    0x4(%eax),%edx
  103758:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10375b:	8b 00                	mov    (%eax),%eax
  10375d:	01 c2                	add    %eax,%edx
  10375f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103762:	89 50 04             	mov    %edx,0x4(%eax)
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  103765:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103768:	c1 e0 0c             	shl    $0xc,%eax
  10376b:	89 c2                	mov    %eax,%edx
  10376d:	2b 55 08             	sub    0x8(%ebp),%edx
  103770:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103773:	89 10                	mov    %edx,(%eax)
	    }
	    else
  103775:	83 ec 08             	sub    $0x8,%esp
  103778:	ff 75 ec             	pushl  -0x14(%ebp)
  10377b:	68 3c 85 12 00       	push   $0x12853c
  103780:	e8 8e fd ff ff       	call   103513 <append_to_list>
  103785:	83 c4 10             	add    $0x10,%esp
	    {
            cpu->eax = RW_ERR_VFS;
	    }
  103788:	83 ec 08             	sub    $0x8,%esp
  10378b:	ff 75 e8             	pushl  -0x18(%ebp)
  10378e:	68 38 85 12 00       	push   $0x128538
  103793:	e8 7b fd ff ff       	call   103513 <append_to_list>
  103798:	83 c4 10             	add    $0x10,%esp
	}
	    break;
  10379b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10379e:	8b 40 04             	mov    0x4(%eax),%eax
  1037a1:	eb 7b                	jmp    10381e <malloc+0x174>

	case 13: /* fread */
  1037a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037a6:	8b 00                	mov    (%eax),%eax
  1037a8:	2b 45 08             	sub    0x8(%ebp),%eax
  1037ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
        vfs_reset_error();
  1037ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037b1:	8b 55 08             	mov    0x8(%ebp),%edx
  1037b4:	89 10                	mov    %edx,(%eax)
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
  1037b6:	83 ec 08             	sub    $0x8,%esp
  1037b9:	ff 75 dc             	pushl  -0x24(%ebp)
  1037bc:	68 3c 85 12 00       	push   $0x12853c
  1037c1:	e8 f6 fc ff ff       	call   1034bc <remove_from_list>
  1037c6:	83 c4 10             	add    $0x10,%esp
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  1037c9:	83 ec 08             	sub    $0x8,%esp
  1037cc:	ff 75 dc             	pushl  -0x24(%ebp)
  1037cf:	68 38 85 12 00       	push   $0x128538
  1037d4:	e8 3a fd ff ff       	call   103513 <append_to_list>
  1037d9:	83 c4 10             	add    $0x10,%esp
        }
        else
  1037dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1037e0:	74 36                	je     103818 <malloc+0x16e>
        {
  1037e2:	e8 d7 fd ff ff       	call   1035be <pop_unused_node>
  1037e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = RW_ERR_VFS;
        }
  1037ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037ed:	8b 50 04             	mov    0x4(%eax),%edx
  1037f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1037f3:	8b 00                	mov    (%eax),%eax
  1037f5:	01 c2                	add    %eax,%edx
  1037f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037fa:	89 50 04             	mov    %edx,0x4(%eax)
	}
  1037fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103800:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103803:	89 10                	mov    %edx,(%eax)
	    break;

  103805:	83 ec 08             	sub    $0x8,%esp
  103808:	ff 75 f4             	pushl  -0xc(%ebp)
  10380b:	68 3c 85 12 00       	push   $0x12853c
  103810:	e8 fe fc ff ff       	call   103513 <append_to_list>
  103815:	83 c4 10             	add    $0x10,%esp
	case 14: /* fmkfifo */
	{
        vfs_reset_error();
  103818:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10381b:	8b 40 04             	mov    0x4(%eax),%eax
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  10381e:	c9                   	leave  
  10381f:	c3                   	ret    

00103820 <calloc>:

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
  103820:	55                   	push   %ebp
  103821:	89 e5                	mov    %esp,%ebp
  103823:	83 ec 18             	sub    $0x18,%esp
  103826:	8b 45 08             	mov    0x8(%ebp),%eax
  103829:	0f af 45 0c          	imul   0xc(%ebp),%eax
  10382d:	89 45 f0             	mov    %eax,-0x10(%ebp)
            register_handle(handle);
  103830:	83 ec 0c             	sub    $0xc,%esp
  103833:	ff 75 f0             	pushl  -0x10(%ebp)
  103836:	e8 6f fe ff ff       	call   1036aa <malloc>
  10383b:	83 c4 10             	add    $0x10,%esp
  10383e:	89 45 f4             	mov    %eax,-0xc(%ebp)
            cpu->eax = (uint32_t) handle;
        }
  103841:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103845:	74 13                	je     10385a <calloc+0x3a>
        else
  103847:	83 ec 04             	sub    $0x4,%esp
  10384a:	ff 75 f0             	pushl  -0x10(%ebp)
  10384d:	6a 00                	push   $0x0
  10384f:	ff 75 f4             	pushl  -0xc(%ebp)
  103852:	e8 ed 00 00 00       	call   103944 <memset>
  103857:	83 c4 10             	add    $0x10,%esp
        {
            cpu->eax = 0;
        }
  10385a:	8b 45 f4             	mov    -0xc(%ebp),%eax

  10385d:	c9                   	leave  
  10385e:	c3                   	ret    

0010385f <realloc>:
        free(name);
	}
	    break;
  10385f:	55                   	push   %ebp
  103860:	89 e5                	mov    %esp,%ebp
  103862:	83 ec 18             	sub    $0x18,%esp
  103865:	a1 38 85 12 00       	mov    0x128538,%eax
  10386a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	case 15: /* getLastVFSErr */
  10386d:	eb 74                	jmp    1038e3 <realloc+0x84>
	{
  10386f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103872:	8b 50 04             	mov    0x4(%eax),%edx
  103875:	8b 45 08             	mov    0x8(%ebp),%eax
  103878:	39 c2                	cmp    %eax,%edx
  10387a:	75 5e                	jne    1038da <realloc+0x7b>
	    cpu->eax = get_current_task()->vfserr;
  10387c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103880:	75 15                	jne    103897 <realloc+0x38>
        vfs_reset_error();
  103882:	83 ec 0c             	sub    $0xc,%esp
  103885:	ff 75 08             	pushl  0x8(%ebp)
  103888:	e8 63 00 00 00       	call   1038f0 <free>
  10388d:	83 c4 10             	add    $0x10,%esp
	}
  103890:	b8 00 00 00 00       	mov    $0x0,%eax
  103895:	eb 57                	jmp    1038ee <realloc+0x8f>
	    break;

  103897:	83 ec 0c             	sub    $0xc,%esp
  10389a:	ff 75 0c             	pushl  0xc(%ebp)
  10389d:	e8 08 fe ff ff       	call   1036aa <malloc>
  1038a2:	83 c4 10             	add    $0x10,%esp
  1038a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	case 16: /* favailable */
  1038a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038ab:	8b 10                	mov    (%eax),%edx
  1038ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038b0:	8b 40 04             	mov    0x4(%eax),%eax
  1038b3:	83 ec 04             	sub    $0x4,%esp
  1038b6:	52                   	push   %edx
  1038b7:	50                   	push   %eax
  1038b8:	ff 75 f4             	pushl  -0xc(%ebp)
  1038bb:	e8 b2 00 00 00       	call   103972 <memcpy>
  1038c0:	83 c4 10             	add    $0x10,%esp
	{
  1038c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038c6:	8b 40 04             	mov    0x4(%eax),%eax
  1038c9:	83 ec 0c             	sub    $0xc,%esp
  1038cc:	50                   	push   %eax
  1038cd:	e8 1e 00 00 00       	call   1038f0 <free>
  1038d2:	83 c4 10             	add    $0x10,%esp
	    cpu->eax = vfs_available((void*)cpu->ebx);
	}
  1038d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1038d8:	eb 14                	jmp    1038ee <realloc+0x8f>
	    break;

	case 17: /* getPathChild */
  1038da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038dd:	8b 40 08             	mov    0x8(%eax),%eax
  1038e0:	89 45 f0             	mov    %eax,-0x10(%ebp)

        free(name);
	}
	    break;

	case 15: /* getLastVFSErr */
  1038e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1038e7:	75 86                	jne    10386f <realloc+0x10>
	}
	    break;

	case 17: /* getPathChild */
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);
  1038e9:	b8 00 00 00 00       	mov    $0x0,%eax

  1038ee:	c9                   	leave  
  1038ef:	c3                   	ret    

001038f0 <free>:
		if(path != 0 && cpu->ecx != 0) {
			strcpy((char*)cpu->ecx, path);
			free(path);
  1038f0:	55                   	push   %ebp
  1038f1:	89 e5                	mov    %esp,%ebp
  1038f3:	83 ec 10             	sub    $0x10,%esp
  1038f6:	a1 38 85 12 00       	mov    0x128538,%eax
  1038fb:	89 45 fc             	mov    %eax,-0x4(%ebp)

			cpu->eax = cpu->ecx;
  1038fe:	eb 39                	jmp    103939 <free+0x49>
		}
  103900:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103903:	8b 50 04             	mov    0x4(%eax),%edx
  103906:	8b 45 08             	mov    0x8(%ebp),%eax
  103909:	39 c2                	cmp    %eax,%edx
  10390b:	75 23                	jne    103930 <free+0x40>
		else
  10390d:	8b 15 40 85 12 00    	mov    0x128540,%edx
  103913:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103916:	8b 00                	mov    (%eax),%eax
  103918:	89 d1                	mov    %edx,%ecx
  10391a:	29 c1                	sub    %eax,%ecx
  10391c:	89 c8                	mov    %ecx,%eax
  10391e:	a3 40 85 12 00       	mov    %eax,0x128540
		{
			cpu->eax = 0;
  103923:	ff 75 fc             	pushl  -0x4(%ebp)
  103926:	e8 ce fc ff ff       	call   1035f9 <merge_into_frees>
  10392b:	83 c4 04             	add    $0x4,%esp
		}
  10392e:	eb 0f                	jmp    10393f <free+0x4f>
	}
		break;
  103930:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103933:	8b 40 08             	mov    0x8(%eax),%eax
  103936:	89 45 fc             	mov    %eax,-0x4(%ebp)

		if(path != 0 && cpu->ecx != 0) {
			strcpy((char*)cpu->ecx, path);
			free(path);

			cpu->eax = cpu->ecx;
  103939:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
  10393d:	75 c1                	jne    103900 <free+0x10>
			cpu->eax = 0;
		}
	}
		break;

	case 20: /* getpmhandle */
  10393f:	c9                   	leave  
  103940:	c3                   	ret    
  103941:	00 00                	add    %al,(%eax)
	...

00103944 <memset>:
#include "kernel.h"
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
  103944:	55                   	push   %ebp
  103945:	89 e5                	mov    %esp,%ebp
  103947:	83 ec 10             	sub    $0x10,%esp
  10394a:	8b 45 08             	mov    0x8(%ebp),%eax
  10394d:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include "ramfs/vgacntrl.h"

  103950:	eb 0d                	jmp    10395f <memset+0x1b>
struct exec_info {
  103952:	8b 45 0c             	mov    0xc(%ebp),%eax
  103955:	88 c2                	mov    %al,%dl
  103957:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10395a:	88 10                	mov    %dl,(%eax)
  10395c:	ff 45 fc             	incl   -0x4(%ebp)
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

  10395f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103963:	0f 95 c0             	setne  %al
  103966:	ff 4d 10             	decl   0x10(%ebp)
  103969:	84 c0                	test   %al,%al
  10396b:	75 e5                	jne    103952 <memset+0xe>
struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
  10396d:	8b 45 08             	mov    0x8(%ebp),%eax
    char* stderr;
  103970:	c9                   	leave  
  103971:	c3                   	ret    

00103972 <memcpy>:
};

struct cpu_state* syscall(struct cpu_state* cpu) {
  103972:	55                   	push   %ebp
  103973:	89 e5                	mov    %esp,%ebp
  103975:	83 ec 10             	sub    $0x10,%esp
  103978:	8b 45 08             	mov    0x8(%ebp),%eax
  10397b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    cpu = save_cpu_state(cpu);
  10397e:	8b 45 0c             	mov    0xc(%ebp),%eax
  103981:	89 45 fc             	mov    %eax,-0x4(%ebp)

	switch (cpu->eax) {
  103984:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  103988:	75 19                	jne    1039a3 <memcpy+0x31>
  10398a:	b8 00 00 00 00       	mov    $0x0,%eax
  10398f:	eb 24                	jmp    1039b5 <memcpy+0x43>
	case 1: /* exit */
		return terminate_current(cpu);

  103991:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103994:	8a 10                	mov    (%eax),%dl
  103996:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103999:	88 10                	mov    %dl,(%eax)
  10399b:	ff 45 f8             	incl   -0x8(%ebp)
  10399e:	ff 45 fc             	incl   -0x4(%ebp)
  1039a1:	eb 01                	jmp    1039a4 <memcpy+0x32>
struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);

	switch (cpu->eax) {
	case 1: /* exit */
		return terminate_current(cpu);
  1039a3:	90                   	nop    
  1039a4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1039a8:	0f 95 c0             	setne  %al
  1039ab:	ff 4d 10             	decl   0x10(%ebp)
  1039ae:	84 c0                	test   %al,%al
  1039b0:	75 df                	jne    103991 <memcpy+0x1f>

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  1039b2:	8b 45 08             	mov    0x8(%ebp),%eax
	}
  1039b5:	c9                   	leave  
  1039b6:	c3                   	ret    

001039b7 <memcmp>:
	    break;

    case 3: /* exec */
  1039b7:	55                   	push   %ebp
  1039b8:	89 e5                	mov    %esp,%ebp
  1039ba:	83 ec 10             	sub    $0x10,%esp
  1039bd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1039c1:	75 0a                	jne    1039cd <memcmp+0x16>
    {
  1039c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1039c8:	e9 83 00 00 00       	jmp    103a50 <memcmp+0x99>
        char* path = strclone((char*) cpu->ebx);
  1039cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1039d1:	75 07                	jne    1039da <memcmp+0x23>

  1039d3:	b8 01 00 00 00       	mov    $0x1,%eax
  1039d8:	eb 76                	jmp    103a50 <memcmp+0x99>
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);
  1039da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1039de:	75 07                	jne    1039e7 <memcmp+0x30>

  1039e0:	b8 00 00 00 00       	mov    $0x0,%eax
  1039e5:	eb 69                	jmp    103a50 <memcmp+0x99>
        free(path);

  1039e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1039ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(cpu->edx) {
  1039ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  1039f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
			cpu = schedule(cpu);
		}
  1039f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1039fa:	eb 47                	jmp    103a43 <memcmp+0x8c>
    }
  1039fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103a02:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103a05:	8a 10                	mov    (%eax),%dl
  103a07:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a0a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103a0d:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103a10:	8a 00                	mov    (%eax),%al
  103a12:	38 c2                	cmp    %al,%dl
  103a14:	74 2a                	je     103a40 <memcmp+0x89>
        break;
  103a16:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a19:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103a1c:	8d 04 02             	lea    (%edx,%eax,1),%eax
  103a1f:	8a 00                	mov    (%eax),%al
  103a21:	ba 00 00 00 00       	mov    $0x0,%edx
  103a26:	88 c2                	mov    %al,%dl
  103a28:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a2b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103a2e:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  103a31:	8a 00                	mov    (%eax),%al
  103a33:	25 ff 00 00 00       	and    $0xff,%eax
  103a38:	89 d1                	mov    %edx,%ecx
  103a3a:	29 c1                	sub    %eax,%ecx
  103a3c:	89 c8                	mov    %ecx,%eax
  103a3e:	eb 10                	jmp    103a50 <memcmp+0x99>

        free(path);

		if(cpu->edx) {
			cpu = schedule(cpu);
		}
  103a40:	ff 45 fc             	incl   -0x4(%ebp)
  103a43:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a46:	3b 45 10             	cmp    0x10(%ebp),%eax
  103a49:	72 b1                	jb     1039fc <memcmp+0x45>
    }
        break;

    case 4: /* getargs */
    {
  103a4b:	b8 00 00 00 00       	mov    $0x0,%eax
        cpu->eax = (uint32_t) get_current_task()->args;
  103a50:	c9                   	leave  
  103a51:	c3                   	ret    

00103a52 <strcmp>:
    }
        break;

  103a52:	55                   	push   %ebp
  103a53:	89 e5                	mov    %esp,%ebp
  103a55:	83 ec 18             	sub    $0x18,%esp
  103a58:	83 ec 0c             	sub    $0xc,%esp
  103a5b:	ff 75 08             	pushl  0x8(%ebp)
  103a5e:	e8 3e 00 00 00       	call   103aa1 <strlen>
  103a63:	83 c4 10             	add    $0x10,%esp
  103a66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    case 5: /* yield */
  103a69:	83 ec 0c             	sub    $0xc,%esp
  103a6c:	ff 75 0c             	pushl  0xc(%ebp)
  103a6f:	e8 2d 00 00 00       	call   103aa1 <strlen>
  103a74:	83 c4 10             	add    $0x10,%esp
  103a77:	89 45 f4             	mov    %eax,-0xc(%ebp)
    {
  103a7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a80:	39 d0                	cmp    %edx,%eax
  103a82:	7e 02                	jle    103a86 <strcmp+0x34>
  103a84:	89 d0                	mov    %edx,%eax
  103a86:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cpu = schedule(cpu);
    }
  103a89:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a8c:	40                   	inc    %eax
  103a8d:	83 ec 04             	sub    $0x4,%esp
  103a90:	50                   	push   %eax
  103a91:	ff 75 0c             	pushl  0xc(%ebp)
  103a94:	ff 75 08             	pushl  0x8(%ebp)
  103a97:	e8 1b ff ff ff       	call   1039b7 <memcmp>
  103a9c:	83 c4 10             	add    $0x10,%esp
        break;
  103a9f:	c9                   	leave  
  103aa0:	c3                   	ret    

00103aa1 <strlen>:

    case 6: /* getExecPath */
    {
  103aa1:	55                   	push   %ebp
  103aa2:	89 e5                	mov    %esp,%ebp
  103aa4:	83 ec 10             	sub    $0x10,%esp
  103aa7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103aab:	75 07                	jne    103ab4 <strlen+0x13>
        char* dest = (char*)cpu->ebx;
  103aad:	b8 00 00 00 00       	mov    $0x0,%eax
  103ab2:	eb 1b                	jmp    103acf <strlen+0x2e>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
  103ab4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103abb:	eb 03                	jmp    103ac0 <strlen+0x1f>
  103abd:	ff 45 fc             	incl   -0x4(%ebp)
  103ac0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103ac3:	03 45 08             	add    0x8(%ebp),%eax
  103ac6:	8a 00                	mov    (%eax),%al
  103ac8:	84 c0                	test   %al,%al
  103aca:	75 f1                	jne    103abd <strlen+0x1c>
        break;

  103acc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    case 7: /* changeExecPath */
  103acf:	c9                   	leave  
  103ad0:	c3                   	ret    

00103ad1 <strcpy>:
    {
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);
  103ad1:	55                   	push   %ebp
  103ad2:	89 e5                	mov    %esp,%ebp
  103ad4:	ff 75 0c             	pushl  0xc(%ebp)
  103ad7:	e8 c5 ff ff ff       	call   103aa1 <strlen>
  103adc:	83 c4 04             	add    $0x4,%esp
  103adf:	40                   	inc    %eax
  103ae0:	50                   	push   %eax
  103ae1:	ff 75 0c             	pushl  0xc(%ebp)
  103ae4:	ff 75 08             	pushl  0x8(%ebp)
  103ae7:	e8 86 fe ff ff       	call   103972 <memcpy>
  103aec:	83 c4 0c             	add    $0xc,%esp

  103aef:	8b 45 08             	mov    0x8(%ebp),%eax
        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  103af2:	c9                   	leave  
  103af3:	c3                   	ret    

00103af4 <strclone>:

        char* new = vfs_resolve_path(path);
  103af4:	55                   	push   %ebp
  103af5:	89 e5                	mov    %esp,%ebp
  103af7:	83 ec 18             	sub    $0x18,%esp

  103afa:	ff 75 08             	pushl  0x8(%ebp)
  103afd:	e8 9f ff ff ff       	call   103aa1 <strlen>
  103b02:	83 c4 04             	add    $0x4,%esp
  103b05:	40                   	inc    %eax
  103b06:	83 ec 0c             	sub    $0xc,%esp
  103b09:	50                   	push   %eax
  103b0a:	e8 9b fb ff ff       	call   1036aa <malloc>
  103b0f:	83 c4 10             	add    $0x10,%esp
  103b12:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cpu->eax = 0;
  103b15:	83 ec 08             	sub    $0x8,%esp
  103b18:	ff 75 08             	pushl  0x8(%ebp)
  103b1b:	ff 75 f4             	pushl  -0xc(%ebp)
  103b1e:	e8 ae ff ff ff       	call   103ad1 <strcpy>
  103b23:	83 c4 10             	add    $0x10,%esp
        if(new) {
            get_current_task()->execPath = new;
  103b26:	8b 45 f4             	mov    -0xc(%ebp),%eax
            cpu->eax = 1;
  103b29:	c9                   	leave  
  103b2a:	c3                   	ret    

00103b2b <strtok>:
        }

        free(path);
    }
        break;
  103b2b:	55                   	push   %ebp
  103b2c:	89 e5                	mov    %esp,%ebp
  103b2e:	83 ec 08             	sub    $0x8,%esp

  103b31:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103b35:	74 43                	je     103b7a <strtok+0x4f>
	case 10: /* fopen */
  103b37:	a1 48 85 12 00       	mov    0x128548,%eax
  103b3c:	85 c0                	test   %eax,%eax
  103b3e:	74 11                	je     103b51 <strtok+0x26>
	{
  103b40:	a1 48 85 12 00       	mov    0x128548,%eax
  103b45:	83 ec 0c             	sub    $0xc,%esp
  103b48:	50                   	push   %eax
  103b49:	e8 a2 fd ff ff       	call   1038f0 <free>
  103b4e:	83 c4 10             	add    $0x10,%esp
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  103b51:	83 ec 0c             	sub    $0xc,%esp
  103b54:	ff 75 08             	pushl  0x8(%ebp)
  103b57:	e8 98 ff ff ff       	call   103af4 <strclone>
  103b5c:	83 c4 10             	add    $0x10,%esp
  103b5f:	a3 48 85 12 00       	mov    %eax,0x128548
	    uint32_t fmode = (uint32_t) cpu->ecx;
  103b64:	a1 48 85 12 00       	mov    0x128548,%eax
  103b69:	83 ec 08             	sub    $0x8,%esp
  103b6c:	ff 75 0c             	pushl  0xc(%ebp)
  103b6f:	50                   	push   %eax
  103b70:	e8 17 00 00 00       	call   103b8c <strtoknc>
  103b75:	83 c4 10             	add    $0x10,%esp
  103b78:	eb 10                	jmp    103b8a <strtok+0x5f>

	    struct res_handle* handle = vfs_open(name, fmode);
  103b7a:	83 ec 08             	sub    $0x8,%esp
  103b7d:	ff 75 0c             	pushl  0xc(%ebp)
  103b80:	6a 00                	push   $0x0
  103b82:	e8 05 00 00 00       	call   103b8c <strtoknc>
  103b87:	83 c4 10             	add    $0x10,%esp
	    if(handle) {
  103b8a:	c9                   	leave  
  103b8b:	c3                   	ret    

00103b8c <strtoknc>:
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
  103b8c:	55                   	push   %ebp
  103b8d:	89 e5                	mov    %esp,%ebp
  103b8f:	83 ec 10             	sub    $0x10,%esp
	    }
  103b92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    else
  103b99:	ff 75 0c             	pushl  0xc(%ebp)
  103b9c:	e8 00 ff ff ff       	call   103aa1 <strlen>
  103ba1:	83 c4 04             	add    $0x4,%esp
  103ba4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	    {
	        cpu->eax = 0;
	    }
  103ba7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  103bab:	75 0a                	jne    103bb7 <strtoknc+0x2b>

  103bad:	b8 00 00 00 00       	mov    $0x0,%eax
  103bb2:	e9 e0 00 00 00       	jmp    103c97 <strtoknc+0x10b>
	    free(name);
	}
	    break;
  103bb7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103bbb:	75 13                	jne    103bd0 <strtoknc+0x44>
  103bbd:	a1 44 85 12 00       	mov    0x128544,%eax
  103bc2:	85 c0                	test   %eax,%eax
  103bc4:	75 0a                	jne    103bd0 <strtoknc+0x44>

  103bc6:	b8 00 00 00 00       	mov    $0x0,%eax
  103bcb:	e9 c7 00 00 00       	jmp    103c97 <strtoknc+0x10b>
	case 11: /* fclose */
	{
        vfs_reset_error();
  103bd0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103bd4:	74 08                	je     103bde <strtoknc+0x52>
	    struct res_handle* handle = (void*) cpu->ebx;
  103bd6:	8b 45 08             	mov    0x8(%ebp),%eax
  103bd9:	a3 44 85 12 00       	mov    %eax,0x128544
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

	        cpu->eax = 0;
  103bde:	a1 44 85 12 00       	mov    0x128544,%eax
  103be3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103be6:	eb 01                	jmp    103be9 <strtoknc+0x5d>

	case 12: /* fwrite */
	{
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
  103be8:	90                   	nop    
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

	        cpu->eax = 0;
	    }
	    else
  103be9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103bf0:	eb 19                	jmp    103c0b <strtoknc+0x7f>
	    {
  103bf2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103bf5:	8a 10                	mov    (%eax),%dl
  103bf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bfa:	03 45 0c             	add    0xc(%ebp),%eax
  103bfd:	8a 00                	mov    (%eax),%al
  103bff:	38 c2                	cmp    %al,%dl
  103c01:	75 05                	jne    103c08 <strtoknc+0x7c>
	        cpu->eax = (uint32_t) -1;
  103c03:	ff 45 fc             	incl   -0x4(%ebp)
	    }
  103c06:	eb 0b                	jmp    103c13 <strtoknc+0x87>
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

	        cpu->eax = 0;
	    }
	    else
  103c08:	ff 45 f4             	incl   -0xc(%ebp)
  103c0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c0e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c11:	7c df                	jl     103bf2 <strtoknc+0x66>
	        cpu->eax = (uint32_t) -1;
	    }
	}
	    break;

	case 12: /* fwrite */
  103c13:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c16:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c19:	75 cd                	jne    103be8 <strtoknc+0x5c>
	{
  103c1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c1e:	a3 44 85 12 00       	mov    %eax,0x128544
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
	    else
  103c23:	a1 44 85 12 00       	mov    0x128544,%eax
  103c28:	8a 00                	mov    (%eax),%al
  103c2a:	84 c0                	test   %al,%al
  103c2c:	75 57                	jne    103c85 <strtoknc+0xf9>
	    {
  103c2e:	c7 05 44 85 12 00 00 	movl   $0x0,0x128544
  103c35:	00 00 00 
            cpu->eax = RW_ERR_VFS;
  103c38:	a1 44 85 12 00       	mov    0x128544,%eax
  103c3d:	eb 58                	jmp    103c97 <strtoknc+0x10b>
	    }
	}
	    break;

	case 13: /* fread */
  103c3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103c46:	eb 20                	jmp    103c68 <strtoknc+0xdc>
	{
  103c48:	a1 44 85 12 00       	mov    0x128544,%eax
  103c4d:	8a 10                	mov    (%eax),%dl
  103c4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c52:	03 45 0c             	add    0xc(%ebp),%eax
  103c55:	8a 00                	mov    (%eax),%al
  103c57:	38 c2                	cmp    %al,%dl
  103c59:	75 0a                	jne    103c65 <strtoknc+0xd9>
        vfs_reset_error();
  103c5b:	a1 44 85 12 00       	mov    0x128544,%eax
  103c60:	c6 00 00             	movb   $0x0,(%eax)
        struct res_handle* handle = (void*) cpu->ebx;
  103c63:	eb 0b                	jmp    103c70 <strtoknc+0xe4>
            cpu->eax = RW_ERR_VFS;
	    }
	}
	    break;

	case 13: /* fread */
  103c65:	ff 45 f4             	incl   -0xc(%ebp)
  103c68:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c6b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c6e:	7c d8                	jl     103c48 <strtoknc+0xbc>
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
  103c70:	a1 44 85 12 00       	mov    0x128544,%eax
  103c75:	40                   	inc    %eax
  103c76:	a3 44 85 12 00       	mov    %eax,0x128544
        {
  103c7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c7e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103c81:	7c 10                	jl     103c93 <strtoknc+0x107>
  103c83:	eb 01                	jmp    103c86 <strtoknc+0xfa>
	    {
            cpu->eax = RW_ERR_VFS;
	    }
	}
	    break;

  103c85:	90                   	nop    
  103c86:	a1 44 85 12 00       	mov    0x128544,%eax
  103c8b:	8a 00                	mov    (%eax),%al
  103c8d:	84 c0                	test   %al,%al
  103c8f:	75 ae                	jne    103c3f <strtoknc+0xb3>
  103c91:	eb 01                	jmp    103c94 <strtoknc+0x108>
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
        {
            cpu->eax = RW_ERR_VFS;
  103c93:	90                   	nop    
        }
	}
	    break;
  103c94:	8b 45 fc             	mov    -0x4(%ebp),%eax

  103c97:	c9                   	leave  
  103c98:	c3                   	ret    
  103c99:	00 00                	add    %al,(%eax)
	...

00103c9c <vfs_set_error>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct exec_info {
  103c9c:	55                   	push   %ebp
  103c9d:	89 e5                	mov    %esp,%ebp
  103c9f:	83 ec 08             	sub    $0x8,%esp
    char* execPath;
  103ca2:	e8 8e ee ff ff       	call   102b35 <get_current_task>
  103ca7:	85 c0                	test   %eax,%eax
  103ca9:	74 17                	je     103cc2 <vfs_set_error+0x26>
    char* stdin;
  103cab:	e8 85 ee ff ff       	call   102b35 <get_current_task>
  103cb0:	8b 40 2c             	mov    0x2c(%eax),%eax
  103cb3:	85 c0                	test   %eax,%eax
  103cb5:	75 0b                	jne    103cc2 <vfs_set_error+0x26>
    char* stdout;
  103cb7:	e8 79 ee ff ff       	call   102b35 <get_current_task>
  103cbc:	8b 55 08             	mov    0x8(%ebp),%edx
  103cbf:	89 50 2c             	mov    %edx,0x2c(%eax)
    char* stderr;
};

  103cc2:	c9                   	leave  
  103cc3:	c3                   	ret    

00103cc4 <vfs_reset_error>:
struct cpu_state* syscall(struct cpu_state* cpu) {
    cpu = save_cpu_state(cpu);
  103cc4:	55                   	push   %ebp
  103cc5:	89 e5                	mov    %esp,%ebp
  103cc7:	83 ec 08             	sub    $0x8,%esp

  103cca:	e8 66 ee ff ff       	call   102b35 <get_current_task>
  103ccf:	85 c0                	test   %eax,%eax
  103cd1:	74 0c                	je     103cdf <vfs_reset_error+0x1b>
	switch (cpu->eax) {
  103cd3:	e8 5d ee ff ff       	call   102b35 <get_current_task>
  103cd8:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	case 1: /* exit */
		return terminate_current(cpu);
  103cdf:	c9                   	leave  
  103ce0:	c3                   	ret    

00103ce1 <vfs_construct_absolute_path_for_node>:

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
  103ce1:	55                   	push   %ebp
  103ce2:	89 e5                	mov    %esp,%ebp
  103ce4:	83 ec 18             	sub    $0x18,%esp
	}
  103ce7:	c6 05 c0 87 1c 00 00 	movb   $0x0,0x1c87c0
	    break;
  103cee:	c7 45 f4 bf 87 1c 00 	movl   $0x1c87bf,-0xc(%ebp)

    case 3: /* exec */
  103cf5:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103cfa:	39 45 08             	cmp    %eax,0x8(%ebp)
  103cfd:	75 67                	jne    103d66 <vfs_construct_absolute_path_for_node+0x85>
    {
  103cff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d02:	c6 00 2f             	movb   $0x2f,(%eax)
        char* path = strclone((char*) cpu->ebx);

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);
  103d05:	eb 60                	jmp    103d67 <vfs_construct_absolute_path_for_node+0x86>

  103d07:	8b 45 08             	mov    0x8(%ebp),%eax
  103d0a:	83 ec 0c             	sub    $0xc,%esp
  103d0d:	50                   	push   %eax
  103d0e:	e8 8e fd ff ff       	call   103aa1 <strlen>
  103d13:	83 c4 10             	add    $0x10,%esp
  103d16:	f7 d8                	neg    %eax
  103d18:	01 45 f4             	add    %eax,-0xc(%ebp)
        free(path);
  103d1b:	8b 45 08             	mov    0x8(%ebp),%eax
  103d1e:	83 ec 08             	sub    $0x8,%esp
  103d21:	50                   	push   %eax
  103d22:	ff 75 f4             	pushl  -0xc(%ebp)
  103d25:	e8 a7 fd ff ff       	call   103ad1 <strcpy>
  103d2a:	83 c4 10             	add    $0x10,%esp

  103d2d:	8b 45 08             	mov    0x8(%ebp),%eax
  103d30:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103d36:	85 c0                	test   %eax,%eax
  103d38:	75 15                	jne    103d4f <vfs_construct_absolute_path_for_node+0x6e>
  103d3a:	8b 45 08             	mov    0x8(%ebp),%eax
  103d3d:	83 ec 0c             	sub    $0xc,%esp
  103d40:	50                   	push   %eax
  103d41:	e8 5b fd ff ff       	call   103aa1 <strlen>
  103d46:	83 c4 10             	add    $0x10,%esp
  103d49:	03 45 f4             	add    -0xc(%ebp),%eax
  103d4c:	c6 00 2f             	movb   $0x2f,(%eax)
		if(cpu->edx) {
  103d4f:	ff 4d f4             	decl   -0xc(%ebp)
  103d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d55:	c6 00 2f             	movb   $0x2f,(%eax)
			cpu = schedule(cpu);
		}
  103d58:	8b 45 08             	mov    0x8(%ebp),%eax
  103d5b:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  103d61:	89 45 08             	mov    %eax,0x8(%ebp)
  103d64:	eb 01                	jmp    103d67 <vfs_construct_absolute_path_for_node+0x86>

    case 3: /* exec */
    {
        char* path = strclone((char*) cpu->ebx);

		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);
  103d66:	90                   	nop    
  103d67:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103d6c:	39 45 08             	cmp    %eax,0x8(%ebp)
  103d6f:	75 96                	jne    103d07 <vfs_construct_absolute_path_for_node+0x26>
		if(cpu->edx) {
			cpu = schedule(cpu);
		}
    }
        break;

  103d71:	83 ec 0c             	sub    $0xc,%esp
  103d74:	ff 75 f4             	pushl  -0xc(%ebp)
  103d77:	e8 78 fd ff ff       	call   103af4 <strclone>
  103d7c:	83 c4 10             	add    $0x10,%esp
    case 4: /* getargs */
  103d7f:	c9                   	leave  
  103d80:	c3                   	ret    

00103d81 <vfs_find_node>:
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  103d81:	55                   	push   %ebp
  103d82:	89 e5                	mov    %esp,%ebp
  103d84:	83 ec 18             	sub    $0x18,%esp
    }
  103d87:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103d8b:	75 08                	jne    103d95 <vfs_find_node+0x14>
  103d8d:	8b 45 08             	mov    0x8(%ebp),%eax
  103d90:	e9 ab 00 00 00       	jmp    103e40 <vfs_find_node+0xbf>
        break;
  103d95:	8b 45 0c             	mov    0xc(%ebp),%eax
  103d98:	8a 00                	mov    (%eax),%al
  103d9a:	84 c0                	test   %al,%al
  103d9c:	75 08                	jne    103da6 <vfs_find_node+0x25>
  103d9e:	8b 45 08             	mov    0x8(%ebp),%eax
  103da1:	e9 9a 00 00 00       	jmp    103e40 <vfs_find_node+0xbf>

    case 5: /* yield */
  103da6:	83 ec 08             	sub    $0x8,%esp
  103da9:	68 90 78 10 00       	push   $0x107890
  103dae:	ff 75 0c             	pushl  0xc(%ebp)
  103db1:	e8 9c fc ff ff       	call   103a52 <strcmp>
  103db6:	83 c4 10             	add    $0x10,%esp
  103db9:	85 c0                	test   %eax,%eax
  103dbb:	75 05                	jne    103dc2 <vfs_find_node+0x41>
  103dbd:	8b 45 08             	mov    0x8(%ebp),%eax
  103dc0:	eb 7e                	jmp    103e40 <vfs_find_node+0xbf>
    {
  103dc2:	83 ec 08             	sub    $0x8,%esp
  103dc5:	68 92 78 10 00       	push   $0x107892
  103dca:	ff 75 0c             	pushl  0xc(%ebp)
  103dcd:	e8 80 fc ff ff       	call   103a52 <strcmp>
  103dd2:	83 c4 10             	add    $0x10,%esp
  103dd5:	85 c0                	test   %eax,%eax
  103dd7:	75 1a                	jne    103df3 <vfs_find_node+0x72>
        cpu = schedule(cpu);
  103dd9:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103dde:	39 45 08             	cmp    %eax,0x8(%ebp)
  103de1:	75 05                	jne    103de8 <vfs_find_node+0x67>
  103de3:	8b 45 08             	mov    0x8(%ebp),%eax
  103de6:	eb 58                	jmp    103e40 <vfs_find_node+0xbf>
    }
  103de8:	8b 45 08             	mov    0x8(%ebp),%eax
  103deb:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
  103df1:	eb 4d                	jmp    103e40 <vfs_find_node+0xbf>
        break;

    case 6: /* getExecPath */
  103df3:	8b 45 08             	mov    0x8(%ebp),%eax
  103df6:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103dfc:	85 c0                	test   %eax,%eax
  103dfe:	75 3b                	jne    103e3b <vfs_find_node+0xba>
    {
  103e00:	8b 45 08             	mov    0x8(%ebp),%eax
  103e03:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  103e0c:	eb 27                	jmp    103e35 <vfs_find_node+0xb4>
    }
  103e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e11:	83 ec 08             	sub    $0x8,%esp
  103e14:	50                   	push   %eax
  103e15:	ff 75 0c             	pushl  0xc(%ebp)
  103e18:	e8 35 fc ff ff       	call   103a52 <strcmp>
  103e1d:	83 c4 10             	add    $0x10,%esp
  103e20:	85 c0                	test   %eax,%eax
  103e22:	75 05                	jne    103e29 <vfs_find_node+0xa8>
        break;
  103e24:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e27:	eb 17                	jmp    103e40 <vfs_find_node+0xbf>

    case 7: /* changeExecPath */
    {
  103e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e2c:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  103e32:	89 45 f4             	mov    %eax,-0xc(%ebp)
        break;

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  103e35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103e39:	75 d3                	jne    103e0e <vfs_find_node+0x8d>
    case 7: /* changeExecPath */
    {
        vfs_reset_error();
        char* path = strclone((char*) cpu->ebx);

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  103e3b:	b8 00 00 00 00       	mov    $0x0,%eax

  103e40:	c9                   	leave  
  103e41:	c3                   	ret    

00103e42 <vfs_insert_node>:
        char* new = vfs_resolve_path(path);

  103e42:	55                   	push   %ebp
  103e43:	89 e5                	mov    %esp,%ebp
        cpu->eax = 0;
  103e45:	8b 45 08             	mov    0x8(%ebp),%eax
  103e48:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103e4e:	85 c0                	test   %eax,%eax
  103e50:	75 0d                	jne    103e5f <vfs_insert_node+0x1d>
        if(new) {
  103e52:	8b 45 08             	mov    0x8(%ebp),%eax
  103e55:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  103e5c:	00 00 00 
            get_current_task()->execPath = new;
            cpu->eax = 1;
        }
  103e5f:	8b 45 08             	mov    0x8(%ebp),%eax
  103e62:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  103e68:	85 c0                	test   %eax,%eax
  103e6a:	75 33                	jne    103e9f <vfs_insert_node+0x5d>

  103e6c:	8b 45 08             	mov    0x8(%ebp),%eax
  103e6f:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  103e75:	89 c2                	mov    %eax,%edx
  103e77:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e7a:	89 90 08 01 00 00    	mov    %edx,0x108(%eax)
        free(path);
  103e80:	8b 45 0c             	mov    0xc(%ebp),%eax
  103e83:	8b 55 08             	mov    0x8(%ebp),%edx
  103e86:	89 90 0c 01 00 00    	mov    %edx,0x10c(%eax)
    }
  103e8c:	8b 45 08             	mov    0x8(%ebp),%eax
  103e8f:	8b 55 0c             	mov    0xc(%ebp),%edx
  103e92:	89 90 04 01 00 00    	mov    %edx,0x104(%eax)
        break;

  103e98:	b8 00 00 00 00       	mov    $0x0,%eax
  103e9d:	eb 05                	jmp    103ea4 <vfs_insert_node+0x62>
	case 10: /* fopen */
	{
        vfs_reset_error();
  103e9f:	b8 01 00 00 00       	mov    $0x1,%eax
	    char* name = strclone((char*) cpu->ebx);
  103ea4:	5d                   	pop    %ebp
  103ea5:	c3                   	ret    

00103ea6 <vfs_get_relative_node>:
	    uint32_t fmode = (uint32_t) cpu->ecx;

	    struct res_handle* handle = vfs_open(name, fmode);
  103ea6:	55                   	push   %ebp
  103ea7:	89 e5                	mov    %esp,%ebp
  103ea9:	83 ec 18             	sub    $0x18,%esp
	    if(handle) {
	        register_handle(handle);
  103eac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	        cpu->eax = (uint32_t) handle;
	    }
  103eb3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  103eb7:	75 17                	jne    103ed0 <vfs_get_relative_node+0x2a>
	    else
  103eb9:	83 ec 0c             	sub    $0xc,%esp
  103ebc:	6a 05                	push   $0x5
  103ebe:	e8 d9 fd ff ff       	call   103c9c <vfs_set_error>
  103ec3:	83 c4 10             	add    $0x10,%esp
	    {
  103ec6:	b8 00 00 00 00       	mov    $0x0,%eax
  103ecb:	e9 af 00 00 00       	jmp    103f7f <vfs_get_relative_node+0xd9>
	        cpu->eax = 0;
	    }

  103ed0:	8b 45 0c             	mov    0xc(%ebp),%eax
  103ed3:	8a 00                	mov    (%eax),%al
  103ed5:	84 c0                	test   %al,%al
  103ed7:	75 17                	jne    103ef0 <vfs_get_relative_node+0x4a>
	    free(name);
  103ed9:	83 ec 0c             	sub    $0xc,%esp
  103edc:	6a 05                	push   $0x5
  103ede:	e8 b9 fd ff ff       	call   103c9c <vfs_set_error>
  103ee3:	83 c4 10             	add    $0x10,%esp
	}
  103ee6:	b8 00 00 00 00       	mov    $0x0,%eax
  103eeb:	e9 8f 00 00 00       	jmp    103f7f <vfs_get_relative_node+0xd9>
	    break;

	case 11: /* fclose */
  103ef0:	83 ec 08             	sub    $0x8,%esp
  103ef3:	68 95 78 10 00       	push   $0x107895
  103ef8:	ff 75 0c             	pushl  0xc(%ebp)
  103efb:	e8 2b fc ff ff       	call   103b2b <strtok>
  103f00:	83 c4 10             	add    $0x10,%esp
  103f03:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
        vfs_reset_error();
  103f06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103f0a:	75 05                	jne    103f11 <vfs_get_relative_node+0x6b>
	    struct res_handle* handle = (void*) cpu->ebx;
  103f0c:	8b 45 08             	mov    0x8(%ebp),%eax
  103f0f:	eb 6e                	jmp    103f7f <vfs_get_relative_node+0xd9>
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

  103f11:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103f14:	8a 00                	mov    (%eax),%al
  103f16:	84 c0                	test   %al,%al
  103f18:	75 15                	jne    103f2f <vfs_get_relative_node+0x89>
  103f1a:	83 ec 08             	sub    $0x8,%esp
  103f1d:	68 95 78 10 00       	push   $0x107895
  103f22:	6a 00                	push   $0x0
  103f24:	e8 02 fc ff ff       	call   103b2b <strtok>
  103f29:	83 c4 10             	add    $0x10,%esp
  103f2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	        cpu->eax = 0;
	    }
  103f2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103f33:	75 41                	jne    103f76 <vfs_get_relative_node+0xd0>
	    else
  103f35:	8b 45 08             	mov    0x8(%ebp),%eax
  103f38:	eb 45                	jmp    103f7f <vfs_get_relative_node+0xd9>
	    {
	        cpu->eax = (uint32_t) -1;
	    }
	}
	    break;
  103f3a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103f3e:	75 07                	jne    103f47 <vfs_get_relative_node+0xa1>
  103f40:	b8 00 00 00 00       	mov    $0x0,%eax
  103f45:	eb 38                	jmp    103f7f <vfs_get_relative_node+0xd9>

	case 12: /* fwrite */
  103f47:	83 ec 08             	sub    $0x8,%esp
  103f4a:	ff 75 f0             	pushl  -0x10(%ebp)
  103f4d:	ff 75 08             	pushl  0x8(%ebp)
  103f50:	e8 2c fe ff ff       	call   103d81 <vfs_find_node>
  103f55:	83 c4 10             	add    $0x10,%esp
  103f58:	89 45 f4             	mov    %eax,-0xc(%ebp)
	{
  103f5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f5e:	89 45 08             	mov    %eax,0x8(%ebp)
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
  103f61:	83 ec 08             	sub    $0x8,%esp
  103f64:	68 95 78 10 00       	push   $0x107895
  103f69:	6a 00                	push   $0x0
  103f6b:	e8 bb fb ff ff       	call   103b2b <strtok>
  103f70:	83 c4 10             	add    $0x10,%esp
  103f73:	89 45 f0             	mov    %eax,-0x10(%ebp)
	        cpu->eax = 0;
	    }
	    else
	    {
	        cpu->eax = (uint32_t) -1;
	    }
  103f76:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  103f7a:	75 be                	jne    103f3a <vfs_get_relative_node+0x94>
	{
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
	    }
  103f7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
	    else
  103f7f:	c9                   	leave  
  103f80:	c3                   	ret    

00103f81 <vfs_get_current_task_root_node_for_path>:
	    {
            cpu->eax = RW_ERR_VFS;
  103f81:	55                   	push   %ebp
  103f82:	89 e5                	mov    %esp,%ebp
  103f84:	83 ec 08             	sub    $0x8,%esp
	    }
  103f87:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  103f8b:	74 09                	je     103f96 <vfs_get_current_task_root_node_for_path+0x15>
  103f8d:	8b 45 08             	mov    0x8(%ebp),%eax
  103f90:	8a 00                	mov    (%eax),%al
  103f92:	84 c0                	test   %al,%al
  103f94:	75 14                	jne    103faa <vfs_get_current_task_root_node_for_path+0x29>
	}
  103f96:	83 ec 0c             	sub    $0xc,%esp
  103f99:	6a 05                	push   $0x5
  103f9b:	e8 fc fc ff ff       	call   103c9c <vfs_set_error>
  103fa0:	83 c4 10             	add    $0x10,%esp
	    break;
  103fa3:	b8 00 00 00 00       	mov    $0x0,%eax
  103fa8:	eb 4d                	jmp    103ff7 <vfs_get_current_task_root_node_for_path+0x76>

	case 13: /* fread */
	{
  103faa:	8b 45 08             	mov    0x8(%ebp),%eax
  103fad:	8a 00                	mov    (%eax),%al
  103faf:	3c 2f                	cmp    $0x2f,%al
  103fb1:	75 07                	jne    103fba <vfs_get_current_task_root_node_for_path+0x39>
  103fb3:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fb8:	eb 3d                	jmp    103ff7 <vfs_get_current_task_root_node_for_path+0x76>
        vfs_reset_error();
  103fba:	e8 76 eb ff ff       	call   102b35 <get_current_task>
  103fbf:	85 c0                	test   %eax,%eax
  103fc1:	75 07                	jne    103fca <vfs_get_current_task_root_node_for_path+0x49>
  103fc3:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fc8:	eb 2d                	jmp    103ff7 <vfs_get_current_task_root_node_for_path+0x76>
        struct res_handle* handle = (void*) cpu->ebx;
  103fca:	e8 66 eb ff ff       	call   102b35 <get_current_task>
  103fcf:	8b 40 28             	mov    0x28(%eax),%eax
  103fd2:	85 c0                	test   %eax,%eax
  103fd4:	75 07                	jne    103fdd <vfs_get_current_task_root_node_for_path+0x5c>
  103fd6:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fdb:	eb 1a                	jmp    103ff7 <vfs_get_current_task_root_node_for_path+0x76>
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  103fdd:	e8 53 eb ff ff       	call   102b35 <get_current_task>
  103fe2:	8b 50 28             	mov    0x28(%eax),%edx
  103fe5:	a1 4c 85 12 00       	mov    0x12854c,%eax
  103fea:	83 ec 08             	sub    $0x8,%esp
  103fed:	52                   	push   %edx
  103fee:	50                   	push   %eax
  103fef:	e8 b2 fe ff ff       	call   103ea6 <vfs_get_relative_node>
  103ff4:	83 c4 10             	add    $0x10,%esp
        }
        else
  103ff7:	c9                   	leave  
  103ff8:	c3                   	ret    

00103ff9 <vfs_get_node>:
        {
            cpu->eax = RW_ERR_VFS;
  103ff9:	55                   	push   %ebp
  103ffa:	89 e5                	mov    %esp,%ebp
  103ffc:	83 ec 08             	sub    $0x8,%esp
        }
  103fff:	83 ec 0c             	sub    $0xc,%esp
  104002:	ff 75 08             	pushl  0x8(%ebp)
  104005:	e8 77 ff ff ff       	call   103f81 <vfs_get_current_task_root_node_for_path>
  10400a:	83 c4 10             	add    $0x10,%esp
  10400d:	83 ec 08             	sub    $0x8,%esp
  104010:	ff 75 08             	pushl  0x8(%ebp)
  104013:	50                   	push   %eax
  104014:	e8 8d fe ff ff       	call   103ea6 <vfs_get_relative_node>
  104019:	83 c4 10             	add    $0x10,%esp
	}
  10401c:	c9                   	leave  
  10401d:	c3                   	ret    

0010401e <vfs_create_path>:
	    break;

  10401e:	55                   	push   %ebp
  10401f:	89 e5                	mov    %esp,%ebp
  104021:	83 ec 18             	sub    $0x18,%esp
	case 14: /* fmkfifo */
	{
  104024:	83 ec 0c             	sub    $0xc,%esp
  104027:	ff 75 08             	pushl  0x8(%ebp)
  10402a:	e8 52 ff ff ff       	call   103f81 <vfs_get_current_task_root_node_for_path>
  10402f:	83 c4 10             	add    $0x10,%esp
  104032:	89 45 ec             	mov    %eax,-0x14(%ebp)
        vfs_reset_error();
  104035:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  10403c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  104043:	83 ec 08             	sub    $0x8,%esp
  104046:	68 95 78 10 00       	push   $0x107895
  10404b:	ff 75 08             	pushl  0x8(%ebp)
  10404e:	e8 d8 fa ff ff       	call   103b2b <strtok>
  104053:	83 c4 10             	add    $0x10,%esp
  104056:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(handle) {
  104059:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10405c:	8a 00                	mov    (%eax),%al
  10405e:	84 c0                	test   %al,%al
  104060:	0f 85 c4 00 00 00    	jne    10412a <vfs_create_path+0x10c>
  104066:	83 ec 08             	sub    $0x8,%esp
  104069:	68 95 78 10 00       	push   $0x107895
  10406e:	6a 00                	push   $0x0
  104070:	e8 b6 fa ff ff       	call   103b2b <strtok>
  104075:	83 c4 10             	add    $0x10,%esp
  104078:	89 45 e8             	mov    %eax,-0x18(%ebp)
            register_handle(handle);
            cpu->eax = (uint32_t) handle;
  10407b:	e9 aa 00 00 00       	jmp    10412a <vfs_create_path+0x10c>
        }
        else
  104080:	83 ec 08             	sub    $0x8,%esp
  104083:	ff 75 e8             	pushl  -0x18(%ebp)
  104086:	ff 75 ec             	pushl  -0x14(%ebp)
  104089:	e8 f3 fc ff ff       	call   103d81 <vfs_find_node>
  10408e:	83 c4 10             	add    $0x10,%esp
  104091:	89 45 f0             	mov    %eax,-0x10(%ebp)
        {
            cpu->eax = 0;
  104094:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104098:	75 75                	jne    10410f <vfs_create_path+0xf1>
        }
  10409a:	83 ec 0c             	sub    $0xc,%esp
  10409d:	68 10 01 00 00       	push   $0x110
  1040a2:	e8 03 f6 ff ff       	call   1036aa <malloc>
  1040a7:	83 c4 10             	add    $0x10,%esp
  1040aa:	89 45 f0             	mov    %eax,-0x10(%ebp)

        free(name);
  1040ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040b0:	83 ec 08             	sub    $0x8,%esp
  1040b3:	ff 75 e8             	pushl  -0x18(%ebp)
  1040b6:	50                   	push   %eax
  1040b7:	e8 15 fa ff ff       	call   103ad1 <strcpy>
  1040bc:	83 c4 10             	add    $0x10,%esp
	}
  1040bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040c2:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  1040c9:	00 00 00 
	    break;
  1040cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040cf:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  1040d6:	00 00 00 

	case 15: /* getLastVFSErr */
  1040d9:	ff 45 f4             	incl   -0xc(%ebp)
	{
	    cpu->eax = get_current_task()->vfserr;
  1040dc:	83 ec 08             	sub    $0x8,%esp
  1040df:	ff 75 f0             	pushl  -0x10(%ebp)
  1040e2:	ff 75 ec             	pushl  -0x14(%ebp)
  1040e5:	e8 58 fd ff ff       	call   103e42 <vfs_insert_node>
  1040ea:	83 c4 10             	add    $0x10,%esp
  1040ed:	85 c0                	test   %eax,%eax
  1040ef:	74 1e                	je     10410f <vfs_create_path+0xf1>
        vfs_reset_error();
  1040f1:	83 ec 0c             	sub    $0xc,%esp
  1040f4:	6a 38                	push   $0x38
  1040f6:	e8 af f5 ff ff       	call   1036aa <malloc>
  1040fb:	83 c4 10             	add    $0x10,%esp
  1040fe:	83 ec 08             	sub    $0x8,%esp
  104101:	68 98 78 10 00       	push   $0x107898
  104106:	50                   	push   %eax
  104107:	e8 ca c0 ff ff       	call   1001d6 <show_cod>
  10410c:	83 c4 10             	add    $0x10,%esp
	}
	    break;

	case 16: /* favailable */
  10410f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104112:	89 45 ec             	mov    %eax,-0x14(%ebp)
	{
	    cpu->eax = vfs_available((void*)cpu->ebx);
  104115:	83 ec 08             	sub    $0x8,%esp
  104118:	68 95 78 10 00       	push   $0x107895
  10411d:	6a 00                	push   $0x0
  10411f:	e8 07 fa ff ff       	call   103b2b <strtok>
  104124:	83 c4 10             	add    $0x10,%esp
  104127:	89 45 e8             	mov    %eax,-0x18(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
            register_handle(handle);
            cpu->eax = (uint32_t) handle;
  10412a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  10412e:	0f 85 4c ff ff ff    	jne    104080 <vfs_create_path+0x62>
	case 16: /* favailable */
	{
	    cpu->eax = vfs_available((void*)cpu->ebx);
	}
	    break;

  104134:	8b 45 f4             	mov    -0xc(%ebp),%eax
	case 17: /* getPathChild */
  104137:	c9                   	leave  
  104138:	c3                   	ret    

00104139 <vfs_get_child_of_path>:
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);
  104139:	55                   	push   %ebp
  10413a:	89 e5                	mov    %esp,%ebp
  10413c:	83 ec 18             	sub    $0x18,%esp

  10413f:	83 ec 0c             	sub    $0xc,%esp
  104142:	ff 75 08             	pushl  0x8(%ebp)
  104145:	e8 af fe ff ff       	call   103ff9 <vfs_get_node>
  10414a:	83 c4 10             	add    $0x10,%esp
  10414d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(path != 0 && cpu->ecx != 0) {
  104150:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  104154:	74 59                	je     1041af <vfs_get_child_of_path+0x76>
			strcpy((char*)cpu->ecx, path);
  104156:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104159:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  10415f:	85 c0                	test   %eax,%eax
  104161:	74 07                	je     10416a <vfs_get_child_of_path+0x31>
  104163:	b8 00 00 00 00       	mov    $0x0,%eax
  104168:	eb 4a                	jmp    1041b4 <vfs_get_child_of_path+0x7b>
			free(path);

  10416a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10416d:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104173:	89 45 f4             	mov    %eax,-0xc(%ebp)
			cpu->eax = cpu->ecx;
		}
  104176:	eb 19                	jmp    104191 <vfs_get_child_of_path+0x58>
		else
  104178:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10417b:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  104181:	89 45 f4             	mov    %eax,-0xc(%ebp)
		{
			cpu->eax = 0;
  104184:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104188:	75 07                	jne    104191 <vfs_get_child_of_path+0x58>
  10418a:	b8 00 00 00 00       	mov    $0x0,%eax
  10418f:	eb 23                	jmp    1041b4 <vfs_get_child_of_path+0x7b>
		if(path != 0 && cpu->ecx != 0) {
			strcpy((char*)cpu->ecx, path);
			free(path);

			cpu->eax = cpu->ecx;
		}
  104191:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104195:	0f 95 c0             	setne  %al
  104198:	ff 4d 0c             	decl   0xc(%ebp)
  10419b:	84 c0                	test   %al,%al
  10419d:	75 d9                	jne    104178 <vfs_get_child_of_path+0x3f>
		else
		{
			cpu->eax = 0;
		}
	}
		break;
  10419f:	83 ec 0c             	sub    $0xc,%esp
  1041a2:	ff 75 f4             	pushl  -0xc(%ebp)
  1041a5:	e8 37 fb ff ff       	call   103ce1 <vfs_construct_absolute_path_for_node>
  1041aa:	83 c4 10             	add    $0x10,%esp
  1041ad:	eb 05                	jmp    1041b4 <vfs_get_child_of_path+0x7b>

	case 20: /* getpmhandle */
	{
  1041af:	b8 00 00 00 00       	mov    $0x0,%eax
	    struct res_handle* handle = 0;
  1041b4:	c9                   	leave  
  1041b5:	c3                   	ret    

001041b6 <vfs_create_dir>:

	    switch(cpu->ebx) {
  1041b6:	55                   	push   %ebp
  1041b7:	89 e5                	mov    %esp,%ebp
  1041b9:	83 ec 08             	sub    $0x8,%esp
	    case PMID_STDOUT:
  1041bc:	83 ec 0c             	sub    $0xc,%esp
  1041bf:	ff 75 08             	pushl  0x8(%ebp)
  1041c2:	e8 57 fe ff ff       	call   10401e <vfs_create_path>
  1041c7:	83 c4 10             	add    $0x10,%esp
	        handle = get_current_task()->stdout;
  1041ca:	c9                   	leave  
  1041cb:	c3                   	ret    

001041cc <vfs_create_kfile>:
	        break;
        case PMID_STDIN:
  1041cc:	55                   	push   %ebp
  1041cd:	89 e5                	mov    %esp,%ebp
  1041cf:	53                   	push   %ebx
  1041d0:	83 ec 14             	sub    $0x14,%esp
            handle = get_current_task()->stdin;
  1041d3:	83 ec 0c             	sub    $0xc,%esp
  1041d6:	ff 75 08             	pushl  0x8(%ebp)
  1041d9:	e8 c3 f8 ff ff       	call   103aa1 <strlen>
  1041de:	83 c4 10             	add    $0x10,%esp
  1041e1:	40                   	inc    %eax
  1041e2:	83 ec 0c             	sub    $0xc,%esp
  1041e5:	50                   	push   %eax
  1041e6:	e8 bf f4 ff ff       	call   1036aa <malloc>
  1041eb:	83 c4 10             	add    $0x10,%esp
  1041ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
            break;
  1041f1:	83 ec 08             	sub    $0x8,%esp
  1041f4:	ff 75 08             	pushl  0x8(%ebp)
  1041f7:	ff 75 f0             	pushl  -0x10(%ebp)
  1041fa:	e8 d2 f8 ff ff       	call   103ad1 <strcpy>
  1041ff:	83 c4 10             	add    $0x10,%esp
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  104202:	83 ec 0c             	sub    $0xc,%esp
  104205:	ff 75 f0             	pushl  -0x10(%ebp)
  104208:	e8 11 fe ff ff       	call   10401e <vfs_create_path>
  10420d:	83 c4 10             	add    $0x10,%esp
  104210:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
        default:
            handle = get_current_task()->stdout;
  104213:	83 ec 0c             	sub    $0xc,%esp
  104216:	ff 75 08             	pushl  0x8(%ebp)
  104219:	e8 db fd ff ff       	call   103ff9 <vfs_get_node>
  10421e:	83 c4 10             	add    $0x10,%esp
  104221:	a3 60 85 12 00       	mov    %eax,0x128560
            break;
	    }
  104226:	a1 60 85 12 00       	mov    0x128560,%eax
  10422b:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  104232:	00 00 00 

  104235:	8b 1d 60 85 12 00    	mov    0x128560,%ebx
  10423b:	8b 45 0c             	mov    0xc(%ebp),%eax
  10423e:	8b 40 14             	mov    0x14(%eax),%eax
  104241:	83 ec 0c             	sub    $0xc,%esp
  104244:	ff 75 10             	pushl  0x10(%ebp)
  104247:	ff d0                	call   *%eax
  104249:	83 c4 10             	add    $0x10,%esp
  10424c:	89 83 04 01 00 00    	mov    %eax,0x104(%ebx)
	    cpu->eax = (uint32_t) handle;
  104252:	a1 60 85 12 00       	mov    0x128560,%eax
  104257:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10425d:	8b 55 0c             	mov    0xc(%ebp),%edx
  104260:	89 50 04             	mov    %edx,0x4(%eax)
	}
	    break;
  104263:	8b 45 f4             	mov    -0xc(%ebp),%eax

  104266:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104269:	c9                   	leave  
  10426a:	c3                   	ret    

0010426b <vfs_open>:
	case 21: /* fopenpmhandle */
	{
  10426b:	55                   	push   %ebp
  10426c:	89 e5                	mov    %esp,%ebp
  10426e:	83 ec 18             	sub    $0x18,%esp
	    vfs_reset_error();
	    char* path = strclone((char*)cpu->ecx);

  104271:	83 ec 0c             	sub    $0xc,%esp
  104274:	ff 75 08             	pushl  0x8(%ebp)
  104277:	e8 7d fd ff ff       	call   103ff9 <vfs_get_node>
  10427c:	83 c4 10             	add    $0x10,%esp
  10427f:	a3 5c 85 12 00       	mov    %eax,0x12855c
	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  104284:	a1 5c 85 12 00       	mov    0x12855c,%eax
  104289:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  10428f:	83 f8 01             	cmp    $0x1,%eax
  104292:	75 2d                	jne    1042c1 <vfs_open+0x56>

  104294:	a1 5c 85 12 00       	mov    0x12855c,%eax
  104299:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10429f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    if(cpu->ebx == PMID_STDIN) {
  1042a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1042a5:	8b 40 04             	mov    0x4(%eax),%eax
  1042a8:	8b 40 08             	mov    0x8(%eax),%eax
  1042ab:	83 ec 08             	sub    $0x8,%esp
  1042ae:	ff 75 0c             	pushl  0xc(%ebp)
  1042b1:	ff 75 f0             	pushl  -0x10(%ebp)
  1042b4:	ff d0                	call   *%eax
  1042b6:	83 c4 10             	add    $0x10,%esp
  1042b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	        fm = FM_READ;
	    }
  1042bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1042bf:	eb 05                	jmp    1042c6 <vfs_open+0x5b>

	    open = vfs_open(path, fm);

  1042c1:	b8 00 00 00 00       	mov    $0x0,%eax
	    free(path);
  1042c6:	c9                   	leave  
  1042c7:	c3                   	ret    

001042c8 <vfs_close>:

	    if(!open) {
  1042c8:	55                   	push   %ebp
  1042c9:	89 e5                	mov    %esp,%ebp
  1042cb:	83 ec 18             	sub    $0x18,%esp
	        cpu->eax = (uint32_t) -1;
  1042ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1042d1:	8b 00                	mov    (%eax),%eax
  1042d3:	83 f8 01             	cmp    $0x1,%eax
  1042d6:	75 1f                	jne    1042f7 <vfs_close+0x2f>
	        break;
  1042d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1042db:	8b 40 04             	mov    0x4(%eax),%eax
  1042de:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    }

  1042e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1042e4:	8b 40 04             	mov    0x4(%eax),%eax
  1042e7:	8b 40 0c             	mov    0xc(%eax),%eax
  1042ea:	83 ec 0c             	sub    $0xc,%esp
  1042ed:	ff 75 08             	pushl  0x8(%ebp)
  1042f0:	ff d0                	call   *%eax
  1042f2:	83 c4 10             	add    $0x10,%esp
  1042f5:	eb 05                	jmp    1042fc <vfs_close+0x34>
	    struct res_handle* oldhandle = 0;

        switch(cpu->ebx) {
  1042f7:	b8 00 00 00 00       	mov    $0x0,%eax
        case PMID_STDOUT:
  1042fc:	c9                   	leave  
  1042fd:	c3                   	ret    

001042fe <vfs_read>:
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
  1042fe:	55                   	push   %ebp
  1042ff:	89 e5                	mov    %esp,%ebp
  104301:	83 ec 18             	sub    $0x18,%esp
            break;
  104304:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104308:	75 07                	jne    104311 <vfs_read+0x13>
  10430a:	b8 02 00 00 00       	mov    $0x2,%eax
  10430f:	eb 74                	jmp    104385 <vfs_read+0x87>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  104311:	8b 45 08             	mov    0x8(%ebp),%eax
  104314:	8b 40 0c             	mov    0xc(%eax),%eax
  104317:	83 e0 01             	and    $0x1,%eax
  10431a:	85 c0                	test   %eax,%eax
  10431c:	75 07                	jne    104325 <vfs_read+0x27>
  10431e:	b8 04 00 00 00       	mov    $0x4,%eax
  104323:	eb 60                	jmp    104385 <vfs_read+0x87>
            get_current_task()->stdin = open;
            break;
  104325:	8b 45 08             	mov    0x8(%ebp),%eax
  104328:	8b 00                	mov    (%eax),%eax
  10432a:	83 f8 01             	cmp    $0x1,%eax
  10432d:	75 51                	jne    104380 <vfs_read+0x82>
        case PMID_STDERR:
  10432f:	8b 45 08             	mov    0x8(%ebp),%eax
  104332:	8b 40 04             	mov    0x4(%eax),%eax
  104335:	89 45 f0             	mov    %eax,-0x10(%ebp)
            oldhandle = get_current_task()->stderr;
            get_current_task()->stderr = open;
  104338:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10433b:	8b 40 04             	mov    0x4(%eax),%eax
  10433e:	8b 10                	mov    (%eax),%edx
  104340:	8b 45 10             	mov    0x10(%ebp),%eax
  104343:	0f af 45 14          	imul   0x14(%ebp),%eax
  104347:	83 ec 04             	sub    $0x4,%esp
  10434a:	50                   	push   %eax
  10434b:	ff 75 0c             	pushl  0xc(%ebp)
  10434e:	ff 75 08             	pushl  0x8(%ebp)
  104351:	ff d2                	call   *%edx
  104353:	83 c4 10             	add    $0x10,%esp
  104356:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
        default:
  104359:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10435d:	75 1c                	jne    10437b <vfs_read+0x7d>
            oldhandle = get_current_task()->stdout;
  10435f:	8b 45 08             	mov    0x8(%ebp),%eax
  104362:	8b 50 08             	mov    0x8(%eax),%edx
  104365:	8b 45 10             	mov    0x10(%ebp),%eax
  104368:	0f af 45 14          	imul   0x14(%ebp),%eax
  10436c:	01 c2                	add    %eax,%edx
  10436e:	8b 45 08             	mov    0x8(%ebp),%eax
  104371:	89 50 08             	mov    %edx,0x8(%eax)
            get_current_task()->stdout = open;
  104374:	b8 00 00 00 00       	mov    $0x0,%eax
  104379:	eb 0a                	jmp    104385 <vfs_read+0x87>
            break;
        }

  10437b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10437e:	eb 05                	jmp    104385 <vfs_read+0x87>
        if(oldhandle != 0) {
            vfs_close(oldhandle);
        }
  104380:	b8 02 00 00 00       	mov    $0x2,%eax

  104385:	c9                   	leave  
  104386:	c3                   	ret    

00104387 <vfs_write>:
        cpu->eax = 0;
	}
  104387:	55                   	push   %ebp
  104388:	89 e5                	mov    %esp,%ebp
  10438a:	83 ec 18             	sub    $0x18,%esp
	    break;
  10438d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104391:	75 07                	jne    10439a <vfs_write+0x13>
  104393:	b8 02 00 00 00       	mov    $0x2,%eax
  104398:	eb 75                	jmp    10440f <vfs_write+0x88>

	case 30: /* return_rpc */
  10439a:	8b 45 08             	mov    0x8(%ebp),%eax
  10439d:	8b 40 0c             	mov    0xc(%eax),%eax
  1043a0:	83 e0 02             	and    $0x2,%eax
  1043a3:	85 c0                	test   %eax,%eax
  1043a5:	75 07                	jne    1043ae <vfs_write+0x27>
  1043a7:	b8 05 00 00 00       	mov    $0x5,%eax
  1043ac:	eb 61                	jmp    10440f <vfs_write+0x88>
	{
	    cpu = return_rpc_call(cpu);
  1043ae:	8b 45 08             	mov    0x8(%ebp),%eax
  1043b1:	8b 00                	mov    (%eax),%eax
  1043b3:	83 f8 01             	cmp    $0x1,%eax
  1043b6:	75 52                	jne    10440a <vfs_write+0x83>
	}
  1043b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1043bb:	8b 40 04             	mov    0x4(%eax),%eax
  1043be:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    break;

  1043c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043c4:	8b 40 04             	mov    0x4(%eax),%eax
  1043c7:	8b 50 04             	mov    0x4(%eax),%edx
  1043ca:	8b 45 10             	mov    0x10(%ebp),%eax
  1043cd:	0f af 45 14          	imul   0x14(%ebp),%eax
  1043d1:	83 ec 04             	sub    $0x4,%esp
  1043d4:	50                   	push   %eax
  1043d5:	ff 75 0c             	pushl  0xc(%ebp)
  1043d8:	ff 75 08             	pushl  0x8(%ebp)
  1043db:	ff d2                	call   *%edx
  1043dd:	83 c4 10             	add    $0x10,%esp
  1043e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	case 31: /* call_rpc */
	{
  1043e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1043e7:	75 1c                	jne    104405 <vfs_write+0x7e>
	    int PID = cpu->ebx;
  1043e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1043ec:	8b 50 08             	mov    0x8(%eax),%edx
  1043ef:	8b 45 10             	mov    0x10(%ebp),%eax
  1043f2:	0f af 45 14          	imul   0x14(%ebp),%eax
  1043f6:	01 c2                	add    %eax,%edx
  1043f8:	8b 45 08             	mov    0x8(%ebp),%eax
  1043fb:	89 50 08             	mov    %edx,0x8(%eax)

  1043fe:	b8 00 00 00 00       	mov    $0x0,%eax
  104403:	eb 0a                	jmp    10440f <vfs_write+0x88>
	    //TODO create RPC for U2U
	}
	    break;
  104405:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104408:	eb 05                	jmp    10440f <vfs_write+0x88>

	case 32: /* set_rpc_handler */
	{
  10440a:	b8 02 00 00 00       	mov    $0x2,%eax
	    uint32_t handlerAddr = cpu->ebx;
  10440f:	c9                   	leave  
  104410:	c3                   	ret    

00104411 <vfs_available>:
	    if(get_current_task()->rpc_handler_addr == 0) {
	        get_current_task()->rpc_handler_addr = handlerAddr;
  104411:	55                   	push   %ebp
  104412:	89 e5                	mov    %esp,%ebp
  104414:	83 ec 18             	sub    $0x18,%esp
	    }
  104417:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10441b:	75 07                	jne    104424 <vfs_available+0x13>
  10441d:	b8 00 00 00 00       	mov    $0x0,%eax
  104422:	eb 2e                	jmp    104452 <vfs_available+0x41>
	}
	    break;
  104424:	8b 45 08             	mov    0x8(%ebp),%eax
  104427:	8b 00                	mov    (%eax),%eax
  104429:	83 f8 01             	cmp    $0x1,%eax
  10442c:	75 1f                	jne    10444d <vfs_available+0x3c>

  10442e:	8b 45 08             	mov    0x8(%ebp),%eax
  104431:	8b 40 04             	mov    0x4(%eax),%eax
  104434:	89 45 f4             	mov    %eax,-0xc(%ebp)
	case 33: /* fetch_rpc_data */
	{
  104437:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10443a:	8b 40 04             	mov    0x4(%eax),%eax
  10443d:	8b 40 10             	mov    0x10(%eax),%eax
  104440:	83 ec 0c             	sub    $0xc,%esp
  104443:	ff 75 08             	pushl  0x8(%ebp)
  104446:	ff d0                	call   *%eax
  104448:	83 c4 10             	add    $0x10,%esp
  10444b:	eb 05                	jmp    104452 <vfs_available+0x41>
	    cpu->eax = 0;
	    void* dest = (void*) cpu->ebx;
	    if(get_current_task()->rpc != 0) {
  10444d:	b8 00 00 00 00       	mov    $0x0,%eax
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
  104452:	c9                   	leave  
  104453:	c3                   	ret    

00104454 <vfs_exists>:
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
  104454:	55                   	push   %ebp
  104455:	89 e5                	mov    %esp,%ebp
  104457:	83 ec 08             	sub    $0x8,%esp
	}
  10445a:	83 ec 0c             	sub    $0xc,%esp
  10445d:	ff 75 08             	pushl  0x8(%ebp)
  104460:	e8 94 fb ff ff       	call   103ff9 <vfs_get_node>
  104465:	83 c4 10             	add    $0x10,%esp
  104468:	85 c0                	test   %eax,%eax
  10446a:	74 07                	je     104473 <vfs_exists+0x1f>
  10446c:	b8 01 00 00 00       	mov    $0x1,%eax
  104471:	eb 05                	jmp    104478 <vfs_exists+0x24>
	    break;
  104473:	b8 00 00 00 00       	mov    $0x0,%eax

  104478:	c9                   	leave  
  104479:	c3                   	ret    

0010447a <vfs_seek>:
	case 40:
	{
  10447a:	55                   	push   %ebp
  10447b:	89 e5                	mov    %esp,%ebp
	    cpu->eax = register_irq_rpc(cpu->ebx);
  10447d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  104481:	75 09                	jne    10448c <vfs_seek+0x12>
	}
  104483:	8b 45 08             	mov    0x8(%ebp),%eax
  104486:	8b 55 0c             	mov    0xc(%ebp),%edx
  104489:	89 50 08             	mov    %edx,0x8(%eax)
	    break;

	case 50:
  10448c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  104490:	75 11                	jne    1044a3 <vfs_seek+0x29>
	{
  104492:	8b 45 08             	mov    0x8(%ebp),%eax
  104495:	8b 40 08             	mov    0x8(%eax),%eax
  104498:	89 c2                	mov    %eax,%edx
  10449a:	03 55 0c             	add    0xc(%ebp),%edx
  10449d:	8b 45 08             	mov    0x8(%ebp),%eax
  1044a0:	89 50 08             	mov    %edx,0x8(%eax)
	    cpu->eax = require_port((uint16_t)cpu->ebx);
	}
  1044a3:	5d                   	pop    %ebp
  1044a4:	c3                   	ret    

001044a5 <vfs_exec>:
	    break;

  1044a5:	55                   	push   %ebp
  1044a6:	89 e5                	mov    %esp,%ebp
  1044a8:	53                   	push   %ebx
  1044a9:	83 ec 64             	sub    $0x64,%esp
	case 51:
  1044ac:	83 ec 0c             	sub    $0xc,%esp
  1044af:	ff 75 08             	pushl  0x8(%ebp)
  1044b2:	e8 3d f6 ff ff       	call   103af4 <strclone>
  1044b7:	83 c4 10             	add    $0x10,%esp
  1044ba:	89 45 08             	mov    %eax,0x8(%ebp)
	{
  1044bd:	83 ec 0c             	sub    $0xc,%esp
  1044c0:	ff 75 08             	pushl  0x8(%ebp)
  1044c3:	e8 8c ff ff ff       	call   104454 <vfs_exists>
  1044c8:	83 c4 10             	add    $0x10,%esp
  1044cb:	85 c0                	test   %eax,%eax
  1044cd:	75 25                	jne    1044f4 <vfs_exec+0x4f>
	    cpu->eax = port_out(cpu->ebx, (uint16_t)cpu->ecx, cpu->edx);
  1044cf:	83 ec 0c             	sub    $0xc,%esp
  1044d2:	ff 75 08             	pushl  0x8(%ebp)
  1044d5:	e8 16 f4 ff ff       	call   1038f0 <free>
  1044da:	83 c4 10             	add    $0x10,%esp
	}
  1044dd:	83 ec 0c             	sub    $0xc,%esp
  1044e0:	6a 01                	push   $0x1
  1044e2:	e8 b5 f7 ff ff       	call   103c9c <vfs_set_error>
  1044e7:	83 c4 10             	add    $0x10,%esp
	    break;
  1044ea:	b8 00 00 00 00       	mov    $0x0,%eax
  1044ef:	e9 ba 04 00 00       	jmp    1049ae <vfs_exec+0x509>

	case 52:
	{
	    cpu->eax = port_in(cpu->ebx, (uint16_t)cpu->ecx);
	}
  1044f4:	e8 8d 08 00 00       	call   104d86 <vmm_create_pagedir>
  1044f9:	89 45 a0             	mov    %eax,-0x60(%ebp)
	    break;

	case 201: /* kputc */
  1044fc:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		cpu->eax = kprintf("%c", cpu->ebx);
		break;
  104503:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  104507:	74 14                	je     10451d <vfs_exec+0x78>

  104509:	eb 03                	jmp    10450e <vfs_exec+0x69>
	case 202: /* kputs */
  10450b:	ff 45 a4             	incl   -0x5c(%ebp)
	    break;

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
		break;

  10450e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104511:	c1 e0 02             	shl    $0x2,%eax
  104514:	03 45 0c             	add    0xc(%ebp),%eax
  104517:	8b 00                	mov    (%eax),%eax
  104519:	85 c0                	test   %eax,%eax
  10451b:	75 ee                	jne    10450b <vfs_exec+0x66>
	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
		break;

	case 203: /* vmm_alloc_ucont */
  10451d:	ff 45 a4             	incl   -0x5c(%ebp)
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  104520:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104523:	40                   	inc    %eax
  104524:	c1 e0 02             	shl    $0x2,%eax
  104527:	83 ec 0c             	sub    $0xc,%esp
  10452a:	50                   	push   %eax
  10452b:	e8 7a f1 ff ff       	call   1036aa <malloc>
  104530:	83 c4 10             	add    $0x10,%esp
  104533:	89 45 a8             	mov    %eax,-0x58(%ebp)
		break;

  104536:	83 ec 0c             	sub    $0xc,%esp
  104539:	ff 75 08             	pushl  0x8(%ebp)
  10453c:	e8 b3 f5 ff ff       	call   103af4 <strclone>
  104541:	83 c4 10             	add    $0x10,%esp
  104544:	8b 55 a8             	mov    -0x58(%ebp),%edx
  104547:	89 02                	mov    %eax,(%edx)
	case 204: /* vmm_free */
		cpu->eax = 0;
  104549:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
  104550:	eb 59                	jmp    1045ab <vfs_exec+0x106>
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  104552:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104555:	c1 e0 02             	shl    $0x2,%eax
  104558:	89 c3                	mov    %eax,%ebx
  10455a:	03 5d a8             	add    -0x58(%ebp),%ebx
  10455d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104560:	48                   	dec    %eax
  104561:	c1 e0 02             	shl    $0x2,%eax
  104564:	03 45 0c             	add    0xc(%ebp),%eax
  104567:	8b 00                	mov    (%eax),%eax
  104569:	83 ec 0c             	sub    $0xc,%esp
  10456c:	50                   	push   %eax
  10456d:	e8 2f f5 ff ff       	call   103aa1 <strlen>
  104572:	83 c4 10             	add    $0x10,%esp
  104575:	40                   	inc    %eax
  104576:	83 ec 0c             	sub    $0xc,%esp
  104579:	50                   	push   %eax
  10457a:	e8 2b f1 ff ff       	call   1036aa <malloc>
  10457f:	83 c4 10             	add    $0x10,%esp
  104582:	89 03                	mov    %eax,(%ebx)
			vmm_free((void*) cpu->ebx);
  104584:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104587:	48                   	dec    %eax
  104588:	c1 e0 02             	shl    $0x2,%eax
  10458b:	03 45 0c             	add    0xc(%ebp),%eax
  10458e:	8b 10                	mov    (%eax),%edx
  104590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104593:	c1 e0 02             	shl    $0x2,%eax
  104596:	03 45 a8             	add    -0x58(%ebp),%eax
  104599:	8b 00                	mov    (%eax),%eax
  10459b:	83 ec 08             	sub    $0x8,%esp
  10459e:	52                   	push   %edx
  10459f:	50                   	push   %eax
  1045a0:	e8 2c f5 ff ff       	call   103ad1 <strcpy>
  1045a5:	83 c4 10             	add    $0x10,%esp
	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
		break;

	case 204: /* vmm_free */
		cpu->eax = 0;
  1045a8:	ff 45 d4             	incl   -0x2c(%ebp)
  1045ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1045ae:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
  1045b1:	72 9f                	jb     104552 <vfs_exec+0xad>
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
			vmm_free((void*) cpu->ebx);
		}
		break;

  1045b3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1045b6:	c1 e0 02             	shl    $0x2,%eax
  1045b9:	03 45 a8             	add    -0x58(%ebp),%eax
  1045bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	case 205: /* pmm_print_stats */
		pmm_print_stats();
		break;
  1045c2:	83 ec 08             	sub    $0x8,%esp
  1045c5:	6a 05                	push   $0x5
  1045c7:	ff 75 08             	pushl  0x8(%ebp)
  1045ca:	e8 9c fc ff ff       	call   10426b <vfs_open>
  1045cf:	83 c4 10             	add    $0x10,%esp
  1045d2:	89 45 ac             	mov    %eax,-0x54(%ebp)

	default:
  1045d5:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
  1045d9:	75 25                	jne    104600 <vfs_exec+0x15b>
		kprintf("Invalid Syscall %d...", cpu->eax);
  1045db:	83 ec 0c             	sub    $0xc,%esp
  1045de:	6a 02                	push   $0x2
  1045e0:	e8 b7 f6 ff ff       	call   103c9c <vfs_set_error>
  1045e5:	83 c4 10             	add    $0x10,%esp
		break;
  1045e8:	83 ec 0c             	sub    $0xc,%esp
  1045eb:	ff 75 08             	pushl  0x8(%ebp)
  1045ee:	e8 fd f2 ff ff       	call   1038f0 <free>
  1045f3:	83 c4 10             	add    $0x10,%esp
	}
  1045f6:	b8 00 00 00 00       	mov    $0x0,%eax
  1045fb:	e9 ae 03 00 00       	jmp    1049ae <vfs_exec+0x509>

	return cpu;
}
  104600:	83 ec 0c             	sub    $0xc,%esp
  104603:	ff 75 ac             	pushl  -0x54(%ebp)
  104606:	e8 06 fe ff ff       	call   104411 <vfs_available>
  10460b:	83 c4 10             	add    $0x10,%esp
  10460e:	89 45 b0             	mov    %eax,-0x50(%ebp)

  104611:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  104615:	75 25                	jne    10463c <vfs_exec+0x197>
void kernel_main(struct multiboot_info* mb_info) {
  104617:	83 ec 0c             	sub    $0xc,%esp
  10461a:	6a 03                	push   $0x3
  10461c:	e8 7b f6 ff ff       	call   103c9c <vfs_set_error>
  104621:	83 c4 10             	add    $0x10,%esp
	uint32_t kernel_init_pdir = vmm_init();
  104624:	83 ec 0c             	sub    $0xc,%esp
  104627:	ff 75 08             	pushl  0x8(%ebp)
  10462a:	e8 c1 f2 ff ff       	call   1038f0 <free>
  10462f:	83 c4 10             	add    $0x10,%esp

  104632:	b8 00 00 00 00       	mov    $0x0,%eax
  104637:	e9 72 03 00 00       	jmp    1049ae <vfs_exec+0x509>
	kprintf("Setting PIT interval...\n");

    outb(0x43, 0b00110100);
  10463c:	83 ec 0c             	sub    $0xc,%esp
  10463f:	ff 75 b0             	pushl  -0x50(%ebp)
  104642:	e8 63 f0 ff ff       	call   1036aa <malloc>
  104647:	83 c4 10             	add    $0x10,%esp
  10464a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    outb(0x40, 0x00);
    outb(0x40, 0x08);
  10464d:	6a 01                	push   $0x1
  10464f:	ff 75 b0             	pushl  -0x50(%ebp)
  104652:	ff 75 b4             	pushl  -0x4c(%ebp)
  104655:	ff 75 ac             	pushl  -0x54(%ebp)
  104658:	e8 a1 fc ff ff       	call   1042fe <vfs_read>
  10465d:	83 c4 10             	add    $0x10,%esp
  104660:	89 45 b8             	mov    %eax,-0x48(%ebp)

    kprintf("Initializing vfs...\n");
  104663:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  104667:	74 33                	je     10469c <vfs_exec+0x1f7>

  104669:	83 ec 0c             	sub    $0xc,%esp
  10466c:	ff 75 08             	pushl  0x8(%ebp)
  10466f:	e8 7c f2 ff ff       	call   1038f0 <free>
  104674:	83 c4 10             	add    $0x10,%esp
    vfs_init_root();
  104677:	83 ec 0c             	sub    $0xc,%esp
  10467a:	ff 75 b4             	pushl  -0x4c(%ebp)
  10467d:	e8 6e f2 ff ff       	call   1038f0 <free>
  104682:	83 c4 10             	add    $0x10,%esp
    ramfs_fifo_init();
  104685:	83 ec 0c             	sub    $0xc,%esp
  104688:	6a 04                	push   $0x4
  10468a:	e8 0d f6 ff ff       	call   103c9c <vfs_set_error>
  10468f:	83 c4 10             	add    $0x10,%esp
    ramfs_block_init();
  104692:	b8 00 00 00 00       	mov    $0x0,%eax
  104697:	e9 12 03 00 00       	jmp    1049ae <vfs_exec+0x509>

    //driver_keyboard_init();

  10469c:	e8 db 06 00 00       	call   104d7c <vmm_get_current_pagedir>
  1046a1:	89 45 bc             	mov    %eax,-0x44(%ebp)

    map_address_active((uint32_t) mb_info,
                       (uint32_t) mb_info, 0);
  1046a4:	83 ec 0c             	sub    $0xc,%esp
  1046a7:	ff 75 a0             	pushl  -0x60(%ebp)
  1046aa:	e8 c5 0c 00 00       	call   105374 <vmm_activate_pagedir>
  1046af:	83 c4 10             	add    $0x10,%esp
    map_address_active((uint32_t) mb_info->mi_mods_addr,
                       (uint32_t) mb_info->mi_mods_addr, 0);
  1046b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  1046b5:	89 45 c0             	mov    %eax,-0x40(%ebp)

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
        vmm_map_range(mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].start,
  1046b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1046bb:	8b 00                	mov    (%eax),%eax
  1046bd:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  1046c2:	74 33                	je     1046f7 <vfs_exec+0x252>
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
  1046c4:	83 ec 0c             	sub    $0xc,%esp
  1046c7:	ff 75 b4             	pushl  -0x4c(%ebp)
  1046ca:	e8 21 f2 ff ff       	call   1038f0 <free>
  1046cf:	83 c4 10             	add    $0x10,%esp
                      0);
  1046d2:	83 ec 0c             	sub    $0xc,%esp
  1046d5:	ff 75 08             	pushl  0x8(%ebp)
  1046d8:	e8 13 f2 ff ff       	call   1038f0 <free>
  1046dd:	83 c4 10             	add    $0x10,%esp

  1046e0:	83 ec 0c             	sub    $0xc,%esp
  1046e3:	6a 03                	push   $0x3
  1046e5:	e8 b2 f5 ff ff       	call   103c9c <vfs_set_error>
  1046ea:	83 c4 10             	add    $0x10,%esp
        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  1046ed:	b8 00 00 00 00       	mov    $0x0,%eax
  1046f2:	e9 b7 02 00 00       	jmp    1049ae <vfs_exec+0x509>
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  1046f7:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1046fa:	8b 40 18             	mov    0x18(%eax),%eax
  1046fd:	89 45 c8             	mov    %eax,-0x38(%ebp)
    } else {
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  104700:	8b 55 c0             	mov    -0x40(%ebp),%edx
  104703:	8b 45 c0             	mov    -0x40(%ebp),%eax
  104706:	8b 40 1c             	mov    0x1c(%eax),%eax
  104709:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10470c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    }

  10470f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104716:	e9 88 00 00 00       	jmp    1047a3 <vfs_exec+0x2fe>
    kprintf("[kernel_res] Creating /dev/vga\n");
  10471b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10471e:	8b 40 08             	mov    0x8(%eax),%eax
  104721:	89 45 dc             	mov    %eax,-0x24(%ebp)
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  104724:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104727:	8b 40 04             	mov    0x4(%eax),%eax
  10472a:	03 45 c0             	add    -0x40(%ebp),%eax
  10472d:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if(vfs_exists("/ibin/init")) {
        kprintf("[init] /ibin/init found. Executing...\n");
  104730:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104733:	8b 00                	mov    (%eax),%eax
  104735:	83 f8 01             	cmp    $0x1,%eax
  104738:	75 61                	jne    10479b <vfs_exec+0x2f6>

        vfs_exec("/ibin/init", 0, 0, 0, 0, 0, 0);
        enableScheduling();
    }
  10473a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104741:	eb 33                	jmp    104776 <vfs_exec+0x2d1>

  104743:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104746:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104749:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10474c:	83 ec 0c             	sub    $0xc,%esp
  10474f:	50                   	push   %eax
  104750:	e8 64 09 00 00       	call   1050b9 <vmm_free>
  104755:	83 c4 10             	add    $0x10,%esp
	while(1);
  104758:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10475b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10475e:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104761:	83 ec 08             	sub    $0x8,%esp
  104764:	6a 00                	push   $0x0
  104766:	50                   	push   %eax
  104767:	e8 63 0b 00 00       	call   1052cf <vmm_alloc_addr>
  10476c:	83 c4 10             	add    $0x10,%esp
    if(vfs_exists("/ibin/init")) {
        kprintf("[init] /ibin/init found. Executing...\n");

        vfs_exec("/ibin/init", 0, 0, 0, 0, 0, 0);
        enableScheduling();
    }
  10476f:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  104776:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104779:	8b 40 14             	mov    0x14(%eax),%eax
  10477c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  10477f:	77 c2                	ja     104743 <vfs_exec+0x29e>

	while(1);
    //*********************************************************************** KERNEL END
}
  104781:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  104784:	8b 40 10             	mov    0x10(%eax),%eax
  104787:	83 ec 04             	sub    $0x4,%esp
  10478a:	50                   	push   %eax
  10478b:	ff 75 e0             	pushl  -0x20(%ebp)
  10478e:	ff 75 dc             	pushl  -0x24(%ebp)
  104791:	e8 dc f1 ff ff       	call   103972 <memcpy>
  104796:	83 c4 10             	add    $0x10,%esp
  104799:	eb 01                	jmp    10479c <vfs_exec+0x2f7>
    kprintf("[kernel_res] Creating /dev/vga\n");
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);

    if(vfs_exists("/ibin/init")) {
        kprintf("[init] /ibin/init found. Executing...\n");

  10479b:	90                   	nop    

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
    } else {
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
    }

  10479c:	ff 45 d8             	incl   -0x28(%ebp)
  10479f:	83 45 c4 20          	addl   $0x20,-0x3c(%ebp)
  1047a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1047a6:	66 8b 40 2c          	mov    0x2c(%eax),%ax
  1047aa:	25 ff ff 00 00       	and    $0xffff,%eax
  1047af:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  1047b2:	0f 87 63 ff ff ff    	ja     10471b <vfs_exec+0x276>
}
  1047b8:	83 ec 0c             	sub    $0xc,%esp
  1047bb:	6a 01                	push   $0x1
  1047bd:	e8 91 0a 00 00       	call   105253 <vmm_alloc_ucont>
  1047c2:	83 c4 10             	add    $0x10,%esp
  1047c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1047c8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1047cf:	eb 57                	jmp    104828 <vfs_exec+0x383>
  1047d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1047d4:	c1 e0 02             	shl    $0x2,%eax
  1047d7:	89 c3                	mov    %eax,%ebx
  1047d9:	03 5d cc             	add    -0x34(%ebp),%ebx
  1047dc:	83 ec 0c             	sub    $0xc,%esp
  1047df:	6a 01                	push   $0x1
  1047e1:	e8 6d 0a 00 00       	call   105253 <vmm_alloc_ucont>
  1047e6:	83 c4 10             	add    $0x10,%esp
  1047e9:	89 03                	mov    %eax,(%ebx)
  1047eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1047ee:	c1 e0 02             	shl    $0x2,%eax
  1047f1:	03 45 a8             	add    -0x58(%ebp),%eax
  1047f4:	8b 10                	mov    (%eax),%edx
  1047f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1047f9:	c1 e0 02             	shl    $0x2,%eax
  1047fc:	03 45 cc             	add    -0x34(%ebp),%eax
  1047ff:	8b 00                	mov    (%eax),%eax
  104801:	83 ec 08             	sub    $0x8,%esp
  104804:	52                   	push   %edx
  104805:	50                   	push   %eax
  104806:	e8 c6 f2 ff ff       	call   103ad1 <strcpy>
  10480b:	83 c4 10             	add    $0x10,%esp
  10480e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104811:	c1 e0 02             	shl    $0x2,%eax
  104814:	03 45 a8             	add    -0x58(%ebp),%eax
  104817:	8b 00                	mov    (%eax),%eax
  104819:	83 ec 0c             	sub    $0xc,%esp
  10481c:	50                   	push   %eax
  10481d:	e8 ce f0 ff ff       	call   1038f0 <free>
  104822:	83 c4 10             	add    $0x10,%esp
  104825:	ff 45 e8             	incl   -0x18(%ebp)
  104828:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10482b:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
  10482e:	72 a1                	jb     1047d1 <vfs_exec+0x32c>
  104830:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  104833:	c1 e0 02             	shl    $0x2,%eax
  104836:	03 45 cc             	add    -0x34(%ebp),%eax
  104839:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  10483f:	83 ec 0c             	sub    $0xc,%esp
  104842:	ff 75 a8             	pushl  -0x58(%ebp)
  104845:	e8 a6 f0 ff ff       	call   1038f0 <free>
  10484a:	83 c4 10             	add    $0x10,%esp
  10484d:	83 ec 08             	sub    $0x8,%esp
  104850:	ff 75 c8             	pushl  -0x38(%ebp)
  104853:	ff 75 a0             	pushl  -0x60(%ebp)
  104856:	e8 1c e6 ff ff       	call   102e77 <init_task>
  10485b:	83 c4 10             	add    $0x10,%esp
  10485e:	89 45 d0             	mov    %eax,-0x30(%ebp)
  104861:	e8 cf e2 ff ff       	call   102b35 <get_current_task>
  104866:	85 c0                	test   %eax,%eax
  104868:	74 38                	je     1048a2 <vfs_exec+0x3fd>
  10486a:	e8 c6 e2 ff ff       	call   102b35 <get_current_task>
  10486f:	8b 50 38             	mov    0x38(%eax),%edx
  104872:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104875:	89 50 38             	mov    %edx,0x38(%eax)
  104878:	e8 b8 e2 ff ff       	call   102b35 <get_current_task>
  10487d:	8b 50 30             	mov    0x30(%eax),%edx
  104880:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104883:	89 50 30             	mov    %edx,0x30(%eax)
  104886:	e8 aa e2 ff ff       	call   102b35 <get_current_task>
  10488b:	8b 50 34             	mov    0x34(%eax),%edx
  10488e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104891:	89 50 34             	mov    %edx,0x34(%eax)
  104894:	e8 9c e2 ff ff       	call   102b35 <get_current_task>
  104899:	8b 50 28             	mov    0x28(%eax),%edx
  10489c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10489f:	89 50 28             	mov    %edx,0x28(%eax)
  1048a2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  1048a6:	74 09                	je     1048b1 <vfs_exec+0x40c>
  1048a8:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048ab:	8b 55 10             	mov    0x10(%ebp),%edx
  1048ae:	89 50 28             	mov    %edx,0x28(%eax)
  1048b1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  1048b5:	74 34                	je     1048eb <vfs_exec+0x446>
  1048b7:	83 ec 0c             	sub    $0xc,%esp
  1048ba:	ff 75 14             	pushl  0x14(%ebp)
  1048bd:	e8 92 fb ff ff       	call   104454 <vfs_exists>
  1048c2:	83 c4 10             	add    $0x10,%esp
  1048c5:	85 c0                	test   %eax,%eax
  1048c7:	74 22                	je     1048eb <vfs_exec+0x446>
  1048c9:	83 ec 08             	sub    $0x8,%esp
  1048cc:	6a 01                	push   $0x1
  1048ce:	ff 75 14             	pushl  0x14(%ebp)
  1048d1:	e8 95 f9 ff ff       	call   10426b <vfs_open>
  1048d6:	83 c4 10             	add    $0x10,%esp
  1048d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1048dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  1048e0:	74 09                	je     1048eb <vfs_exec+0x446>
  1048e2:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1048e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1048e8:	89 50 38             	mov    %edx,0x38(%eax)
  1048eb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  1048ef:	74 34                	je     104925 <vfs_exec+0x480>
  1048f1:	83 ec 0c             	sub    $0xc,%esp
  1048f4:	ff 75 18             	pushl  0x18(%ebp)
  1048f7:	e8 58 fb ff ff       	call   104454 <vfs_exists>
  1048fc:	83 c4 10             	add    $0x10,%esp
  1048ff:	85 c0                	test   %eax,%eax
  104901:	74 22                	je     104925 <vfs_exec+0x480>
  104903:	83 ec 08             	sub    $0x8,%esp
  104906:	6a 01                	push   $0x1
  104908:	ff 75 18             	pushl  0x18(%ebp)
  10490b:	e8 5b f9 ff ff       	call   10426b <vfs_open>
  104910:	83 c4 10             	add    $0x10,%esp
  104913:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104916:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10491a:	74 09                	je     104925 <vfs_exec+0x480>
  10491c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10491f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104922:	89 50 30             	mov    %edx,0x30(%eax)
  104925:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  104929:	74 34                	je     10495f <vfs_exec+0x4ba>
  10492b:	83 ec 0c             	sub    $0xc,%esp
  10492e:	ff 75 1c             	pushl  0x1c(%ebp)
  104931:	e8 1e fb ff ff       	call   104454 <vfs_exists>
  104936:	83 c4 10             	add    $0x10,%esp
  104939:	85 c0                	test   %eax,%eax
  10493b:	74 22                	je     10495f <vfs_exec+0x4ba>
  10493d:	83 ec 08             	sub    $0x8,%esp
  104940:	6a 01                	push   $0x1
  104942:	ff 75 1c             	pushl  0x1c(%ebp)
  104945:	e8 21 f9 ff ff       	call   10426b <vfs_open>
  10494a:	83 c4 10             	add    $0x10,%esp
  10494d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104950:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  104954:	74 09                	je     10495f <vfs_exec+0x4ba>
  104956:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104959:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10495c:	89 50 34             	mov    %edx,0x34(%eax)
  10495f:	8b 45 d0             	mov    -0x30(%ebp),%eax
  104962:	8b 55 cc             	mov    -0x34(%ebp),%edx
  104965:	89 50 20             	mov    %edx,0x20(%eax)
  104968:	8b 45 d0             	mov    -0x30(%ebp),%eax
  10496b:	8b 55 08             	mov    0x8(%ebp),%edx
  10496e:	89 50 24             	mov    %edx,0x24(%eax)
  104971:	83 ec 0c             	sub    $0xc,%esp
  104974:	ff 75 bc             	pushl  -0x44(%ebp)
  104977:	e8 f8 09 00 00       	call   105374 <vmm_activate_pagedir>
  10497c:	83 c4 10             	add    $0x10,%esp
  10497f:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  104983:	74 16                	je     10499b <vfs_exec+0x4f6>
  104985:	e8 ab e1 ff ff       	call   102b35 <get_current_task>
  10498a:	8b 55 d0             	mov    -0x30(%ebp),%edx
  10498d:	89 50 44             	mov    %edx,0x44(%eax)
  104990:	e8 a0 e1 ff ff       	call   102b35 <get_current_task>
  104995:	8b 55 d0             	mov    -0x30(%ebp),%edx
  104998:	89 42 40             	mov    %eax,0x40(%edx)
  10499b:	83 ec 0c             	sub    $0xc,%esp
  10499e:	ff 75 b4             	pushl  -0x4c(%ebp)
  1049a1:	e8 4a ef ff ff       	call   1038f0 <free>
  1049a6:	83 c4 10             	add    $0x10,%esp
  1049a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1049ac:	8b 00                	mov    (%eax),%eax
  1049ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1049b1:	c9                   	leave  
  1049b2:	c3                   	ret    

001049b3 <vfs_resolve_path>:
  1049b3:	55                   	push   %ebp
  1049b4:	89 e5                	mov    %esp,%ebp
  1049b6:	83 ec 18             	sub    $0x18,%esp
  1049b9:	83 ec 0c             	sub    $0xc,%esp
  1049bc:	ff 75 08             	pushl  0x8(%ebp)
  1049bf:	e8 35 f6 ff ff       	call   103ff9 <vfs_get_node>
  1049c4:	83 c4 10             	add    $0x10,%esp
  1049c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1049ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1049ce:	75 07                	jne    1049d7 <vfs_resolve_path+0x24>
  1049d0:	b8 00 00 00 00       	mov    $0x0,%eax
  1049d5:	eb 0e                	jmp    1049e5 <vfs_resolve_path+0x32>
  1049d7:	83 ec 0c             	sub    $0xc,%esp
  1049da:	ff 75 f4             	pushl  -0xc(%ebp)
  1049dd:	e8 ff f2 ff ff       	call   103ce1 <vfs_construct_absolute_path_for_node>
  1049e2:	83 c4 10             	add    $0x10,%esp
  1049e5:	c9                   	leave  
  1049e6:	c3                   	ret    

001049e7 <vfs_init_root>:
  1049e7:	55                   	push   %ebp
  1049e8:	89 e5                	mov    %esp,%ebp
  1049ea:	83 ec 08             	sub    $0x8,%esp
  1049ed:	a1 4c 85 12 00       	mov    0x12854c,%eax
  1049f2:	85 c0                	test   %eax,%eax
  1049f4:	75 69                	jne    104a5f <vfs_init_root+0x78>
  1049f6:	83 ec 0c             	sub    $0xc,%esp
  1049f9:	68 10 01 00 00       	push   $0x110
  1049fe:	e8 a7 ec ff ff       	call   1036aa <malloc>
  104a03:	83 c4 10             	add    $0x10,%esp
  104a06:	a3 4c 85 12 00       	mov    %eax,0x12854c
  104a0b:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a10:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  104a17:	00 00 00 
  104a1a:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a1f:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  104a26:	00 00 00 
  104a29:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a2e:	83 ec 04             	sub    $0x4,%esp
  104a31:	6a 02                	push   $0x2
  104a33:	68 ca 78 10 00       	push   $0x1078ca
  104a38:	50                   	push   %eax
  104a39:	e8 34 ef ff ff       	call   103972 <memcpy>
  104a3e:	83 c4 10             	add    $0x10,%esp
  104a41:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a46:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
  104a4d:	00 00 00 
  104a50:	a1 4c 85 12 00       	mov    0x12854c,%eax
  104a55:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  104a5c:	00 00 00 
  104a5f:	c9                   	leave  
  104a60:	c3                   	ret    

00104a61 <vfs_debug_ls>:
  104a61:	55                   	push   %ebp
  104a62:	89 e5                	mov    %esp,%ebp
  104a64:	83 ec 18             	sub    $0x18,%esp
  104a67:	83 ec 0c             	sub    $0xc,%esp
  104a6a:	ff 75 08             	pushl  0x8(%ebp)
  104a6d:	e8 87 f5 ff ff       	call   103ff9 <vfs_get_node>
  104a72:	83 c4 10             	add    $0x10,%esp
  104a75:	a3 58 85 12 00       	mov    %eax,0x128558
  104a7a:	a1 58 85 12 00       	mov    0x128558,%eax
  104a7f:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104a85:	a3 58 85 12 00       	mov    %eax,0x128558
  104a8a:	eb 6a                	jmp    104af6 <vfs_debug_ls+0x95>
  104a8c:	c7 45 f4 cc 78 10 00 	movl   $0x1078cc,-0xc(%ebp)
  104a93:	a1 58 85 12 00       	mov    0x128558,%eax
  104a98:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104a9e:	85 c0                	test   %eax,%eax
  104aa0:	75 07                	jne    104aa9 <vfs_debug_ls+0x48>
  104aa2:	c7 45 f4 d0 78 10 00 	movl   $0x1078d0,-0xc(%ebp)
  104aa9:	a1 58 85 12 00       	mov    0x128558,%eax
  104aae:	8b 80 00 01 00 00    	mov    0x100(%eax),%eax
  104ab4:	83 f8 01             	cmp    $0x1,%eax
  104ab7:	75 14                	jne    104acd <vfs_debug_ls+0x6c>
  104ab9:	a1 58 85 12 00       	mov    0x128558,%eax
  104abe:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104ac4:	8b 40 04             	mov    0x4(%eax),%eax
  104ac7:	8b 40 18             	mov    0x18(%eax),%eax
  104aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104acd:	a1 58 85 12 00       	mov    0x128558,%eax
  104ad2:	ff 75 f4             	pushl  -0xc(%ebp)
  104ad5:	50                   	push   %eax
  104ad6:	ff 75 08             	pushl  0x8(%ebp)
  104ad9:	68 d4 78 10 00       	push   $0x1078d4
  104ade:	e8 8a ba ff ff       	call   10056d <kprintf>
  104ae3:	83 c4 10             	add    $0x10,%esp
  104ae6:	a1 58 85 12 00       	mov    0x128558,%eax
  104aeb:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  104af1:	a3 58 85 12 00       	mov    %eax,0x128558
  104af6:	a1 58 85 12 00       	mov    0x128558,%eax
  104afb:	85 c0                	test   %eax,%eax
  104afd:	75 8d                	jne    104a8c <vfs_debug_ls+0x2b>
  104aff:	c9                   	leave  
  104b00:	c3                   	ret    
  104b01:	00 00                	add    %al,(%eax)
	...

00104b04 <vmm_create_vpdraw>:
struct exec_info {
    char* execPath;
    char* stdin;
    char* stdout;
    char* stderr;
};
  104b04:	55                   	push   %ebp
  104b05:	89 e5                	mov    %esp,%ebp
  104b07:	53                   	push   %ebx
  104b08:	83 ec 34             	sub    $0x34,%esp

  104b0b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
struct cpu_state* syscall(struct cpu_state* cpu) {
  104b12:	83 ec 0c             	sub    $0xc,%esp
  104b15:	8d 45 dc             	lea    -0x24(%ebp),%eax
  104b18:	50                   	push   %eax
  104b19:	e8 92 07 00 00       	call   1052b0 <vmm_alloc>
  104b1e:	83 c4 10             	add    $0x10,%esp
  104b21:	89 45 e0             	mov    %eax,-0x20(%ebp)
    cpu = save_cpu_state(cpu);

  104b24:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	switch (cpu->eax) {
  104b2b:	83 ec 0c             	sub    $0xc,%esp
  104b2e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  104b31:	50                   	push   %eax
  104b32:	e8 79 07 00 00       	call   1052b0 <vmm_alloc>
  104b37:	83 c4 10             	add    $0x10,%esp
  104b3a:	89 c2                	mov    %eax,%edx
  104b3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104b3f:	89 10                	mov    %edx,(%eax)
	case 1: /* exit */
  104b41:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  104b45:	74 08                	je     104b4f <vmm_create_vpdraw+0x4b>
		return terminate_current(cpu);
  104b47:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104b4a:	8b 45 08             	mov    0x8(%ebp),%eax
  104b4d:	89 10                	mov    %edx,(%eax)

	case 2: /* pexists */
  104b4f:	83 ec 0c             	sub    $0xc,%esp
  104b52:	6a 00                	push   $0x0
  104b54:	e8 57 07 00 00       	call   1052b0 <vmm_alloc>
  104b59:	83 c4 10             	add    $0x10,%esp
  104b5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
	}
  104b5f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104b66:	e9 f9 00 00 00       	jmp    104c64 <vmm_create_vpdraw+0x160>
	    break;
  104b6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b6e:	c1 e0 02             	shl    $0x2,%eax
  104b71:	89 c3                	mov    %eax,%ebx
  104b73:	03 5d e4             	add    -0x1c(%ebp),%ebx
  104b76:	83 ec 0c             	sub    $0xc,%esp
  104b79:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  104b7c:	50                   	push   %eax
  104b7d:	e8 2e 07 00 00       	call   1052b0 <vmm_alloc>
  104b82:	83 c4 10             	add    $0x10,%esp
  104b85:	89 03                	mov    %eax,(%ebx)

    case 3: /* exec */
  104b87:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
  104b8b:	77 48                	ja     104bd5 <vmm_create_vpdraw+0xd1>
    {
  104b8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b90:	c1 e0 02             	shl    $0x2,%eax
  104b93:	03 45 e4             	add    -0x1c(%ebp),%eax
  104b96:	8b 00                	mov    (%eax),%eax
  104b98:	83 ec 0c             	sub    $0xc,%esp
  104b9b:	50                   	push   %eax
  104b9c:	e8 18 05 00 00       	call   1050b9 <vmm_free>
  104ba1:	83 c4 10             	add    $0x10,%esp
        char* path = strclone((char*) cpu->ebx);
  104ba4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104ba7:	8b 14 85 e0 87 1c 00 	mov    0x1c87e0(,%eax,4),%edx
  104bae:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bb1:	c1 e0 02             	shl    $0x2,%eax
  104bb4:	03 45 e4             	add    -0x1c(%ebp),%eax
  104bb7:	8b 00                	mov    (%eax),%eax
  104bb9:	83 ec 04             	sub    $0x4,%esp
  104bbc:	6a 00                	push   $0x0
  104bbe:	52                   	push   %edx
  104bbf:	50                   	push   %eax
  104bc0:	e8 9f 04 00 00       	call   105064 <map_address_active>
  104bc5:	83 c4 10             	add    $0x10,%esp

  104bc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bcb:	8b 04 85 e0 87 1c 00 	mov    0x1c87e0(,%eax,4),%eax
  104bd2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);
  104bd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104bd8:	8b 00                	mov    (%eax),%eax
  104bda:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104bdd:	c1 e2 02             	shl    $0x2,%edx
  104be0:	01 d0                	add    %edx,%eax
  104be2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  104be5:	83 ca 07             	or     $0x7,%edx
  104be8:	89 10                	mov    %edx,(%eax)

		if(cpu->edx) {
  104bea:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
  104bee:	76 71                	jbe    104c61 <vmm_create_vpdraw+0x15d>
			cpu = schedule(cpu);
  104bf0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  104bf7:	eb 5f                	jmp    104c58 <vmm_create_vpdraw+0x154>
		}
  104bf9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bfc:	89 c2                	mov    %eax,%edx
  104bfe:	c1 e2 16             	shl    $0x16,%edx
  104c01:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c04:	c1 e0 0c             	shl    $0xc,%eax
  104c07:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104c0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
        break;
  104c0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c10:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  104c17:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c1a:	c1 e0 02             	shl    $0x2,%eax
  104c1d:	03 45 e4             	add    -0x1c(%ebp),%eax
  104c20:	8b 00                	mov    (%eax),%eax
  104c22:	8d 04 02             	lea    (%edx,%eax,1),%eax
  104c25:	89 c1                	mov    %eax,%ecx
  104c27:	81 7d f4 00 10 40 01 	cmpl   $0x1401000,-0xc(%ebp)
  104c2e:	76 07                	jbe    104c37 <vmm_create_vpdraw+0x133>
  104c30:	ba 00 02 00 00       	mov    $0x200,%edx
  104c35:	eb 05                	jmp    104c3c <vmm_create_vpdraw+0x138>
  104c37:	ba 00 00 00 00       	mov    $0x0,%edx
  104c3c:	81 7d f4 00 10 40 01 	cmpl   $0x1401000,-0xc(%ebp)
  104c43:	76 07                	jbe    104c4c <vmm_create_vpdraw+0x148>
  104c45:	b8 04 00 00 00       	mov    $0x4,%eax
  104c4a:	eb 05                	jmp    104c51 <vmm_create_vpdraw+0x14d>
  104c4c:	b8 00 00 00 00       	mov    $0x0,%eax
  104c51:	09 d0                	or     %edx,%eax
  104c53:	89 01                	mov    %eax,(%ecx)
		cpu->eax = vfs_exec(path, (char**) cpu->ecx, 0, 0, 0, 0, cpu->edx);

        free(path);

		if(cpu->edx) {
			cpu = schedule(cpu);
  104c55:	ff 45 ec             	incl   -0x14(%ebp)
  104c58:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
  104c5f:	76 98                	jbe    104bf9 <vmm_create_vpdraw+0xf5>
		return terminate_current(cpu);

	case 2: /* pexists */
	{
	    cpu->eax = (uint32_t)get_task_by_pid((int)cpu->ebx);
	}
  104c61:	ff 45 e8             	incl   -0x18(%ebp)
  104c64:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  104c6b:	0f 86 fa fe ff ff    	jbe    104b6b <vmm_create_vpdraw+0x67>
    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

  104c71:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  104c78:	eb 3d                	jmp    104cb7 <vmm_create_vpdraw+0x1b3>
    case 5: /* yield */
  104c7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104c7d:	8b 00                	mov    (%eax),%eax
  104c7f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104c82:	c1 e2 02             	shl    $0x2,%edx
  104c85:	01 d0                	add    %edx,%eax
  104c87:	8b 00                	mov    (%eax),%eax
  104c89:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104c8e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    {
  104c91:	8b 45 d4             	mov    -0x2c(%ebp),%eax
        cpu = schedule(cpu);
  104c94:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104c97:	89 d1                	mov    %edx,%ecx
  104c99:	c1 e1 0c             	shl    $0xc,%ecx
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

    case 5: /* yield */
    {
  104c9c:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  104ca2:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  104ca5:	6a 00                	push   $0x0
  104ca7:	50                   	push   %eax
  104ca8:	52                   	push   %edx
  104ca9:	ff 75 e4             	pushl  -0x1c(%ebp)
  104cac:	e8 2f 03 00 00       	call   104fe0 <map_address_context>
  104cb1:	83 c4 10             	add    $0x10,%esp
    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
    }
        break;

  104cb4:	ff 45 e8             	incl   -0x18(%ebp)
  104cb7:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  104cbe:	76 ba                	jbe    104c7a <vmm_create_vpdraw+0x176>
    case 5: /* yield */
    {
        cpu = schedule(cpu);
    }
        break;

  104cc0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  104cc3:	a1 00 61 10 00       	mov    0x106100,%eax
  104cc8:	6a 00                	push   $0x0
  104cca:	52                   	push   %edx
  104ccb:	50                   	push   %eax
  104ccc:	ff 75 e4             	pushl  -0x1c(%ebp)
  104ccf:	e8 0c 03 00 00       	call   104fe0 <map_address_context>
  104cd4:	83 c4 10             	add    $0x10,%esp
    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  104cd7:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
  104cde:	eb 1a                	jmp    104cfa <vmm_create_vpdraw+0x1f6>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
  104ce0:	6a 00                	push   $0x0
  104ce2:	ff 75 e8             	pushl  -0x18(%ebp)
  104ce5:	ff 75 e8             	pushl  -0x18(%ebp)
  104ce8:	ff 75 e4             	pushl  -0x1c(%ebp)
  104ceb:	e8 f0 02 00 00       	call   104fe0 <map_address_context>
  104cf0:	83 c4 10             	add    $0x10,%esp
    }
        break;

    case 6: /* getExecPath */
    {
        char* dest = (char*)cpu->ebx;
  104cf3:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
  104cfa:	b8 00 90 1c 00       	mov    $0x1c9000,%eax
  104cff:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  104d02:	72 dc                	jb     104ce0 <vmm_create_vpdraw+0x1dc>
        if(get_current_task()->execPath != 0) strcpy(dest, get_current_task()->execPath);
    }
        break;

  104d04:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104d07:	8b 00                	mov    (%eax),%eax
  104d09:	89 45 f0             	mov    %eax,-0x10(%ebp)
    case 7: /* changeExecPath */
  104d0c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104d0f:	89 c2                	mov    %eax,%edx
  104d11:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104d14:	89 10                	mov    %edx,(%eax)
    {
        vfs_reset_error();
  104d16:	83 ec 0c             	sub    $0xc,%esp
  104d19:	ff 75 f0             	pushl  -0x10(%ebp)
  104d1c:	e8 18 04 00 00       	call   105139 <vmm_unmap>
  104d21:	83 c4 10             	add    $0x10,%esp
        char* path = strclone((char*) cpu->ebx);
  104d24:	83 ec 0c             	sub    $0xc,%esp
  104d27:	ff 75 e0             	pushl  -0x20(%ebp)
  104d2a:	e8 0a 04 00 00       	call   105139 <vmm_unmap>
  104d2f:	83 c4 10             	add    $0x10,%esp

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);
  104d32:	8b 45 e4             	mov    -0x1c(%ebp),%eax

  104d35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  104d38:	c9                   	leave  
  104d39:	c3                   	ret    

00104d3a <vmm_free_pdptr>:
        char* new = vfs_resolve_path(path);

  104d3a:	55                   	push   %ebp
  104d3b:	89 e5                	mov    %esp,%ebp
  104d3d:	83 ec 18             	sub    $0x18,%esp
        cpu->eax = 0;
  104d40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104d47:	eb 1a                	jmp    104d63 <vmm_free_pdptr+0x29>
        if(new) {
  104d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d4c:	c1 e0 02             	shl    $0x2,%eax
  104d4f:	03 45 08             	add    0x8(%ebp),%eax
  104d52:	8b 00                	mov    (%eax),%eax
  104d54:	83 ec 0c             	sub    $0xc,%esp
  104d57:	50                   	push   %eax
  104d58:	e8 dc 03 00 00       	call   105139 <vmm_unmap>
  104d5d:	83 c4 10             	add    $0x10,%esp

        if(get_current_task()->execPath != 0) free(get_current_task()->execPath);

        char* new = vfs_resolve_path(path);

        cpu->eax = 0;
  104d60:	ff 45 f4             	incl   -0xc(%ebp)
  104d63:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  104d6a:	76 dd                	jbe    104d49 <vmm_free_pdptr+0xf>
        if(new) {
            get_current_task()->execPath = new;
            cpu->eax = 1;
        }
  104d6c:	83 ec 0c             	sub    $0xc,%esp
  104d6f:	ff 75 08             	pushl  0x8(%ebp)
  104d72:	e8 c2 03 00 00       	call   105139 <vmm_unmap>
  104d77:	83 c4 10             	add    $0x10,%esp

  104d7a:	c9                   	leave  
  104d7b:	c3                   	ret    

00104d7c <vmm_get_current_pagedir>:
        free(path);
    }
  104d7c:	55                   	push   %ebp
  104d7d:	89 e5                	mov    %esp,%ebp
        break;
  104d7f:	a1 64 85 12 00       	mov    0x128564,%eax

  104d84:	5d                   	pop    %ebp
  104d85:	c3                   	ret    

00104d86 <vmm_create_pagedir>:
	case 10: /* fopen */
	{
  104d86:	55                   	push   %ebp
  104d87:	89 e5                	mov    %esp,%ebp
  104d89:	83 ec 18             	sub    $0x18,%esp
        vfs_reset_error();
	    char* name = strclone((char*) cpu->ebx);
  104d8c:	83 ec 0c             	sub    $0xc,%esp
  104d8f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  104d92:	50                   	push   %eax
  104d93:	e8 6c fd ff ff       	call   104b04 <vmm_create_vpdraw>
  104d98:	83 c4 10             	add    $0x10,%esp
  104d9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  104d9e:	83 ec 0c             	sub    $0xc,%esp
  104da1:	ff 75 f4             	pushl  -0xc(%ebp)
  104da4:	e8 91 ff ff ff       	call   104d3a <vmm_free_pdptr>
  104da9:	83 c4 10             	add    $0x10,%esp

	    struct res_handle* handle = vfs_open(name, fmode);
  104dac:	8b 45 f0             	mov    -0x10(%ebp),%eax
	    if(handle) {
  104daf:	c9                   	leave  
  104db0:	c3                   	ret    

00104db1 <vmm_free_current_pagetables>:
	        register_handle(handle);
	        cpu->eax = (uint32_t) handle;
  104db1:	55                   	push   %ebp
  104db2:	89 e5                	mov    %esp,%ebp
  104db4:	83 ec 18             	sub    $0x18,%esp
	    }
  104db7:	83 ec 0c             	sub    $0xc,%esp
  104dba:	6a 00                	push   $0x0
  104dbc:	e8 ef 04 00 00       	call   1052b0 <vmm_alloc>
  104dc1:	83 c4 10             	add    $0x10,%esp
  104dc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	    else
  104dc7:	83 ec 0c             	sub    $0xc,%esp
  104dca:	6a 00                	push   $0x0
  104dcc:	e8 df 04 00 00       	call   1052b0 <vmm_alloc>
  104dd1:	83 c4 10             	add    $0x10,%esp
  104dd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    {
  104dd7:	83 ec 0c             	sub    $0xc,%esp
  104dda:	ff 75 e8             	pushl  -0x18(%ebp)
  104ddd:	e8 d7 02 00 00       	call   1050b9 <vmm_free>
  104de2:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = 0;
  104de5:	83 ec 0c             	sub    $0xc,%esp
  104de8:	ff 75 ec             	pushl  -0x14(%ebp)
  104deb:	e8 c9 02 00 00       	call   1050b9 <vmm_free>
  104df0:	83 c4 10             	add    $0x10,%esp
	    }

  104df3:	e8 3d dd ff ff       	call   102b35 <get_current_task>
  104df8:	8b 50 14             	mov    0x14(%eax),%edx
  104dfb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104dfe:	83 ec 04             	sub    $0x4,%esp
  104e01:	6a 00                	push   $0x0
  104e03:	52                   	push   %edx
  104e04:	50                   	push   %eax
  104e05:	e8 5a 02 00 00       	call   105064 <map_address_active>
  104e0a:	83 c4 10             	add    $0x10,%esp
	    free(name);
	}
  104e0d:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
  104e14:	e9 99 00 00 00       	jmp    104eb2 <vmm_free_current_pagetables+0x101>
	    break;
  104e19:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e1c:	c1 e0 02             	shl    $0x2,%eax
  104e1f:	03 45 e8             	add    -0x18(%ebp),%eax
  104e22:	8b 00                	mov    (%eax),%eax
  104e24:	89 c2                	mov    %eax,%edx
  104e26:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  104e2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104e2f:	83 ec 04             	sub    $0x4,%esp
  104e32:	6a 00                	push   $0x0
  104e34:	52                   	push   %edx
  104e35:	50                   	push   %eax
  104e36:	e8 29 02 00 00       	call   105064 <map_address_active>
  104e3b:	83 c4 10             	add    $0x10,%esp

	case 11: /* fclose */
  104e3e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104e45:	eb 31                	jmp    104e78 <vmm_free_current_pagetables+0xc7>
	{
  104e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e4a:	c1 e0 02             	shl    $0x2,%eax
  104e4d:	03 45 ec             	add    -0x14(%ebp),%eax
  104e50:	8b 00                	mov    (%eax),%eax
  104e52:	83 e0 01             	and    $0x1,%eax
  104e55:	84 c0                	test   %al,%al
  104e57:	74 1c                	je     104e75 <vmm_free_current_pagetables+0xc4>
        vfs_reset_error();
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);
  104e59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e5c:	c1 e0 02             	shl    $0x2,%eax
  104e5f:	03 45 ec             	add    -0x14(%ebp),%eax
  104e62:	8b 00                	mov    (%eax),%eax
  104e64:	25 00 f0 ff 0f       	and    $0xffff000,%eax
  104e69:	83 ec 0c             	sub    $0xc,%esp
  104e6c:	50                   	push   %eax
  104e6d:	e8 34 cd ff ff       	call   101ba6 <pmm_free>
  104e72:	83 c4 10             	add    $0x10,%esp

	    free(name);
	}
	    break;

	case 11: /* fclose */
  104e75:	ff 45 f4             	incl   -0xc(%ebp)
  104e78:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  104e7f:	76 c6                	jbe    104e47 <vmm_free_current_pagetables+0x96>
	    if(!unregister_handle(handle)) {
	        vfs_close(handle);

	        cpu->eax = 0;
	    }
	    else
  104e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e84:	c1 e0 02             	shl    $0x2,%eax
  104e87:	03 45 e8             	add    -0x18(%ebp),%eax
  104e8a:	8b 00                	mov    (%eax),%eax
  104e8c:	83 e0 01             	and    $0x1,%eax
  104e8f:	84 c0                	test   %al,%al
  104e91:	74 1c                	je     104eaf <vmm_free_current_pagetables+0xfe>
	    {
  104e93:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e96:	c1 e0 02             	shl    $0x2,%eax
  104e99:	03 45 e8             	add    -0x18(%ebp),%eax
  104e9c:	8b 00                	mov    (%eax),%eax
  104e9e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104ea3:	83 ec 0c             	sub    $0xc,%esp
  104ea6:	50                   	push   %eax
  104ea7:	e8 fa cc ff ff       	call   101ba6 <pmm_free>
  104eac:	83 c4 10             	add    $0x10,%esp
	    {
	        cpu->eax = 0;
	    }

	    free(name);
	}
  104eaf:	ff 45 f0             	incl   -0x10(%ebp)
  104eb2:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
  104eb9:	0f 86 5a ff ff ff    	jbe    104e19 <vmm_free_current_pagetables+0x68>
	    }
	    else
	    {
	        cpu->eax = (uint32_t) -1;
	    }
	}
  104ebf:	e8 71 dc ff ff       	call   102b35 <get_current_task>
  104ec4:	8b 40 14             	mov    0x14(%eax),%eax
  104ec7:	83 ec 0c             	sub    $0xc,%esp
  104eca:	50                   	push   %eax
  104ecb:	e8 d6 cc ff ff       	call   101ba6 <pmm_free>
  104ed0:	83 c4 10             	add    $0x10,%esp
	    break;
  104ed3:	c9                   	leave  
  104ed4:	c3                   	ret    

00104ed5 <vmm_resolve>:

	case 12: /* fwrite */
  104ed5:	55                   	push   %ebp
  104ed6:	89 e5                	mov    %esp,%ebp
	{
  104ed8:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  104edd:	8b 55 08             	mov    0x8(%ebp),%edx
  104ee0:	c1 ea 0c             	shr    $0xc,%edx
  104ee3:	c1 e2 02             	shl    $0x2,%edx
  104ee6:	01 d0                	add    %edx,%eax
  104ee8:	8b 00                	mov    (%eax),%eax
  104eea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
        vfs_reset_error();
  104eef:	5d                   	pop    %ebp
  104ef0:	c3                   	ret    

00104ef1 <vmm_resolve_ppd>:
	    struct res_handle* handle = (void*) cpu->ebx;
	    if(handle != 0) {
  104ef1:	55                   	push   %ebp
  104ef2:	89 e5                	mov    %esp,%ebp
  104ef4:	83 ec 28             	sub    $0x28,%esp
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  104ef7:	8b 45 0c             	mov    0xc(%ebp),%eax
  104efa:	c1 e8 16             	shr    $0x16,%eax
  104efd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    }
  104f00:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f03:	c1 e8 0c             	shr    $0xc,%eax
  104f06:	25 ff 03 00 00       	and    $0x3ff,%eax
  104f0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	    else
	    {
  104f0e:	83 ec 0c             	sub    $0xc,%esp
  104f11:	6a 00                	push   $0x0
  104f13:	e8 98 03 00 00       	call   1052b0 <vmm_alloc>
  104f18:	83 c4 10             	add    $0x10,%esp
  104f1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
            cpu->eax = RW_ERR_VFS;
  104f1e:	83 ec 0c             	sub    $0xc,%esp
  104f21:	ff 75 ec             	pushl  -0x14(%ebp)
  104f24:	e8 90 01 00 00       	call   1050b9 <vmm_free>
  104f29:	83 c4 10             	add    $0x10,%esp
	    }
	}
  104f2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f2f:	83 ec 04             	sub    $0x4,%esp
  104f32:	6a 00                	push   $0x0
  104f34:	ff 75 08             	pushl  0x8(%ebp)
  104f37:	50                   	push   %eax
  104f38:	e8 27 01 00 00       	call   105064 <map_address_active>
  104f3d:	83 c4 10             	add    $0x10,%esp
	    break;
  104f40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104f43:	c1 e0 02             	shl    $0x2,%eax
  104f46:	03 45 ec             	add    -0x14(%ebp),%eax
  104f49:	8b 00                	mov    (%eax),%eax
  104f4b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104f50:	89 45 f0             	mov    %eax,-0x10(%ebp)

	case 13: /* fread */
  104f53:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f56:	83 ec 04             	sub    $0x4,%esp
  104f59:	6a 00                	push   $0x0
  104f5b:	ff 75 f0             	pushl  -0x10(%ebp)
  104f5e:	50                   	push   %eax
  104f5f:	e8 00 01 00 00       	call   105064 <map_address_active>
  104f64:	83 c4 10             	add    $0x10,%esp
	{
  104f67:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104f6a:	c1 e0 02             	shl    $0x2,%eax
  104f6d:	03 45 ec             	add    -0x14(%ebp),%eax
  104f70:	8b 00                	mov    (%eax),%eax
  104f72:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  104f77:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
        struct res_handle* handle = (void*) cpu->ebx;
  104f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104f7d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
        if(handle != 0) {
  104f82:	c9                   	leave  
  104f83:	c3                   	ret    

00104f84 <vmm_map_range>:
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
  104f84:	55                   	push   %ebp
  104f85:	89 e5                	mov    %esp,%ebp
  104f87:	83 ec 18             	sub    $0x18,%esp
        else
  104f8a:	8b 45 08             	mov    0x8(%ebp),%eax
  104f8d:	25 ff 0f 00 00       	and    $0xfff,%eax
  104f92:	85 c0                	test   %eax,%eax
  104f94:	75 44                	jne    104fda <vmm_map_range+0x56>
        {
            cpu->eax = RW_ERR_VFS;
  104f96:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f99:	25 ff 0f 00 00       	and    $0xfff,%eax
  104f9e:	85 c0                	test   %eax,%eax
  104fa0:	75 3b                	jne    104fdd <vmm_map_range+0x59>
        }
	}
	    break;
  104fa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104fa9:	eb 25                	jmp    104fd0 <vmm_map_range+0x4c>

  104fab:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fae:	89 c2                	mov    %eax,%edx
  104fb0:	03 55 f4             	add    -0xc(%ebp),%edx
  104fb3:	8b 45 08             	mov    0x8(%ebp),%eax
  104fb6:	03 45 f4             	add    -0xc(%ebp),%eax
  104fb9:	83 ec 04             	sub    $0x4,%esp
  104fbc:	ff 75 14             	pushl  0x14(%ebp)
  104fbf:	52                   	push   %edx
  104fc0:	50                   	push   %eax
  104fc1:	e8 9e 00 00 00       	call   105064 <map_address_active>
  104fc6:	83 c4 10             	add    $0x10,%esp
        else
        {
            cpu->eax = RW_ERR_VFS;
        }
	}
	    break;
  104fc9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  104fd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104fd3:	3b 45 10             	cmp    0x10(%ebp),%eax
  104fd6:	72 d3                	jb     104fab <vmm_map_range+0x27>
  104fd8:	eb 04                	jmp    104fde <vmm_map_range+0x5a>
        struct res_handle* handle = (void*) cpu->ebx;
        if(handle != 0) {
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
        }
        else
        {
  104fda:	90                   	nop    
  104fdb:	eb 01                	jmp    104fde <vmm_map_range+0x5a>
            cpu->eax = RW_ERR_VFS;
        }
  104fdd:	90                   	nop    
	}
	    break;

	case 14: /* fmkfifo */
	{
  104fde:	c9                   	leave  
  104fdf:	c3                   	ret    

00104fe0 <map_address_context>:
        vfs_reset_error();
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  104fe0:	55                   	push   %ebp
  104fe1:	89 e5                	mov    %esp,%ebp
  104fe3:	53                   	push   %ebx
  104fe4:	83 ec 10             	sub    $0x10,%esp

  104fe7:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fea:	c1 e8 16             	shr    $0x16,%eax
  104fed:	89 45 f4             	mov    %eax,-0xc(%ebp)
        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  104ff0:	8b 45 0c             	mov    0xc(%ebp),%eax
  104ff3:	c1 e8 0c             	shr    $0xc,%eax
  104ff6:	25 ff 03 00 00       	and    $0x3ff,%eax
  104ffb:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if(handle) {
            register_handle(handle);
  104ffe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105001:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  105008:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10500b:	c1 e0 02             	shl    $0x2,%eax
  10500e:	03 45 08             	add    0x8(%ebp),%eax
  105011:	8b 00                	mov    (%eax),%eax
  105013:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105018:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10501b:	8b 55 10             	mov    0x10(%ebp),%edx
  10501e:	89 d1                	mov    %edx,%ecx
  105020:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
            cpu->eax = (uint32_t) handle;
  105026:	8b 55 14             	mov    0x14(%ebp),%edx
  105029:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
            register_handle(handle);
  10502f:	09 d1                	or     %edx,%ecx
            cpu->eax = (uint32_t) handle;
        }
  105031:	8b 55 f8             	mov    -0x8(%ebp),%edx
  105034:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
  10503b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10503e:	c1 e2 02             	shl    $0x2,%edx
  105041:	03 55 08             	add    0x8(%ebp),%edx
  105044:	8b 12                	mov    (%edx),%edx
  105046:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  10504c:	8d 14 13             	lea    (%ebx,%edx,1),%edx
  10504f:	8b 12                	mov    (%edx),%edx
  105051:	81 e2 04 02 00 00    	and    $0x204,%edx
        char* name = strclone((char*) cpu->ebx);
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
        if(handle) {
            register_handle(handle);
  105057:	09 ca                	or     %ecx,%edx
  105059:	83 ca 03             	or     $0x3,%edx
  10505c:	89 10                	mov    %edx,(%eax)
            cpu->eax = (uint32_t) handle;
        }
        else
        {
  10505e:	83 c4 10             	add    $0x10,%esp
  105061:	5b                   	pop    %ebx
  105062:	5d                   	pop    %ebp
  105063:	c3                   	ret    

00105064 <map_address_active>:
            cpu->eax = 0;
        }
  105064:	55                   	push   %ebp
  105065:	89 e5                	mov    %esp,%ebp
  105067:	53                   	push   %ebx

  105068:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10506d:	8b 55 08             	mov    0x8(%ebp),%edx
  105070:	c1 ea 0c             	shr    $0xc,%edx
  105073:	c1 e2 02             	shl    $0x2,%edx
  105076:	01 d0                	add    %edx,%eax
  105078:	8b 55 0c             	mov    0xc(%ebp),%edx
  10507b:	89 d1                	mov    %edx,%ecx
  10507d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
        free(name);
  105083:	8b 55 10             	mov    0x10(%ebp),%edx
  105086:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
        }
        else
        {
            cpu->eax = 0;
        }

  10508c:	89 cb                	mov    %ecx,%ebx
  10508e:	09 d3                	or     %edx,%ebx
        free(name);
	}
  105090:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  105096:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105099:	c1 e9 0c             	shr    $0xc,%ecx
  10509c:	c1 e1 02             	shl    $0x2,%ecx
  10509f:	01 ca                	add    %ecx,%edx
  1050a1:	8b 12                	mov    (%edx),%edx
  1050a3:	81 e2 04 02 00 00    	and    $0x204,%edx
        }
        else
        {
            cpu->eax = 0;
        }

  1050a9:	09 da                	or     %ebx,%edx
  1050ab:	83 ca 03             	or     $0x3,%edx
  1050ae:	89 10                	mov    %edx,(%eax)
        free(name);
	}
	    break;
  1050b0:	8b 45 08             	mov    0x8(%ebp),%eax
  1050b3:	0f 01 38             	invlpg (%eax)

  1050b6:	5b                   	pop    %ebx
  1050b7:	5d                   	pop    %ebp
  1050b8:	c3                   	ret    

001050b9 <vmm_free>:
	case 15: /* getLastVFSErr */
	{
  1050b9:	55                   	push   %ebp
  1050ba:	89 e5                	mov    %esp,%ebp
  1050bc:	83 ec 18             	sub    $0x18,%esp
	    cpu->eax = get_current_task()->vfserr;
  1050bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1050c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        vfs_reset_error();
	}
  1050c5:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1050ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1050cd:	c1 ea 0c             	shr    $0xc,%edx
  1050d0:	c1 e2 02             	shl    $0x2,%edx
  1050d3:	01 d0                	add    %edx,%eax
  1050d5:	8b 00                	mov    (%eax),%eax
  1050d7:	25 01 02 00 00       	and    $0x201,%eax
  1050dc:	3d 01 02 00 00       	cmp    $0x201,%eax
  1050e1:	75 54                	jne    105137 <vmm_free+0x7e>
	    break;

  1050e3:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1050e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1050eb:	c1 ea 0c             	shr    $0xc,%edx
  1050ee:	c1 e2 02             	shl    $0x2,%edx
  1050f1:	01 d0                	add    %edx,%eax
  1050f3:	8b 00                	mov    (%eax),%eax
  1050f5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1050fa:	83 ec 0c             	sub    $0xc,%esp
  1050fd:	50                   	push   %eax
  1050fe:	e8 a3 ca ff ff       	call   101ba6 <pmm_free>
  105103:	83 c4 10             	add    $0x10,%esp
	case 16: /* favailable */
	{
  105106:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10510b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10510e:	c1 ea 0c             	shr    $0xc,%edx
  105111:	c1 e2 02             	shl    $0x2,%edx
  105114:	01 d0                	add    %edx,%eax
	    cpu->eax = vfs_available((void*)cpu->ebx);
  105116:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  10511c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10511f:	c1 e9 0c             	shr    $0xc,%ecx
  105122:	c1 e1 02             	shl    $0x2,%ecx
  105125:	01 ca                	add    %ecx,%edx
  105127:	8b 12                	mov    (%edx),%edx
  105129:	83 e2 04             	and    $0x4,%edx
        vfs_reset_error();
	}
	    break;

	case 16: /* favailable */
	{
  10512c:	80 ce 02             	or     $0x2,%dh
  10512f:	89 10                	mov    %edx,(%eax)
	    cpu->eax = vfs_available((void*)cpu->ebx);
	}
  105131:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105134:	0f 01 38             	invlpg (%eax)
	    break;

  105137:	c9                   	leave  
  105138:	c3                   	ret    

00105139 <vmm_unmap>:
	case 17: /* getPathChild */
	{
  105139:	55                   	push   %ebp
  10513a:	89 e5                	mov    %esp,%ebp
  10513c:	83 ec 10             	sub    $0x10,%esp
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);
  10513f:	8b 45 08             	mov    0x8(%ebp),%eax
  105142:	89 45 fc             	mov    %eax,-0x4(%ebp)

		if(path != 0 && cpu->ecx != 0) {
  105145:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10514a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10514d:	c1 ea 0c             	shr    $0xc,%edx
  105150:	c1 e2 02             	shl    $0x2,%edx
  105153:	01 d0                	add    %edx,%eax
  105155:	8b 00                	mov    (%eax),%eax
  105157:	25 01 02 00 00       	and    $0x201,%eax
  10515c:	3d 01 02 00 00       	cmp    $0x201,%eax
  105161:	75 31                	jne    105194 <vmm_unmap+0x5b>
			strcpy((char*)cpu->ecx, path);
			free(path);
  105163:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  105168:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10516b:	c1 ea 0c             	shr    $0xc,%edx
  10516e:	c1 e2 02             	shl    $0x2,%edx
  105171:	01 d0                	add    %edx,%eax

  105173:	8b 15 fc 60 10 00    	mov    0x1060fc,%edx
  105179:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10517c:	c1 e9 0c             	shr    $0xc,%ecx
  10517f:	c1 e1 02             	shl    $0x2,%ecx
  105182:	01 ca                	add    %ecx,%edx
  105184:	8b 12                	mov    (%edx),%edx
  105186:	83 e2 04             	and    $0x4,%edx
	{
		char* path = vfs_get_child_of_path((char*)cpu->edx, cpu->ebx);

		if(path != 0 && cpu->ecx != 0) {
			strcpy((char*)cpu->ecx, path);
			free(path);
  105189:	80 ce 02             	or     $0x2,%dh
  10518c:	89 10                	mov    %edx,(%eax)

			cpu->eax = cpu->ecx;
  10518e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105191:	0f 01 38             	invlpg (%eax)
		}
		else
  105194:	c9                   	leave  
  105195:	c3                   	ret    

00105196 <vmm_alloc_in_range>:
		{
			cpu->eax = 0;
		}
  105196:	55                   	push   %ebp
  105197:	89 e5                	mov    %esp,%ebp
  105199:	83 ec 18             	sub    $0x18,%esp
	}
  10519c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		break;
  1051a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  1051aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	case 20: /* getpmhandle */
	{
  1051b1:	8b 45 08             	mov    0x8(%ebp),%eax
  1051b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1051b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1051bc:	eb 48                	jmp    105206 <vmm_alloc_in_range+0x70>
	    struct res_handle* handle = 0;
  1051be:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1051c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1051c6:	c1 ea 0c             	shr    $0xc,%edx
  1051c9:	c1 e2 02             	shl    $0x2,%edx
  1051cc:	01 d0                	add    %edx,%eax
  1051ce:	8b 00                	mov    (%eax),%eax
  1051d0:	25 01 02 00 00       	and    $0x201,%eax
  1051d5:	3d 00 02 00 00       	cmp    $0x200,%eax
  1051da:	75 19                	jne    1051f5 <vmm_alloc_in_range+0x5f>

	    switch(cpu->ebx) {
  1051dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1051e0:	75 06                	jne    1051e8 <vmm_alloc_in_range+0x52>
	    case PMID_STDOUT:
  1051e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1051e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	        handle = get_current_task()->stdout;
  1051e8:	ff 45 f0             	incl   -0x10(%ebp)
	        break;
  1051eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1051ee:	3b 45 14             	cmp    0x14(%ebp),%eax
  1051f1:	72 0b                	jb     1051fe <vmm_alloc_in_range+0x68>
        case PMID_STDIN:
  1051f3:	eb 19                	jmp    10520e <vmm_alloc_in_range+0x78>
            handle = get_current_task()->stdin;
            break;
  1051f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1051fc:	eb 01                	jmp    1051ff <vmm_alloc_in_range+0x69>

	    switch(cpu->ebx) {
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
	        break;
        case PMID_STDIN:
  1051fe:	90                   	nop    
		}
	}
		break;

	case 20: /* getpmhandle */
	{
  1051ff:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
  105206:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105209:	3b 45 0c             	cmp    0xc(%ebp),%eax
  10520c:	72 b0                	jb     1051be <vmm_alloc_in_range+0x28>
            handle = get_current_task()->stdin;
            break;
        case PMID_STDERR:
            handle = get_current_task()->stderr;
            break;
        default:
  10520e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            handle = get_current_task()->stdout;
            break;
  105215:	eb 29                	jmp    105240 <vmm_alloc_in_range+0xaa>
	    }
  105217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  10521b:	75 05                	jne    105222 <vmm_alloc_in_range+0x8c>
  10521d:	8b 45 10             	mov    0x10(%ebp),%eax
  105220:	eb 05                	jmp    105227 <vmm_alloc_in_range+0x91>
  105222:	b8 00 00 00 00       	mov    $0x0,%eax
  105227:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10522a:	c1 e2 0c             	shl    $0xc,%edx
  10522d:	03 55 e8             	add    -0x18(%ebp),%edx
  105230:	83 ec 08             	sub    $0x8,%esp
  105233:	50                   	push   %eax
  105234:	52                   	push   %edx
  105235:	e8 95 00 00 00       	call   1052cf <vmm_alloc_addr>
  10523a:	83 c4 10             	add    $0x10,%esp

  10523d:	ff 45 f4             	incl   -0xc(%ebp)
        case PMID_STDERR:
            handle = get_current_task()->stderr;
            break;
        default:
            handle = get_current_task()->stdout;
            break;
  105240:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  105244:	0f 95 c0             	setne  %al
  105247:	ff 4d f0             	decl   -0x10(%ebp)
  10524a:	84 c0                	test   %al,%al
  10524c:	75 c9                	jne    105217 <vmm_alloc_in_range+0x81>
	    }

	    cpu->eax = (uint32_t) handle;
	}
	    break;
  10524e:	8b 45 e8             	mov    -0x18(%ebp),%eax

  105251:	c9                   	leave  
  105252:	c3                   	ret    

00105253 <vmm_alloc_ucont>:
	case 21: /* fopenpmhandle */
	{
  105253:	55                   	push   %ebp
  105254:	89 e5                	mov    %esp,%ebp
  105256:	83 ec 08             	sub    $0x8,%esp
	    vfs_reset_error();
  105259:	ff 75 08             	pushl  0x8(%ebp)
  10525c:	6a 00                	push   $0x0
  10525e:	68 00 f0 ff ff       	push   $0xfffff000
  105263:	68 00 10 40 01       	push   $0x1401000
  105268:	e8 29 ff ff ff       	call   105196 <vmm_alloc_in_range>
  10526d:	83 c4 10             	add    $0x10,%esp
	    char* path = strclone((char*)cpu->ecx);
  105270:	c9                   	leave  
  105271:	c3                   	ret    

00105272 <vmm_alloc_user>:

	    struct res_handle* open;
  105272:	55                   	push   %ebp
  105273:	89 e5                	mov    %esp,%ebp
  105275:	83 ec 08             	sub    $0x8,%esp
	    uint32_t fm = FM_WRITE;
  105278:	6a 01                	push   $0x1
  10527a:	ff 75 08             	pushl  0x8(%ebp)
  10527d:	68 00 f0 ff ff       	push   $0xfffff000
  105282:	68 00 10 40 01       	push   $0x1401000
  105287:	e8 0a ff ff ff       	call   105196 <vmm_alloc_in_range>
  10528c:	83 c4 10             	add    $0x10,%esp

  10528f:	c9                   	leave  
  105290:	c3                   	ret    

00105291 <vmm_alloc_cont>:
	    if(cpu->ebx == PMID_STDIN) {
	        fm = FM_READ;
  105291:	55                   	push   %ebp
  105292:	89 e5                	mov    %esp,%ebp
  105294:	83 ec 08             	sub    $0x8,%esp
	    }
  105297:	ff 75 08             	pushl  0x8(%ebp)
  10529a:	6a 00                	push   $0x0
  10529c:	68 00 00 00 20       	push   $0x20000000
  1052a1:	68 00 10 40 01       	push   $0x1401000
  1052a6:	e8 eb fe ff ff       	call   105196 <vmm_alloc_in_range>
  1052ab:	83 c4 10             	add    $0x10,%esp

  1052ae:	c9                   	leave  
  1052af:	c3                   	ret    

001052b0 <vmm_alloc>:
	    open = vfs_open(path, fm);

  1052b0:	55                   	push   %ebp
  1052b1:	89 e5                	mov    %esp,%ebp
  1052b3:	83 ec 08             	sub    $0x8,%esp
	    free(path);
  1052b6:	6a 01                	push   $0x1
  1052b8:	ff 75 08             	pushl  0x8(%ebp)
  1052bb:	68 00 00 00 20       	push   $0x20000000
  1052c0:	68 00 10 40 01       	push   $0x1401000
  1052c5:	e8 cc fe ff ff       	call   105196 <vmm_alloc_in_range>
  1052ca:	83 c4 10             	add    $0x10,%esp

  1052cd:	c9                   	leave  
  1052ce:	c3                   	ret    

001052cf <vmm_alloc_addr>:
	    if(!open) {
	        cpu->eax = (uint32_t) -1;
  1052cf:	55                   	push   %ebp
  1052d0:	89 e5                	mov    %esp,%ebp
  1052d2:	83 ec 18             	sub    $0x18,%esp
	        break;
  1052d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1052d9:	75 1c                	jne    1052f7 <vmm_alloc_addr+0x28>
	    }
  1052db:	83 ec 04             	sub    $0x4,%esp
  1052de:	6a 00                	push   $0x0
  1052e0:	ff 75 08             	pushl  0x8(%ebp)
  1052e3:	68 e4 78 10 00       	push   $0x1078e4
  1052e8:	e8 80 b2 ff ff       	call   10056d <kprintf>
  1052ed:	83 c4 10             	add    $0x10,%esp

	    struct res_handle* oldhandle = 0;

  1052f0:	b8 00 00 00 00       	mov    $0x0,%eax
  1052f5:	eb 7b                	jmp    105372 <vmm_alloc_addr+0xa3>
        switch(cpu->ebx) {
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  1052f7:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1052fc:	8b 55 08             	mov    0x8(%ebp),%edx
  1052ff:	c1 ea 0c             	shr    $0xc,%edx
  105302:	c1 e2 02             	shl    $0x2,%edx
  105305:	01 d0                	add    %edx,%eax
  105307:	8b 00                	mov    (%eax),%eax
  105309:	25 01 02 00 00       	and    $0x201,%eax
  10530e:	3d 00 02 00 00       	cmp    $0x200,%eax
  105313:	74 2d                	je     105342 <vmm_alloc_addr+0x73>
            get_current_task()->stdout = open;
            break;
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  105315:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  10531a:	8b 55 08             	mov    0x8(%ebp),%edx
  10531d:	c1 ea 0c             	shr    $0xc,%edx
  105320:	c1 e2 02             	shl    $0x2,%edx
  105323:	01 d0                	add    %edx,%eax

        switch(cpu->ebx) {
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
            get_current_task()->stdout = open;
            break;
  105325:	8b 00                	mov    (%eax),%eax
  105327:	83 ec 04             	sub    $0x4,%esp
  10532a:	50                   	push   %eax
  10532b:	ff 75 08             	pushl  0x8(%ebp)
  10532e:	68 e4 78 10 00       	push   $0x1078e4
  105333:	e8 35 b2 ff ff       	call   10056d <kprintf>
  105338:	83 c4 10             	add    $0x10,%esp
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
            get_current_task()->stdin = open;
  10533b:	b8 00 00 00 00       	mov    $0x0,%eax
  105340:	eb 30                	jmp    105372 <vmm_alloc_addr+0xa3>
            break;
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  105342:	e8 ed c6 ff ff       	call   101a34 <pmm_alloc>
  105347:	89 45 f4             	mov    %eax,-0xc(%ebp)
            get_current_task()->stderr = open;
  10534a:	8b 45 08             	mov    0x8(%ebp),%eax
  10534d:	83 ec 04             	sub    $0x4,%esp
  105350:	68 04 02 00 00       	push   $0x204
  105355:	ff 75 f4             	pushl  -0xc(%ebp)
  105358:	50                   	push   %eax
  105359:	e8 06 fd ff ff       	call   105064 <map_address_active>
  10535e:	83 c4 10             	add    $0x10,%esp
            break;
        default:
  105361:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  105365:	74 08                	je     10536f <vmm_alloc_addr+0xa0>
            oldhandle = get_current_task()->stdout;
  105367:	8b 45 0c             	mov    0xc(%ebp),%eax
  10536a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10536d:	89 10                	mov    %edx,(%eax)
            get_current_task()->stdout = open;
            break;
  10536f:	8b 45 08             	mov    0x8(%ebp),%eax
        }
  105372:	c9                   	leave  
  105373:	c3                   	ret    

00105374 <vmm_activate_pagedir>:

        if(oldhandle != 0) {
  105374:	55                   	push   %ebp
  105375:	89 e5                	mov    %esp,%ebp
            vfs_close(oldhandle);
  105377:	8b 45 08             	mov    0x8(%ebp),%eax
  10537a:	a3 64 85 12 00       	mov    %eax,0x128564
        }
  10537f:	8b 45 08             	mov    0x8(%ebp),%eax
  105382:	0f 22 d8             	mov    %eax,%cr3

  105385:	5d                   	pop    %ebp
  105386:	c3                   	ret    

00105387 <vmm_init>:
        cpu->eax = 0;
	}
  105387:	55                   	push   %ebp
  105388:	89 e5                	mov    %esp,%ebp
  10538a:	53                   	push   %ebx
  10538b:	83 ec 24             	sub    $0x24,%esp
	    break;

	case 30: /* return_rpc */
  10538e:	e8 a1 c6 ff ff       	call   101a34 <pmm_alloc>
  105393:	89 45 e0             	mov    %eax,-0x20(%ebp)
	{
	    cpu = return_rpc_call(cpu);
	}
  105396:	e8 99 c6 ff ff       	call   101a34 <pmm_alloc>
  10539b:	89 c2                	mov    %eax,%edx
  10539d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053a0:	89 10                	mov    %edx,(%eax)
	    break;

  1053a2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1053a9:	e9 d3 00 00 00       	jmp    105481 <vmm_init+0xfa>
	case 31: /* call_rpc */
  1053ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053b1:	8b 00                	mov    (%eax),%eax
  1053b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1053b6:	c1 e2 02             	shl    $0x2,%edx
  1053b9:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  1053bc:	e8 73 c6 ff ff       	call   101a34 <pmm_alloc>
  1053c1:	89 03                	mov    %eax,(%ebx)
	{
  1053c3:	83 7d e4 7f          	cmpl   $0x7f,-0x1c(%ebp)
  1053c7:	77 19                	ja     1053e2 <vmm_init+0x5b>
	    int PID = cpu->ebx;
  1053c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1053cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1053cf:	8b 12                	mov    (%edx),%edx
  1053d1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1053d4:	c1 e1 02             	shl    $0x2,%ecx
  1053d7:	01 ca                	add    %ecx,%edx
  1053d9:	8b 12                	mov    (%edx),%edx
  1053db:	89 14 85 e0 87 1c 00 	mov    %edx,0x1c87e0(,%eax,4)

	    //TODO create RPC for U2U
	}
  1053e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053e5:	8b 00                	mov    (%eax),%eax
  1053e7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1053ea:	c1 e2 02             	shl    $0x2,%edx
  1053ed:	8d 14 10             	lea    (%eax,%edx,1),%edx
  1053f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1053f3:	8b 00                	mov    (%eax),%eax
  1053f5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1053f8:	c1 e1 02             	shl    $0x2,%ecx
  1053fb:	01 c8                	add    %ecx,%eax
  1053fd:	8b 00                	mov    (%eax),%eax
  1053ff:	83 c8 07             	or     $0x7,%eax
  105402:	89 02                	mov    %eax,(%edx)
	    break;

  105404:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10540b:	eb 68                	jmp    105475 <vmm_init+0xee>
	case 32: /* set_rpc_handler */
  10540d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105410:	89 c2                	mov    %eax,%edx
  105412:	c1 e2 16             	shl    $0x16,%edx
  105415:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105418:	c1 e0 0c             	shl    $0xc,%eax
  10541b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  10541e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
	    uint32_t handlerAddr = cpu->ebx;
  105421:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105424:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  10542b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10542e:	8b 00                	mov    (%eax),%eax
  105430:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  105433:	c1 e2 02             	shl    $0x2,%edx
  105436:	01 d0                	add    %edx,%eax
  105438:	8b 00                	mov    (%eax),%eax
  10543a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10543f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  105442:	89 c1                	mov    %eax,%ecx
  105444:	81 7d f0 00 10 40 01 	cmpl   $0x1401000,-0x10(%ebp)
  10544b:	76 07                	jbe    105454 <vmm_init+0xcd>
  10544d:	ba 00 02 00 00       	mov    $0x200,%edx
  105452:	eb 05                	jmp    105459 <vmm_init+0xd2>
  105454:	ba 00 00 00 00       	mov    $0x0,%edx
  105459:	81 7d f0 00 10 40 01 	cmpl   $0x1401000,-0x10(%ebp)
  105460:	76 07                	jbe    105469 <vmm_init+0xe2>
  105462:	b8 04 00 00 00       	mov    $0x4,%eax
  105467:	eb 05                	jmp    10546e <vmm_init+0xe7>
  105469:	b8 00 00 00 00       	mov    $0x0,%eax
  10546e:	09 d0                	or     %edx,%eax
  105470:	89 01                	mov    %eax,(%ecx)
	    int PID = cpu->ebx;

	    //TODO create RPC for U2U
	}
	    break;

  105472:	ff 45 e8             	incl   -0x18(%ebp)
  105475:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
  10547c:	76 8f                	jbe    10540d <vmm_init+0x86>
	case 30: /* return_rpc */
	{
	    cpu = return_rpc_call(cpu);
	}
	    break;

  10547e:	ff 45 e4             	incl   -0x1c(%ebp)
  105481:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
  105488:	0f 86 20 ff ff ff    	jbe    1053ae <vmm_init+0x27>
	    if(get_current_task()->rpc_handler_addr == 0) {
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
	}
	    break;

  10548e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  105495:	eb 3d                	jmp    1054d4 <vmm_init+0x14d>
	case 33: /* fetch_rpc_data */
  105497:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10549a:	8b 00                	mov    (%eax),%eax
  10549c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  10549f:	c1 e2 02             	shl    $0x2,%edx
  1054a2:	01 d0                	add    %edx,%eax
  1054a4:	8b 00                	mov    (%eax),%eax
  1054a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1054ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
	{
	    cpu->eax = 0;
  1054ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1054b1:	89 c2                	mov    %eax,%edx
  1054b3:	c1 e2 0c             	shl    $0xc,%edx
	    }
	}
	    break;

	case 33: /* fetch_rpc_data */
	{
  1054b6:	a1 fc 60 10 00       	mov    0x1060fc,%eax
  1054bb:	01 c2                	add    %eax,%edx
  1054bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1054c0:	8b 00                	mov    (%eax),%eax
  1054c2:	6a 00                	push   $0x0
  1054c4:	ff 75 f4             	pushl  -0xc(%ebp)
  1054c7:	52                   	push   %edx
  1054c8:	50                   	push   %eax
  1054c9:	e8 12 fb ff ff       	call   104fe0 <map_address_context>
  1054ce:	83 c4 10             	add    $0x10,%esp
	    if(get_current_task()->rpc_handler_addr == 0) {
	        get_current_task()->rpc_handler_addr = handlerAddr;
	    }
	}
	    break;

  1054d1:	ff 45 e4             	incl   -0x1c(%ebp)
  1054d4:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
  1054db:	76 ba                	jbe    105497 <vmm_init+0x110>
	case 33: /* fetch_rpc_data */
	{
	    cpu->eax = 0;
	    void* dest = (void*) cpu->ebx;
	    if(get_current_task()->rpc != 0) {
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
  1054dd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1054e0:	a1 00 61 10 00       	mov    0x106100,%eax
  1054e5:	89 c2                	mov    %eax,%edx
  1054e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1054ea:	8b 00                	mov    (%eax),%eax
  1054ec:	6a 00                	push   $0x0
  1054ee:	51                   	push   %ecx
  1054ef:	52                   	push   %edx
  1054f0:	50                   	push   %eax
  1054f1:	e8 ea fa ff ff       	call   104fe0 <map_address_context>
  1054f6:	83 c4 10             	add    $0x10,%esp
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
  1054f9:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
  105500:	eb 1d                	jmp    10551f <vmm_init+0x198>
	    break;
  105502:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105505:	8b 00                	mov    (%eax),%eax
  105507:	6a 00                	push   $0x0
  105509:	ff 75 e4             	pushl  -0x1c(%ebp)
  10550c:	ff 75 e4             	pushl  -0x1c(%ebp)
  10550f:	50                   	push   %eax
  105510:	e8 cb fa ff ff       	call   104fe0 <map_address_context>
  105515:	83 c4 10             	add    $0x10,%esp
	    void* dest = (void*) cpu->ebx;
	    if(get_current_task()->rpc != 0) {
	        memcpy(dest, get_current_task()->rpc->data, get_current_task()->rpc->dataSize);
	        cpu->eax = get_current_task()->rpc->dataSize;
	    }
	}
  105518:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
  10551f:	b8 00 90 1c 00       	mov    $0x1c9000,%eax
  105524:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  105527:	72 d9                	jb     105502 <vmm_init+0x17b>
	    break;

	case 40:
	{
	    cpu->eax = register_irq_rpc(cpu->ebx);
	}
  105529:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10552c:	8b 00                	mov    (%eax),%eax
  10552e:	83 ec 0c             	sub    $0xc,%esp
  105531:	50                   	push   %eax
  105532:	e8 3d fe ff ff       	call   105374 <vmm_activate_pagedir>
  105537:	83 c4 10             	add    $0x10,%esp
	    break;

	case 50:
	{
  10553a:	0f 20 c0             	mov    %cr0,%eax
  10553d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    cpu->eax = require_port((uint16_t)cpu->ebx);
  105540:	81 4d ec 00 00 00 80 	orl    $0x80000000,-0x14(%ebp)
	}
  105547:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10554a:	0f 22 c0             	mov    %eax,%cr0
	    break;

  10554d:	a1 00 61 10 00       	mov    0x106100,%eax
  105552:	8b 00                	mov    (%eax),%eax
	case 51:
  105554:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  105557:	c9                   	leave  
  105558:	c3                   	ret    
