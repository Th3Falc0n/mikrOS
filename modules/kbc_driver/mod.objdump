
../../initrfs/ibin/drivers/kbc:     file format elf32-i386
../../initrfs/ibin/drivers/kbc
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x40000866

Program Header:
    LOAD off    0x00001000 vaddr 0x40000000 paddr 0x40000000 align 2**12
         filesz 0x000016f4 memsz 0x000016f4 flags r-x
    LOAD off    0x00003000 vaddr 0x40002000 paddr 0x40002000 align 2**12
         filesz 0x000012b2 memsz 0x00002640 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000016f4  40000000  40000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000200  40002000  40002000  00003000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       00000128  40003000  40003000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 0000018a  40003128  40003128  00004128  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          00000640  40004000  40004000  000042b2  2**5
                  ALLOC
  5 .stab         0000531c  00000000  00000000  000042b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000090  00000000  00000000  000095d0  2**0
                  CONTENTS, READONLY
  7 .stabstr      00001b6f  00000000  00000000  00009660  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
40000000 l    d  .text	00000000 .text
40002000 l    d  .data	00000000 .data
40003000 l    d  .rodata	00000000 .rodata
40003128 l    d  .rodata.str1.1	00000000 .rodata.str1.1
40004000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 kbc_driver.c
40002000 l     O .data	00000100 sc_to_kc
40002100 l     O .data	00000100 kc_to_char
40000000 l     F .text	00000088 translate_scancode
40000088 l     F .text	00000053 getcharfromkc
400000db l     F .text	00000068 send_command
40004008 l     O .bss	00000004 e1_code.1042
4000400c l     O .bss	00000004 e0_code.1041
40004010 l     O .bss	00000002 e1_prev.1043
00000000 l    df *ABS*	00000000 process.c
40004014 l     O .bss	00000200 irq_handlers
40003110 l     O .rodata	00000018 C.7.1019
400008d8 l     F .text	000000c0 _handle_rpc
00000000 l    df *ABS*	00000000 stdio.c
40000998 l     F .text	00000047 resolveHandle
40000e48 l     F .text	0000004a printrwerror
40000c95 l     F .text	0000003f putn
00000000 l    df *ABS*	00000000 string.c
00000000 l    df *ABS*	00000000 stdlib.c
4000133c l     F .text	00000069 pop_unused_node
00000000 l    df *ABS*	00000000 vmmcall.c
00000000 l    df *ABS*	00000000 ports.c
00000000 l    df *ABS*	00000000 syscall.c
4000065c g     F .text	0000003d getExecPath
40000d4c g     F .text	00000014 putchar
400010f9 g     F .text	00000033 strcpy
400006df g     F .text	0000003e yield
40000d60 g     F .text	000000e8 printf
400016a4 g     F .text	00000050 syscall
40004000 g     O .bss	00000004 init_done
40000f5d g     F .text	00000042 fgets
40000f51 g     F .text	0000000c getc
40001028 g     F .text	00000026 memcpy
40000c83 g     F .text	00000012 puts
4000071d g     F .text	0000003d pexists
400013a5 g     F .text	000000f8 malloc
400007b2 g     F .text	0000003d fetch_rpc_data
4000112c g     F .text	000000a5 strtoknc
400005f2 g     F .text	0000003d changeExecPath
40001665 g     F .text	0000003e require_port
400015ec g     F .text	0000003d port_in
40004224 g     O .bss	00000004 first_free
4000057f g     F .text	00000037 dexec
40001629 g     F .text	0000003c port_out
40000b32 g     F .text	00000012 setstdout
400014fd g     F .text	00000034 calloc
400005b6 g     F .text	0000003c getExecPathChild
400015af g     F .text	0000003d vmm_alloc_cont
4000050d g     F .text	0000003b exec
40000866 g     F .text	00000072 _start
4000149d g     F .text	00000060 realloc
40000829 g     F .text	0000003d set_rpc_handler
4000120a g     F .text	00000052 strtok
4000104e g     F .text	00000047 memcmp
40000548 g     F .text	00000037 sexec
40000e92 g     F .text	00000085 fread
4000421c g     O .bss	00000004 first_unused
40000a96 g     F .text	0000003c fopen
4000100c g     F .text	0000001c memset
40000328 g     F .text	00000171 main
40000a59 g     F .text	0000003d fclose
40000f42 g     F .text	0000000f getchar
40004240 g     O .bss	00000400 key_flags
40000f9f g     F .text	0000006c getln
40004218 g     O .bss	00000004 fr
40000a1c g     F .text	0000003d favailable
40000d39 g     F .text	00000013 putc
40004004 g     O .bss	00000004 charout
40001095 g     F .text	00000049 strcmp
40000f17 g     F .text	0000002b fgetc
40004214 g     O .bss	00000004 sp
4000062f g     F .text	0000002d cd
40000143 g     F .text	000001e5 irq_handler
40004220 g     O .bss	00000004 first_used
40000cd4 g     F .text	00000065 fputc
40000b82 g     F .text	00000093 fwrite
40000b20 g     F .text	00000012 setstdin
400011d1 g     F .text	00000039 strclone
40000699 g     F .text	00000046 exit
4000075a g     F .text	00000058 register_irq_handler
40000ad2 g     F .text	0000003c fopenpmhandle
40001572 g     F .text	0000003d vmm_free
4000049c g     F .text	00000071 printFilesystemError
400010de g     F .text	0000001b strlen
40000b44 g     F .text	0000003e getLastVFSErr
40000c15 g     F .text	0000006e fputs
400009df g     F .text	0000003d fmkfifo
400007ef g     F .text	0000003a call_rpc
40000b0e g     F .text	00000012 setstderr
40001534 g     F .text	0000003e print_memstat
4000125c g     F .text	000000e0 free



Disassembly of section .text:

40000000 <translate_scancode>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000000:	55                   	push   %ebp
40000001:	89 e5                	mov    %esp,%ebp
40000003:	83 ec 28             	sub    $0x28,%esp
40000006:	8b 45 0c             	mov    0xc(%ebp),%eax
40000009:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    uint8_t keycode = 0;
4000000d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    switch (set) {
40000011:	8b 45 08             	mov    0x8(%ebp),%eax
40000014:	83 f8 01             	cmp    $0x1,%eax
40000017:	74 1c                	je     40000035 <translate_scancode+0x35>
40000019:	83 f8 02             	cmp    $0x2,%eax
4000001c:	74 2a                	je     40000048 <translate_scancode+0x48>
4000001e:	85 c0                	test   %eax,%eax
40000020:	75 3f                	jne    40000061 <translate_scancode+0x61>
        // Normal scancodes
        case 0:
            keycode = sc_to_kc[0][scancode];
40000022:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000025:	25 ff ff 00 00       	and    $0xffff,%eax
4000002a:	8a 80 00 20 00 40    	mov    0x40002000(%eax),%al
40000030:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
40000033:	eb 2c                	jmp    40000061 <translate_scancode+0x61>

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
40000035:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000038:	25 ff ff 00 00       	and    $0xffff,%eax
4000003d:	8a 80 80 20 00 40    	mov    0x40002080(%eax),%al
40000043:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
40000046:	eb 19                	jmp    40000061 <translate_scancode+0x61>

        // e1-Scancodes
        case 2:
            switch (scancode) {
40000048:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000004b:	25 ff ff 00 00       	and    $0xffff,%eax
40000050:	3d 1d 45 00 00       	cmp    $0x451d,%eax
40000055:	75 06                	jne    4000005d <translate_scancode+0x5d>
                // Pause
                case 0x451D:
                    keycode = 119;
40000057:	c6 45 f7 77          	movb   $0x77,-0x9(%ebp)
                    break;
4000005b:	eb 04                	jmp    40000061 <translate_scancode+0x61>

                default:
                    keycode = 0x0;
4000005d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
            };
            break;
    }

    if (keycode == 0) {
40000061:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
40000065:	75 1c                	jne    40000083 <translate_scancode+0x83>
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
40000067:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000006a:	25 ff ff 00 00       	and    $0xffff,%eax
4000006f:	83 ec 04             	sub    $0x4,%esp
40000072:	ff 75 08             	pushl  0x8(%ebp)
40000075:	50                   	push   %eax
40000076:	68 00 30 00 40       	push   $0x40003000
4000007b:	e8 e0 0c 00 00       	call   40000d60 <printf>
40000080:	83 c4 10             	add    $0x10,%esp
    }

    return keycode;
40000083:	8a 45 f7             	mov    -0x9(%ebp),%al
}
40000086:	c9                   	leave  
40000087:	c3                   	ret    

40000088 <getcharfromkc>:

static char getcharfromkc(uint8_t keycode) {
40000088:	55                   	push   %ebp
40000089:	89 e5                	mov    %esp,%ebp
4000008b:	83 ec 14             	sub    $0x14,%esp
4000008e:	8b 45 08             	mov    0x8(%ebp),%eax
40000091:	88 45 ec             	mov    %al,-0x14(%ebp)
    uint32_t index = 0;
40000094:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
4000009b:	a1 e8 42 00 40       	mov    0x400042e8,%eax
400000a0:	83 e0 01             	and    $0x1,%eax
400000a3:	84 c0                	test   %al,%al
400000a5:	74 07                	je     400000ae <getcharfromkc+0x26>
400000a7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
400000ae:	a1 18 43 00 40       	mov    0x40004318,%eax
400000b3:	83 e0 01             	and    $0x1,%eax
400000b6:	84 c0                	test   %al,%al
400000b8:	74 07                	je     400000c1 <getcharfromkc+0x39>
400000ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

    return kc_to_char[index][keycode];
400000c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
400000c4:	b8 00 00 00 00       	mov    $0x0,%eax
400000c9:	8a 45 ec             	mov    -0x14(%ebp),%al
400000cc:	c1 e2 07             	shl    $0x7,%edx
400000cf:	8d 04 02             	lea    (%edx,%eax,1),%eax
400000d2:	05 00 21 00 40       	add    $0x40002100,%eax
400000d7:	8a 00                	mov    (%eax),%al
}
400000d9:	c9                   	leave  
400000da:	c3                   	ret    

400000db <send_command>:

static void send_command(uint8_t command)
{
400000db:	55                   	push   %ebp
400000dc:	89 e5                	mov    %esp,%ebp
400000de:	83 ec 18             	sub    $0x18,%esp
400000e1:	8b 45 08             	mov    0x8(%ebp),%eax
400000e4:	88 45 f4             	mov    %al,-0xc(%ebp)
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
400000e7:	83 ec 08             	sub    $0x8,%esp
400000ea:	6a 64                	push   $0x64
400000ec:	6a 00                	push   $0x0
400000ee:	e8 f9 14 00 00       	call   400015ec <port_in>
400000f3:	83 c4 10             	add    $0x10,%esp
400000f6:	83 e0 02             	and    $0x2,%eax
400000f9:	85 c0                	test   %eax,%eax
400000fb:	75 ea                	jne    400000e7 <send_command+0xc>
        }

        port_out(PORTM_BYTE, 0x60, command);
400000fd:	b8 00 00 00 00       	mov    $0x0,%eax
40000102:	8a 45 f4             	mov    -0xc(%ebp),%al
40000105:	83 ec 04             	sub    $0x4,%esp
40000108:	50                   	push   %eax
40000109:	6a 60                	push   $0x60
4000010b:	6a 00                	push   $0x0
4000010d:	e8 17 15 00 00       	call   40001629 <port_out>
40000112:	83 c4 10             	add    $0x10,%esp

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000115:	83 ec 08             	sub    $0x8,%esp
40000118:	6a 64                	push   $0x64
4000011a:	6a 00                	push   $0x0
4000011c:	e8 cb 14 00 00       	call   400015ec <port_in>
40000121:	83 c4 10             	add    $0x10,%esp
40000124:	83 e0 01             	and    $0x1,%eax
40000127:	85 c0                	test   %eax,%eax
40000129:	74 ea                	je     40000115 <send_command+0x3a>
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000012b:	83 ec 08             	sub    $0x8,%esp
4000012e:	6a 60                	push   $0x60
40000130:	6a 00                	push   $0x0
40000132:	e8 b5 14 00 00       	call   400015ec <port_in>
40000137:	83 c4 10             	add    $0x10,%esp
4000013a:	3d fe 00 00 00       	cmp    $0xfe,%eax
4000013f:	74 a6                	je     400000e7 <send_command+0xc>
}
40000141:	c9                   	leave  
40000142:	c3                   	ret    

40000143 <irq_handler>:

void irq_handler(uint32_t irq) {
40000143:	55                   	push   %ebp
40000144:	89 e5                	mov    %esp,%ebp
40000146:	83 ec 18             	sub    $0x18,%esp
    uint8_t scancode;
    uint8_t keycode = 0;
40000149:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int break_code = 0;
4000014d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000154:	a1 00 40 00 40       	mov    0x40004000,%eax
40000159:	85 c0                	test   %eax,%eax
4000015b:	0f 84 c4 01 00 00    	je     40000325 <irq_handler+0x1e2>

    scancode = port_in(PORTM_BYTE, 0x60);
40000161:	83 ec 08             	sub    $0x8,%esp
40000164:	6a 60                	push   $0x60
40000166:	6a 00                	push   $0x0
40000168:	e8 7f 14 00 00       	call   400015ec <port_in>
4000016d:	83 c4 10             	add    $0x10,%esp
40000170:	88 45 f2             	mov    %al,-0xe(%ebp)

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
40000173:	8a 45 f2             	mov    -0xe(%ebp),%al
40000176:	84 c0                	test   %al,%al
40000178:	79 29                	jns    400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
4000017a:	a1 08 40 00 40       	mov    0x40004008,%eax

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000017f:	85 c0                	test   %eax,%eax
40000181:	75 06                	jne    40000189 <irq_handler+0x46>
40000183:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
40000187:	74 1a                	je     400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
40000189:	a1 0c 40 00 40       	mov    0x4000400c,%eax

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000018e:	85 c0                	test   %eax,%eax
40000190:	75 06                	jne    40000198 <irq_handler+0x55>
40000192:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
40000196:	74 0b                	je     400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000198:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        scancode &= ~0x80;
4000019f:	80 65 f2 7f          	andb   $0x7f,-0xe(%ebp)
    }

    if (e0_code) {
400001a3:	a1 0c 40 00 40       	mov    0x4000400c,%eax
400001a8:	85 c0                	test   %eax,%eax
400001aa:	74 43                	je     400001ef <irq_handler+0xac>
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
400001ac:	80 7d f2 2a          	cmpb   $0x2a,-0xe(%ebp)
400001b0:	74 06                	je     400001b8 <irq_handler+0x75>
400001b2:	80 7d f2 36          	cmpb   $0x36,-0xe(%ebp)
400001b6:	75 0f                	jne    400001c7 <irq_handler+0x84>
            e0_code = 0;
400001b8:	c7 05 0c 40 00 40 00 	movl   $0x0,0x4000400c
400001bf:	00 00 00 
            return;
400001c2:	e9 5f 01 00 00       	jmp    40000326 <irq_handler+0x1e3>
        }

        keycode = translate_scancode(1, scancode);
400001c7:	b8 00 00 00 00       	mov    $0x0,%eax
400001cc:	8a 45 f2             	mov    -0xe(%ebp),%al
400001cf:	83 ec 08             	sub    $0x8,%esp
400001d2:	50                   	push   %eax
400001d3:	6a 01                	push   $0x1
400001d5:	e8 26 fe ff ff       	call   40000000 <translate_scancode>
400001da:	83 c4 10             	add    $0x10,%esp
400001dd:	88 45 f3             	mov    %al,-0xd(%ebp)
        e0_code = 0;
400001e0:	c7 05 0c 40 00 40 00 	movl   $0x0,0x4000400c
400001e7:	00 00 00 
400001ea:	e9 af 00 00 00       	jmp    4000029e <irq_handler+0x15b>
    } else if (e1_code == 2) {
400001ef:	a1 08 40 00 40       	mov    0x40004008,%eax
400001f4:	83 f8 02             	cmp    $0x2,%eax
400001f7:	75 43                	jne    4000023c <irq_handler+0xf9>
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
400001f9:	b8 00 00 00 00       	mov    $0x0,%eax
400001fe:	8a 45 f2             	mov    -0xe(%ebp),%al
40000201:	c1 e0 08             	shl    $0x8,%eax
40000204:	89 c2                	mov    %eax,%edx
40000206:	66 a1 10 40 00 40    	mov    0x40004010,%ax
4000020c:	09 d0                	or     %edx,%eax
4000020e:	66 a3 10 40 00 40    	mov    %ax,0x40004010
        keycode = translate_scancode(2, e1_prev);
40000214:	66 a1 10 40 00 40    	mov    0x40004010,%ax
4000021a:	25 ff ff 00 00       	and    $0xffff,%eax
4000021f:	83 ec 08             	sub    $0x8,%esp
40000222:	50                   	push   %eax
40000223:	6a 02                	push   $0x2
40000225:	e8 d6 fd ff ff       	call   40000000 <translate_scancode>
4000022a:	83 c4 10             	add    $0x10,%esp
4000022d:	88 45 f3             	mov    %al,-0xd(%ebp)
        e1_code = 0;
40000230:	c7 05 08 40 00 40 00 	movl   $0x0,0x40004008
40000237:	00 00 00 
4000023a:	eb 62                	jmp    4000029e <irq_handler+0x15b>
    } else if (e1_code == 1) {
4000023c:	a1 08 40 00 40       	mov    0x40004008,%eax
40000241:	83 f8 01             	cmp    $0x1,%eax
40000244:	75 1b                	jne    40000261 <irq_handler+0x11e>
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
40000246:	b8 00 00 00 00       	mov    $0x0,%eax
4000024b:	8a 45 f2             	mov    -0xe(%ebp),%al
4000024e:	66 a3 10 40 00 40    	mov    %ax,0x40004010
        e1_code++;
40000254:	a1 08 40 00 40       	mov    0x40004008,%eax
40000259:	40                   	inc    %eax
4000025a:	a3 08 40 00 40       	mov    %eax,0x40004008
4000025f:	eb 3d                	jmp    4000029e <irq_handler+0x15b>
    } else if (scancode == 0xE0) {
40000261:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
40000265:	75 0c                	jne    40000273 <irq_handler+0x130>
        // Anfang eines e0-Codes
        e0_code = 1;
40000267:	c7 05 0c 40 00 40 01 	movl   $0x1,0x4000400c
4000026e:	00 00 00 
40000271:	eb 2b                	jmp    4000029e <irq_handler+0x15b>
    } else if (scancode == 0xE1) {
40000273:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
40000277:	75 0c                	jne    40000285 <irq_handler+0x142>
        // Anfang eines e1-Codes
        e1_code = 1;
40000279:	c7 05 08 40 00 40 01 	movl   $0x1,0x40004008
40000280:	00 00 00 
40000283:	eb 19                	jmp    4000029e <irq_handler+0x15b>
    } else {
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
40000285:	b8 00 00 00 00       	mov    $0x0,%eax
4000028a:	8a 45 f2             	mov    -0xe(%ebp),%al
4000028d:	83 ec 08             	sub    $0x8,%esp
40000290:	50                   	push   %eax
40000291:	6a 00                	push   $0x0
40000293:	e8 68 fd ff ff       	call   40000000 <translate_scancode>
40000298:	83 c4 10             	add    $0x10,%esp
4000029b:	88 45 f3             	mov    %al,-0xd(%ebp)
    }

    if(break_code) {
4000029e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400002a2:	74 23                	je     400002c7 <irq_handler+0x184>
        key_flags[keycode] &= ~KF_PRESSED;
400002a4:	b8 00 00 00 00       	mov    $0x0,%eax
400002a9:	8a 45 f3             	mov    -0xd(%ebp),%al
400002ac:	ba 00 00 00 00       	mov    $0x0,%edx
400002b1:	8a 55 f3             	mov    -0xd(%ebp),%dl
400002b4:	8b 14 95 40 42 00 40 	mov    0x40004240(,%edx,4),%edx
400002bb:	83 e2 fe             	and    $0xfffffffe,%edx
400002be:	89 14 85 40 42 00 40 	mov    %edx,0x40004240(,%eax,4)
400002c5:	eb 21                	jmp    400002e8 <irq_handler+0x1a5>
    }
    else
    {
        key_flags[keycode] |= KF_PRESSED;
400002c7:	b8 00 00 00 00       	mov    $0x0,%eax
400002cc:	8a 45 f3             	mov    -0xd(%ebp),%al
400002cf:	ba 00 00 00 00       	mov    $0x0,%edx
400002d4:	8a 55 f3             	mov    -0xd(%ebp),%dl
400002d7:	8b 14 95 40 42 00 40 	mov    0x40004240(,%edx,4),%edx
400002de:	83 ca 01             	or     $0x1,%edx
400002e1:	89 14 85 40 42 00 40 	mov    %edx,0x40004240(,%eax,4)
    }

    char chr = getcharfromkc(keycode);
400002e8:	b8 00 00 00 00       	mov    $0x0,%eax
400002ed:	8a 45 f3             	mov    -0xd(%ebp),%al
400002f0:	83 ec 0c             	sub    $0xc,%esp
400002f3:	50                   	push   %eax
400002f4:	e8 8f fd ff ff       	call   40000088 <getcharfromkc>
400002f9:	83 c4 10             	add    $0x10,%esp
400002fc:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(!break_code && chr) {
400002ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40000303:	75 21                	jne    40000326 <irq_handler+0x1e3>
40000305:	8a 45 f1             	mov    -0xf(%ebp),%al
40000308:	84 c0                	test   %al,%al
4000030a:	74 1a                	je     40000326 <irq_handler+0x1e3>
        fwrite(charout, &chr, sizeof(char));
4000030c:	a1 04 40 00 40       	mov    0x40004004,%eax
40000311:	83 ec 04             	sub    $0x4,%esp
40000314:	6a 01                	push   $0x1
40000316:	8d 55 f1             	lea    -0xf(%ebp),%edx
40000319:	52                   	push   %edx
4000031a:	50                   	push   %eax
4000031b:	e8 62 08 00 00       	call   40000b82 <fwrite>
40000320:	83 c4 10             	add    $0x10,%esp
40000323:	eb 01                	jmp    40000326 <irq_handler+0x1e3>

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000325:	90                   	nop    
    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
    }
}
40000326:	c9                   	leave  
40000327:	c3                   	ret    

40000328 <main>:

int main(int argc, char* args[])
{
40000328:	8d 4c 24 04          	lea    0x4(%esp),%ecx
4000032c:	83 e4 f0             	and    $0xfffffff0,%esp
4000032f:	ff 71 fc             	pushl  -0x4(%ecx)
40000332:	55                   	push   %ebp
40000333:	89 e5                	mov    %esp,%ebp
40000335:	51                   	push   %ecx
40000336:	83 ec 14             	sub    $0x14,%esp
    printf("[kbcdrv] requesting neccesary resources...\n");
40000339:	83 ec 0c             	sub    $0xc,%esp
4000033c:	68 24 30 00 40       	push   $0x40003024
40000341:	e8 1a 0a 00 00       	call   40000d60 <printf>
40000346:	83 c4 10             	add    $0x10,%esp

    register_irq_handler(0x21, &irq_handler);
40000349:	83 ec 08             	sub    $0x8,%esp
4000034c:	68 43 01 00 40       	push   $0x40000143
40000351:	6a 21                	push   $0x21
40000353:	e8 02 04 00 00       	call   4000075a <register_irq_handler>
40000358:	83 c4 10             	add    $0x10,%esp
    require_port(0x64);
4000035b:	83 ec 0c             	sub    $0xc,%esp
4000035e:	6a 64                	push   $0x64
40000360:	e8 00 13 00 00       	call   40001665 <require_port>
40000365:	83 c4 10             	add    $0x10,%esp
    require_port(0x60);
40000368:	83 ec 0c             	sub    $0xc,%esp
4000036b:	6a 60                	push   $0x60
4000036d:	e8 f3 12 00 00       	call   40001665 <require_port>
40000372:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] emptying keyboard buffer...\n");
40000375:	83 ec 0c             	sub    $0xc,%esp
40000378:	68 50 30 00 40       	push   $0x40003050
4000037d:	e8 de 09 00 00       	call   40000d60 <printf>
40000382:	83 c4 10             	add    $0x10,%esp

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
40000385:	eb 0f                	jmp    40000396 <main+0x6e>
        port_in(PORTM_BYTE, 0x60);
40000387:	83 ec 08             	sub    $0x8,%esp
4000038a:	6a 60                	push   $0x60
4000038c:	6a 00                	push   $0x0
4000038e:	e8 59 12 00 00       	call   400015ec <port_in>
40000393:	83 c4 10             	add    $0x10,%esp
    require_port(0x64);
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
40000396:	83 ec 08             	sub    $0x8,%esp
40000399:	6a 64                	push   $0x64
4000039b:	6a 00                	push   $0x0
4000039d:	e8 4a 12 00 00       	call   400015ec <port_in>
400003a2:	83 c4 10             	add    $0x10,%esp
400003a5:	83 e0 01             	and    $0x1,%eax
400003a8:	84 c0                	test   %al,%al
400003aa:	75 db                	jne    40000387 <main+0x5f>
        port_in(PORTM_BYTE, 0x60);
    }

    printf("[kbcdrv] initializing KBC...\n");
400003ac:	83 ec 0c             	sub    $0xc,%esp
400003af:	68 76 30 00 40       	push   $0x40003076
400003b4:	e8 a7 09 00 00       	call   40000d60 <printf>
400003b9:	83 c4 10             	add    $0x10,%esp

    memset(key_flags, 0, 256 * sizeof(uint32_t));
400003bc:	83 ec 04             	sub    $0x4,%esp
400003bf:	68 00 04 00 00       	push   $0x400
400003c4:	6a 00                	push   $0x0
400003c6:	68 40 42 00 40       	push   $0x40004240
400003cb:	e8 3c 0c 00 00       	call   4000100c <memset>
400003d0:	83 c4 10             	add    $0x10,%esp

    // Leds alle ausloeschen
    send_command(0xED);
400003d3:	83 ec 0c             	sub    $0xc,%esp
400003d6:	68 ed 00 00 00       	push   $0xed
400003db:	e8 fb fc ff ff       	call   400000db <send_command>
400003e0:	83 c4 10             	add    $0x10,%esp
    send_command(0);
400003e3:	83 ec 0c             	sub    $0xc,%esp
400003e6:	6a 00                	push   $0x0
400003e8:	e8 ee fc ff ff       	call   400000db <send_command>
400003ed:	83 c4 10             	add    $0x10,%esp

    // Schnellste Wiederholrate
    send_command(0xF3);
400003f0:	83 ec 0c             	sub    $0xc,%esp
400003f3:	68 f3 00 00 00       	push   $0xf3
400003f8:	e8 de fc ff ff       	call   400000db <send_command>
400003fd:	83 c4 10             	add    $0x10,%esp
    send_command(0);
40000400:	83 ec 0c             	sub    $0xc,%esp
40000403:	6a 00                	push   $0x0
40000405:	e8 d1 fc ff ff       	call   400000db <send_command>
4000040a:	83 c4 10             	add    $0x10,%esp

    send_command(0xF4);
4000040d:	83 ec 0c             	sub    $0xc,%esp
40000410:	68 f4 00 00 00       	push   $0xf4
40000415:	e8 c1 fc ff ff       	call   400000db <send_command>
4000041a:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
4000041d:	83 ec 0c             	sub    $0xc,%esp
40000420:	68 94 30 00 40       	push   $0x40003094
40000425:	e8 36 09 00 00       	call   40000d60 <printf>
4000042a:	83 c4 10             	add    $0x10,%esp

    charout = fmkfifo("/dev/keyboard");
4000042d:	83 ec 0c             	sub    $0xc,%esp
40000430:	68 c9 30 00 40       	push   $0x400030c9
40000435:	e8 a5 05 00 00       	call   400009df <fmkfifo>
4000043a:	83 c4 10             	add    $0x10,%esp
4000043d:	a3 04 40 00 40       	mov    %eax,0x40004004

    init_done = 1;
40000442:	c7 05 00 40 00 40 01 	movl   $0x1,0x40004000
40000449:	00 00 00 

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
4000044c:	83 ec 08             	sub    $0x8,%esp
4000044f:	6a 02                	push   $0x2
40000451:	68 d7 30 00 40       	push   $0x400030d7
40000456:	e8 3b 06 00 00       	call   40000a96 <fopen>
4000045b:	83 c4 10             	add    $0x10,%esp
4000045e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000461:	c6 45 f3 4b          	movb   $0x4b,-0xd(%ebp)
40000465:	83 ec 04             	sub    $0x4,%esp
40000468:	6a 01                	push   $0x1
4000046a:	8d 45 f3             	lea    -0xd(%ebp),%eax
4000046d:	50                   	push   %eax
4000046e:	ff 75 f4             	pushl  -0xc(%ebp)
40000471:	e8 0c 07 00 00       	call   40000b82 <fwrite>
40000476:	83 c4 10             	add    $0x10,%esp
    fclose(initCtrl);
40000479:	83 ec 0c             	sub    $0xc,%esp
4000047c:	ff 75 f4             	pushl  -0xc(%ebp)
4000047f:	e8 d5 05 00 00       	call   40000a59 <fclose>
40000484:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] Done!\n");
40000487:	83 ec 0c             	sub    $0xc,%esp
4000048a:	68 e7 30 00 40       	push   $0x400030e7
4000048f:	e8 cc 08 00 00       	call   40000d60 <printf>
40000494:	83 c4 10             	add    $0x10,%esp

    while(1);
40000497:	eb fe                	jmp    40000497 <main+0x16f>
40000499:	00 00                	add    %al,(%eax)
	...

4000049c <printFilesystemError>:
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }

4000049c:	55                   	push   %ebp
4000049d:	89 e5                	mov    %esp,%ebp
4000049f:	83 ec 08             	sub    $0x8,%esp
400004a2:	8b 55 0c             	mov    0xc(%ebp),%edx
400004a5:	8b 45 08             	mov    0x8(%ebp),%eax
    if (e0_code) {
400004a8:	83 fa 05             	cmp    $0x5,%edx
400004ab:	77 43                	ja     400004f0 <printFilesystemError+0x54>
400004ad:	ff 24 95 f8 30 00 40 	jmp    *0x400030f8(,%edx,4)
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
400004b4:	52                   	push   %edx
400004b5:	52                   	push   %edx
400004b6:	50                   	push   %eax
400004b7:	68 28 31 00 40       	push   $0x40003128
400004bc:	eb 3a                	jmp    400004f8 <printFilesystemError+0x5c>
            e0_code = 0;
            return;
        }
400004be:	51                   	push   %ecx
400004bf:	51                   	push   %ecx
400004c0:	50                   	push   %eax
400004c1:	68 3a 31 00 40       	push   $0x4000313a
400004c6:	eb 30                	jmp    400004f8 <printFilesystemError+0x5c>

        keycode = translate_scancode(1, scancode);
        e0_code = 0;
400004c8:	52                   	push   %edx
400004c9:	52                   	push   %edx
400004ca:	50                   	push   %eax
400004cb:	68 59 31 00 40       	push   $0x40003159
400004d0:	eb 26                	jmp    400004f8 <printFilesystemError+0x5c>
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
400004d2:	51                   	push   %ecx
400004d3:	51                   	push   %ecx
400004d4:	50                   	push   %eax
400004d5:	68 83 31 00 40       	push   $0x40003183
400004da:	eb 1c                	jmp    400004f8 <printFilesystemError+0x5c>
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
400004dc:	52                   	push   %edx
400004dd:	52                   	push   %edx
400004de:	50                   	push   %eax
400004df:	68 98 31 00 40       	push   $0x40003198
400004e4:	eb 12                	jmp    400004f8 <printFilesystemError+0x5c>
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
400004e6:	51                   	push   %ecx
400004e7:	51                   	push   %ecx
400004e8:	50                   	push   %eax
400004e9:	68 d3 31 00 40       	push   $0x400031d3
400004ee:	eb 08                	jmp    400004f8 <printFilesystemError+0x5c>
        e1_code++;
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
400004f0:	52                   	push   %edx
400004f1:	52                   	push   %edx
400004f2:	50                   	push   %eax
400004f3:	68 e6 31 00 40       	push   $0x400031e6
400004f8:	e8 63 08 00 00       	call   40000d60 <printf>
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
400004fd:	c7 45 08 03 32 00 40 	movl   $0x40003203,0x8(%ebp)
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
        e1_code++;
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
40000504:	83 c4 10             	add    $0x10,%esp
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
    } else {
40000507:	c9                   	leave  
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
40000508:	e9 53 08 00 00       	jmp    40000d60 <printf>

4000050d <exec>:
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
4000050d:	55                   	push   %ebp
4000050e:	89 e5                	mov    %esp,%ebp
40000510:	83 ec 34             	sub    $0x34,%esp
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000513:	8b 45 08             	mov    0x8(%ebp),%eax
40000516:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%ebp)
4000051d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000520:	8b 45 0c             	mov    0xc(%ebp),%eax
40000523:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000526:	8b 45 10             	mov    0x10(%ebp),%eax
40000529:	89 45 ec             	mov    %eax,-0x14(%ebp)
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000052c:	8d 45 e0             	lea    -0x20(%ebp),%eax
4000052f:	50                   	push   %eax
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000530:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000537:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000053e:	e8 61 11 00 00       	call   400016a4 <syscall>
}

void irq_handler(uint32_t irq) {
40000543:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000546:	c9                   	leave  
40000547:	c3                   	ret    

40000548 <sexec>:
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

40000548:	55                   	push   %ebp
40000549:	89 e5                	mov    %esp,%ebp
4000054b:	56                   	push   %esi
4000054c:	53                   	push   %ebx
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
4000054d:	53                   	push   %ebx
4000054e:	6a 01                	push   $0x1
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

40000550:	8b 75 08             	mov    0x8(%ebp),%esi
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
40000553:	ff 75 0c             	pushl  0xc(%ebp)
40000556:	56                   	push   %esi
40000557:	e8 b1 ff ff ff       	call   4000050d <exec>
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000055c:	83 c4 10             	add    $0x10,%esp

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
4000055f:	89 c3                	mov    %eax,%ebx
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
40000561:	85 c0                	test   %eax,%eax
40000563:	75 11                	jne    40000576 <sexec+0x2e>
        (e1_code || (scancode != 0xE1)) &&
40000565:	e8 da 05 00 00       	call   40000b44 <getLastVFSErr>
4000056a:	51                   	push   %ecx
4000056b:	51                   	push   %ecx
4000056c:	50                   	push   %eax
4000056d:	56                   	push   %esi
4000056e:	e8 29 ff ff ff       	call   4000049c <printFilesystemError>
40000573:	83 c4 10             	add    $0x10,%esp
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
40000576:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000579:	89 d8                	mov    %ebx,%eax
4000057b:	5b                   	pop    %ebx
4000057c:	5e                   	pop    %esi
4000057d:	5d                   	pop    %ebp
4000057e:	c3                   	ret    

4000057f <dexec>:
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
4000057f:	55                   	push   %ebp
40000580:	89 e5                	mov    %esp,%ebp
40000582:	56                   	push   %esi
40000583:	53                   	push   %ebx
    int break_code = 0;
40000584:	51                   	push   %ecx
40000585:	6a 00                	push   $0x0
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40000587:	8b 75 08             	mov    0x8(%ebp),%esi
    int break_code = 0;
4000058a:	ff 75 0c             	pushl  0xc(%ebp)
4000058d:	56                   	push   %esi
4000058e:	e8 7a ff ff ff       	call   4000050d <exec>

    static int      e0_code = 0;
40000593:	83 c4 10             	add    $0x10,%esp
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
    int break_code = 0;
40000596:	89 c3                	mov    %eax,%ebx

    static int      e0_code = 0;
40000598:	85 c0                	test   %eax,%eax
4000059a:	75 11                	jne    400005ad <dexec+0x2e>
    static int      e1_code = 0;
4000059c:	e8 a3 05 00 00       	call   40000b44 <getLastVFSErr>
400005a1:	52                   	push   %edx
400005a2:	52                   	push   %edx
400005a3:	50                   	push   %eax
400005a4:	56                   	push   %esi
400005a5:	e8 f2 fe ff ff       	call   4000049c <printFilesystemError>
400005aa:	83 c4 10             	add    $0x10,%esp
    static uint16_t e1_prev = 0;

    if(!init_done) return;

400005ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
400005b0:	89 d8                	mov    %ebx,%eax
400005b2:	5b                   	pop    %ebx
400005b3:	5e                   	pop    %esi
400005b4:	5d                   	pop    %ebp
400005b5:	c3                   	ret    

400005b6 <getExecPathChild>:
                    break;

                default:
                    keycode = 0x0;
            };
            break;
400005b6:	55                   	push   %ebp
400005b7:	89 e5                	mov    %esp,%ebp
400005b9:	83 ec 34             	sub    $0x34,%esp
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
400005bc:	8b 45 08             	mov    0x8(%ebp),%eax
400005bf:	c7 45 e0 11 00 00 00 	movl   $0x11,-0x20(%ebp)
400005c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400005c9:	8b 45 0c             	mov    0xc(%ebp),%eax
400005cc:	89 45 e8             	mov    %eax,-0x18(%ebp)

static char getcharfromkc(uint8_t keycode) {
400005cf:	8d 45 e0             	lea    -0x20(%ebp),%eax
400005d2:	50                   	push   %eax
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
400005d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400005da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400005e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

static char getcharfromkc(uint8_t keycode) {
400005e8:	e8 b7 10 00 00       	call   400016a4 <syscall>
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
400005ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
400005f0:	c9                   	leave  
400005f1:	c3                   	ret    

400005f2 <changeExecPath>:
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400005f2:	55                   	push   %ebp
400005f3:	89 e5                	mov    %esp,%ebp
400005f5:	83 ec 34             	sub    $0x34,%esp

        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
400005f8:	8b 45 08             	mov    0x8(%ebp),%eax
400005fb:	c7 45 e0 07 00 00 00 	movl   $0x7,-0x20(%ebp)
40000602:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    keycode = 119;
                    break;
40000605:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000608:	50                   	push   %eax

        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
40000609:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000610:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000617:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000061e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                    keycode = 119;
                    break;
40000625:	e8 7a 10 00 00       	call   400016a4 <syscall>

                default:
                    keycode = 0x0;
4000062a:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000062d:	c9                   	leave  
4000062e:	c3                   	ret    

4000062f <cd>:
static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

4000062f:	55                   	push   %ebp
40000630:	89 e5                	mov    %esp,%ebp
40000632:	53                   	push   %ebx
40000633:	83 ec 10             	sub    $0x10,%esp
40000636:	8b 5d 08             	mov    0x8(%ebp),%ebx
    return kc_to_char[index][keycode];
40000639:	53                   	push   %ebx
4000063a:	e8 b3 ff ff ff       	call   400005f2 <changeExecPath>
4000063f:	83 c4 10             	add    $0x10,%esp
40000642:	85 c0                	test   %eax,%eax
40000644:	75 11                	jne    40000657 <cd+0x28>
40000646:	e8 f9 04 00 00       	call   40000b44 <getLastVFSErr>
4000064b:	52                   	push   %edx
4000064c:	52                   	push   %edx
4000064d:	50                   	push   %eax
4000064e:	53                   	push   %ebx
4000064f:	e8 48 fe ff ff       	call   4000049c <printFilesystemError>
40000654:	83 c4 10             	add    $0x10,%esp
}
40000657:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000065a:	c9                   	leave  
4000065b:	c3                   	ret    

4000065c <getExecPath>:

#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;
4000065c:	55                   	push   %ebp
4000065d:	89 e5                	mov    %esp,%ebp
4000065f:	83 ec 34             	sub    $0x34,%esp
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
40000662:	8b 45 08             	mov    0x8(%ebp),%eax
40000665:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
4000066c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            keycode = sc_to_kc[0][scancode];
            break;
4000066f:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000672:	50                   	push   %eax
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
40000673:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000067a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000681:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000688:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            keycode = sc_to_kc[0][scancode];
            break;
4000068f:	e8 10 10 00 00       	call   400016a4 <syscall>
40000694:	83 c4 10             	add    $0x10,%esp

40000697:	c9                   	leave  
40000698:	c3                   	ret    

40000699 <exit>:
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
40000699:	55                   	push   %ebp
4000069a:	89 e5                	mov    %esp,%ebp
4000069c:	83 ec 34             	sub    $0x34,%esp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000069f:	8b 45 08             	mov    0x8(%ebp),%eax
400006a2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
400006a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
400006ac:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400006af:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400006b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400006bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400006c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
400006cb:	50                   	push   %eax
400006cc:	e8 d3 0f 00 00       	call   400016a4 <syscall>
};

#define KF_PRESSED (1 << 0)
400006d1:	c7 04 24 ee 31 00 40 	movl   $0x400031ee,(%esp)
400006d8:	e8 83 06 00 00       	call   40000d60 <printf>
400006dd:	eb f2                	jmp    400006d1 <exit+0x38>

400006df <yield>:
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400006df:	55                   	push   %ebp
400006e0:	89 e5                	mov    %esp,%ebp
400006e2:	83 ec 34             	sub    $0x34,%esp
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006e5:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400006e8:	c7 45 e0 05 00 00 00 	movl   $0x5,-0x20(%ebp)
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006ef:	50                   	push   %eax
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400006f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400006f7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400006fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000705:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000070c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000713:	e8 8c 0f 00 00       	call   400016a4 <syscall>
40000718:	83 c4 10             	add    $0x10,%esp
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
4000071b:	c9                   	leave  
4000071c:	c3                   	ret    

4000071d <pexists>:
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000071d:	55                   	push   %ebp
4000071e:	89 e5                	mov    %esp,%ebp
40000720:	83 ec 34             	sub    $0x34,%esp

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000723:	8b 45 08             	mov    0x8(%ebp),%eax
40000726:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
4000072d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000730:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000733:	50                   	push   %eax

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000734:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000073b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000742:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000749:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000750:	e8 4f 0f 00 00       	call   400016a4 <syscall>
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
40000755:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000758:	c9                   	leave  
40000759:	c3                   	ret    

4000075a <register_irq_handler>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
4000075a:	55                   	push   %ebp
4000075b:	89 e5                	mov    %esp,%ebp
4000075d:	53                   	push   %ebx
4000075e:	83 ec 30             	sub    $0x30,%esp
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000761:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000764:	8b 5d 08             	mov    0x8(%ebp),%ebx
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000767:	50                   	push   %eax
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000768:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
4000076f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40000772:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000779:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000780:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000787:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000078e:	e8 11 0f 00 00       	call   400016a4 <syscall>
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000793:	83 c4 10             	add    $0x10,%esp
40000796:	31 c0                	xor    %eax,%eax
40000798:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
4000079c:	74 0f                	je     400007ad <register_irq_handler+0x53>
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
4000079e:	8b 45 0c             	mov    0xc(%ebp),%eax
400007a1:	89 04 9d 14 40 00 40 	mov    %eax,0x40004014(,%ebx,4)
400007a8:	b8 01 00 00 00       	mov    $0x1,%eax
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400007ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400007b0:	c9                   	leave  
400007b1:	c3                   	ret    

400007b2 <fetch_rpc_data>:
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
400007b2:	55                   	push   %ebp
400007b3:	89 e5                	mov    %esp,%ebp
400007b5:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

400007b8:	8b 45 08             	mov    0x8(%ebp),%eax
400007bb:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
400007c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
400007c5:	8d 45 e0             	lea    -0x20(%ebp),%eax
400007c8:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

400007c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400007d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400007d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400007de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
400007e5:	e8 ba 0e 00 00       	call   400016a4 <syscall>
400007ea:	83 c4 10             	add    $0x10,%esp
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
400007ed:	c9                   	leave  
400007ee:	c3                   	ret    

400007ef <call_rpc>:
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007ef:	55                   	push   %ebp
400007f0:	89 e5                	mov    %esp,%ebp
400007f2:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007f5:	8b 45 08             	mov    0x8(%ebp),%eax
400007f8:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%ebp)
400007ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000802:	8b 45 0c             	mov    0xc(%ebp),%eax
40000805:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000808:	8b 45 10             	mov    0x10(%ebp),%eax
4000080b:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000080e:	8b 45 14             	mov    0x14(%ebp),%eax
40000811:	89 45 f0             	mov    %eax,-0x10(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000814:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000817:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000818:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000081f:	e8 80 0e 00 00       	call   400016a4 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
40000824:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000827:	c9                   	leave  
40000828:	c3                   	ret    

40000829 <set_rpc_handler>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000829:	55                   	push   %ebp
4000082a:	89 e5                	mov    %esp,%ebp
4000082c:	57                   	push   %edi
4000082d:	56                   	push   %esi
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
4000082e:	be 10 31 00 40       	mov    $0x40003110,%esi
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000833:	83 ec 24             	sub    $0x24,%esp
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
40000836:	8d 7d e0             	lea    -0x20(%ebp),%edi

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;
40000839:	68 00 02 00 00       	push   $0x200
4000083e:	6a 00                	push   $0x0
40000840:	68 14 40 00 40       	push   $0x40004014
40000845:	e8 c2 07 00 00       	call   4000100c <memset>
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
4000084a:	b9 06 00 00 00       	mov    $0x6,%ecx
            keycode = sc_to_kc[1][scancode];
            break;
4000084f:	8d 45 e0             	lea    -0x20(%ebp),%eax
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
40000852:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
            keycode = sc_to_kc[1][scancode];
            break;
40000854:	89 04 24             	mov    %eax,(%esp)
40000857:	e8 48 0e 00 00       	call   400016a4 <syscall>
4000085c:	83 c4 10             	add    $0x10,%esp

4000085f:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000862:	5e                   	pop    %esi
40000863:	5f                   	pop    %edi
40000864:	5d                   	pop    %ebp
40000865:	c3                   	ret    

40000866 <_start>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000866:	55                   	push   %ebp
40000867:	89 e5                	mov    %esp,%ebp
40000869:	56                   	push   %esi
4000086a:	53                   	push   %ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
4000086b:	31 db                	xor    %ebx,%ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000086d:	83 ec 2c             	sub    $0x2c,%esp
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
40000870:	8d 45 e0             	lea    -0x20(%ebp),%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000873:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
4000087a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
40000881:	50                   	push   %eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000882:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000889:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000890:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000897:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000089e:	e8 01 0e 00 00       	call   400016a4 <syscall>
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
400008a3:	8b 75 e0             	mov    -0x20(%ebp),%esi
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400008a6:	83 c4 10             	add    $0x10,%esp
400008a9:	85 f6                	test   %esi,%esi
400008ab:	75 05                	jne    400008b2 <_start+0x4c>
400008ad:	89 f3                	mov    %esi,%ebx
400008af:	eb 07                	jmp    400008b8 <_start+0x52>

static char kc_to_char[][128] = {
400008b1:	43                   	inc    %ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

400008b2:	83 3c 9e 00          	cmpl   $0x0,(%esi,%ebx,4)
400008b6:	75 f9                	jne    400008b1 <_start+0x4b>
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
400008b8:	e8 6c ff ff ff       	call   40000829 <set_rpc_handler>
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
400008bd:	51                   	push   %ecx
400008be:	51                   	push   %ecx
400008bf:	56                   	push   %esi
400008c0:	53                   	push   %ebx
400008c1:	e8 62 fa ff ff       	call   40000328 <main>
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
400008c6:	89 04 24             	mov    %eax,(%esp)
400008c9:	e8 cb fd ff ff       	call   40000699 <exit>
400008ce:	83 c4 10             	add    $0x10,%esp
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008d1:	8d 65 f8             	lea    -0x8(%ebp),%esp
400008d4:	5b                   	pop    %ebx
400008d5:	5e                   	pop    %esi
400008d6:	5d                   	pop    %ebp
400008d7:	c3                   	ret    

400008d8 <_handle_rpc>:
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400008d8:	55                   	push   %ebp
400008d9:	89 e5                	mov    %esp,%ebp
400008db:	56                   	push   %esi
400008dc:	53                   	push   %ebx
400008dd:	83 ec 2c             	sub    $0x2c,%esp
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400008e0:	ff 75 10             	pushl  0x10(%ebp)
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400008e3:	8b 75 0c             	mov    0xc(%ebp),%esi
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400008e6:	e8 ba 0a 00 00       	call   400013a5 <malloc>
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008eb:	89 04 24             	mov    %eax,(%esp)
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400008ee:	89 c3                	mov    %eax,%ebx
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008f0:	e8 bd fe ff ff       	call   400007b2 <fetch_rpc_data>
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008f5:	83 c4 10             	add    $0x10,%esp
400008f8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400008fc:	75 4b                	jne    40000949 <_handle_rpc+0x71>
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008fe:	8b 04 b5 14 40 00 40 	mov    0x40004014(,%esi,4),%eax
40000905:	85 c0                	test   %eax,%eax
40000907:	74 40                	je     40000949 <_handle_rpc+0x71>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000909:	83 ec 0c             	sub    $0xc,%esp
4000090c:	56                   	push   %esi
4000090d:	ff d0                	call   *%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000090f:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000912:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000919:	89 04 24             	mov    %eax,(%esp)
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000091c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000923:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000092a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000931:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000938:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000093f:	e8 60 0d 00 00       	call   400016a4 <syscall>
40000944:	83 c4 10             	add    $0x10,%esp
40000947:	eb fe                	jmp    40000947 <_handle_rpc+0x6f>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)

40000949:	83 ec 0c             	sub    $0xc,%esp
4000094c:	68 f5 31 00 40       	push   $0x400031f5
40000951:	e8 0a 04 00 00       	call   40000d60 <printf>
uint32_t key_flags[256];

40000956:	89 1c 24             	mov    %ebx,(%esp)
40000959:	e8 fe 08 00 00       	call   4000125c <free>
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000095e:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000961:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000968:	89 04 24             	mov    %eax,(%esp)
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000096b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000972:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000979:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000980:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000987:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000098e:	e8 11 0d 00 00       	call   400016a4 <syscall>
40000993:	83 c4 10             	add    $0x10,%esp
40000996:	eb fe                	jmp    40000996 <_handle_rpc+0xbe>

40000998 <resolveHandle>:
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
40000998:	55                   	push   %ebp
40000999:	89 e5                	mov    %esp,%ebp
4000099b:	83 ec 28             	sub    $0x28,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
4000099e:	3d fe 0f 00 00       	cmp    $0xffe,%eax
400009a3:	77 38                	ja     400009dd <resolveHandle+0x45>

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400009a5:	83 ec 0c             	sub    $0xc,%esp
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400009a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400009ab:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400009ae:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400009b5:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400009b6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400009bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400009c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400009cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400009d2:	e8 cd 0c 00 00       	call   400016a4 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400009d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
400009da:	83 c4 10             	add    $0x10,%esp
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400009dd:	c9                   	leave  
400009de:	c3                   	ret    

400009df <fmkfifo>:
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
400009df:	55                   	push   %ebp
400009e0:	89 e5                	mov    %esp,%ebp
400009e2:	83 ec 34             	sub    $0x34,%esp
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
400009e5:	8b 45 08             	mov    0x8(%ebp),%eax
400009e8:	c7 45 e0 0e 00 00 00 	movl   $0xe,-0x20(%ebp)
400009ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    } else {
        // Normaler Scancode
400009f2:	8d 45 e0             	lea    -0x20(%ebp),%eax
400009f5:	50                   	push   %eax
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
400009f6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400009fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    } else {
        // Normaler Scancode
40000a12:	e8 8d 0c 00 00       	call   400016a4 <syscall>
        keycode = translate_scancode(0, scancode);
    }

40000a17:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a1a:	c9                   	leave  
40000a1b:	c3                   	ret    

40000a1c <favailable>:
                case 0x451D:
                    keycode = 119;
                    break;

                default:
                    keycode = 0x0;
40000a1c:	55                   	push   %ebp
40000a1d:	89 e5                	mov    %esp,%ebp
40000a1f:	83 ec 34             	sub    $0x34,%esp
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

40000a22:	8b 45 08             	mov    0x8(%ebp),%eax
40000a25:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
40000a2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    return keycode;
}
40000a2f:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000a32:	50                   	push   %eax
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

40000a33:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    return keycode;
}
40000a4f:	e8 50 0c 00 00       	call   400016a4 <syscall>

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;
40000a54:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a57:	c9                   	leave  
40000a58:	c3                   	ret    

40000a59 <fclose>:
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
40000a59:	55                   	push   %ebp
40000a5a:	89 e5                	mov    %esp,%ebp
40000a5c:	83 ec 34             	sub    $0x34,%esp
#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;

40000a5f:	8b 45 08             	mov    0x8(%ebp),%eax
40000a62:	c7 45 e0 0b 00 00 00 	movl   $0xb,-0x20(%ebp)
40000a69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000a6c:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000a6f:	50                   	push   %eax
#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;

40000a70:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a77:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000a8c:	e8 13 0c 00 00       	call   400016a4 <syscall>
    uint8_t keycode = 0;

    switch (set) {
40000a91:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a94:	c9                   	leave  
40000a95:	c3                   	ret    

40000a96 <fopen>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000a96:	55                   	push   %ebp
40000a97:	89 e5                	mov    %esp,%ebp
40000a99:	83 ec 34             	sub    $0x34,%esp
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000a9c:	8b 45 08             	mov    0x8(%ebp),%eax
40000a9f:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
40000aa6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000aa9:	8b 45 0c             	mov    0xc(%ebp),%eax
40000aac:	89 45 e8             	mov    %eax,-0x18(%ebp)
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000aaf:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000ab2:	50                   	push   %eax
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000ab3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000aba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000ac1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000ac8:	e8 d7 0b 00 00       	call   400016a4 <syscall>
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000acd:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000ad0:	c9                   	leave  
40000ad1:	c3                   	ret    

40000ad2 <fopenpmhandle>:
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40000ad2:	55                   	push   %ebp
40000ad3:	89 e5                	mov    %esp,%ebp
40000ad5:	83 ec 34             	sub    $0x34,%esp
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40000ad8:	8b 45 08             	mov    0x8(%ebp),%eax
40000adb:	c7 45 e0 15 00 00 00 	movl   $0x15,-0x20(%ebp)
40000ae2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000ae5:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ae8:	89 45 e8             	mov    %eax,-0x18(%ebp)
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000aeb:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000aee:	50                   	push   %eax
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40000aef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000af6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000afd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000b04:	e8 9b 0b 00 00       	call   400016a4 <syscall>
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000b09:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000b0c:	c9                   	leave  
40000b0d:	c3                   	ret    

40000b0e <setstderr>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
40000b0e:	55                   	push   %ebp
40000b0f:	89 e5                	mov    %esp,%ebp
40000b11:	83 ec 10             	sub    $0x10,%esp
40000b14:	ff 75 08             	pushl  0x8(%ebp)
40000b17:	6a 03                	push   $0x3
40000b19:	e8 b4 ff ff ff       	call   40000ad2 <fopenpmhandle>
40000b1e:	c9                   	leave  
40000b1f:	c3                   	ret    

40000b20 <setstdin>:
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
40000b20:	55                   	push   %ebp
40000b21:	89 e5                	mov    %esp,%ebp
40000b23:	83 ec 10             	sub    $0x10,%esp
40000b26:	ff 75 08             	pushl  0x8(%ebp)
40000b29:	6a 02                	push   $0x2
40000b2b:	e8 a2 ff ff ff       	call   40000ad2 <fopenpmhandle>
40000b30:	c9                   	leave  
40000b31:	c3                   	ret    

40000b32 <setstdout>:
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000b32:	55                   	push   %ebp
40000b33:	89 e5                	mov    %esp,%ebp
40000b35:	83 ec 10             	sub    $0x10,%esp
40000b38:	ff 75 08             	pushl  0x8(%ebp)
40000b3b:	6a 01                	push   $0x1
40000b3d:	e8 90 ff ff ff       	call   40000ad2 <fopenpmhandle>
40000b42:	c9                   	leave  
40000b43:	c3                   	ret    

40000b44 <getLastVFSErr>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ports.h"
40000b44:	55                   	push   %ebp
40000b45:	89 e5                	mov    %esp,%ebp
40000b47:	83 ec 34             	sub    $0x34,%esp
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b4a:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000b4d:	c7 45 e0 0f 00 00 00 	movl   $0xf,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b54:	50                   	push   %eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000b55:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000b5c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000b63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000b6a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000b71:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b78:	e8 27 0b 00 00       	call   400016a4 <syscall>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40000b7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000b80:	c9                   	leave  
40000b81:	c3                   	ret    

40000b82 <fwrite>:
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40000b82:	55                   	push   %ebp
40000b83:	89 e5                	mov    %esp,%ebp
40000b85:	57                   	push   %edi
40000b86:	56                   	push   %esi
40000b87:	53                   	push   %ebx
40000b88:	83 ec 3c             	sub    $0x3c,%esp
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b8b:	8b 45 08             	mov    0x8(%ebp),%eax
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40000b8e:	8b 7d 10             	mov    0x10(%ebp),%edi
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b91:	e8 02 fe ff ff       	call   40000998 <resolveHandle>

static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b96:	83 ec 0c             	sub    $0xc,%esp

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b99:	89 c6                	mov    %eax,%esi
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b9b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40000b9e:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ba1:	c7 45 d0 0c 00 00 00 	movl   $0xc,-0x30(%ebp)
40000ba8:	89 45 d8             	mov    %eax,-0x28(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000bab:	8d 45 d0             	lea    -0x30(%ebp),%eax
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000bae:	89 7d dc             	mov    %edi,-0x24(%ebp)
40000bb1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000bb8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000bbf:	50                   	push   %eax
40000bc0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
40000bc3:	eb 2d                	jmp    40000bf2 <fwrite+0x70>
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40000bc5:	e8 15 fb ff ff       	call   400006df <yield>
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000bca:	8b 45 0c             	mov    0xc(%ebp),%eax
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000bcd:	83 ec 0c             	sub    $0xc,%esp
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000bd0:	89 45 d8             	mov    %eax,-0x28(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000bd3:	8d 45 d0             	lea    -0x30(%ebp),%eax
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000bd6:	c7 45 d0 0c 00 00 00 	movl   $0xc,-0x30(%ebp)
40000bdd:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000be0:	89 7d dc             	mov    %edi,-0x24(%ebp)
40000be3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000bea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000bf1:	50                   	push   %eax
40000bf2:	e8 ad 0a 00 00       	call   400016a4 <syscall>

        port_out(PORTM_BYTE, 0x60, command);
40000bf7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40000bfa:	83 c4 10             	add    $0x10,%esp
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
40000bfd:	83 fb 01             	cmp    $0x1,%ebx
40000c00:	74 c3                	je     40000bc5 <fwrite+0x43>
    uint8_t keycode = 0;
    int break_code = 0;

    static int      e0_code = 0;
    static int      e1_code = 0;
40000c02:	89 f0                	mov    %esi,%eax
40000c04:	89 da                	mov    %ebx,%edx
40000c06:	e8 3d 02 00 00       	call   40000e48 <printrwerror>
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000c0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000c0e:	89 d8                	mov    %ebx,%eax
40000c10:	5b                   	pop    %ebx
40000c11:	5e                   	pop    %esi
40000c12:	5f                   	pop    %edi
40000c13:	5d                   	pop    %ebp
40000c14:	c3                   	ret    

40000c15 <fputs>:
40000c15:	55                   	push   %ebp
40000c16:	89 e5                	mov    %esp,%ebp
40000c18:	56                   	push   %esi
40000c19:	53                   	push   %ebx
40000c1a:	83 ec 20             	sub    $0x20,%esp
40000c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
40000c20:	8b 5d 08             	mov    0x8(%ebp),%ebx
40000c23:	e8 70 fd ff ff       	call   40000998 <resolveHandle>
40000c28:	89 c6                	mov    %eax,%esi
40000c2a:	85 c0                	test   %eax,%eax
40000c2c:	74 16                	je     40000c44 <fputs+0x2f>
40000c2e:	83 ec 0c             	sub    $0xc,%esp
40000c31:	53                   	push   %ebx
40000c32:	e8 a7 04 00 00       	call   400010de <strlen>
40000c37:	83 c4 0c             	add    $0xc,%esp
40000c3a:	50                   	push   %eax
40000c3b:	53                   	push   %ebx
40000c3c:	56                   	push   %esi
40000c3d:	e8 40 ff ff ff       	call   40000b82 <fwrite>
40000c42:	eb 35                	jmp    40000c79 <fputs+0x64>
40000c44:	83 ec 0c             	sub    $0xc,%esp
40000c47:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000c4a:	c7 45 e0 ca 00 00 00 	movl   $0xca,-0x20(%ebp)
40000c51:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40000c54:	50                   	push   %eax
40000c55:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000c5c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000c63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000c6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40000c71:	e8 2e 0a 00 00       	call   400016a4 <syscall>
40000c76:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c79:	83 c4 10             	add    $0x10,%esp
40000c7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000c7f:	5b                   	pop    %ebx
40000c80:	5e                   	pop    %esi
40000c81:	5d                   	pop    %ebp
40000c82:	c3                   	ret    

40000c83 <puts>:
40000c83:	55                   	push   %ebp
40000c84:	89 e5                	mov    %esp,%ebp
40000c86:	83 ec 10             	sub    $0x10,%esp
40000c89:	6a 01                	push   $0x1
40000c8b:	ff 75 08             	pushl  0x8(%ebp)
40000c8e:	e8 82 ff ff ff       	call   40000c15 <fputs>
40000c93:	c9                   	leave  
40000c94:	c3                   	ret    

40000c95 <putn>:
40000c95:	55                   	push   %ebp
40000c96:	89 e5                	mov    %esp,%ebp
40000c98:	56                   	push   %esi
40000c99:	53                   	push   %ebx
40000c9a:	31 f6                	xor    %esi,%esi
40000c9c:	83 ec 50             	sub    $0x50,%esp
40000c9f:	89 d3                	mov    %edx,%ebx
40000ca1:	83 fa 24             	cmp    $0x24,%edx
40000ca4:	7f 25                	jg     40000ccb <putn+0x36>
40000ca6:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
40000caa:	8d 4d f7             	lea    -0x9(%ebp),%ecx
40000cad:	31 d2                	xor    %edx,%edx
40000caf:	49                   	dec    %ecx
40000cb0:	f7 f3                	div    %ebx
40000cb2:	46                   	inc    %esi
40000cb3:	85 c0                	test   %eax,%eax
40000cb5:	8a 92 05 32 00 40    	mov    0x40003205(%edx),%dl
40000cbb:	88 11                	mov    %dl,(%ecx)
40000cbd:	75 ee                	jne    40000cad <putn+0x18>
40000cbf:	83 ec 0c             	sub    $0xc,%esp
40000cc2:	51                   	push   %ecx
40000cc3:	e8 bb ff ff ff       	call   40000c83 <puts>
40000cc8:	83 c4 10             	add    $0x10,%esp
40000ccb:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000cce:	89 f0                	mov    %esi,%eax
40000cd0:	5b                   	pop    %ebx
40000cd1:	5e                   	pop    %esi
40000cd2:	5d                   	pop    %ebp
40000cd3:	c3                   	ret    

40000cd4 <fputc>:
40000cd4:	55                   	push   %ebp
40000cd5:	89 e5                	mov    %esp,%ebp
40000cd7:	83 ec 38             	sub    $0x38,%esp
40000cda:	8b 45 08             	mov    0x8(%ebp),%eax
40000cdd:	88 45 d4             	mov    %al,-0x2c(%ebp)
40000ce0:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ce3:	e8 b0 fc ff ff       	call   40000998 <resolveHandle>
40000ce8:	85 c0                	test   %eax,%eax
40000cea:	74 0f                	je     40000cfb <fputc+0x27>
40000cec:	52                   	push   %edx
40000ced:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40000cf0:	6a 01                	push   $0x1
40000cf2:	52                   	push   %edx
40000cf3:	50                   	push   %eax
40000cf4:	e8 89 fe ff ff       	call   40000b82 <fwrite>
40000cf9:	eb 39                	jmp    40000d34 <fputc+0x60>
40000cfb:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
40000cff:	83 ec 0c             	sub    $0xc,%esp
40000d02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d05:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000d08:	c7 45 e0 c9 00 00 00 	movl   $0xc9,-0x20(%ebp)
40000d0f:	50                   	push   %eax
40000d10:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000d17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000d1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000d25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40000d2c:	e8 73 09 00 00       	call   400016a4 <syscall>
40000d31:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000d34:	83 c4 10             	add    $0x10,%esp
40000d37:	c9                   	leave  
40000d38:	c3                   	ret    

40000d39 <putc>:
40000d39:	55                   	push   %ebp
40000d3a:	89 e5                	mov    %esp,%ebp
40000d3c:	83 ec 08             	sub    $0x8,%esp
40000d3f:	0f be 45 08          	movsbl 0x8(%ebp),%eax
40000d43:	89 45 08             	mov    %eax,0x8(%ebp)
40000d46:	c9                   	leave  
40000d47:	e9 88 ff ff ff       	jmp    40000cd4 <fputc>

40000d4c <putchar>:
40000d4c:	55                   	push   %ebp
40000d4d:	89 e5                	mov    %esp,%ebp
40000d4f:	83 ec 10             	sub    $0x10,%esp
40000d52:	0f be 45 08          	movsbl 0x8(%ebp),%eax
40000d56:	6a 01                	push   $0x1
40000d58:	50                   	push   %eax
40000d59:	e8 76 ff ff ff       	call   40000cd4 <fputc>
40000d5e:	c9                   	leave  
40000d5f:	c3                   	ret    

40000d60 <printf>:
40000d60:	55                   	push   %ebp
40000d61:	89 e5                	mov    %esp,%ebp
40000d63:	57                   	push   %edi
40000d64:	56                   	push   %esi
40000d65:	53                   	push   %ebx
40000d66:	83 ec 1c             	sub    $0x1c,%esp
40000d69:	8d 75 0c             	lea    0xc(%ebp),%esi
40000d6c:	8b 7d 08             	mov    0x8(%ebp),%edi
40000d6f:	31 db                	xor    %ebx,%ebx
40000d71:	e9 be 00 00 00       	jmp    40000e34 <printf+0xd4>
40000d76:	3c 25                	cmp    $0x25,%al
40000d78:	0f 85 a4 00 00 00    	jne    40000e22 <printf+0xc2>
40000d7e:	47                   	inc    %edi
40000d7f:	8a 07                	mov    (%edi),%al
40000d81:	3c 70                	cmp    $0x70,%al
40000d83:	74 47                	je     40000dcc <printf+0x6c>
40000d85:	7f 1a                	jg     40000da1 <printf+0x41>
40000d87:	3c 63                	cmp    $0x63,%al
40000d89:	74 5a                	je     40000de5 <printf+0x85>
40000d8b:	7f 0e                	jg     40000d9b <printf+0x3b>
40000d8d:	84 c0                	test   %al,%al
40000d8f:	0f 84 a9 00 00 00    	je     40000e3e <printf+0xde>
40000d95:	3c 25                	cmp    $0x25,%al
40000d97:	75 6c                	jne    40000e05 <printf+0xa5>
40000d99:	eb 63                	jmp    40000dfe <printf+0x9e>
40000d9b:	3c 64                	cmp    $0x64,%al
40000d9d:	75 66                	jne    40000e05 <printf+0xa5>
40000d9f:	eb 1e                	jmp    40000dbf <printf+0x5f>
40000da1:	3c 75                	cmp    $0x75,%al
40000da3:	74 1a                	je     40000dbf <printf+0x5f>
40000da5:	3c 78                	cmp    $0x78,%al
40000da7:	74 23                	je     40000dcc <printf+0x6c>
40000da9:	3c 73                	cmp    $0x73,%al
40000dab:	75 58                	jne    40000e05 <printf+0xa5>
40000dad:	83 ec 0c             	sub    $0xc,%esp
40000db0:	8d 46 04             	lea    0x4(%esi),%eax
40000db3:	ff 36                	pushl  (%esi)
40000db5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000db8:	e8 c6 fe ff ff       	call   40000c83 <puts>
40000dbd:	eb 38                	jmp    40000df7 <printf+0x97>
40000dbf:	8d 46 04             	lea    0x4(%esi),%eax
40000dc2:	ba 0a 00 00 00       	mov    $0xa,%edx
40000dc7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000dca:	eb 0b                	jmp    40000dd7 <printf+0x77>
40000dcc:	8d 46 04             	lea    0x4(%esi),%eax
40000dcf:	ba 10 00 00 00       	mov    $0x10,%edx
40000dd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000dd7:	8b 06                	mov    (%esi),%eax
40000dd9:	e8 b7 fe ff ff       	call   40000c95 <putn>
40000dde:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40000de1:	01 c3                	add    %eax,%ebx
40000de3:	eb 4e                	jmp    40000e33 <printf+0xd3>
40000de5:	8d 46 04             	lea    0x4(%esi),%eax
40000de8:	83 ec 0c             	sub    $0xc,%esp
40000deb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000dee:	0f be 06             	movsbl (%esi),%eax
40000df1:	50                   	push   %eax
40000df2:	e8 55 ff ff ff       	call   40000d4c <putchar>
40000df7:	01 c3                	add    %eax,%ebx
40000df9:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40000dfc:	eb 32                	jmp    40000e30 <printf+0xd0>
40000dfe:	83 ec 0c             	sub    $0xc,%esp
40000e01:	6a 25                	push   $0x25
40000e03:	eb 24                	jmp    40000e29 <printf+0xc9>
40000e05:	83 ec 0c             	sub    $0xc,%esp
40000e08:	6a 25                	push   $0x25
40000e0a:	e8 3d ff ff ff       	call   40000d4c <putchar>
40000e0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000e12:	0f be 07             	movsbl (%edi),%eax
40000e15:	89 04 24             	mov    %eax,(%esp)
40000e18:	e8 2f ff ff ff       	call   40000d4c <putchar>
40000e1d:	03 45 e4             	add    -0x1c(%ebp),%eax
40000e20:	eb 0c                	jmp    40000e2e <printf+0xce>
40000e22:	83 ec 0c             	sub    $0xc,%esp
40000e25:	0f be c0             	movsbl %al,%eax
40000e28:	50                   	push   %eax
40000e29:	e8 1e ff ff ff       	call   40000d4c <putchar>
40000e2e:	01 c3                	add    %eax,%ebx
40000e30:	83 c4 10             	add    $0x10,%esp
40000e33:	47                   	inc    %edi
40000e34:	8a 07                	mov    (%edi),%al
40000e36:	84 c0                	test   %al,%al
40000e38:	0f 85 38 ff ff ff    	jne    40000d76 <printf+0x16>
40000e3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000e41:	89 d8                	mov    %ebx,%eax
40000e43:	5b                   	pop    %ebx
40000e44:	5e                   	pop    %esi
40000e45:	5f                   	pop    %edi
40000e46:	5d                   	pop    %ebp
40000e47:	c3                   	ret    

40000e48 <printrwerror>:
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
40000e48:	55                   	push   %ebp
40000e49:	89 e5                	mov    %esp,%ebp
40000e4b:	83 ec 08             	sub    $0x8,%esp
            keycode = sc_to_kc[0][scancode];
40000e4e:	83 fa 02             	cmp    $0x2,%edx
40000e51:	75 0a                	jne    40000e5d <printrwerror+0x15>
            break;
40000e53:	52                   	push   %edx
40000e54:	52                   	push   %edx
40000e55:	50                   	push   %eax
40000e56:	68 2a 32 00 40       	push   $0x4000322a
40000e5b:	eb 2b                	jmp    40000e88 <printrwerror+0x40>

        // e0-Scancodes
        case 1:
40000e5d:	83 fa 03             	cmp    $0x3,%edx
40000e60:	75 0a                	jne    40000e6c <printrwerror+0x24>
            keycode = sc_to_kc[1][scancode];
40000e62:	51                   	push   %ecx
40000e63:	51                   	push   %ecx
40000e64:	50                   	push   %eax
40000e65:	68 42 32 00 40       	push   $0x40003242
40000e6a:	eb 1c                	jmp    40000e88 <printrwerror+0x40>
            break;

        // e1-Scancodes
40000e6c:	83 fa 04             	cmp    $0x4,%edx
40000e6f:	75 0a                	jne    40000e7b <printrwerror+0x33>
        case 2:
40000e71:	52                   	push   %edx
40000e72:	52                   	push   %edx
40000e73:	50                   	push   %eax
40000e74:	68 5d 32 00 40       	push   $0x4000325d
40000e79:	eb 0d                	jmp    40000e88 <printrwerror+0x40>
            switch (scancode) {
                // Pause
                case 0x451D:
40000e7b:	83 fa 05             	cmp    $0x5,%edx
40000e7e:	75 10                	jne    40000e90 <printrwerror+0x48>
                    keycode = 119;
40000e80:	51                   	push   %ecx
40000e81:	51                   	push   %ecx
40000e82:	50                   	push   %eax
40000e83:	68 87 32 00 40       	push   $0x40003287
40000e88:	e8 d3 fe ff ff       	call   40000d60 <printf>
40000e8d:	83 c4 10             	add    $0x10,%esp
                    break;

40000e90:	c9                   	leave  
40000e91:	c3                   	ret    

40000e92 <fread>:
    }

    if (e0_code) {
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40000e92:	55                   	push   %ebp
40000e93:	89 e5                	mov    %esp,%ebp
40000e95:	57                   	push   %edi
40000e96:	56                   	push   %esi
40000e97:	53                   	push   %ebx
40000e98:	83 ec 38             	sub    $0x38,%esp
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }
40000e9b:	8d 7d d0             	lea    -0x30(%ebp),%edi
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    }

    if (e0_code) {
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40000ea1:	8b 75 08             	mov    0x8(%ebp),%esi
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000ea4:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000ea7:	8b 45 10             	mov    0x10(%ebp),%eax
40000eaa:	c7 45 d0 0d 00 00 00 	movl   $0xd,-0x30(%ebp)
40000eb1:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000eb4:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000eb7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000ebe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000ec5:	eb 2c                	jmp    40000ef3 <fread+0x61>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
        }

        keycode = translate_scancode(1, scancode);
40000ec7:	e8 13 f8 ff ff       	call   400006df <yield>
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ecf:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000ed2:	8b 45 10             	mov    0x10(%ebp),%eax
40000ed5:	c7 45 d0 0d 00 00 00 	movl   $0xd,-0x30(%ebp)
40000edc:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000edf:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000ee2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000ee9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        scancode &= ~0x80;
    }
40000ef0:	83 ec 0c             	sub    $0xc,%esp
40000ef3:	57                   	push   %edi
40000ef4:	e8 ab 07 00 00       	call   400016a4 <syscall>

    if (e0_code) {
40000ef9:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40000efc:	83 c4 10             	add    $0x10,%esp
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
        }

40000eff:	83 fb 01             	cmp    $0x1,%ebx
40000f02:	74 c3                	je     40000ec7 <fread+0x35>
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
40000f04:	89 f0                	mov    %esi,%eax
40000f06:	89 da                	mov    %ebx,%edx
40000f08:	e8 3b ff ff ff       	call   40000e48 <printrwerror>
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
40000f0d:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000f10:	89 d8                	mov    %ebx,%eax
40000f12:	5b                   	pop    %ebx
40000f13:	5e                   	pop    %esi
40000f14:	5f                   	pop    %edi
40000f15:	5d                   	pop    %ebp
40000f16:	c3                   	ret    

40000f17 <fgetc>:
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
    }

    if(break_code) {
        key_flags[keycode] &= ~KF_PRESSED;
40000f17:	55                   	push   %ebp
40000f18:	89 e5                	mov    %esp,%ebp
40000f1a:	83 ec 18             	sub    $0x18,%esp
    }
40000f1d:	8b 45 08             	mov    0x8(%ebp),%eax
40000f20:	e8 73 fa ff ff       	call   40000998 <resolveHandle>
    else
40000f25:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
    {
40000f29:	85 c0                	test   %eax,%eax
40000f2b:	74 10                	je     40000f3d <fgetc+0x26>
        key_flags[keycode] |= KF_PRESSED;
40000f2d:	8d 55 f7             	lea    -0x9(%ebp),%edx
40000f30:	51                   	push   %ecx
40000f31:	6a 01                	push   $0x1
40000f33:	52                   	push   %edx
40000f34:	50                   	push   %eax
40000f35:	e8 58 ff ff ff       	call   40000e92 <fread>
40000f3a:	83 c4 10             	add    $0x10,%esp
    }

    char chr = getcharfromkc(keycode);
40000f3d:	8a 45 f7             	mov    -0x9(%ebp),%al
40000f40:	c9                   	leave  
40000f41:	c3                   	ret    

40000f42 <getchar>:
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
        port_in(PORTM_BYTE, 0x60);
40000f42:	55                   	push   %ebp
40000f43:	89 e5                	mov    %esp,%ebp
40000f45:	83 ec 14             	sub    $0x14,%esp
    }
40000f48:	6a 02                	push   $0x2
40000f4a:	e8 c8 ff ff ff       	call   40000f17 <fgetc>

40000f4f:	c9                   	leave  
40000f50:	c3                   	ret    

40000f51 <getc>:
    printf("[kbcdrv] requesting neccesary resources...\n");

    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
    require_port(0x60);

40000f51:	55                   	push   %ebp
40000f52:	89 e5                	mov    %esp,%ebp
40000f54:	83 ec 08             	sub    $0x8,%esp
    printf("[kbcdrv] emptying keyboard buffer...\n");

40000f57:	c9                   	leave  

    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");
40000f58:	e9 ba ff ff ff       	jmp    40000f17 <fgetc>

40000f5d <fgets>:
        key_flags[keycode] |= KF_PRESSED;
    }

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
40000f5d:	55                   	push   %ebp
40000f5e:	89 e5                	mov    %esp,%ebp
40000f60:	57                   	push   %edi
40000f61:	56                   	push   %esi
40000f62:	53                   	push   %ebx
40000f63:	83 ec 1c             	sub    $0x1c,%esp
40000f66:	31 db                	xor    %ebx,%ebx
40000f68:	8b 7d 0c             	mov    0xc(%ebp),%edi
40000f6b:	8b 75 08             	mov    0x8(%ebp),%esi
        fwrite(charout, &chr, sizeof(char));
40000f6e:	8d 47 ff             	lea    -0x1(%edi),%eax
40000f71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000f74:	eb 16                	jmp    40000f8c <fgets+0x2f>
    }
40000f76:	83 ec 0c             	sub    $0xc,%esp
40000f79:	ff 75 10             	pushl  0x10(%ebp)
40000f7c:	e8 96 ff ff ff       	call   40000f17 <fgetc>
}
40000f81:	83 c4 10             	add    $0x10,%esp

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
    }
40000f84:	88 04 1e             	mov    %al,(%esi,%ebx,1)
}
40000f87:	84 c0                	test   %al,%al
40000f89:	74 0a                	je     40000f95 <fgets+0x38>
    }

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
40000f8b:	43                   	inc    %ebx
40000f8c:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
40000f8f:	7c e5                	jl     40000f76 <fgets+0x19>
}

int main(int argc, char* args[])
{
    printf("[kbcdrv] requesting neccesary resources...\n");

40000f91:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
40000f95:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000f98:	89 f0                	mov    %esi,%eax
40000f9a:	5b                   	pop    %ebx
40000f9b:	5e                   	pop    %esi
40000f9c:	5f                   	pop    %edi
40000f9d:	5d                   	pop    %ebp
40000f9e:	c3                   	ret    

40000f9f <getln>:
    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
        port_in(PORTM_BYTE, 0x60);
    }

    printf("[kbcdrv] initializing KBC...\n");

40000f9f:	55                   	push   %ebp
40000fa0:	89 e5                	mov    %esp,%ebp
40000fa2:	56                   	push   %esi
40000fa3:	53                   	push   %ebx
40000fa4:	31 db                	xor    %ebx,%ebx
40000fa6:	8b 75 08             	mov    0x8(%ebp),%esi
    memset(key_flags, 0, 256 * sizeof(uint32_t));

    // Leds alle ausloeschen
    send_command(0xED);
40000fa9:	eb 42                	jmp    40000fed <getln+0x4e>
    send_command(0);
40000fab:	3c 0a                	cmp    $0xa,%al
40000fad:	75 0f                	jne    40000fbe <getln+0x1f>

40000faf:	83 ec 0c             	sub    $0xc,%esp
40000fb2:	6a 0a                	push   $0xa
40000fb4:	e8 93 fd ff ff       	call   40000d4c <putchar>
    // Schnellste Wiederholrate
40000fb9:	83 c4 10             	add    $0x10,%esp
40000fbc:	eb 40                	jmp    40000ffe <getln+0x5f>
    send_command(0xF3);
    send_command(0);

40000fbe:	3c 08                	cmp    $0x8,%al
40000fc0:	75 18                	jne    40000fda <getln+0x3b>
    send_command(0xF4);
40000fc2:	85 db                	test   %ebx,%ebx
40000fc4:	74 0e                	je     40000fd4 <getln+0x35>

    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
40000fc6:	83 ec 0c             	sub    $0xc,%esp
    // Schnellste Wiederholrate
    send_command(0xF3);
    send_command(0);

    send_command(0xF4);

40000fc9:	4b                   	dec    %ebx
    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
40000fca:	6a 08                	push   $0x8
40000fcc:	e8 7b fd ff ff       	call   40000d4c <putchar>
40000fd1:	83 c4 10             	add    $0x10,%esp

    charout = fmkfifo("/dev/keyboard");
40000fd4:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)

40000fd8:	eb 13                	jmp    40000fed <getln+0x4e>
    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000fda:	83 ec 0c             	sub    $0xc,%esp

    charout = fmkfifo("/dev/keyboard");

    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
40000fdd:	88 04 1e             	mov    %al,(%esi,%ebx,1)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000fe0:	0f be c0             	movsbl %al,%eax
40000fe3:	50                   	push   %eax
    fclose(initCtrl);

40000fe4:	43                   	inc    %ebx
    charout = fmkfifo("/dev/keyboard");

    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000fe5:	e8 62 fd ff ff       	call   40000d4c <putchar>
    fclose(initCtrl);

40000fea:	83 c4 10             	add    $0x10,%esp
    printf("[kbcdrv] initializing KBC...\n");

    memset(key_flags, 0, 256 * sizeof(uint32_t));

    // Leds alle ausloeschen
    send_command(0xED);
40000fed:	83 ec 0c             	sub    $0xc,%esp
40000ff0:	6a 02                	push   $0x2
40000ff2:	e8 20 ff ff ff       	call   40000f17 <fgetc>
40000ff7:	83 c4 10             	add    $0x10,%esp
40000ffa:	84 c0                	test   %al,%al
40000ffc:	75 ad                	jne    40000fab <getln+0xc>
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
    fclose(initCtrl);

    printf("[kbcdrv] Done!\n");

    while(1);
40000ffe:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)
}
40001002:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001005:	89 f0                	mov    %esi,%eax
40001007:	5b                   	pop    %ebx
40001008:	5e                   	pop    %esi
40001009:	5d                   	pop    %ebp
4000100a:	c3                   	ret    
	...

4000100c <memset>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
4000100c:	55                   	push   %ebp
4000100d:	89 e5                	mov    %esp,%ebp
4000100f:	53                   	push   %ebx
40001010:	8b 45 08             	mov    0x8(%ebp),%eax
40001013:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40001016:	8b 4d 10             	mov    0x10(%ebp),%ecx
#include "ports.h"
40001019:	89 c2                	mov    %eax,%edx
 
uint32_t init_done = 0;
4000101b:	eb 04                	jmp    40001021 <memset+0x15>
static uint8_t sc_to_kc[][128] = {
4000101d:	88 1a                	mov    %bl,(%edx)
4000101f:	49                   	dec    %ecx
40001020:	42                   	inc    %edx
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ports.h"
 
uint32_t init_done = 0;
40001021:	85 c9                	test   %ecx,%ecx
40001023:	75 f8                	jne    4000101d <memset+0x11>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001025:	5b                   	pop    %ebx
40001026:	5d                   	pop    %ebp
40001027:	c3                   	ret    

40001028 <memcpy>:
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001028:	55                   	push   %ebp
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001029:	31 c9                	xor    %ecx,%ecx
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
4000102b:	89 e5                	mov    %esp,%ebp
4000102d:	56                   	push   %esi
4000102e:	53                   	push   %ebx
4000102f:	8b 75 10             	mov    0x10(%ebp),%esi
40001032:	8b 45 08             	mov    0x8(%ebp),%eax
40001035:	8b 5d 0c             	mov    0xc(%ebp),%ebx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001038:	85 f6                	test   %esi,%esi
4000103a:	75 04                	jne    40001040 <memcpy+0x18>
4000103c:	31 c0                	xor    %eax,%eax
4000103e:	eb 0a                	jmp    4000104a <memcpy+0x22>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001040:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
40001043:	88 14 08             	mov    %dl,(%eax,%ecx,1)
40001046:	41                   	inc    %ecx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001047:	4e                   	dec    %esi
40001048:	75 f6                	jne    40001040 <memcpy+0x18>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

4000104a:	5b                   	pop    %ebx
4000104b:	5e                   	pop    %esi
4000104c:	5d                   	pop    %ebp
4000104d:	c3                   	ret    

4000104e <memcmp>:
    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
4000104e:	55                   	push   %ebp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000104f:	83 c8 ff             	or     $0xffffffff,%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
40001052:	89 e5                	mov    %esp,%ebp
40001054:	57                   	push   %edi
40001055:	56                   	push   %esi
40001056:	53                   	push   %ebx
40001057:	8b 75 08             	mov    0x8(%ebp),%esi
4000105a:	8b 7d 0c             	mov    0xc(%ebp),%edi
4000105d:	8b 5d 10             	mov    0x10(%ebp),%ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001060:	85 f6                	test   %esi,%esi
40001062:	74 2c                	je     40001090 <memcmp+0x42>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40001064:	b8 01 00 00 00       	mov    $0x1,%eax
40001069:	85 ff                	test   %edi,%edi
4000106b:	74 23                	je     40001090 <memcmp+0x42>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000106d:	31 d2                	xor    %edx,%edx
4000106f:	85 db                	test   %ebx,%ebx
40001071:	75 17                	jne    4000108a <memcmp+0x3c>
40001073:	eb 19                	jmp    4000108e <memcmp+0x40>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001075:	8a 04 16             	mov    (%esi,%edx,1),%al
40001078:	8a 0c 17             	mov    (%edi,%edx,1),%cl
4000107b:	38 c8                	cmp    %cl,%al
4000107d:	74 0a                	je     40001089 <memcmp+0x3b>
         00,  00,  00,  00,  00,  00,  00,  00
4000107f:	0f b6 c0             	movzbl %al,%eax
40001082:	0f b6 c9             	movzbl %cl,%ecx
40001085:	29 c8                	sub    %ecx,%eax
40001087:	eb 07                	jmp    40001090 <memcmp+0x42>
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001089:	42                   	inc    %edx
4000108a:	39 da                	cmp    %ebx,%edx
4000108c:	72 e7                	jb     40001075 <memcmp+0x27>
4000108e:	31 c0                	xor    %eax,%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

static char kc_to_char[][128] = {
40001090:	5b                   	pop    %ebx
40001091:	5e                   	pop    %esi
40001092:	5f                   	pop    %edi
40001093:	5d                   	pop    %ebp
40001094:	c3                   	ret    

40001095 <strcmp>:
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40001095:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001096:	31 c0                	xor    %eax,%eax
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40001098:	89 e5                	mov    %esp,%ebp
4000109a:	56                   	push   %esi
4000109b:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000109c:	31 db                	xor    %ebx,%ebx
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
4000109e:	8b 55 08             	mov    0x8(%ebp),%edx
400010a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010a4:	85 d2                	test   %edx,%edx
400010a6:	75 03                	jne    400010ab <strcmp+0x16>
400010a8:	eb 09                	jmp    400010b3 <strcmp+0x1e>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010aa:	40                   	inc    %eax
400010ab:	89 c3                	mov    %eax,%ebx
400010ad:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
400010b1:	75 f7                	jne    400010aa <strcmp+0x15>
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010b3:	31 c0                	xor    %eax,%eax
400010b5:	31 f6                	xor    %esi,%esi
400010b7:	85 c9                	test   %ecx,%ecx
400010b9:	75 03                	jne    400010be <strcmp+0x29>
400010bb:	eb 09                	jmp    400010c6 <strcmp+0x31>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010bd:	40                   	inc    %eax
400010be:	89 c6                	mov    %eax,%esi
400010c0:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
400010c4:	75 f7                	jne    400010bd <strcmp+0x28>
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
400010c6:	89 f0                	mov    %esi,%eax
400010c8:	39 de                	cmp    %ebx,%esi
400010ca:	7e 02                	jle    400010ce <strcmp+0x39>
400010cc:	89 d8                	mov    %ebx,%eax
400010ce:	40                   	inc    %eax
400010cf:	50                   	push   %eax
400010d0:	51                   	push   %ecx
400010d1:	52                   	push   %edx
400010d2:	e8 77 ff ff ff       	call   4000104e <memcmp>
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
400010d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
400010da:	5b                   	pop    %ebx
400010db:	5e                   	pop    %esi
400010dc:	5d                   	pop    %ebp
400010dd:	c3                   	ret    

400010de <strlen>:
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400010de:	55                   	push   %ebp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010df:	31 d2                	xor    %edx,%edx
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400010e1:	89 e5                	mov    %esp,%ebp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010e3:	31 c0                	xor    %eax,%eax
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400010e5:	8b 4d 08             	mov    0x8(%ebp),%ecx
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010e8:	85 c9                	test   %ecx,%ecx
400010ea:	75 03                	jne    400010ef <strlen+0x11>
400010ec:	eb 09                	jmp    400010f7 <strlen+0x19>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010ee:	42                   	inc    %edx
400010ef:	89 d0                	mov    %edx,%eax
400010f1:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
400010f5:	75 f7                	jne    400010ee <strlen+0x10>
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010f7:	5d                   	pop    %ebp
400010f8:	c3                   	ret    

400010f9 <strcpy>:
        },
        {   /* 1 Table: With shift */
400010f9:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010fa:	31 d2                	xor    %edx,%edx
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400010fc:	89 e5                	mov    %esp,%ebp
400010fe:	56                   	push   %esi
400010ff:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001100:	31 c9                	xor    %ecx,%ecx
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
40001102:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40001105:	8b 45 08             	mov    0x8(%ebp),%eax
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001108:	85 db                	test   %ebx,%ebx
4000110a:	75 03                	jne    4000110f <strcpy+0x16>
4000110c:	eb 09                	jmp    40001117 <strcpy+0x1e>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000110e:	42                   	inc    %edx
4000110f:	89 d1                	mov    %edx,%ecx
40001111:	80 3c 13 00          	cmpb   $0x0,(%ebx,%edx,1)
40001115:	75 f7                	jne    4000110e <strcpy+0x15>
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001117:	89 ce                	mov    %ecx,%esi
40001119:	46                   	inc    %esi
4000111a:	74 0c                	je     40001128 <strcpy+0x2f>
4000111c:	31 d2                	xor    %edx,%edx
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000111e:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
40001121:	88 0c 10             	mov    %cl,(%eax,%edx,1)
40001124:	42                   	inc    %edx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001125:	4e                   	dec    %esi
40001126:	75 f6                	jne    4000111e <strcpy+0x25>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
40001128:	5b                   	pop    %ebx
40001129:	5e                   	pop    %esi
4000112a:	5d                   	pop    %ebp
4000112b:	c3                   	ret    

4000112c <strtoknc>:

uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
4000112c:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000112d:	31 c0                	xor    %eax,%eax

uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
4000112f:	89 e5                	mov    %esp,%ebp
40001131:	57                   	push   %edi
40001132:	56                   	push   %esi
40001133:	53                   	push   %ebx
40001134:	83 ec 04             	sub    $0x4,%esp
40001137:	8b 5d 0c             	mov    0xc(%ebp),%ebx
4000113a:	8b 4d 08             	mov    0x8(%ebp),%ecx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000113d:	85 db                	test   %ebx,%ebx
4000113f:	75 06                	jne    40001147 <strtoknc+0x1b>
40001141:	e9 83 00 00 00       	jmp    400011c9 <strtoknc+0x9d>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001146:	40                   	inc    %eax
40001147:	89 c7                	mov    %eax,%edi
40001149:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
4000114d:	75 f7                	jne    40001146 <strtoknc+0x1a>
static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
4000114f:	85 c0                	test   %eax,%eax
40001151:	74 76                	je     400011c9 <strtoknc+0x9d>
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

40001153:	85 c9                	test   %ecx,%ecx
40001155:	75 0b                	jne    40001162 <strtoknc+0x36>
40001157:	83 3d 14 42 00 40 00 	cmpl   $0x0,0x40004214
4000115e:	75 08                	jne    40001168 <strtoknc+0x3c>
40001160:	eb 67                	jmp    400011c9 <strtoknc+0x9d>
        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

40001162:	89 0d 14 42 00 40    	mov    %ecx,0x40004214
        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
40001168:	a1 14 42 00 40       	mov    0x40004214,%eax
4000116d:	31 c9                	xor    %ecx,%ecx
                case 0x451D:
                    keycode = 119;
4000116f:	eb 0b                	jmp    4000117c <strtoknc+0x50>
                    break;
40001171:	8a 10                	mov    (%eax),%dl
40001173:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
40001176:	75 03                	jne    4000117b <strtoknc+0x4f>

40001178:	40                   	inc    %eax
                default:
40001179:	eb 05                	jmp    40001180 <strtoknc+0x54>
        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
4000117b:	41                   	inc    %ecx
4000117c:	39 f9                	cmp    %edi,%ecx
4000117e:	7c f1                	jl     40001171 <strtoknc+0x45>

                default:
                    keycode = 0x0;
            };
            break;
    }
40001180:	39 f9                	cmp    %edi,%ecx
40001182:	75 e9                	jne    4000116d <strtoknc+0x41>

40001184:	a3 14 42 00 40       	mov    %eax,0x40004214
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
40001189:	80 38 00             	cmpb   $0x0,(%eax)
4000118c:	75 28                	jne    400011b6 <strtoknc+0x8a>

4000118e:	c7 05 14 42 00 40 00 	movl   $0x0,0x40004214
40001195:	00 00 00 
40001198:	eb 2f                	jmp    400011c9 <strtoknc+0x9d>
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

    return kc_to_char[index][keycode];
4000119a:	8a 55 f3             	mov    -0xd(%ebp),%dl
4000119d:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
400011a0:	75 05                	jne    400011a7 <strtoknc+0x7b>
}
400011a2:	c6 06 00             	movb   $0x0,(%esi)

400011a5:	eb 05                	jmp    400011ac <strtoknc+0x80>
static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

400011a7:	41                   	inc    %ecx
400011a8:	39 f9                	cmp    %edi,%ecx
400011aa:	7c ee                	jl     4000119a <strtoknc+0x6e>
}

static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
400011ac:	ff 05 14 42 00 40    	incl   0x40004214
        }
400011b2:	39 f9                	cmp    %edi,%ecx
400011b4:	7c 15                	jl     400011cb <strtoknc+0x9f>

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
400011b6:	8b 35 14 42 00 40    	mov    0x40004214,%esi
400011bc:	8a 16                	mov    (%esi),%dl
400011be:	88 55 f3             	mov    %dl,-0xd(%ebp)
400011c1:	84 d2                	test   %dl,%dl
400011c3:	74 06                	je     400011cb <strtoknc+0x9f>
400011c5:	31 c9                	xor    %ecx,%ecx
400011c7:	eb df                	jmp    400011a8 <strtoknc+0x7c>
400011c9:	31 c0                	xor    %eax,%eax
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
400011cb:	5a                   	pop    %edx
400011cc:	5b                   	pop    %ebx
400011cd:	5e                   	pop    %esi
400011ce:	5f                   	pop    %edi
400011cf:	5d                   	pop    %ebp
400011d0:	c3                   	ret    

400011d1 <strclone>:
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400011d1:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400011d2:	31 c0                	xor    %eax,%eax
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400011d4:	89 e5                	mov    %esp,%ebp
400011d6:	56                   	push   %esi
400011d7:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400011d8:	31 d2                	xor    %edx,%edx
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400011da:	8b 5d 08             	mov    0x8(%ebp),%ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400011dd:	85 db                	test   %ebx,%ebx
400011df:	75 03                	jne    400011e4 <strclone+0x13>
400011e1:	eb 09                	jmp    400011ec <strclone+0x1b>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400011e3:	40                   	inc    %eax
400011e4:	89 c2                	mov    %eax,%edx
400011e6:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
400011ea:	75 f7                	jne    400011e3 <strclone+0x12>
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
400011ec:	83 ec 0c             	sub    $0xc,%esp
400011ef:	42                   	inc    %edx
400011f0:	52                   	push   %edx
400011f1:	e8 af 01 00 00       	call   400013a5 <malloc>
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
400011f6:	59                   	pop    %ecx
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
400011f7:	89 c6                	mov    %eax,%esi
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
400011f9:	58                   	pop    %eax
400011fa:	53                   	push   %ebx
400011fb:	56                   	push   %esi
400011fc:	e8 f8 fe ff ff       	call   400010f9 <strcpy>
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001201:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001204:	89 f0                	mov    %esi,%eax
40001206:	5b                   	pop    %ebx
40001207:	5e                   	pop    %esi
40001208:	5d                   	pop    %ebp
40001209:	c3                   	ret    

4000120a <strtok>:
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000120a:	55                   	push   %ebp
4000120b:	89 e5                	mov    %esp,%ebp
4000120d:	56                   	push   %esi
4000120e:	53                   	push   %ebx
4000120f:	8b 75 08             	mov    0x8(%ebp),%esi
40001212:	8b 5d 0c             	mov    0xc(%ebp),%ebx
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001215:	85 f6                	test   %esi,%esi
40001217:	74 2e                	je     40001247 <strtok+0x3d>
        }
40001219:	a1 18 42 00 40       	mov    0x40004218,%eax
4000121e:	85 c0                	test   %eax,%eax
40001220:	74 0c                	je     4000122e <strtok+0x24>
};
40001222:	83 ec 0c             	sub    $0xc,%esp
40001225:	50                   	push   %eax
40001226:	e8 31 00 00 00       	call   4000125c <free>
4000122b:	83 c4 10             	add    $0x10,%esp

#define KF_PRESSED (1 << 0)
4000122e:	83 ec 0c             	sub    $0xc,%esp
40001231:	56                   	push   %esi
40001232:	e8 9a ff ff ff       	call   400011d1 <strclone>

40001237:	83 c4 10             	add    $0x10,%esp
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)
4000123a:	a3 18 42 00 40       	mov    %eax,0x40004218

4000123f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
40001242:	89 45 08             	mov    %eax,0x8(%ebp)
40001245:	eb 0a                	jmp    40001251 <strtok+0x47>
uint32_t key_flags[256];

40001247:	89 5d 0c             	mov    %ebx,0xc(%ebp)
4000124a:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
HANDLE charout = 0;
40001251:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001254:	5b                   	pop    %ebx
40001255:	5e                   	pop    %esi
40001256:	5d                   	pop    %ebp
};

#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

40001257:	e9 d0 fe ff ff       	jmp    4000112c <strtoknc>

4000125c <free>:
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
4000125c:	55                   	push   %ebp
4000125d:	89 e5                	mov    %esp,%ebp
4000125f:	57                   	push   %edi
40001260:	56                   	push   %esi
40001261:	53                   	push   %ebx
40001262:	83 ec 08             	sub    $0x8,%esp
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
40001265:	8b 15 20 42 00 40    	mov    0x40004220,%edx
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
4000126b:	8b 4d 08             	mov    0x8(%ebp),%ecx
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
4000126e:	89 d0                	mov    %edx,%eax
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
40001270:	e9 b8 00 00 00       	jmp    4000132d <free+0xd1>
        e1_prev = scancode;
40001275:	3b 48 04             	cmp    0x4(%eax),%ecx
40001278:	0f 85 ac 00 00 00    	jne    4000132a <free+0xce>
4000127e:	31 c9                	xor    %ecx,%ecx
40001280:	eb 23                	jmp    400012a5 <free+0x49>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001282:	39 c2                	cmp    %eax,%edx
40001284:	75 1a                	jne    400012a0 <free+0x44>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001286:	85 c9                	test   %ecx,%ecx
40001288:	8b 50 08             	mov    0x8(%eax),%edx
4000128b:	75 0e                	jne    4000129b <free+0x3f>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000128d:	89 15 20 42 00 40    	mov    %edx,0x40004220
40001293:	8b 0d 24 42 00 40    	mov    0x40004224,%ecx
40001299:	eb 10                	jmp    400012ab <free+0x4f>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
4000129b:	89 51 08             	mov    %edx,0x8(%ecx)
4000129e:	eb f3                	jmp    40001293 <free+0x37>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400012a0:	89 d1                	mov    %edx,%ecx
400012a2:	8b 52 08             	mov    0x8(%edx),%edx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400012a5:	85 d2                	test   %edx,%edx
400012a7:	75 d9                	jne    40001282 <free+0x26>
400012a9:	eb e8                	jmp    40001293 <free+0x37>
400012ab:	89 ca                	mov    %ecx,%edx
400012ad:	eb 6d                	jmp    4000131c <free+0xc0>
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400012af:	8b 5a 04             	mov    0x4(%edx),%ebx
400012b2:	8b 32                	mov    (%edx),%esi
400012b4:	8b 78 04             	mov    0x4(%eax),%edi
400012b7:	89 7d ec             	mov    %edi,-0x14(%ebp)
400012ba:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
400012bd:	89 7d f0             	mov    %edi,-0x10(%ebp)
400012c0:	8b 7d ec             	mov    -0x14(%ebp),%edi
400012c3:	39 7d f0             	cmp    %edi,-0x10(%ebp)
400012c6:	75 18                	jne    400012e0 <free+0x84>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400012c8:	89 58 04             	mov    %ebx,0x4(%eax)
400012cb:	31 f6                	xor    %esi,%esi
400012cd:	89 cb                	mov    %ecx,%ebx
400012cf:	eb 09                	jmp    400012da <free+0x7e>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400012d1:	39 d3                	cmp    %edx,%ebx
400012d3:	74 29                	je     400012fe <free+0xa2>
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400012d5:	89 de                	mov    %ebx,%esi
400012d7:	8b 5b 08             	mov    0x8(%ebx),%ebx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400012da:	85 db                	test   %ebx,%ebx
400012dc:	75 f3                	jne    400012d1 <free+0x75>
400012de:	eb cb                	jmp    400012ab <free+0x4f>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400012e0:	8b 38                	mov    (%eax),%edi
400012e2:	89 7d f0             	mov    %edi,-0x10(%ebp)
400012e5:	8b 7d ec             	mov    -0x14(%ebp),%edi
400012e8:	03 7d f0             	add    -0x10(%ebp),%edi
400012eb:	39 fb                	cmp    %edi,%ebx
400012ed:	75 2a                	jne    40001319 <free+0xbd>
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400012ef:	03 75 f0             	add    -0x10(%ebp),%esi
400012f2:	89 cb                	mov    %ecx,%ebx
400012f4:	89 30                	mov    %esi,(%eax)
400012f6:	31 f6                	xor    %esi,%esi
400012f8:	eb 19                	jmp    40001313 <free+0xb7>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400012fa:	39 d3                	cmp    %edx,%ebx
400012fc:	75 10                	jne    4000130e <free+0xb2>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
400012fe:	85 f6                	test   %esi,%esi
40001300:	8b 53 08             	mov    0x8(%ebx),%edx
40001303:	75 04                	jne    40001309 <free+0xad>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001305:	89 d1                	mov    %edx,%ecx
40001307:	eb a2                	jmp    400012ab <free+0x4f>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001309:	89 56 08             	mov    %edx,0x8(%esi)
4000130c:	eb 9d                	jmp    400012ab <free+0x4f>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
4000130e:	89 de                	mov    %ebx,%esi
40001310:	8b 5b 08             	mov    0x8(%ebx),%ebx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001313:	85 db                	test   %ebx,%ebx
40001315:	75 e3                	jne    400012fa <free+0x9e>
40001317:	eb 92                	jmp    400012ab <free+0x4f>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)

40001319:	8b 52 08             	mov    0x8(%edx),%edx
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
4000131c:	85 d2                	test   %edx,%edx
4000131e:	75 8f                	jne    400012af <free+0x53>
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001320:	89 48 08             	mov    %ecx,0x8(%eax)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40001323:	a3 24 42 00 40       	mov    %eax,0x40004224
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
        e1_code++;
    } else if (scancode == 0xE0) {
40001328:	eb 0b                	jmp    40001335 <free+0xd9>
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
4000132a:	8b 40 08             	mov    0x8(%eax),%eax
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
4000132d:	85 c0                	test   %eax,%eax
4000132f:	0f 85 40 ff ff ff    	jne    40001275 <free+0x19>
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
40001335:	58                   	pop    %eax
40001336:	5a                   	pop    %edx
40001337:	5b                   	pop    %ebx
40001338:	5e                   	pop    %esi
40001339:	5f                   	pop    %edi
4000133a:	5d                   	pop    %ebp
4000133b:	c3                   	ret    

4000133c <pop_unused_node>:
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
4000133c:	55                   	push   %ebp
4000133d:	89 e5                	mov    %esp,%ebp
4000133f:	53                   	push   %ebx
40001340:	83 ec 04             	sub    $0x4,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001343:	a1 1c 42 00 40       	mov    0x4000421c,%eax
40001348:	eb 45                	jmp    4000138f <pop_unused_node+0x53>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
4000134a:	83 ec 0c             	sub    $0xc,%esp
4000134d:	6a 01                	push   $0x1
4000134f:	e8 5b 02 00 00       	call   400015af <vmm_alloc_cont>

40001354:	83 c4 0c             	add    $0xc,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40001357:	89 c3                	mov    %eax,%ebx

40001359:	68 00 10 00 00       	push   $0x1000
4000135e:	6a 00                	push   $0x0
40001360:	50                   	push   %eax
40001361:	e8 a6 fc ff ff       	call   4000100c <memset>
40001366:	8b 15 1c 42 00 40    	mov    0x4000421c,%edx
4000136c:	8d 43 0c             	lea    0xc(%ebx),%eax
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
4000136f:	8d 8b fc 0f 00 00    	lea    0xffc(%ebx),%ecx
40001375:	83 c4 10             	add    $0x10,%esp
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001378:	89 50 08             	mov    %edx,0x8(%eax)
4000137b:	89 c2                	mov    %eax,%edx
4000137d:	83 c0 0c             	add    $0xc,%eax
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
40001380:	39 c8                	cmp    %ecx,%eax
40001382:	75 f4                	jne    40001378 <pop_unused_node+0x3c>
40001384:	8d 83 f0 0f 00 00    	lea    0xff0(%ebx),%eax
4000138a:	a3 1c 42 00 40       	mov    %eax,0x4000421c
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000138f:	85 c0                	test   %eax,%eax
40001391:	74 b7                	je     4000134a <pop_unused_node+0xe>
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001393:	8b 50 08             	mov    0x8(%eax),%edx
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001396:	85 c0                	test   %eax,%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001398:	89 15 1c 42 00 40    	mov    %edx,0x4000421c
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000139e:	74 aa                	je     4000134a <pop_unused_node+0xe>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400013a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400013a3:	c9                   	leave  
400013a4:	c3                   	ret    

400013a5 <malloc>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
400013a5:	55                   	push   %ebp
400013a6:	89 e5                	mov    %esp,%ebp
400013a8:	57                   	push   %edi
400013a9:	56                   	push   %esi
400013aa:	53                   	push   %ebx
400013ab:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t keycode = 0;

400013ae:	a1 24 42 00 40       	mov    0x40004224,%eax
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
400013b3:	8b 75 08             	mov    0x8(%ebp),%esi
    uint8_t keycode = 0;

400013b6:	89 c3                	mov    %eax,%ebx
    switch (set) {
        // Normal scancodes
400013b8:	eb 07                	jmp    400013c1 <malloc+0x1c>
        case 0:
400013ba:	39 33                	cmp    %esi,(%ebx)
400013bc:	73 0c                	jae    400013ca <malloc+0x25>
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
400013be:	8b 5b 08             	mov    0x8(%ebx),%ebx
static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
400013c1:	85 db                	test   %ebx,%ebx
400013c3:	75 f5                	jne    400013ba <malloc+0x15>
400013c5:	e9 93 00 00 00       	jmp    4000145d <malloc+0xb8>
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
400013ca:	8b 3b                	mov    (%ebx),%edi
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

400013cc:	31 d2                	xor    %edx,%edx
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
400013ce:	29 f7                	sub    %esi,%edi
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

400013d0:	89 33                	mov    %esi,(%ebx)
400013d2:	eb 4b                	jmp    4000141f <malloc+0x7a>

                default:
                    keycode = 0x0;
            };
            break;
    }
400013d4:	e8 63 ff ff ff       	call   4000133c <pop_unused_node>

    if (keycode == 0) {
400013d9:	8b 13                	mov    (%ebx),%edx
400013db:	03 53 04             	add    0x4(%ebx),%edx
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
400013de:	29 f7                	sub    %esi,%edi
                    keycode = 0x0;
            };
            break;
    }

    if (keycode == 0) {
400013e0:	89 50 04             	mov    %edx,0x4(%eax)
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013e3:	8b 15 24 42 00 40    	mov    0x40004224,%edx
400013e9:	89 50 08             	mov    %edx,0x8(%eax)
            };
            break;
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
400013ec:	89 38                	mov    %edi,(%eax)

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013ee:	a3 24 42 00 40       	mov    %eax,0x40004224
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013f3:	a1 20 42 00 40       	mov    0x40004220,%eax
400013f8:	89 43 08             	mov    %eax,0x8(%ebx)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013fb:	89 1d 20 42 00 40    	mov    %ebx,0x40004220
40001401:	eb 4f                	jmp    40001452 <malloc+0xad>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001403:	39 d8                	cmp    %ebx,%eax
40001405:	75 13                	jne    4000141a <malloc+0x75>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001407:	85 d2                	test   %edx,%edx
40001409:	8b 43 08             	mov    0x8(%ebx),%eax
4000140c:	75 07                	jne    40001415 <malloc+0x70>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000140e:	a3 24 42 00 40       	mov    %eax,0x40004224
40001413:	eb 0e                	jmp    40001423 <malloc+0x7e>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001415:	89 42 08             	mov    %eax,0x8(%edx)
40001418:	eb 09                	jmp    40001423 <malloc+0x7e>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
4000141a:	89 c2                	mov    %eax,%edx
4000141c:	8b 40 08             	mov    0x8(%eax),%eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
4000141f:	85 c0                	test   %eax,%eax
40001421:	75 e0                	jne    40001403 <malloc+0x5e>
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001423:	a1 20 42 00 40       	mov    0x40004220,%eax

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
40001428:	85 ff                	test   %edi,%edi
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000142a:	89 43 08             	mov    %eax,0x8(%ebx)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000142d:	89 1d 20 42 00 40    	mov    %ebx,0x40004220

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
40001433:	74 1d                	je     40001452 <malloc+0xad>
    do {
40001435:	e8 02 ff ff ff       	call   4000133c <pop_unused_node>
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
4000143a:	8b 13                	mov    (%ebx),%edx
4000143c:	03 53 04             	add    0x4(%ebx),%edx
4000143f:	89 50 04             	mov    %edx,0x4(%eax)
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001442:	8b 15 24 42 00 40    	mov    0x40004224,%edx
40001448:	89 50 08             	mov    %edx,0x8(%eax)
static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

4000144b:	89 38                	mov    %edi,(%eax)

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000144d:	a3 24 42 00 40       	mov    %eax,0x40004224

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40001452:	8b 43 04             	mov    0x4(%ebx),%eax
}

40001455:	8d 65 f4             	lea    -0xc(%ebp),%esp
40001458:	5b                   	pop    %ebx
40001459:	5e                   	pop    %esi
4000145a:	5f                   	pop    %edi
4000145b:	5d                   	pop    %ebp
4000145c:	c3                   	ret    
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

        // e1-Scancodes
        case 2:
4000145d:	89 f0                	mov    %esi,%eax

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

4000145f:	89 f7                	mov    %esi,%edi
40001461:	c1 ef 0c             	shr    $0xc,%edi
        // e1-Scancodes
        case 2:
40001464:	25 ff 0f 00 00       	and    $0xfff,%eax
            switch (scancode) {
40001469:	83 f8 01             	cmp    $0x1,%eax
4000146c:	83 df ff             	sbb    $0xffffffff,%edi
                // Pause
                case 0x451D:
4000146f:	83 ec 0c             	sub    $0xc,%esp
40001472:	57                   	push   %edi
40001473:	e8 37 01 00 00       	call   400015af <vmm_alloc_cont>
                    break;

                default:
                    keycode = 0x0;
            };
            break;
40001478:	c1 e7 0c             	shl    $0xc,%edi
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
                    break;
4000147b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000147e:	e8 b9 fe ff ff       	call   4000133c <pop_unused_node>

                default:
40001483:	8b 55 e4             	mov    -0x1c(%ebp),%edx
                    keycode = 0x0;
            };
            break;
40001486:	83 c4 10             	add    $0x10,%esp
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
                    break;
40001489:	89 c3                	mov    %eax,%ebx

                default:
4000148b:	89 50 04             	mov    %edx,0x4(%eax)
                    keycode = 0x0;
4000148e:	89 30                	mov    %esi,(%eax)
            };
            break;
40001490:	39 f7                	cmp    %esi,%edi
40001492:	0f 86 5b ff ff ff    	jbe    400013f3 <malloc+0x4e>
40001498:	e9 37 ff ff ff       	jmp    400013d4 <malloc+0x2f>

4000149d <realloc>:
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

4000149d:	55                   	push   %ebp
4000149e:	89 e5                	mov    %esp,%ebp
400014a0:	56                   	push   %esi
400014a1:	53                   	push   %ebx
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
400014a2:	8b 1d 20 42 00 40    	mov    0x40004220,%ebx
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

400014a8:	8b 55 08             	mov    0x8(%ebp),%edx
400014ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
400014ae:	eb 3e                	jmp    400014ee <realloc+0x51>
        (e0_code || (scancode != 0xE0)))
400014b0:	3b 53 04             	cmp    0x4(%ebx),%edx
400014b3:	75 36                	jne    400014eb <realloc+0x4e>
    {
400014b5:	85 c0                	test   %eax,%eax
400014b7:	75 0b                	jne    400014c4 <realloc+0x27>
        break_code = 1;
400014b9:	52                   	push   %edx
400014ba:	31 f6                	xor    %esi,%esi
400014bc:	e8 9b fd ff ff       	call   4000125c <free>
        scancode &= ~0x80;
400014c1:	5b                   	pop    %ebx
400014c2:	eb 30                	jmp    400014f4 <realloc+0x57>
    }

400014c4:	83 ec 0c             	sub    $0xc,%esp
400014c7:	50                   	push   %eax
400014c8:	e8 d8 fe ff ff       	call   400013a5 <malloc>
    if (e0_code) {
400014cd:	83 c4 0c             	add    $0xc,%esp
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }

400014d0:	89 c6                	mov    %eax,%esi
    if (e0_code) {
400014d2:	ff 33                	pushl  (%ebx)
400014d4:	ff 73 04             	pushl  0x4(%ebx)
400014d7:	50                   	push   %eax
400014d8:	e8 4b fb ff ff       	call   40001028 <memcpy>
        // Fake shift abfangen und ignorieren
400014dd:	59                   	pop    %ecx
400014de:	ff 73 04             	pushl  0x4(%ebx)
400014e1:	e8 76 fd ff ff       	call   4000125c <free>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
400014e6:	83 c4 10             	add    $0x10,%esp
400014e9:	eb 09                	jmp    400014f4 <realloc+0x57>
            return;
        }

        keycode = translate_scancode(1, scancode);
400014eb:	8b 5b 08             	mov    0x8(%ebx),%ebx
    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
400014ee:	85 db                	test   %ebx,%ebx
400014f0:	75 be                	jne    400014b0 <realloc+0x13>
400014f2:	31 f6                	xor    %esi,%esi
        }

        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
400014f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
400014f7:	89 f0                	mov    %esi,%eax
400014f9:	5b                   	pop    %ebx
400014fa:	5e                   	pop    %esi
400014fb:	5d                   	pop    %ebp
400014fc:	c3                   	ret    

400014fd <calloc>:
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
400014fd:	55                   	push   %ebp
400014fe:	89 e5                	mov    %esp,%ebp
40001500:	56                   	push   %esi
40001501:	53                   	push   %ebx
40001502:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    uint8_t keycode = 0;
    int break_code = 0;
40001505:	83 ec 0c             	sub    $0xc,%esp
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40001508:	0f af 5d 08          	imul   0x8(%ebp),%ebx
    int break_code = 0;
4000150c:	53                   	push   %ebx
4000150d:	e8 93 fe ff ff       	call   400013a5 <malloc>

    static int      e0_code = 0;
40001512:	83 c4 10             	add    $0x10,%esp
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
    int break_code = 0;
40001515:	89 c6                	mov    %eax,%esi

    static int      e0_code = 0;
40001517:	85 c0                	test   %eax,%eax
40001519:	74 0d                	je     40001528 <calloc+0x2b>
    static int      e1_code = 0;
4000151b:	50                   	push   %eax
4000151c:	53                   	push   %ebx
4000151d:	6a 00                	push   $0x0
4000151f:	56                   	push   %esi
40001520:	e8 e7 fa ff ff       	call   4000100c <memset>
40001525:	83 c4 10             	add    $0x10,%esp
    static uint16_t e1_prev = 0;

    if(!init_done) return;

40001528:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000152b:	89 f0                	mov    %esi,%eax
4000152d:	5b                   	pop    %ebx
4000152e:	5e                   	pop    %esi
4000152f:	5d                   	pop    %ebp
40001530:	c3                   	ret    
40001531:	00 00                	add    %al,(%eax)
	...

40001534 <print_memstat>:
    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001534:	55                   	push   %ebp
40001535:	89 e5                	mov    %esp,%ebp
40001537:	83 ec 34             	sub    $0x34,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
4000153a:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000153d:	c7 45 e0 cd 00 00 00 	movl   $0xcd,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00
    },
40001544:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001545:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
4000154c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001553:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000155a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001561:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00
    },
40001568:	e8 37 01 00 00       	call   400016a4 <syscall>
4000156d:	83 c4 10             	add    $0x10,%esp
};
40001570:	c9                   	leave  
40001571:	c3                   	ret    

40001572 <vmm_free>:
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001572:	55                   	push   %ebp
40001573:	89 e5                	mov    %esp,%ebp
40001575:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
40001578:	8b 45 08             	mov    0x8(%ebp),%eax
4000157b:	c7 45 e0 cc 00 00 00 	movl   $0xcc,-0x20(%ebp)
40001582:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001585:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001588:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
40001589:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001590:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001597:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000159e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015a5:	e8 fa 00 00 00       	call   400016a4 <syscall>
400015aa:	83 c4 10             	add    $0x10,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015ad:	c9                   	leave  
400015ae:	c3                   	ret    

400015af <vmm_alloc_cont>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
400015af:	55                   	push   %ebp
400015b0:	89 e5                	mov    %esp,%ebp
400015b2:	83 ec 34             	sub    $0x34,%esp
 
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
400015b5:	8b 45 08             	mov    0x8(%ebp),%eax
400015b8:	c7 45 e0 cb 00 00 00 	movl   $0xcb,-0x20(%ebp)
400015bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400015c2:	8d 45 e0             	lea    -0x20(%ebp),%eax
400015c5:	50                   	push   %eax
 
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
400015c6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400015cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400015d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400015db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400015e2:	e8 bd 00 00 00       	call   400016a4 <syscall>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
400015e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
400015ea:	c9                   	leave  
400015eb:	c3                   	ret    

400015ec <port_in>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015ec:	55                   	push   %ebp
400015ed:	89 e5                	mov    %esp,%ebp
400015ef:	83 ec 34             	sub    $0x34,%esp
400015f2:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400015f6:	8b 55 08             	mov    0x8(%ebp),%edx
400015f9:	89 45 e8             	mov    %eax,-0x18(%ebp)

static char kc_to_char[][128] = {
400015fc:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400015ff:	c7 45 e0 34 00 00 00 	movl   $0x34,-0x20(%ebp)

static char kc_to_char[][128] = {
40001606:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40001607:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4000160a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001611:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001618:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

static char kc_to_char[][128] = {
4000161f:	e8 80 00 00 00       	call   400016a4 <syscall>
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
40001624:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001627:	c9                   	leave  
40001628:	c3                   	ret    

40001629 <port_out>:
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
40001629:	55                   	push   %ebp
4000162a:	89 e5                	mov    %esp,%ebp
4000162c:	83 ec 34             	sub    $0x34,%esp
4000162f:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
40001633:	89 45 e8             	mov    %eax,-0x18(%ebp)
40001636:	8b 45 10             	mov    0x10(%ebp),%eax
40001639:	8b 55 08             	mov    0x8(%ebp),%edx
4000163c:	89 45 ec             	mov    %eax,-0x14(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000163f:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
40001642:	c7 45 e0 33 00 00 00 	movl   $0x33,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001649:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
4000164a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4000164d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001654:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000165b:	e8 44 00 00 00       	call   400016a4 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001660:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001663:	c9                   	leave  
40001664:	c3                   	ret    

40001665 <require_port>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
40001665:	55                   	push   %ebp
40001666:	89 e5                	mov    %esp,%ebp
40001668:	83 ec 34             	sub    $0x34,%esp
4000166b:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
4000166f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001672:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001675:	50                   	push   %eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001676:	c7 45 e0 32 00 00 00 	movl   $0x32,-0x20(%ebp)
4000167d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001684:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000168b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001692:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001699:	e8 06 00 00 00       	call   400016a4 <syscall>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000169e:	8b 45 e0             	mov    -0x20(%ebp),%eax
400016a1:	c9                   	leave  
400016a2:	c3                   	ret    
	...

400016a4 <syscall>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
400016a4:	55                   	push   %ebp
400016a5:	89 e5                	mov    %esp,%ebp
400016a7:	57                   	push   %edi
400016a8:	56                   	push   %esi
400016a9:	53                   	push   %ebx
400016aa:	83 ec 10             	sub    $0x10,%esp
#include "process.h"
400016ad:	8b 55 08             	mov    0x8(%ebp),%edx
400016b0:	8b 45 08             	mov    0x8(%ebp),%eax
400016b3:	8b 72 0c             	mov    0xc(%edx),%esi
400016b6:	8b 00                	mov    (%eax),%eax
400016b8:	89 75 e4             	mov    %esi,-0x1c(%ebp)
400016bb:	8b 5a 04             	mov    0x4(%edx),%ebx
400016be:	8b 4a 08             	mov    0x8(%edx),%ecx
400016c1:	8b 72 10             	mov    0x10(%edx),%esi
400016c4:	8b 7a 14             	mov    0x14(%edx),%edi
400016c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
400016ca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400016cd:	cd 30                	int    $0x30
400016cf:	89 55 e8             	mov    %edx,-0x18(%ebp)
400016d2:	8b 55 08             	mov    0x8(%ebp),%edx
400016d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
400016d8:	89 02                	mov    %eax,(%edx)
400016da:	8b 45 e8             	mov    -0x18(%ebp),%eax
400016dd:	89 5a 04             	mov    %ebx,0x4(%edx)
400016e0:	89 4a 08             	mov    %ecx,0x8(%edx)
400016e3:	89 42 0c             	mov    %eax,0xc(%edx)
400016e6:	89 72 10             	mov    %esi,0x10(%edx)
400016e9:	89 7a 14             	mov    %edi,0x14(%edx)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
400016ec:	83 c4 10             	add    $0x10,%esp
400016ef:	5b                   	pop    %ebx
400016f0:	5e                   	pop    %esi
400016f1:	5f                   	pop    %edi
400016f2:	5d                   	pop    %ebp
400016f3:	c3                   	ret    
