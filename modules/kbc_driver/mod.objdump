
../../initrfs/ibin/drivers/kbc:     file format elf32-i386
../../initrfs/ibin/drivers/kbc
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x400007f3

Program Header:
    LOAD off    0x00001000 vaddr 0x40000000 paddr 0x40000000 align 2**12
         filesz 0x00001684 memsz 0x00001684 flags r-x
    LOAD off    0x00003000 vaddr 0x40002000 paddr 0x40002000 align 2**12
         filesz 0x000012b2 memsz 0x00002640 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001684  40000000  40000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000200  40002000  40002000  00003000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       00000128  40003000  40003000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 0000018a  40003128  40003128  00004128  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          00000640  40004000  40004000  000042b2  2**5
                  ALLOC
  5 .stab         00005178  00000000  00000000  000042b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000090  00000000  00000000  0000942c  2**0
                  CONTENTS, READONLY
  7 .stabstr      00001afc  00000000  00000000  000094bc  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
40000000 l    d  .text	00000000 .text
40002000 l    d  .data	00000000 .data
40003000 l    d  .rodata	00000000 .rodata
40003128 l    d  .rodata.str1.1	00000000 .rodata.str1.1
40004000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 kbc_driver.c
40002000 l     O .data	00000100 sc_to_kc
40002100 l     O .data	00000100 kc_to_char
40000000 l     F .text	00000088 translate_scancode
40000088 l     F .text	00000053 getcharfromkc
400000db l     F .text	00000068 send_command
40004008 l     O .bss	00000004 e1_code.1035
4000400c l     O .bss	00000004 e0_code.1034
40004010 l     O .bss	00000002 e1_prev.1036
00000000 l    df *ABS*	00000000 process.c
40004014 l     O .bss	00000200 irq_handlers
40003110 l     O .rodata	00000018 C.7.1012
40000865 l     F .text	000000c0 _handle_rpc
00000000 l    df *ABS*	00000000 stdio.c
40000928 l     F .text	00000047 resolveHandle
40000dd8 l     F .text	0000004a printrwerror
40000c25 l     F .text	0000003f putn
00000000 l    df *ABS*	00000000 string.c
00000000 l    df *ABS*	00000000 stdlib.c
400012cc l     F .text	00000069 pop_unused_node
00000000 l    df *ABS*	00000000 vmmcall.c
00000000 l    df *ABS*	00000000 ports.c
00000000 l    df *ABS*	00000000 syscall.c
400005e9 g     F .text	0000003d getExecPath
40000cdc g     F .text	00000014 putchar
40001089 g     F .text	00000033 strcpy
4000066c g     F .text	0000003e yield
40000cf0 g     F .text	000000e8 printf
40001634 g     F .text	00000050 syscall
40004000 g     O .bss	00000004 init_done
40000eed g     F .text	00000042 fgets
40000ee1 g     F .text	0000000c getc
40000fb8 g     F .text	00000026 memcpy
40000c13 g     F .text	00000012 puts
400006aa g     F .text	0000003d pexists
40001335 g     F .text	000000f8 malloc
4000073f g     F .text	0000003d fetch_rpc_data
400010bc g     F .text	000000a5 strtoknc
4000057f g     F .text	0000003d changeExecPath
400015f5 g     F .text	0000003e require_port
4000157c g     F .text	0000003d port_in
40004224 g     O .bss	00000004 first_free
400015b9 g     F .text	0000003c port_out
40000ac2 g     F .text	00000012 setstdout
4000148d g     F .text	00000034 calloc
4000153f g     F .text	0000003d vmm_alloc_cont
4000050d g     F .text	0000003c exec
400007f3 g     F .text	00000072 _start
4000142d g     F .text	00000060 realloc
400007b6 g     F .text	0000003d set_rpc_handler
4000119a g     F .text	00000052 strtok
40000fde g     F .text	00000047 memcmp
40000e22 g     F .text	00000085 fread
4000421c g     O .bss	00000004 first_unused
40000a26 g     F .text	0000003c fopen
40000f9c g     F .text	0000001c memset
40000328 g     F .text	00000171 main
400009e9 g     F .text	0000003d fclose
40000ed2 g     F .text	0000000f getchar
40004240 g     O .bss	00000400 key_flags
40000f2f g     F .text	0000006c getln
40004218 g     O .bss	00000004 fr
400009ac g     F .text	0000003d favailable
40000cc9 g     F .text	00000013 putc
40004004 g     O .bss	00000004 charout
40001025 g     F .text	00000049 strcmp
40000ea7 g     F .text	0000002b fgetc
40004214 g     O .bss	00000004 sp
400005bc g     F .text	0000002d cd
40000143 g     F .text	000001e5 irq_handler
40004220 g     O .bss	00000004 first_used
40000c64 g     F .text	00000065 fputc
40000b12 g     F .text	00000093 fwrite
40000ab0 g     F .text	00000012 setstdin
40000549 g     F .text	00000036 texec
40001161 g     F .text	00000039 strclone
40000626 g     F .text	00000046 exit
400006e7 g     F .text	00000058 register_irq_handler
40000a62 g     F .text	0000003c fopenpmhandle
40001502 g     F .text	0000003d vmm_free
4000049c g     F .text	00000071 printFilesystemError
4000106e g     F .text	0000001b strlen
40000ad4 g     F .text	0000003e getLastVFSErr
40000ba5 g     F .text	0000006e fputs
4000096f g     F .text	0000003d fmkfifo
4000077c g     F .text	0000003a call_rpc
40000a9e g     F .text	00000012 setstderr
400014c4 g     F .text	0000003e print_memstat
400011ec g     F .text	000000e0 free



Disassembly of section .text:

40000000 <translate_scancode>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000000:	55                   	push   %ebp
40000001:	89 e5                	mov    %esp,%ebp
40000003:	83 ec 28             	sub    $0x28,%esp
40000006:	8b 45 0c             	mov    0xc(%ebp),%eax
40000009:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    uint8_t keycode = 0;
4000000d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    switch (set) {
40000011:	8b 45 08             	mov    0x8(%ebp),%eax
40000014:	83 f8 01             	cmp    $0x1,%eax
40000017:	74 1c                	je     40000035 <translate_scancode+0x35>
40000019:	83 f8 02             	cmp    $0x2,%eax
4000001c:	74 2a                	je     40000048 <translate_scancode+0x48>
4000001e:	85 c0                	test   %eax,%eax
40000020:	75 3f                	jne    40000061 <translate_scancode+0x61>
        // Normal scancodes
        case 0:
            keycode = sc_to_kc[0][scancode];
40000022:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000025:	25 ff ff 00 00       	and    $0xffff,%eax
4000002a:	8a 80 00 20 00 40    	mov    0x40002000(%eax),%al
40000030:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
40000033:	eb 2c                	jmp    40000061 <translate_scancode+0x61>

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
40000035:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000038:	25 ff ff 00 00       	and    $0xffff,%eax
4000003d:	8a 80 80 20 00 40    	mov    0x40002080(%eax),%al
40000043:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
40000046:	eb 19                	jmp    40000061 <translate_scancode+0x61>

        // e1-Scancodes
        case 2:
            switch (scancode) {
40000048:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000004b:	25 ff ff 00 00       	and    $0xffff,%eax
40000050:	3d 1d 45 00 00       	cmp    $0x451d,%eax
40000055:	75 06                	jne    4000005d <translate_scancode+0x5d>
                // Pause
                case 0x451D:
                    keycode = 119;
40000057:	c6 45 f7 77          	movb   $0x77,-0x9(%ebp)
                    break;
4000005b:	eb 04                	jmp    40000061 <translate_scancode+0x61>

                default:
                    keycode = 0x0;
4000005d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
            };
            break;
    }

    if (keycode == 0) {
40000061:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
40000065:	75 1c                	jne    40000083 <translate_scancode+0x83>
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
40000067:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000006a:	25 ff ff 00 00       	and    $0xffff,%eax
4000006f:	83 ec 04             	sub    $0x4,%esp
40000072:	ff 75 08             	pushl  0x8(%ebp)
40000075:	50                   	push   %eax
40000076:	68 00 30 00 40       	push   $0x40003000
4000007b:	e8 70 0c 00 00       	call   40000cf0 <printf>
40000080:	83 c4 10             	add    $0x10,%esp
    }

    return keycode;
40000083:	8a 45 f7             	mov    -0x9(%ebp),%al
}
40000086:	c9                   	leave  
40000087:	c3                   	ret    

40000088 <getcharfromkc>:

static char getcharfromkc(uint8_t keycode) {
40000088:	55                   	push   %ebp
40000089:	89 e5                	mov    %esp,%ebp
4000008b:	83 ec 14             	sub    $0x14,%esp
4000008e:	8b 45 08             	mov    0x8(%ebp),%eax
40000091:	88 45 ec             	mov    %al,-0x14(%ebp)
    uint32_t index = 0;
40000094:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
4000009b:	a1 e8 42 00 40       	mov    0x400042e8,%eax
400000a0:	83 e0 01             	and    $0x1,%eax
400000a3:	84 c0                	test   %al,%al
400000a5:	74 07                	je     400000ae <getcharfromkc+0x26>
400000a7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
400000ae:	a1 18 43 00 40       	mov    0x40004318,%eax
400000b3:	83 e0 01             	and    $0x1,%eax
400000b6:	84 c0                	test   %al,%al
400000b8:	74 07                	je     400000c1 <getcharfromkc+0x39>
400000ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

    return kc_to_char[index][keycode];
400000c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
400000c4:	b8 00 00 00 00       	mov    $0x0,%eax
400000c9:	8a 45 ec             	mov    -0x14(%ebp),%al
400000cc:	c1 e2 07             	shl    $0x7,%edx
400000cf:	8d 04 02             	lea    (%edx,%eax,1),%eax
400000d2:	05 00 21 00 40       	add    $0x40002100,%eax
400000d7:	8a 00                	mov    (%eax),%al
}
400000d9:	c9                   	leave  
400000da:	c3                   	ret    

400000db <send_command>:

static void send_command(uint8_t command)
{
400000db:	55                   	push   %ebp
400000dc:	89 e5                	mov    %esp,%ebp
400000de:	83 ec 18             	sub    $0x18,%esp
400000e1:	8b 45 08             	mov    0x8(%ebp),%eax
400000e4:	88 45 f4             	mov    %al,-0xc(%ebp)
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
400000e7:	83 ec 08             	sub    $0x8,%esp
400000ea:	6a 64                	push   $0x64
400000ec:	6a 00                	push   $0x0
400000ee:	e8 89 14 00 00       	call   4000157c <port_in>
400000f3:	83 c4 10             	add    $0x10,%esp
400000f6:	83 e0 02             	and    $0x2,%eax
400000f9:	85 c0                	test   %eax,%eax
400000fb:	75 ea                	jne    400000e7 <send_command+0xc>
        }

        port_out(PORTM_BYTE, 0x60, command);
400000fd:	b8 00 00 00 00       	mov    $0x0,%eax
40000102:	8a 45 f4             	mov    -0xc(%ebp),%al
40000105:	83 ec 04             	sub    $0x4,%esp
40000108:	50                   	push   %eax
40000109:	6a 60                	push   $0x60
4000010b:	6a 00                	push   $0x0
4000010d:	e8 a7 14 00 00       	call   400015b9 <port_out>
40000112:	83 c4 10             	add    $0x10,%esp

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000115:	83 ec 08             	sub    $0x8,%esp
40000118:	6a 64                	push   $0x64
4000011a:	6a 00                	push   $0x0
4000011c:	e8 5b 14 00 00       	call   4000157c <port_in>
40000121:	83 c4 10             	add    $0x10,%esp
40000124:	83 e0 01             	and    $0x1,%eax
40000127:	85 c0                	test   %eax,%eax
40000129:	74 ea                	je     40000115 <send_command+0x3a>
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000012b:	83 ec 08             	sub    $0x8,%esp
4000012e:	6a 60                	push   $0x60
40000130:	6a 00                	push   $0x0
40000132:	e8 45 14 00 00       	call   4000157c <port_in>
40000137:	83 c4 10             	add    $0x10,%esp
4000013a:	3d fe 00 00 00       	cmp    $0xfe,%eax
4000013f:	74 a6                	je     400000e7 <send_command+0xc>
}
40000141:	c9                   	leave  
40000142:	c3                   	ret    

40000143 <irq_handler>:

void irq_handler(uint32_t irq) {
40000143:	55                   	push   %ebp
40000144:	89 e5                	mov    %esp,%ebp
40000146:	83 ec 18             	sub    $0x18,%esp
    uint8_t scancode;
    uint8_t keycode = 0;
40000149:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int break_code = 0;
4000014d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000154:	a1 00 40 00 40       	mov    0x40004000,%eax
40000159:	85 c0                	test   %eax,%eax
4000015b:	0f 84 c4 01 00 00    	je     40000325 <irq_handler+0x1e2>

    scancode = port_in(PORTM_BYTE, 0x60);
40000161:	83 ec 08             	sub    $0x8,%esp
40000164:	6a 60                	push   $0x60
40000166:	6a 00                	push   $0x0
40000168:	e8 0f 14 00 00       	call   4000157c <port_in>
4000016d:	83 c4 10             	add    $0x10,%esp
40000170:	88 45 f2             	mov    %al,-0xe(%ebp)

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
40000173:	8a 45 f2             	mov    -0xe(%ebp),%al
40000176:	84 c0                	test   %al,%al
40000178:	79 29                	jns    400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
4000017a:	a1 08 40 00 40       	mov    0x40004008,%eax

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000017f:	85 c0                	test   %eax,%eax
40000181:	75 06                	jne    40000189 <irq_handler+0x46>
40000183:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
40000187:	74 1a                	je     400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
40000189:	a1 0c 40 00 40       	mov    0x4000400c,%eax

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000018e:	85 c0                	test   %eax,%eax
40000190:	75 06                	jne    40000198 <irq_handler+0x55>
40000192:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
40000196:	74 0b                	je     400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000198:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        scancode &= ~0x80;
4000019f:	80 65 f2 7f          	andb   $0x7f,-0xe(%ebp)
    }

    if (e0_code) {
400001a3:	a1 0c 40 00 40       	mov    0x4000400c,%eax
400001a8:	85 c0                	test   %eax,%eax
400001aa:	74 43                	je     400001ef <irq_handler+0xac>
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
400001ac:	80 7d f2 2a          	cmpb   $0x2a,-0xe(%ebp)
400001b0:	74 06                	je     400001b8 <irq_handler+0x75>
400001b2:	80 7d f2 36          	cmpb   $0x36,-0xe(%ebp)
400001b6:	75 0f                	jne    400001c7 <irq_handler+0x84>
            e0_code = 0;
400001b8:	c7 05 0c 40 00 40 00 	movl   $0x0,0x4000400c
400001bf:	00 00 00 
            return;
400001c2:	e9 5f 01 00 00       	jmp    40000326 <irq_handler+0x1e3>
        }

        keycode = translate_scancode(1, scancode);
400001c7:	b8 00 00 00 00       	mov    $0x0,%eax
400001cc:	8a 45 f2             	mov    -0xe(%ebp),%al
400001cf:	83 ec 08             	sub    $0x8,%esp
400001d2:	50                   	push   %eax
400001d3:	6a 01                	push   $0x1
400001d5:	e8 26 fe ff ff       	call   40000000 <translate_scancode>
400001da:	83 c4 10             	add    $0x10,%esp
400001dd:	88 45 f3             	mov    %al,-0xd(%ebp)
        e0_code = 0;
400001e0:	c7 05 0c 40 00 40 00 	movl   $0x0,0x4000400c
400001e7:	00 00 00 
400001ea:	e9 af 00 00 00       	jmp    4000029e <irq_handler+0x15b>
    } else if (e1_code == 2) {
400001ef:	a1 08 40 00 40       	mov    0x40004008,%eax
400001f4:	83 f8 02             	cmp    $0x2,%eax
400001f7:	75 43                	jne    4000023c <irq_handler+0xf9>
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
400001f9:	b8 00 00 00 00       	mov    $0x0,%eax
400001fe:	8a 45 f2             	mov    -0xe(%ebp),%al
40000201:	c1 e0 08             	shl    $0x8,%eax
40000204:	89 c2                	mov    %eax,%edx
40000206:	66 a1 10 40 00 40    	mov    0x40004010,%ax
4000020c:	09 d0                	or     %edx,%eax
4000020e:	66 a3 10 40 00 40    	mov    %ax,0x40004010
        keycode = translate_scancode(2, e1_prev);
40000214:	66 a1 10 40 00 40    	mov    0x40004010,%ax
4000021a:	25 ff ff 00 00       	and    $0xffff,%eax
4000021f:	83 ec 08             	sub    $0x8,%esp
40000222:	50                   	push   %eax
40000223:	6a 02                	push   $0x2
40000225:	e8 d6 fd ff ff       	call   40000000 <translate_scancode>
4000022a:	83 c4 10             	add    $0x10,%esp
4000022d:	88 45 f3             	mov    %al,-0xd(%ebp)
        e1_code = 0;
40000230:	c7 05 08 40 00 40 00 	movl   $0x0,0x40004008
40000237:	00 00 00 
4000023a:	eb 62                	jmp    4000029e <irq_handler+0x15b>
    } else if (e1_code == 1) {
4000023c:	a1 08 40 00 40       	mov    0x40004008,%eax
40000241:	83 f8 01             	cmp    $0x1,%eax
40000244:	75 1b                	jne    40000261 <irq_handler+0x11e>
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
40000246:	b8 00 00 00 00       	mov    $0x0,%eax
4000024b:	8a 45 f2             	mov    -0xe(%ebp),%al
4000024e:	66 a3 10 40 00 40    	mov    %ax,0x40004010
        e1_code++;
40000254:	a1 08 40 00 40       	mov    0x40004008,%eax
40000259:	40                   	inc    %eax
4000025a:	a3 08 40 00 40       	mov    %eax,0x40004008
4000025f:	eb 3d                	jmp    4000029e <irq_handler+0x15b>
    } else if (scancode == 0xE0) {
40000261:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
40000265:	75 0c                	jne    40000273 <irq_handler+0x130>
        // Anfang eines e0-Codes
        e0_code = 1;
40000267:	c7 05 0c 40 00 40 01 	movl   $0x1,0x4000400c
4000026e:	00 00 00 
40000271:	eb 2b                	jmp    4000029e <irq_handler+0x15b>
    } else if (scancode == 0xE1) {
40000273:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
40000277:	75 0c                	jne    40000285 <irq_handler+0x142>
        // Anfang eines e1-Codes
        e1_code = 1;
40000279:	c7 05 08 40 00 40 01 	movl   $0x1,0x40004008
40000280:	00 00 00 
40000283:	eb 19                	jmp    4000029e <irq_handler+0x15b>
    } else {
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
40000285:	b8 00 00 00 00       	mov    $0x0,%eax
4000028a:	8a 45 f2             	mov    -0xe(%ebp),%al
4000028d:	83 ec 08             	sub    $0x8,%esp
40000290:	50                   	push   %eax
40000291:	6a 00                	push   $0x0
40000293:	e8 68 fd ff ff       	call   40000000 <translate_scancode>
40000298:	83 c4 10             	add    $0x10,%esp
4000029b:	88 45 f3             	mov    %al,-0xd(%ebp)
    }

    if(break_code) {
4000029e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400002a2:	74 23                	je     400002c7 <irq_handler+0x184>
        key_flags[keycode] &= ~KF_PRESSED;
400002a4:	b8 00 00 00 00       	mov    $0x0,%eax
400002a9:	8a 45 f3             	mov    -0xd(%ebp),%al
400002ac:	ba 00 00 00 00       	mov    $0x0,%edx
400002b1:	8a 55 f3             	mov    -0xd(%ebp),%dl
400002b4:	8b 14 95 40 42 00 40 	mov    0x40004240(,%edx,4),%edx
400002bb:	83 e2 fe             	and    $0xfffffffe,%edx
400002be:	89 14 85 40 42 00 40 	mov    %edx,0x40004240(,%eax,4)
400002c5:	eb 21                	jmp    400002e8 <irq_handler+0x1a5>
    }
    else
    {
        key_flags[keycode] |= KF_PRESSED;
400002c7:	b8 00 00 00 00       	mov    $0x0,%eax
400002cc:	8a 45 f3             	mov    -0xd(%ebp),%al
400002cf:	ba 00 00 00 00       	mov    $0x0,%edx
400002d4:	8a 55 f3             	mov    -0xd(%ebp),%dl
400002d7:	8b 14 95 40 42 00 40 	mov    0x40004240(,%edx,4),%edx
400002de:	83 ca 01             	or     $0x1,%edx
400002e1:	89 14 85 40 42 00 40 	mov    %edx,0x40004240(,%eax,4)
    }

    char chr = getcharfromkc(keycode);
400002e8:	b8 00 00 00 00       	mov    $0x0,%eax
400002ed:	8a 45 f3             	mov    -0xd(%ebp),%al
400002f0:	83 ec 0c             	sub    $0xc,%esp
400002f3:	50                   	push   %eax
400002f4:	e8 8f fd ff ff       	call   40000088 <getcharfromkc>
400002f9:	83 c4 10             	add    $0x10,%esp
400002fc:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(!break_code && chr) {
400002ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40000303:	75 21                	jne    40000326 <irq_handler+0x1e3>
40000305:	8a 45 f1             	mov    -0xf(%ebp),%al
40000308:	84 c0                	test   %al,%al
4000030a:	74 1a                	je     40000326 <irq_handler+0x1e3>
        fwrite(charout, &chr, sizeof(char));
4000030c:	a1 04 40 00 40       	mov    0x40004004,%eax
40000311:	83 ec 04             	sub    $0x4,%esp
40000314:	6a 01                	push   $0x1
40000316:	8d 55 f1             	lea    -0xf(%ebp),%edx
40000319:	52                   	push   %edx
4000031a:	50                   	push   %eax
4000031b:	e8 f2 07 00 00       	call   40000b12 <fwrite>
40000320:	83 c4 10             	add    $0x10,%esp
40000323:	eb 01                	jmp    40000326 <irq_handler+0x1e3>

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000325:	90                   	nop    
    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
    }
}
40000326:	c9                   	leave  
40000327:	c3                   	ret    

40000328 <main>:

int main(int argc, char* args[])
{
40000328:	8d 4c 24 04          	lea    0x4(%esp),%ecx
4000032c:	83 e4 f0             	and    $0xfffffff0,%esp
4000032f:	ff 71 fc             	pushl  -0x4(%ecx)
40000332:	55                   	push   %ebp
40000333:	89 e5                	mov    %esp,%ebp
40000335:	51                   	push   %ecx
40000336:	83 ec 14             	sub    $0x14,%esp
    printf("[kbcdrv] requesting neccesary resources...\n");
40000339:	83 ec 0c             	sub    $0xc,%esp
4000033c:	68 24 30 00 40       	push   $0x40003024
40000341:	e8 aa 09 00 00       	call   40000cf0 <printf>
40000346:	83 c4 10             	add    $0x10,%esp

    register_irq_handler(0x21, &irq_handler);
40000349:	83 ec 08             	sub    $0x8,%esp
4000034c:	68 43 01 00 40       	push   $0x40000143
40000351:	6a 21                	push   $0x21
40000353:	e8 8f 03 00 00       	call   400006e7 <register_irq_handler>
40000358:	83 c4 10             	add    $0x10,%esp
    require_port(0x64);
4000035b:	83 ec 0c             	sub    $0xc,%esp
4000035e:	6a 64                	push   $0x64
40000360:	e8 90 12 00 00       	call   400015f5 <require_port>
40000365:	83 c4 10             	add    $0x10,%esp
    require_port(0x60);
40000368:	83 ec 0c             	sub    $0xc,%esp
4000036b:	6a 60                	push   $0x60
4000036d:	e8 83 12 00 00       	call   400015f5 <require_port>
40000372:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] emptying keyboard buffer...\n");
40000375:	83 ec 0c             	sub    $0xc,%esp
40000378:	68 50 30 00 40       	push   $0x40003050
4000037d:	e8 6e 09 00 00       	call   40000cf0 <printf>
40000382:	83 c4 10             	add    $0x10,%esp

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
40000385:	eb 0f                	jmp    40000396 <main+0x6e>
        port_in(PORTM_BYTE, 0x60);
40000387:	83 ec 08             	sub    $0x8,%esp
4000038a:	6a 60                	push   $0x60
4000038c:	6a 00                	push   $0x0
4000038e:	e8 e9 11 00 00       	call   4000157c <port_in>
40000393:	83 c4 10             	add    $0x10,%esp
    require_port(0x64);
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
40000396:	83 ec 08             	sub    $0x8,%esp
40000399:	6a 64                	push   $0x64
4000039b:	6a 00                	push   $0x0
4000039d:	e8 da 11 00 00       	call   4000157c <port_in>
400003a2:	83 c4 10             	add    $0x10,%esp
400003a5:	83 e0 01             	and    $0x1,%eax
400003a8:	84 c0                	test   %al,%al
400003aa:	75 db                	jne    40000387 <main+0x5f>
        port_in(PORTM_BYTE, 0x60);
    }

    printf("[kbcdrv] initializing KBC...\n");
400003ac:	83 ec 0c             	sub    $0xc,%esp
400003af:	68 76 30 00 40       	push   $0x40003076
400003b4:	e8 37 09 00 00       	call   40000cf0 <printf>
400003b9:	83 c4 10             	add    $0x10,%esp

    memset(key_flags, 0, 256 * sizeof(uint32_t));
400003bc:	83 ec 04             	sub    $0x4,%esp
400003bf:	68 00 04 00 00       	push   $0x400
400003c4:	6a 00                	push   $0x0
400003c6:	68 40 42 00 40       	push   $0x40004240
400003cb:	e8 cc 0b 00 00       	call   40000f9c <memset>
400003d0:	83 c4 10             	add    $0x10,%esp

    // Leds alle ausloeschen
    send_command(0xED);
400003d3:	83 ec 0c             	sub    $0xc,%esp
400003d6:	68 ed 00 00 00       	push   $0xed
400003db:	e8 fb fc ff ff       	call   400000db <send_command>
400003e0:	83 c4 10             	add    $0x10,%esp
    send_command(0);
400003e3:	83 ec 0c             	sub    $0xc,%esp
400003e6:	6a 00                	push   $0x0
400003e8:	e8 ee fc ff ff       	call   400000db <send_command>
400003ed:	83 c4 10             	add    $0x10,%esp

    // Schnellste Wiederholrate
    send_command(0xF3);
400003f0:	83 ec 0c             	sub    $0xc,%esp
400003f3:	68 f3 00 00 00       	push   $0xf3
400003f8:	e8 de fc ff ff       	call   400000db <send_command>
400003fd:	83 c4 10             	add    $0x10,%esp
    send_command(0);
40000400:	83 ec 0c             	sub    $0xc,%esp
40000403:	6a 00                	push   $0x0
40000405:	e8 d1 fc ff ff       	call   400000db <send_command>
4000040a:	83 c4 10             	add    $0x10,%esp

    send_command(0xF4);
4000040d:	83 ec 0c             	sub    $0xc,%esp
40000410:	68 f4 00 00 00       	push   $0xf4
40000415:	e8 c1 fc ff ff       	call   400000db <send_command>
4000041a:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
4000041d:	83 ec 0c             	sub    $0xc,%esp
40000420:	68 94 30 00 40       	push   $0x40003094
40000425:	e8 c6 08 00 00       	call   40000cf0 <printf>
4000042a:	83 c4 10             	add    $0x10,%esp

    charout = fmkfifo("/dev/keyboard");
4000042d:	83 ec 0c             	sub    $0xc,%esp
40000430:	68 c9 30 00 40       	push   $0x400030c9
40000435:	e8 35 05 00 00       	call   4000096f <fmkfifo>
4000043a:	83 c4 10             	add    $0x10,%esp
4000043d:	a3 04 40 00 40       	mov    %eax,0x40004004

    init_done = 1;
40000442:	c7 05 00 40 00 40 01 	movl   $0x1,0x40004000
40000449:	00 00 00 

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
4000044c:	83 ec 08             	sub    $0x8,%esp
4000044f:	6a 02                	push   $0x2
40000451:	68 d7 30 00 40       	push   $0x400030d7
40000456:	e8 cb 05 00 00       	call   40000a26 <fopen>
4000045b:	83 c4 10             	add    $0x10,%esp
4000045e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000461:	c6 45 f3 4b          	movb   $0x4b,-0xd(%ebp)
40000465:	83 ec 04             	sub    $0x4,%esp
40000468:	6a 01                	push   $0x1
4000046a:	8d 45 f3             	lea    -0xd(%ebp),%eax
4000046d:	50                   	push   %eax
4000046e:	ff 75 f4             	pushl  -0xc(%ebp)
40000471:	e8 9c 06 00 00       	call   40000b12 <fwrite>
40000476:	83 c4 10             	add    $0x10,%esp
    fclose(initCtrl);
40000479:	83 ec 0c             	sub    $0xc,%esp
4000047c:	ff 75 f4             	pushl  -0xc(%ebp)
4000047f:	e8 65 05 00 00       	call   400009e9 <fclose>
40000484:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] Done!\n");
40000487:	83 ec 0c             	sub    $0xc,%esp
4000048a:	68 e7 30 00 40       	push   $0x400030e7
4000048f:	e8 5c 08 00 00       	call   40000cf0 <printf>
40000494:	83 c4 10             	add    $0x10,%esp

    while(1);
40000497:	eb fe                	jmp    40000497 <main+0x16f>
40000499:	00 00                	add    %al,(%eax)
	...

4000049c <printFilesystemError>:

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000049c:	55                   	push   %ebp
4000049d:	89 e5                	mov    %esp,%ebp
4000049f:	83 ec 08             	sub    $0x8,%esp
400004a2:	8b 55 0c             	mov    0xc(%ebp),%edx
400004a5:	8b 45 08             	mov    0x8(%ebp),%eax
}
400004a8:	83 fa 05             	cmp    $0x5,%edx
400004ab:	77 43                	ja     400004f0 <printFilesystemError+0x54>
400004ad:	ff 24 95 f8 30 00 40 	jmp    *0x400030f8(,%edx,4)

void irq_handler(uint32_t irq) {
400004b4:	52                   	push   %edx
400004b5:	52                   	push   %edx
400004b6:	50                   	push   %eax
400004b7:	68 28 31 00 40       	push   $0x40003128
400004bc:	eb 3a                	jmp    400004f8 <printFilesystemError+0x5c>
    uint8_t scancode;
    uint8_t keycode = 0;
    int break_code = 0;
400004be:	51                   	push   %ecx
400004bf:	51                   	push   %ecx
400004c0:	50                   	push   %eax
400004c1:	68 3a 31 00 40       	push   $0x4000313a
400004c6:	eb 30                	jmp    400004f8 <printFilesystemError+0x5c>

    static int      e0_code = 0;
    static int      e1_code = 0;
400004c8:	52                   	push   %edx
400004c9:	52                   	push   %edx
400004ca:	50                   	push   %eax
400004cb:	68 59 31 00 40       	push   $0x40003159
400004d0:	eb 26                	jmp    400004f8 <printFilesystemError+0x5c>
    static uint16_t e1_prev = 0;

    if(!init_done) return;
400004d2:	51                   	push   %ecx
400004d3:	51                   	push   %ecx
400004d4:	50                   	push   %eax
400004d5:	68 83 31 00 40       	push   $0x40003183
400004da:	eb 1c                	jmp    400004f8 <printFilesystemError+0x5c>

    scancode = port_in(PORTM_BYTE, 0x60);

400004dc:	52                   	push   %edx
400004dd:	52                   	push   %edx
400004de:	50                   	push   %eax
400004df:	68 98 31 00 40       	push   $0x40003198
400004e4:	eb 12                	jmp    400004f8 <printFilesystemError+0x5c>
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
400004e6:	51                   	push   %ecx
400004e7:	51                   	push   %ecx
400004e8:	50                   	push   %eax
400004e9:	68 d3 31 00 40       	push   $0x400031d3
400004ee:	eb 08                	jmp    400004f8 <printFilesystemError+0x5c>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
400004f0:	52                   	push   %edx
400004f1:	52                   	push   %edx
400004f2:	50                   	push   %eax
400004f3:	68 e6 31 00 40       	push   $0x400031e6
400004f8:	e8 f3 07 00 00       	call   40000cf0 <printf>
        break_code = 1;
        scancode &= ~0x80;
    }

400004fd:	c7 45 08 03 32 00 40 	movl   $0x40003203,0x8(%ebp)
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
40000504:	83 c4 10             	add    $0x10,%esp
        break_code = 1;
        scancode &= ~0x80;
    }

    if (e0_code) {
40000507:	c9                   	leave  
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }

40000508:	e9 e3 07 00 00       	jmp    40000cf0 <printf>

4000050d <exec>:
            };
            break;
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
4000050d:	55                   	push   %ebp
4000050e:	89 e5                	mov    %esp,%ebp
40000510:	83 ec 34             	sub    $0x34,%esp
    return keycode;
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

40000513:	8b 45 08             	mov    0x8(%ebp),%eax
40000516:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%ebp)
4000051d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000520:	8b 45 0c             	mov    0xc(%ebp),%eax
40000523:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
40000526:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000529:	50                   	push   %eax
    return keycode;
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

4000052a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000531:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000538:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
4000053f:	e8 f0 10 00 00       	call   40001634 <syscall>

    return kc_to_char[index][keycode];
}
40000544:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000547:	c9                   	leave  
40000548:	c3                   	ret    

40000549 <texec>:

static void send_command(uint8_t command)
40000549:	55                   	push   %ebp
4000054a:	89 e5                	mov    %esp,%ebp
4000054c:	56                   	push   %esi
4000054d:	53                   	push   %ebx
{
4000054e:	53                   	push   %ebx
4000054f:	53                   	push   %ebx
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
40000550:	8b 75 08             	mov    0x8(%ebp),%esi
{
40000553:	ff 75 0c             	pushl  0xc(%ebp)
40000556:	56                   	push   %esi
40000557:	e8 b1 ff ff ff       	call   4000050d <exec>
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
4000055c:	83 c4 10             	add    $0x10,%esp

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
4000055f:	89 c3                	mov    %eax,%ebx
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
40000561:	85 c0                	test   %eax,%eax
40000563:	75 11                	jne    40000576 <texec+0x2d>
        }
40000565:	e8 6a 05 00 00       	call   40000ad4 <getLastVFSErr>
4000056a:	51                   	push   %ecx
4000056b:	51                   	push   %ecx
4000056c:	50                   	push   %eax
4000056d:	56                   	push   %esi
4000056e:	e8 29 ff ff ff       	call   4000049c <printFilesystemError>
40000573:	83 c4 10             	add    $0x10,%esp

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000576:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000579:	89 d8                	mov    %ebx,%eax
4000057b:	5b                   	pop    %ebx
4000057c:	5e                   	pop    %esi
4000057d:	5d                   	pop    %ebp
4000057e:	c3                   	ret    

4000057f <changeExecPath>:
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
4000057f:	55                   	push   %ebp
40000580:	89 e5                	mov    %esp,%ebp
40000582:	83 ec 34             	sub    $0x34,%esp

        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
40000585:	8b 45 08             	mov    0x8(%ebp),%eax
40000588:	c7 45 e0 07 00 00 00 	movl   $0x7,-0x20(%ebp)
4000058f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    keycode = 119;
                    break;
40000592:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000595:	50                   	push   %eax

        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
40000596:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000059d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400005a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400005ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                    keycode = 119;
                    break;
400005b2:	e8 7d 10 00 00       	call   40001634 <syscall>

                default:
                    keycode = 0x0;
400005b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
400005ba:	c9                   	leave  
400005bb:	c3                   	ret    

400005bc <cd>:
            };
            break;
400005bc:	55                   	push   %ebp
400005bd:	89 e5                	mov    %esp,%ebp
400005bf:	53                   	push   %ebx
400005c0:	83 ec 10             	sub    $0x10,%esp
400005c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
    }
400005c6:	53                   	push   %ebx
400005c7:	e8 b3 ff ff ff       	call   4000057f <changeExecPath>
400005cc:	83 c4 10             	add    $0x10,%esp
400005cf:	85 c0                	test   %eax,%eax
400005d1:	75 11                	jne    400005e4 <cd+0x28>
400005d3:	e8 fc 04 00 00       	call   40000ad4 <getLastVFSErr>
400005d8:	52                   	push   %edx
400005d9:	52                   	push   %edx
400005da:	50                   	push   %eax
400005db:	53                   	push   %ebx
400005dc:	e8 bb fe ff ff       	call   4000049c <printFilesystemError>
400005e1:	83 c4 10             	add    $0x10,%esp

400005e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400005e7:	c9                   	leave  
400005e8:	c3                   	ret    

400005e9 <getExecPath>:

#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;
400005e9:	55                   	push   %ebp
400005ea:	89 e5                	mov    %esp,%ebp
400005ec:	83 ec 34             	sub    $0x34,%esp
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
400005ef:	8b 45 08             	mov    0x8(%ebp),%eax
400005f2:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
400005f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            keycode = sc_to_kc[0][scancode];
            break;
400005fc:	8d 45 e0             	lea    -0x20(%ebp),%eax
400005ff:	50                   	push   %eax
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
40000600:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000607:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000060e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000615:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            keycode = sc_to_kc[0][scancode];
            break;
4000061c:	e8 13 10 00 00       	call   40001634 <syscall>
40000621:	83 c4 10             	add    $0x10,%esp

40000624:	c9                   	leave  
40000625:	c3                   	ret    

40000626 <exit>:
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
40000626:	55                   	push   %ebp
40000627:	89 e5                	mov    %esp,%ebp
40000629:	83 ec 34             	sub    $0x34,%esp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000062c:	8b 45 08             	mov    0x8(%ebp),%eax
4000062f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
40000636:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
40000639:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000063c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000643:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000064a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000651:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
40000658:	50                   	push   %eax
40000659:	e8 d6 0f 00 00       	call   40001634 <syscall>
};

#define KF_PRESSED (1 << 0)
4000065e:	c7 04 24 ee 31 00 40 	movl   $0x400031ee,(%esp)
40000665:	e8 86 06 00 00       	call   40000cf0 <printf>
4000066a:	eb f2                	jmp    4000065e <exit+0x38>

4000066c <yield>:
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000066c:	55                   	push   %ebp
4000066d:	89 e5                	mov    %esp,%ebp
4000066f:	83 ec 34             	sub    $0x34,%esp
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000672:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
40000675:	c7 45 e0 05 00 00 00 	movl   $0x5,-0x20(%ebp)
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
4000067c:	50                   	push   %eax
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
4000067d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000684:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000068b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000692:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000699:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006a0:	e8 8f 0f 00 00       	call   40001634 <syscall>
400006a5:	83 c4 10             	add    $0x10,%esp
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400006a8:	c9                   	leave  
400006a9:	c3                   	ret    

400006aa <pexists>:
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400006aa:	55                   	push   %ebp
400006ab:	89 e5                	mov    %esp,%ebp
400006ad:	83 ec 34             	sub    $0x34,%esp

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400006b0:	8b 45 08             	mov    0x8(%ebp),%eax
400006b3:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
400006ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400006bd:	8d 45 e0             	lea    -0x20(%ebp),%eax
400006c0:	50                   	push   %eax

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400006c1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400006c8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400006cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400006d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400006dd:	e8 52 0f 00 00       	call   40001634 <syscall>
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
400006e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
400006e5:	c9                   	leave  
400006e6:	c3                   	ret    

400006e7 <register_irq_handler>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006e7:	55                   	push   %ebp
400006e8:	89 e5                	mov    %esp,%ebp
400006ea:	53                   	push   %ebx
400006eb:	83 ec 30             	sub    $0x30,%esp
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400006ee:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400006f4:	50                   	push   %eax
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400006f5:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
400006fc:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
400006ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000706:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000070d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000714:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000071b:	e8 14 0f 00 00       	call   40001634 <syscall>
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000720:	83 c4 10             	add    $0x10,%esp
40000723:	31 c0                	xor    %eax,%eax
40000725:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
40000729:	74 0f                	je     4000073a <register_irq_handler+0x53>
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
4000072b:	8b 45 0c             	mov    0xc(%ebp),%eax
4000072e:	89 04 9d 14 40 00 40 	mov    %eax,0x40004014(,%ebx,4)
40000735:	b8 01 00 00 00       	mov    $0x1,%eax
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000073a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000073d:	c9                   	leave  
4000073e:	c3                   	ret    

4000073f <fetch_rpc_data>:
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
4000073f:	55                   	push   %ebp
40000740:	89 e5                	mov    %esp,%ebp
40000742:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

40000745:	8b 45 08             	mov    0x8(%ebp),%eax
40000748:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
4000074f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
40000752:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000755:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

40000756:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000075d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000764:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000076b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
40000772:	e8 bd 0e 00 00       	call   40001634 <syscall>
40000777:	83 c4 10             	add    $0x10,%esp
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
4000077a:	c9                   	leave  
4000077b:	c3                   	ret    

4000077c <call_rpc>:
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000077c:	55                   	push   %ebp
4000077d:	89 e5                	mov    %esp,%ebp
4000077f:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000782:	8b 45 08             	mov    0x8(%ebp),%eax
40000785:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%ebp)
4000078c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000078f:	8b 45 0c             	mov    0xc(%ebp),%eax
40000792:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000795:	8b 45 10             	mov    0x10(%ebp),%eax
40000798:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000079b:	8b 45 14             	mov    0x14(%ebp),%eax
4000079e:	89 45 f0             	mov    %eax,-0x10(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400007a1:	8d 45 e0             	lea    -0x20(%ebp),%eax
400007a4:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400007ac:	e8 83 0e 00 00       	call   40001634 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
400007b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
400007b4:	c9                   	leave  
400007b5:	c3                   	ret    

400007b6 <set_rpc_handler>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
400007b6:	55                   	push   %ebp
400007b7:	89 e5                	mov    %esp,%ebp
400007b9:	57                   	push   %edi
400007ba:	56                   	push   %esi
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400007bb:	be 10 31 00 40       	mov    $0x40003110,%esi
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
400007c0:	83 ec 24             	sub    $0x24,%esp
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400007c3:	8d 7d e0             	lea    -0x20(%ebp),%edi

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;
400007c6:	68 00 02 00 00       	push   $0x200
400007cb:	6a 00                	push   $0x0
400007cd:	68 14 40 00 40       	push   $0x40004014
400007d2:	e8 c5 07 00 00       	call   40000f9c <memset>
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400007d7:	b9 06 00 00 00       	mov    $0x6,%ecx
            keycode = sc_to_kc[1][scancode];
            break;
400007dc:	8d 45 e0             	lea    -0x20(%ebp),%eax
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400007df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
            keycode = sc_to_kc[1][scancode];
            break;
400007e1:	89 04 24             	mov    %eax,(%esp)
400007e4:	e8 4b 0e 00 00       	call   40001634 <syscall>
400007e9:	83 c4 10             	add    $0x10,%esp

400007ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
400007ef:	5e                   	pop    %esi
400007f0:	5f                   	pop    %edi
400007f1:	5d                   	pop    %ebp
400007f2:	c3                   	ret    

400007f3 <_start>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007f3:	55                   	push   %ebp
400007f4:	89 e5                	mov    %esp,%ebp
400007f6:	56                   	push   %esi
400007f7:	53                   	push   %ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400007f8:	31 db                	xor    %ebx,%ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007fa:	83 ec 2c             	sub    $0x2c,%esp
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
400007fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000800:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
40000807:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000080e:	50                   	push   %eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000080f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000816:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000081d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000824:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000082b:	e8 04 0e 00 00       	call   40001634 <syscall>
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
40000830:	8b 75 e0             	mov    -0x20(%ebp),%esi
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40000833:	83 c4 10             	add    $0x10,%esp
40000836:	85 f6                	test   %esi,%esi
40000838:	75 05                	jne    4000083f <_start+0x4c>
4000083a:	89 f3                	mov    %esi,%ebx
4000083c:	eb 07                	jmp    40000845 <_start+0x52>

static char kc_to_char[][128] = {
4000083e:	43                   	inc    %ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

4000083f:	83 3c 9e 00          	cmpl   $0x0,(%esi,%ebx,4)
40000843:	75 f9                	jne    4000083e <_start+0x4b>
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
40000845:	e8 6c ff ff ff       	call   400007b6 <set_rpc_handler>
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
4000084a:	51                   	push   %ecx
4000084b:	51                   	push   %ecx
4000084c:	56                   	push   %esi
4000084d:	53                   	push   %ebx
4000084e:	e8 d5 fa ff ff       	call   40000328 <main>
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
40000853:	89 04 24             	mov    %eax,(%esp)
40000856:	e8 cb fd ff ff       	call   40000626 <exit>
4000085b:	83 c4 10             	add    $0x10,%esp
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000085e:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000861:	5b                   	pop    %ebx
40000862:	5e                   	pop    %esi
40000863:	5d                   	pop    %ebp
40000864:	c3                   	ret    

40000865 <_handle_rpc>:
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000865:	55                   	push   %ebp
40000866:	89 e5                	mov    %esp,%ebp
40000868:	56                   	push   %esi
40000869:	53                   	push   %ebx
4000086a:	83 ec 2c             	sub    $0x2c,%esp
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
4000086d:	ff 75 10             	pushl  0x10(%ebp)
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000870:	8b 75 0c             	mov    0xc(%ebp),%esi
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000873:	e8 bd 0a 00 00       	call   40001335 <malloc>
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000878:	89 04 24             	mov    %eax,(%esp)
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
4000087b:	89 c3                	mov    %eax,%ebx
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000087d:	e8 bd fe ff ff       	call   4000073f <fetch_rpc_data>
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000882:	83 c4 10             	add    $0x10,%esp
40000885:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40000889:	75 4b                	jne    400008d6 <_handle_rpc+0x71>
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000088b:	8b 04 b5 14 40 00 40 	mov    0x40004014(,%esi,4),%eax
40000892:	85 c0                	test   %eax,%eax
40000894:	74 40                	je     400008d6 <_handle_rpc+0x71>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000896:	83 ec 0c             	sub    $0xc,%esp
40000899:	56                   	push   %esi
4000089a:	ff d0                	call   *%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000089c:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000089f:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400008a6:	89 04 24             	mov    %eax,(%esp)
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400008a9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400008b0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400008b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400008be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400008c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400008cc:	e8 63 0d 00 00       	call   40001634 <syscall>
400008d1:	83 c4 10             	add    $0x10,%esp
400008d4:	eb fe                	jmp    400008d4 <_handle_rpc+0x6f>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)

400008d6:	83 ec 0c             	sub    $0xc,%esp
400008d9:	68 f5 31 00 40       	push   $0x400031f5
400008de:	e8 0d 04 00 00       	call   40000cf0 <printf>
uint32_t key_flags[256];

400008e3:	89 1c 24             	mov    %ebx,(%esp)
400008e6:	e8 01 09 00 00       	call   400011ec <free>
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400008eb:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400008ee:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400008f5:	89 04 24             	mov    %eax,(%esp)
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400008f8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400008ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000906:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000090d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000914:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000091b:	e8 14 0d 00 00       	call   40001634 <syscall>
40000920:	83 c4 10             	add    $0x10,%esp
40000923:	eb fe                	jmp    40000923 <_handle_rpc+0xbe>
40000925:	00 00                	add    %al,(%eax)
	...

40000928 <resolveHandle>:
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
40000928:	55                   	push   %ebp
40000929:	89 e5                	mov    %esp,%ebp
4000092b:	83 ec 28             	sub    $0x28,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
4000092e:	3d fe 0f 00 00       	cmp    $0xffe,%eax
40000933:	77 38                	ja     4000096d <resolveHandle+0x45>

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000935:	83 ec 0c             	sub    $0xc,%esp
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000938:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000093b:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000093e:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000945:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000946:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000094d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000954:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000095b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000962:	e8 cd 0c 00 00       	call   40001634 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000967:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000096a:	83 c4 10             	add    $0x10,%esp
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
4000096d:	c9                   	leave  
4000096e:	c3                   	ret    

4000096f <fmkfifo>:
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
4000096f:	55                   	push   %ebp
40000970:	89 e5                	mov    %esp,%ebp
40000972:	83 ec 34             	sub    $0x34,%esp
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
40000975:	8b 45 08             	mov    0x8(%ebp),%eax
40000978:	c7 45 e0 0e 00 00 00 	movl   $0xe,-0x20(%ebp)
4000097f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    } else {
        // Normaler Scancode
40000982:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000985:	50                   	push   %eax
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
40000986:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000098d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000994:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000099b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    } else {
        // Normaler Scancode
400009a2:	e8 8d 0c 00 00       	call   40001634 <syscall>
        keycode = translate_scancode(0, scancode);
    }

400009a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
400009aa:	c9                   	leave  
400009ab:	c3                   	ret    

400009ac <favailable>:
                case 0x451D:
                    keycode = 119;
                    break;

                default:
                    keycode = 0x0;
400009ac:	55                   	push   %ebp
400009ad:	89 e5                	mov    %esp,%ebp
400009af:	83 ec 34             	sub    $0x34,%esp
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

400009b2:	8b 45 08             	mov    0x8(%ebp),%eax
400009b5:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
400009bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    return keycode;
}
400009bf:	8d 45 e0             	lea    -0x20(%ebp),%eax
400009c2:	50                   	push   %eax
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

400009c3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400009ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400009d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400009d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    return keycode;
}
400009df:	e8 50 0c 00 00       	call   40001634 <syscall>

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;
400009e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
400009e7:	c9                   	leave  
400009e8:	c3                   	ret    

400009e9 <fclose>:
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
400009e9:	55                   	push   %ebp
400009ea:	89 e5                	mov    %esp,%ebp
400009ec:	83 ec 34             	sub    $0x34,%esp
#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;

400009ef:	8b 45 08             	mov    0x8(%ebp),%eax
400009f2:	c7 45 e0 0b 00 00 00 	movl   $0xb,-0x20(%ebp)
400009f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static uint8_t translate_scancode(int set, uint16_t scancode)
{
400009fc:	8d 45 e0             	lea    -0x20(%ebp),%eax
400009ff:	50                   	push   %eax
#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;

40000a00:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000a1c:	e8 13 0c 00 00       	call   40001634 <syscall>
    uint8_t keycode = 0;

    switch (set) {
40000a21:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a24:	c9                   	leave  
40000a25:	c3                   	ret    

40000a26 <fopen>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000a26:	55                   	push   %ebp
40000a27:	89 e5                	mov    %esp,%ebp
40000a29:	83 ec 34             	sub    $0x34,%esp
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000a2c:	8b 45 08             	mov    0x8(%ebp),%eax
40000a2f:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
40000a36:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000a39:	8b 45 0c             	mov    0xc(%ebp),%eax
40000a3c:	89 45 e8             	mov    %eax,-0x18(%ebp)
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a3f:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000a42:	50                   	push   %eax
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000a43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a58:	e8 d7 0b 00 00       	call   40001634 <syscall>
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a60:	c9                   	leave  
40000a61:	c3                   	ret    

40000a62 <fopenpmhandle>:
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40000a62:	55                   	push   %ebp
40000a63:	89 e5                	mov    %esp,%ebp
40000a65:	83 ec 34             	sub    $0x34,%esp
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40000a68:	8b 45 08             	mov    0x8(%ebp),%eax
40000a6b:	c7 45 e0 15 00 00 00 	movl   $0x15,-0x20(%ebp)
40000a72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000a75:	8b 45 0c             	mov    0xc(%ebp),%eax
40000a78:	89 45 e8             	mov    %eax,-0x18(%ebp)
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000a7b:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000a7e:	50                   	push   %eax
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40000a7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000a94:	e8 9b 0b 00 00       	call   40001634 <syscall>
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a99:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a9c:	c9                   	leave  
40000a9d:	c3                   	ret    

40000a9e <setstderr>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
40000a9e:	55                   	push   %ebp
40000a9f:	89 e5                	mov    %esp,%ebp
40000aa1:	83 ec 10             	sub    $0x10,%esp
40000aa4:	ff 75 08             	pushl  0x8(%ebp)
40000aa7:	6a 03                	push   $0x3
40000aa9:	e8 b4 ff ff ff       	call   40000a62 <fopenpmhandle>
40000aae:	c9                   	leave  
40000aaf:	c3                   	ret    

40000ab0 <setstdin>:
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
40000ab0:	55                   	push   %ebp
40000ab1:	89 e5                	mov    %esp,%ebp
40000ab3:	83 ec 10             	sub    $0x10,%esp
40000ab6:	ff 75 08             	pushl  0x8(%ebp)
40000ab9:	6a 02                	push   $0x2
40000abb:	e8 a2 ff ff ff       	call   40000a62 <fopenpmhandle>
40000ac0:	c9                   	leave  
40000ac1:	c3                   	ret    

40000ac2 <setstdout>:
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000ac2:	55                   	push   %ebp
40000ac3:	89 e5                	mov    %esp,%ebp
40000ac5:	83 ec 10             	sub    $0x10,%esp
40000ac8:	ff 75 08             	pushl  0x8(%ebp)
40000acb:	6a 01                	push   $0x1
40000acd:	e8 90 ff ff ff       	call   40000a62 <fopenpmhandle>
40000ad2:	c9                   	leave  
40000ad3:	c3                   	ret    

40000ad4 <getLastVFSErr>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ports.h"
40000ad4:	55                   	push   %ebp
40000ad5:	89 e5                	mov    %esp,%ebp
40000ad7:	83 ec 34             	sub    $0x34,%esp
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000ada:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000add:	c7 45 e0 0f 00 00 00 	movl   $0xf,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000ae4:	50                   	push   %eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000ae5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000aec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000af3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000afa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000b01:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b08:	e8 27 0b 00 00       	call   40001634 <syscall>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40000b0d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000b10:	c9                   	leave  
40000b11:	c3                   	ret    

40000b12 <fwrite>:
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40000b12:	55                   	push   %ebp
40000b13:	89 e5                	mov    %esp,%ebp
40000b15:	57                   	push   %edi
40000b16:	56                   	push   %esi
40000b17:	53                   	push   %ebx
40000b18:	83 ec 3c             	sub    $0x3c,%esp
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b1b:	8b 45 08             	mov    0x8(%ebp),%eax
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40000b1e:	8b 7d 10             	mov    0x10(%ebp),%edi
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b21:	e8 02 fe ff ff       	call   40000928 <resolveHandle>

static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b26:	83 ec 0c             	sub    $0xc,%esp

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b29:	89 c6                	mov    %eax,%esi
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b2b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40000b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
40000b31:	c7 45 d0 0c 00 00 00 	movl   $0xc,-0x30(%ebp)
40000b38:	89 45 d8             	mov    %eax,-0x28(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b3b:	8d 45 d0             	lea    -0x30(%ebp),%eax
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b3e:	89 7d dc             	mov    %edi,-0x24(%ebp)
40000b41:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000b48:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b4f:	50                   	push   %eax
40000b50:	89 45 c4             	mov    %eax,-0x3c(%ebp)
40000b53:	eb 2d                	jmp    40000b82 <fwrite+0x70>
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40000b55:	e8 12 fb ff ff       	call   4000066c <yield>
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b5d:	83 ec 0c             	sub    $0xc,%esp
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b60:	89 45 d8             	mov    %eax,-0x28(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b63:	8d 45 d0             	lea    -0x30(%ebp),%eax
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b66:	c7 45 d0 0c 00 00 00 	movl   $0xc,-0x30(%ebp)
40000b6d:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000b70:	89 7d dc             	mov    %edi,-0x24(%ebp)
40000b73:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000b7a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b81:	50                   	push   %eax
40000b82:	e8 ad 0a 00 00       	call   40001634 <syscall>

        port_out(PORTM_BYTE, 0x60, command);
40000b87:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40000b8a:	83 c4 10             	add    $0x10,%esp
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
40000b8d:	83 fb 01             	cmp    $0x1,%ebx
40000b90:	74 c3                	je     40000b55 <fwrite+0x43>
    uint8_t keycode = 0;
    int break_code = 0;

    static int      e0_code = 0;
    static int      e1_code = 0;
40000b92:	89 f0                	mov    %esi,%eax
40000b94:	89 da                	mov    %ebx,%edx
40000b96:	e8 3d 02 00 00       	call   40000dd8 <printrwerror>
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000b9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000b9e:	89 d8                	mov    %ebx,%eax
40000ba0:	5b                   	pop    %ebx
40000ba1:	5e                   	pop    %esi
40000ba2:	5f                   	pop    %edi
40000ba3:	5d                   	pop    %ebp
40000ba4:	c3                   	ret    

40000ba5 <fputs>:
40000ba5:	55                   	push   %ebp
40000ba6:	89 e5                	mov    %esp,%ebp
40000ba8:	56                   	push   %esi
40000ba9:	53                   	push   %ebx
40000baa:	83 ec 20             	sub    $0x20,%esp
40000bad:	8b 45 0c             	mov    0xc(%ebp),%eax
40000bb0:	8b 5d 08             	mov    0x8(%ebp),%ebx
40000bb3:	e8 70 fd ff ff       	call   40000928 <resolveHandle>
40000bb8:	89 c6                	mov    %eax,%esi
40000bba:	85 c0                	test   %eax,%eax
40000bbc:	74 16                	je     40000bd4 <fputs+0x2f>
40000bbe:	83 ec 0c             	sub    $0xc,%esp
40000bc1:	53                   	push   %ebx
40000bc2:	e8 a7 04 00 00       	call   4000106e <strlen>
40000bc7:	83 c4 0c             	add    $0xc,%esp
40000bca:	50                   	push   %eax
40000bcb:	53                   	push   %ebx
40000bcc:	56                   	push   %esi
40000bcd:	e8 40 ff ff ff       	call   40000b12 <fwrite>
40000bd2:	eb 35                	jmp    40000c09 <fputs+0x64>
40000bd4:	83 ec 0c             	sub    $0xc,%esp
40000bd7:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000bda:	c7 45 e0 ca 00 00 00 	movl   $0xca,-0x20(%ebp)
40000be1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40000be4:	50                   	push   %eax
40000be5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000bec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000bf3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000bfa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40000c01:	e8 2e 0a 00 00       	call   40001634 <syscall>
40000c06:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c09:	83 c4 10             	add    $0x10,%esp
40000c0c:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000c0f:	5b                   	pop    %ebx
40000c10:	5e                   	pop    %esi
40000c11:	5d                   	pop    %ebp
40000c12:	c3                   	ret    

40000c13 <puts>:
40000c13:	55                   	push   %ebp
40000c14:	89 e5                	mov    %esp,%ebp
40000c16:	83 ec 10             	sub    $0x10,%esp
40000c19:	6a 01                	push   $0x1
40000c1b:	ff 75 08             	pushl  0x8(%ebp)
40000c1e:	e8 82 ff ff ff       	call   40000ba5 <fputs>
40000c23:	c9                   	leave  
40000c24:	c3                   	ret    

40000c25 <putn>:
40000c25:	55                   	push   %ebp
40000c26:	89 e5                	mov    %esp,%ebp
40000c28:	56                   	push   %esi
40000c29:	53                   	push   %ebx
40000c2a:	31 f6                	xor    %esi,%esi
40000c2c:	83 ec 50             	sub    $0x50,%esp
40000c2f:	89 d3                	mov    %edx,%ebx
40000c31:	83 fa 24             	cmp    $0x24,%edx
40000c34:	7f 25                	jg     40000c5b <putn+0x36>
40000c36:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
40000c3a:	8d 4d f7             	lea    -0x9(%ebp),%ecx
40000c3d:	31 d2                	xor    %edx,%edx
40000c3f:	49                   	dec    %ecx
40000c40:	f7 f3                	div    %ebx
40000c42:	46                   	inc    %esi
40000c43:	85 c0                	test   %eax,%eax
40000c45:	8a 92 05 32 00 40    	mov    0x40003205(%edx),%dl
40000c4b:	88 11                	mov    %dl,(%ecx)
40000c4d:	75 ee                	jne    40000c3d <putn+0x18>
40000c4f:	83 ec 0c             	sub    $0xc,%esp
40000c52:	51                   	push   %ecx
40000c53:	e8 bb ff ff ff       	call   40000c13 <puts>
40000c58:	83 c4 10             	add    $0x10,%esp
40000c5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000c5e:	89 f0                	mov    %esi,%eax
40000c60:	5b                   	pop    %ebx
40000c61:	5e                   	pop    %esi
40000c62:	5d                   	pop    %ebp
40000c63:	c3                   	ret    

40000c64 <fputc>:
40000c64:	55                   	push   %ebp
40000c65:	89 e5                	mov    %esp,%ebp
40000c67:	83 ec 38             	sub    $0x38,%esp
40000c6a:	8b 45 08             	mov    0x8(%ebp),%eax
40000c6d:	88 45 d4             	mov    %al,-0x2c(%ebp)
40000c70:	8b 45 0c             	mov    0xc(%ebp),%eax
40000c73:	e8 b0 fc ff ff       	call   40000928 <resolveHandle>
40000c78:	85 c0                	test   %eax,%eax
40000c7a:	74 0f                	je     40000c8b <fputc+0x27>
40000c7c:	52                   	push   %edx
40000c7d:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40000c80:	6a 01                	push   $0x1
40000c82:	52                   	push   %edx
40000c83:	50                   	push   %eax
40000c84:	e8 89 fe ff ff       	call   40000b12 <fwrite>
40000c89:	eb 39                	jmp    40000cc4 <fputc+0x60>
40000c8b:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
40000c8f:	83 ec 0c             	sub    $0xc,%esp
40000c92:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000c95:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000c98:	c7 45 e0 c9 00 00 00 	movl   $0xc9,-0x20(%ebp)
40000c9f:	50                   	push   %eax
40000ca0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000ca7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000cae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000cb5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40000cbc:	e8 73 09 00 00       	call   40001634 <syscall>
40000cc1:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000cc4:	83 c4 10             	add    $0x10,%esp
40000cc7:	c9                   	leave  
40000cc8:	c3                   	ret    

40000cc9 <putc>:
40000cc9:	55                   	push   %ebp
40000cca:	89 e5                	mov    %esp,%ebp
40000ccc:	83 ec 08             	sub    $0x8,%esp
40000ccf:	0f be 45 08          	movsbl 0x8(%ebp),%eax
40000cd3:	89 45 08             	mov    %eax,0x8(%ebp)
40000cd6:	c9                   	leave  
40000cd7:	e9 88 ff ff ff       	jmp    40000c64 <fputc>

40000cdc <putchar>:
40000cdc:	55                   	push   %ebp
40000cdd:	89 e5                	mov    %esp,%ebp
40000cdf:	83 ec 10             	sub    $0x10,%esp
40000ce2:	0f be 45 08          	movsbl 0x8(%ebp),%eax
40000ce6:	6a 01                	push   $0x1
40000ce8:	50                   	push   %eax
40000ce9:	e8 76 ff ff ff       	call   40000c64 <fputc>
40000cee:	c9                   	leave  
40000cef:	c3                   	ret    

40000cf0 <printf>:
40000cf0:	55                   	push   %ebp
40000cf1:	89 e5                	mov    %esp,%ebp
40000cf3:	57                   	push   %edi
40000cf4:	56                   	push   %esi
40000cf5:	53                   	push   %ebx
40000cf6:	83 ec 1c             	sub    $0x1c,%esp
40000cf9:	8d 75 0c             	lea    0xc(%ebp),%esi
40000cfc:	8b 7d 08             	mov    0x8(%ebp),%edi
40000cff:	31 db                	xor    %ebx,%ebx
40000d01:	e9 be 00 00 00       	jmp    40000dc4 <printf+0xd4>
40000d06:	3c 25                	cmp    $0x25,%al
40000d08:	0f 85 a4 00 00 00    	jne    40000db2 <printf+0xc2>
40000d0e:	47                   	inc    %edi
40000d0f:	8a 07                	mov    (%edi),%al
40000d11:	3c 70                	cmp    $0x70,%al
40000d13:	74 47                	je     40000d5c <printf+0x6c>
40000d15:	7f 1a                	jg     40000d31 <printf+0x41>
40000d17:	3c 63                	cmp    $0x63,%al
40000d19:	74 5a                	je     40000d75 <printf+0x85>
40000d1b:	7f 0e                	jg     40000d2b <printf+0x3b>
40000d1d:	84 c0                	test   %al,%al
40000d1f:	0f 84 a9 00 00 00    	je     40000dce <printf+0xde>
40000d25:	3c 25                	cmp    $0x25,%al
40000d27:	75 6c                	jne    40000d95 <printf+0xa5>
40000d29:	eb 63                	jmp    40000d8e <printf+0x9e>
40000d2b:	3c 64                	cmp    $0x64,%al
40000d2d:	75 66                	jne    40000d95 <printf+0xa5>
40000d2f:	eb 1e                	jmp    40000d4f <printf+0x5f>
40000d31:	3c 75                	cmp    $0x75,%al
40000d33:	74 1a                	je     40000d4f <printf+0x5f>
40000d35:	3c 78                	cmp    $0x78,%al
40000d37:	74 23                	je     40000d5c <printf+0x6c>
40000d39:	3c 73                	cmp    $0x73,%al
40000d3b:	75 58                	jne    40000d95 <printf+0xa5>
40000d3d:	83 ec 0c             	sub    $0xc,%esp
40000d40:	8d 46 04             	lea    0x4(%esi),%eax
40000d43:	ff 36                	pushl  (%esi)
40000d45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d48:	e8 c6 fe ff ff       	call   40000c13 <puts>
40000d4d:	eb 38                	jmp    40000d87 <printf+0x97>
40000d4f:	8d 46 04             	lea    0x4(%esi),%eax
40000d52:	ba 0a 00 00 00       	mov    $0xa,%edx
40000d57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d5a:	eb 0b                	jmp    40000d67 <printf+0x77>
40000d5c:	8d 46 04             	lea    0x4(%esi),%eax
40000d5f:	ba 10 00 00 00       	mov    $0x10,%edx
40000d64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d67:	8b 06                	mov    (%esi),%eax
40000d69:	e8 b7 fe ff ff       	call   40000c25 <putn>
40000d6e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40000d71:	01 c3                	add    %eax,%ebx
40000d73:	eb 4e                	jmp    40000dc3 <printf+0xd3>
40000d75:	8d 46 04             	lea    0x4(%esi),%eax
40000d78:	83 ec 0c             	sub    $0xc,%esp
40000d7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d7e:	0f be 06             	movsbl (%esi),%eax
40000d81:	50                   	push   %eax
40000d82:	e8 55 ff ff ff       	call   40000cdc <putchar>
40000d87:	01 c3                	add    %eax,%ebx
40000d89:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40000d8c:	eb 32                	jmp    40000dc0 <printf+0xd0>
40000d8e:	83 ec 0c             	sub    $0xc,%esp
40000d91:	6a 25                	push   $0x25
40000d93:	eb 24                	jmp    40000db9 <printf+0xc9>
40000d95:	83 ec 0c             	sub    $0xc,%esp
40000d98:	6a 25                	push   $0x25
40000d9a:	e8 3d ff ff ff       	call   40000cdc <putchar>
40000d9f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000da2:	0f be 07             	movsbl (%edi),%eax
40000da5:	89 04 24             	mov    %eax,(%esp)
40000da8:	e8 2f ff ff ff       	call   40000cdc <putchar>
40000dad:	03 45 e4             	add    -0x1c(%ebp),%eax
40000db0:	eb 0c                	jmp    40000dbe <printf+0xce>
40000db2:	83 ec 0c             	sub    $0xc,%esp
40000db5:	0f be c0             	movsbl %al,%eax
40000db8:	50                   	push   %eax
40000db9:	e8 1e ff ff ff       	call   40000cdc <putchar>
40000dbe:	01 c3                	add    %eax,%ebx
40000dc0:	83 c4 10             	add    $0x10,%esp
40000dc3:	47                   	inc    %edi
40000dc4:	8a 07                	mov    (%edi),%al
40000dc6:	84 c0                	test   %al,%al
40000dc8:	0f 85 38 ff ff ff    	jne    40000d06 <printf+0x16>
40000dce:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000dd1:	89 d8                	mov    %ebx,%eax
40000dd3:	5b                   	pop    %ebx
40000dd4:	5e                   	pop    %esi
40000dd5:	5f                   	pop    %edi
40000dd6:	5d                   	pop    %ebp
40000dd7:	c3                   	ret    

40000dd8 <printrwerror>:
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
40000dd8:	55                   	push   %ebp
40000dd9:	89 e5                	mov    %esp,%ebp
40000ddb:	83 ec 08             	sub    $0x8,%esp
            keycode = sc_to_kc[0][scancode];
40000dde:	83 fa 02             	cmp    $0x2,%edx
40000de1:	75 0a                	jne    40000ded <printrwerror+0x15>
            break;
40000de3:	52                   	push   %edx
40000de4:	52                   	push   %edx
40000de5:	50                   	push   %eax
40000de6:	68 2a 32 00 40       	push   $0x4000322a
40000deb:	eb 2b                	jmp    40000e18 <printrwerror+0x40>

        // e0-Scancodes
        case 1:
40000ded:	83 fa 03             	cmp    $0x3,%edx
40000df0:	75 0a                	jne    40000dfc <printrwerror+0x24>
            keycode = sc_to_kc[1][scancode];
40000df2:	51                   	push   %ecx
40000df3:	51                   	push   %ecx
40000df4:	50                   	push   %eax
40000df5:	68 42 32 00 40       	push   $0x40003242
40000dfa:	eb 1c                	jmp    40000e18 <printrwerror+0x40>
            break;

        // e1-Scancodes
40000dfc:	83 fa 04             	cmp    $0x4,%edx
40000dff:	75 0a                	jne    40000e0b <printrwerror+0x33>
        case 2:
40000e01:	52                   	push   %edx
40000e02:	52                   	push   %edx
40000e03:	50                   	push   %eax
40000e04:	68 5d 32 00 40       	push   $0x4000325d
40000e09:	eb 0d                	jmp    40000e18 <printrwerror+0x40>
            switch (scancode) {
                // Pause
                case 0x451D:
40000e0b:	83 fa 05             	cmp    $0x5,%edx
40000e0e:	75 10                	jne    40000e20 <printrwerror+0x48>
                    keycode = 119;
40000e10:	51                   	push   %ecx
40000e11:	51                   	push   %ecx
40000e12:	50                   	push   %eax
40000e13:	68 87 32 00 40       	push   $0x40003287
40000e18:	e8 d3 fe ff ff       	call   40000cf0 <printf>
40000e1d:	83 c4 10             	add    $0x10,%esp
                    break;

40000e20:	c9                   	leave  
40000e21:	c3                   	ret    

40000e22 <fread>:
    }

    if (e0_code) {
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40000e22:	55                   	push   %ebp
40000e23:	89 e5                	mov    %esp,%ebp
40000e25:	57                   	push   %edi
40000e26:	56                   	push   %esi
40000e27:	53                   	push   %ebx
40000e28:	83 ec 38             	sub    $0x38,%esp
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }
40000e2b:	8d 7d d0             	lea    -0x30(%ebp),%edi
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    }

    if (e0_code) {
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40000e31:	8b 75 08             	mov    0x8(%ebp),%esi
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e34:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000e37:	8b 45 10             	mov    0x10(%ebp),%eax
40000e3a:	c7 45 d0 0d 00 00 00 	movl   $0xd,-0x30(%ebp)
40000e41:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000e44:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000e47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000e4e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000e55:	eb 2c                	jmp    40000e83 <fread+0x61>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
        }

        keycode = translate_scancode(1, scancode);
40000e57:	e8 10 f8 ff ff       	call   4000066c <yield>
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e5c:	8b 45 0c             	mov    0xc(%ebp),%eax
40000e5f:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000e62:	8b 45 10             	mov    0x10(%ebp),%eax
40000e65:	c7 45 d0 0d 00 00 00 	movl   $0xd,-0x30(%ebp)
40000e6c:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000e6f:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000e72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000e79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        scancode &= ~0x80;
    }
40000e80:	83 ec 0c             	sub    $0xc,%esp
40000e83:	57                   	push   %edi
40000e84:	e8 ab 07 00 00       	call   40001634 <syscall>

    if (e0_code) {
40000e89:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40000e8c:	83 c4 10             	add    $0x10,%esp
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
        }

40000e8f:	83 fb 01             	cmp    $0x1,%ebx
40000e92:	74 c3                	je     40000e57 <fread+0x35>
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
40000e94:	89 f0                	mov    %esi,%eax
40000e96:	89 da                	mov    %ebx,%edx
40000e98:	e8 3b ff ff ff       	call   40000dd8 <printrwerror>
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
40000e9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000ea0:	89 d8                	mov    %ebx,%eax
40000ea2:	5b                   	pop    %ebx
40000ea3:	5e                   	pop    %esi
40000ea4:	5f                   	pop    %edi
40000ea5:	5d                   	pop    %ebp
40000ea6:	c3                   	ret    

40000ea7 <fgetc>:
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
    }

    if(break_code) {
        key_flags[keycode] &= ~KF_PRESSED;
40000ea7:	55                   	push   %ebp
40000ea8:	89 e5                	mov    %esp,%ebp
40000eaa:	83 ec 18             	sub    $0x18,%esp
    }
40000ead:	8b 45 08             	mov    0x8(%ebp),%eax
40000eb0:	e8 73 fa ff ff       	call   40000928 <resolveHandle>
    else
40000eb5:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
    {
40000eb9:	85 c0                	test   %eax,%eax
40000ebb:	74 10                	je     40000ecd <fgetc+0x26>
        key_flags[keycode] |= KF_PRESSED;
40000ebd:	8d 55 f7             	lea    -0x9(%ebp),%edx
40000ec0:	51                   	push   %ecx
40000ec1:	6a 01                	push   $0x1
40000ec3:	52                   	push   %edx
40000ec4:	50                   	push   %eax
40000ec5:	e8 58 ff ff ff       	call   40000e22 <fread>
40000eca:	83 c4 10             	add    $0x10,%esp
    }

    char chr = getcharfromkc(keycode);
40000ecd:	8a 45 f7             	mov    -0x9(%ebp),%al
40000ed0:	c9                   	leave  
40000ed1:	c3                   	ret    

40000ed2 <getchar>:
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
        port_in(PORTM_BYTE, 0x60);
40000ed2:	55                   	push   %ebp
40000ed3:	89 e5                	mov    %esp,%ebp
40000ed5:	83 ec 14             	sub    $0x14,%esp
    }
40000ed8:	6a 02                	push   $0x2
40000eda:	e8 c8 ff ff ff       	call   40000ea7 <fgetc>

40000edf:	c9                   	leave  
40000ee0:	c3                   	ret    

40000ee1 <getc>:
    printf("[kbcdrv] requesting neccesary resources...\n");

    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
    require_port(0x60);

40000ee1:	55                   	push   %ebp
40000ee2:	89 e5                	mov    %esp,%ebp
40000ee4:	83 ec 08             	sub    $0x8,%esp
    printf("[kbcdrv] emptying keyboard buffer...\n");

40000ee7:	c9                   	leave  

    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");
40000ee8:	e9 ba ff ff ff       	jmp    40000ea7 <fgetc>

40000eed <fgets>:
        key_flags[keycode] |= KF_PRESSED;
    }

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
40000eed:	55                   	push   %ebp
40000eee:	89 e5                	mov    %esp,%ebp
40000ef0:	57                   	push   %edi
40000ef1:	56                   	push   %esi
40000ef2:	53                   	push   %ebx
40000ef3:	83 ec 1c             	sub    $0x1c,%esp
40000ef6:	31 db                	xor    %ebx,%ebx
40000ef8:	8b 7d 0c             	mov    0xc(%ebp),%edi
40000efb:	8b 75 08             	mov    0x8(%ebp),%esi
        fwrite(charout, &chr, sizeof(char));
40000efe:	8d 47 ff             	lea    -0x1(%edi),%eax
40000f01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000f04:	eb 16                	jmp    40000f1c <fgets+0x2f>
    }
40000f06:	83 ec 0c             	sub    $0xc,%esp
40000f09:	ff 75 10             	pushl  0x10(%ebp)
40000f0c:	e8 96 ff ff ff       	call   40000ea7 <fgetc>
}
40000f11:	83 c4 10             	add    $0x10,%esp

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
    }
40000f14:	88 04 1e             	mov    %al,(%esi,%ebx,1)
}
40000f17:	84 c0                	test   %al,%al
40000f19:	74 0a                	je     40000f25 <fgets+0x38>
    }

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
40000f1b:	43                   	inc    %ebx
40000f1c:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
40000f1f:	7c e5                	jl     40000f06 <fgets+0x19>
}

int main(int argc, char* args[])
{
    printf("[kbcdrv] requesting neccesary resources...\n");

40000f21:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
40000f25:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000f28:	89 f0                	mov    %esi,%eax
40000f2a:	5b                   	pop    %ebx
40000f2b:	5e                   	pop    %esi
40000f2c:	5f                   	pop    %edi
40000f2d:	5d                   	pop    %ebp
40000f2e:	c3                   	ret    

40000f2f <getln>:
    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
        port_in(PORTM_BYTE, 0x60);
    }

    printf("[kbcdrv] initializing KBC...\n");

40000f2f:	55                   	push   %ebp
40000f30:	89 e5                	mov    %esp,%ebp
40000f32:	56                   	push   %esi
40000f33:	53                   	push   %ebx
40000f34:	31 db                	xor    %ebx,%ebx
40000f36:	8b 75 08             	mov    0x8(%ebp),%esi
    memset(key_flags, 0, 256 * sizeof(uint32_t));

    // Leds alle ausloeschen
    send_command(0xED);
40000f39:	eb 42                	jmp    40000f7d <getln+0x4e>
    send_command(0);
40000f3b:	3c 0a                	cmp    $0xa,%al
40000f3d:	75 0f                	jne    40000f4e <getln+0x1f>

40000f3f:	83 ec 0c             	sub    $0xc,%esp
40000f42:	6a 0a                	push   $0xa
40000f44:	e8 93 fd ff ff       	call   40000cdc <putchar>
    // Schnellste Wiederholrate
40000f49:	83 c4 10             	add    $0x10,%esp
40000f4c:	eb 40                	jmp    40000f8e <getln+0x5f>
    send_command(0xF3);
    send_command(0);

40000f4e:	3c 08                	cmp    $0x8,%al
40000f50:	75 18                	jne    40000f6a <getln+0x3b>
    send_command(0xF4);
40000f52:	85 db                	test   %ebx,%ebx
40000f54:	74 0e                	je     40000f64 <getln+0x35>

    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
40000f56:	83 ec 0c             	sub    $0xc,%esp
    // Schnellste Wiederholrate
    send_command(0xF3);
    send_command(0);

    send_command(0xF4);

40000f59:	4b                   	dec    %ebx
    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
40000f5a:	6a 08                	push   $0x8
40000f5c:	e8 7b fd ff ff       	call   40000cdc <putchar>
40000f61:	83 c4 10             	add    $0x10,%esp

    charout = fmkfifo("/dev/keyboard");
40000f64:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)

40000f68:	eb 13                	jmp    40000f7d <getln+0x4e>
    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000f6a:	83 ec 0c             	sub    $0xc,%esp

    charout = fmkfifo("/dev/keyboard");

    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
40000f6d:	88 04 1e             	mov    %al,(%esi,%ebx,1)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000f70:	0f be c0             	movsbl %al,%eax
40000f73:	50                   	push   %eax
    fclose(initCtrl);

40000f74:	43                   	inc    %ebx
    charout = fmkfifo("/dev/keyboard");

    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000f75:	e8 62 fd ff ff       	call   40000cdc <putchar>
    fclose(initCtrl);

40000f7a:	83 c4 10             	add    $0x10,%esp
    printf("[kbcdrv] initializing KBC...\n");

    memset(key_flags, 0, 256 * sizeof(uint32_t));

    // Leds alle ausloeschen
    send_command(0xED);
40000f7d:	83 ec 0c             	sub    $0xc,%esp
40000f80:	6a 02                	push   $0x2
40000f82:	e8 20 ff ff ff       	call   40000ea7 <fgetc>
40000f87:	83 c4 10             	add    $0x10,%esp
40000f8a:	84 c0                	test   %al,%al
40000f8c:	75 ad                	jne    40000f3b <getln+0xc>
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
    fclose(initCtrl);

    printf("[kbcdrv] Done!\n");

    while(1);
40000f8e:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)
}
40000f92:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000f95:	89 f0                	mov    %esi,%eax
40000f97:	5b                   	pop    %ebx
40000f98:	5e                   	pop    %esi
40000f99:	5d                   	pop    %ebp
40000f9a:	c3                   	ret    
	...

40000f9c <memset>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
40000f9c:	55                   	push   %ebp
40000f9d:	89 e5                	mov    %esp,%ebp
40000f9f:	53                   	push   %ebx
40000fa0:	8b 45 08             	mov    0x8(%ebp),%eax
40000fa3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40000fa6:	8b 4d 10             	mov    0x10(%ebp),%ecx
#include "ports.h"
40000fa9:	89 c2                	mov    %eax,%edx
 
uint32_t init_done = 0;
40000fab:	eb 04                	jmp    40000fb1 <memset+0x15>
static uint8_t sc_to_kc[][128] = {
40000fad:	88 1a                	mov    %bl,(%edx)
40000faf:	49                   	dec    %ecx
40000fb0:	42                   	inc    %edx
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ports.h"
 
uint32_t init_done = 0;
40000fb1:	85 c9                	test   %ecx,%ecx
40000fb3:	75 f8                	jne    40000fad <memset+0x11>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40000fb5:	5b                   	pop    %ebx
40000fb6:	5d                   	pop    %ebp
40000fb7:	c3                   	ret    

40000fb8 <memcpy>:
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40000fb8:	55                   	push   %ebp
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40000fb9:	31 c9                	xor    %ecx,%ecx
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40000fbb:	89 e5                	mov    %esp,%ebp
40000fbd:	56                   	push   %esi
40000fbe:	53                   	push   %ebx
40000fbf:	8b 75 10             	mov    0x10(%ebp),%esi
40000fc2:	8b 45 08             	mov    0x8(%ebp),%eax
40000fc5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40000fc8:	85 f6                	test   %esi,%esi
40000fca:	75 04                	jne    40000fd0 <memcpy+0x18>
40000fcc:	31 c0                	xor    %eax,%eax
40000fce:	eb 0a                	jmp    40000fda <memcpy+0x22>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000fd0:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
40000fd3:	88 14 08             	mov    %dl,(%eax,%ecx,1)
40000fd6:	41                   	inc    %ecx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000fd7:	4e                   	dec    %esi
40000fd8:	75 f6                	jne    40000fd0 <memcpy+0x18>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

40000fda:	5b                   	pop    %ebx
40000fdb:	5e                   	pop    %esi
40000fdc:	5d                   	pop    %ebp
40000fdd:	c3                   	ret    

40000fde <memcmp>:
    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
40000fde:	55                   	push   %ebp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000fdf:	83 c8 ff             	or     $0xffffffff,%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
40000fe2:	89 e5                	mov    %esp,%ebp
40000fe4:	57                   	push   %edi
40000fe5:	56                   	push   %esi
40000fe6:	53                   	push   %ebx
40000fe7:	8b 75 08             	mov    0x8(%ebp),%esi
40000fea:	8b 7d 0c             	mov    0xc(%ebp),%edi
40000fed:	8b 5d 10             	mov    0x10(%ebp),%ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000ff0:	85 f6                	test   %esi,%esi
40000ff2:	74 2c                	je     40001020 <memcmp+0x42>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000ff4:	b8 01 00 00 00       	mov    $0x1,%eax
40000ff9:	85 ff                	test   %edi,%edi
40000ffb:	74 23                	je     40001020 <memcmp+0x42>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000ffd:	31 d2                	xor    %edx,%edx
40000fff:	85 db                	test   %ebx,%ebx
40001001:	75 17                	jne    4000101a <memcmp+0x3c>
40001003:	eb 19                	jmp    4000101e <memcmp+0x40>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001005:	8a 04 16             	mov    (%esi,%edx,1),%al
40001008:	8a 0c 17             	mov    (%edi,%edx,1),%cl
4000100b:	38 c8                	cmp    %cl,%al
4000100d:	74 0a                	je     40001019 <memcmp+0x3b>
         00,  00,  00,  00,  00,  00,  00,  00
4000100f:	0f b6 c0             	movzbl %al,%eax
40001012:	0f b6 c9             	movzbl %cl,%ecx
40001015:	29 c8                	sub    %ecx,%eax
40001017:	eb 07                	jmp    40001020 <memcmp+0x42>
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001019:	42                   	inc    %edx
4000101a:	39 da                	cmp    %ebx,%edx
4000101c:	72 e7                	jb     40001005 <memcmp+0x27>
4000101e:	31 c0                	xor    %eax,%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

static char kc_to_char[][128] = {
40001020:	5b                   	pop    %ebx
40001021:	5e                   	pop    %esi
40001022:	5f                   	pop    %edi
40001023:	5d                   	pop    %ebp
40001024:	c3                   	ret    

40001025 <strcmp>:
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40001025:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001026:	31 c0                	xor    %eax,%eax
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40001028:	89 e5                	mov    %esp,%ebp
4000102a:	56                   	push   %esi
4000102b:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000102c:	31 db                	xor    %ebx,%ebx
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
4000102e:	8b 55 08             	mov    0x8(%ebp),%edx
40001031:	8b 4d 0c             	mov    0xc(%ebp),%ecx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001034:	85 d2                	test   %edx,%edx
40001036:	75 03                	jne    4000103b <strcmp+0x16>
40001038:	eb 09                	jmp    40001043 <strcmp+0x1e>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000103a:	40                   	inc    %eax
4000103b:	89 c3                	mov    %eax,%ebx
4000103d:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
40001041:	75 f7                	jne    4000103a <strcmp+0x15>
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001043:	31 c0                	xor    %eax,%eax
40001045:	31 f6                	xor    %esi,%esi
40001047:	85 c9                	test   %ecx,%ecx
40001049:	75 03                	jne    4000104e <strcmp+0x29>
4000104b:	eb 09                	jmp    40001056 <strcmp+0x31>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000104d:	40                   	inc    %eax
4000104e:	89 c6                	mov    %eax,%esi
40001050:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
40001054:	75 f7                	jne    4000104d <strcmp+0x28>
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
40001056:	89 f0                	mov    %esi,%eax
40001058:	39 de                	cmp    %ebx,%esi
4000105a:	7e 02                	jle    4000105e <strcmp+0x39>
4000105c:	89 d8                	mov    %ebx,%eax
4000105e:	40                   	inc    %eax
4000105f:	50                   	push   %eax
40001060:	51                   	push   %ecx
40001061:	52                   	push   %edx
40001062:	e8 77 ff ff ff       	call   40000fde <memcmp>
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
40001067:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000106a:	5b                   	pop    %ebx
4000106b:	5e                   	pop    %esi
4000106c:	5d                   	pop    %ebp
4000106d:	c3                   	ret    

4000106e <strlen>:
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
4000106e:	55                   	push   %ebp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000106f:	31 d2                	xor    %edx,%edx
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40001071:	89 e5                	mov    %esp,%ebp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001073:	31 c0                	xor    %eax,%eax
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40001075:	8b 4d 08             	mov    0x8(%ebp),%ecx
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001078:	85 c9                	test   %ecx,%ecx
4000107a:	75 03                	jne    4000107f <strlen+0x11>
4000107c:	eb 09                	jmp    40001087 <strlen+0x19>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000107e:	42                   	inc    %edx
4000107f:	89 d0                	mov    %edx,%eax
40001081:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
40001085:	75 f7                	jne    4000107e <strlen+0x10>
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001087:	5d                   	pop    %ebp
40001088:	c3                   	ret    

40001089 <strcpy>:
        },
        {   /* 1 Table: With shift */
40001089:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000108a:	31 d2                	xor    %edx,%edx
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
4000108c:	89 e5                	mov    %esp,%ebp
4000108e:	56                   	push   %esi
4000108f:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001090:	31 c9                	xor    %ecx,%ecx
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
40001092:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40001095:	8b 45 08             	mov    0x8(%ebp),%eax
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001098:	85 db                	test   %ebx,%ebx
4000109a:	75 03                	jne    4000109f <strcpy+0x16>
4000109c:	eb 09                	jmp    400010a7 <strcpy+0x1e>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000109e:	42                   	inc    %edx
4000109f:	89 d1                	mov    %edx,%ecx
400010a1:	80 3c 13 00          	cmpb   $0x0,(%ebx,%edx,1)
400010a5:	75 f7                	jne    4000109e <strcpy+0x15>
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
400010a7:	89 ce                	mov    %ecx,%esi
400010a9:	46                   	inc    %esi
400010aa:	74 0c                	je     400010b8 <strcpy+0x2f>
400010ac:	31 d2                	xor    %edx,%edx
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400010ae:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
400010b1:	88 0c 10             	mov    %cl,(%eax,%edx,1)
400010b4:	42                   	inc    %edx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400010b5:	4e                   	dec    %esi
400010b6:	75 f6                	jne    400010ae <strcpy+0x25>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
400010b8:	5b                   	pop    %ebx
400010b9:	5e                   	pop    %esi
400010ba:	5d                   	pop    %ebp
400010bb:	c3                   	ret    

400010bc <strtoknc>:

uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
400010bc:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010bd:	31 c0                	xor    %eax,%eax

uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
400010bf:	89 e5                	mov    %esp,%ebp
400010c1:	57                   	push   %edi
400010c2:	56                   	push   %esi
400010c3:	53                   	push   %ebx
400010c4:	83 ec 04             	sub    $0x4,%esp
400010c7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400010ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010cd:	85 db                	test   %ebx,%ebx
400010cf:	75 06                	jne    400010d7 <strtoknc+0x1b>
400010d1:	e9 83 00 00 00       	jmp    40001159 <strtoknc+0x9d>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010d6:	40                   	inc    %eax
400010d7:	89 c7                	mov    %eax,%edi
400010d9:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
400010dd:	75 f7                	jne    400010d6 <strtoknc+0x1a>
static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
400010df:	85 c0                	test   %eax,%eax
400010e1:	74 76                	je     40001159 <strtoknc+0x9d>
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

400010e3:	85 c9                	test   %ecx,%ecx
400010e5:	75 0b                	jne    400010f2 <strtoknc+0x36>
400010e7:	83 3d 14 42 00 40 00 	cmpl   $0x0,0x40004214
400010ee:	75 08                	jne    400010f8 <strtoknc+0x3c>
400010f0:	eb 67                	jmp    40001159 <strtoknc+0x9d>
        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

400010f2:	89 0d 14 42 00 40    	mov    %ecx,0x40004214
        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
400010f8:	a1 14 42 00 40       	mov    0x40004214,%eax
400010fd:	31 c9                	xor    %ecx,%ecx
                case 0x451D:
                    keycode = 119;
400010ff:	eb 0b                	jmp    4000110c <strtoknc+0x50>
                    break;
40001101:	8a 10                	mov    (%eax),%dl
40001103:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
40001106:	75 03                	jne    4000110b <strtoknc+0x4f>

40001108:	40                   	inc    %eax
                default:
40001109:	eb 05                	jmp    40001110 <strtoknc+0x54>
        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
4000110b:	41                   	inc    %ecx
4000110c:	39 f9                	cmp    %edi,%ecx
4000110e:	7c f1                	jl     40001101 <strtoknc+0x45>

                default:
                    keycode = 0x0;
            };
            break;
    }
40001110:	39 f9                	cmp    %edi,%ecx
40001112:	75 e9                	jne    400010fd <strtoknc+0x41>

40001114:	a3 14 42 00 40       	mov    %eax,0x40004214
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
40001119:	80 38 00             	cmpb   $0x0,(%eax)
4000111c:	75 28                	jne    40001146 <strtoknc+0x8a>

4000111e:	c7 05 14 42 00 40 00 	movl   $0x0,0x40004214
40001125:	00 00 00 
40001128:	eb 2f                	jmp    40001159 <strtoknc+0x9d>
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

    return kc_to_char[index][keycode];
4000112a:	8a 55 f3             	mov    -0xd(%ebp),%dl
4000112d:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
40001130:	75 05                	jne    40001137 <strtoknc+0x7b>
}
40001132:	c6 06 00             	movb   $0x0,(%esi)

40001135:	eb 05                	jmp    4000113c <strtoknc+0x80>
static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

40001137:	41                   	inc    %ecx
40001138:	39 f9                	cmp    %edi,%ecx
4000113a:	7c ee                	jl     4000112a <strtoknc+0x6e>
}

static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
4000113c:	ff 05 14 42 00 40    	incl   0x40004214
        }
40001142:	39 f9                	cmp    %edi,%ecx
40001144:	7c 15                	jl     4000115b <strtoknc+0x9f>

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
40001146:	8b 35 14 42 00 40    	mov    0x40004214,%esi
4000114c:	8a 16                	mov    (%esi),%dl
4000114e:	88 55 f3             	mov    %dl,-0xd(%ebp)
40001151:	84 d2                	test   %dl,%dl
40001153:	74 06                	je     4000115b <strtoknc+0x9f>
40001155:	31 c9                	xor    %ecx,%ecx
40001157:	eb df                	jmp    40001138 <strtoknc+0x7c>
40001159:	31 c0                	xor    %eax,%eax
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
4000115b:	5a                   	pop    %edx
4000115c:	5b                   	pop    %ebx
4000115d:	5e                   	pop    %esi
4000115e:	5f                   	pop    %edi
4000115f:	5d                   	pop    %ebp
40001160:	c3                   	ret    

40001161 <strclone>:
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
40001161:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001162:	31 c0                	xor    %eax,%eax
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
40001164:	89 e5                	mov    %esp,%ebp
40001166:	56                   	push   %esi
40001167:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001168:	31 d2                	xor    %edx,%edx
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
4000116a:	8b 5d 08             	mov    0x8(%ebp),%ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000116d:	85 db                	test   %ebx,%ebx
4000116f:	75 03                	jne    40001174 <strclone+0x13>
40001171:	eb 09                	jmp    4000117c <strclone+0x1b>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001173:	40                   	inc    %eax
40001174:	89 c2                	mov    %eax,%edx
40001176:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
4000117a:	75 f7                	jne    40001173 <strclone+0x12>
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
4000117c:	83 ec 0c             	sub    $0xc,%esp
4000117f:	42                   	inc    %edx
40001180:	52                   	push   %edx
40001181:	e8 af 01 00 00       	call   40001335 <malloc>
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
40001186:	59                   	pop    %ecx
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
40001187:	89 c6                	mov    %eax,%esi
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
40001189:	58                   	pop    %eax
4000118a:	53                   	push   %ebx
4000118b:	56                   	push   %esi
4000118c:	e8 f8 fe ff ff       	call   40001089 <strcpy>
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001191:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001194:	89 f0                	mov    %esi,%eax
40001196:	5b                   	pop    %ebx
40001197:	5e                   	pop    %esi
40001198:	5d                   	pop    %ebp
40001199:	c3                   	ret    

4000119a <strtok>:
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000119a:	55                   	push   %ebp
4000119b:	89 e5                	mov    %esp,%ebp
4000119d:	56                   	push   %esi
4000119e:	53                   	push   %ebx
4000119f:	8b 75 08             	mov    0x8(%ebp),%esi
400011a2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400011a5:	85 f6                	test   %esi,%esi
400011a7:	74 2e                	je     400011d7 <strtok+0x3d>
        }
400011a9:	a1 18 42 00 40       	mov    0x40004218,%eax
400011ae:	85 c0                	test   %eax,%eax
400011b0:	74 0c                	je     400011be <strtok+0x24>
};
400011b2:	83 ec 0c             	sub    $0xc,%esp
400011b5:	50                   	push   %eax
400011b6:	e8 31 00 00 00       	call   400011ec <free>
400011bb:	83 c4 10             	add    $0x10,%esp

#define KF_PRESSED (1 << 0)
400011be:	83 ec 0c             	sub    $0xc,%esp
400011c1:	56                   	push   %esi
400011c2:	e8 9a ff ff ff       	call   40001161 <strclone>

400011c7:	83 c4 10             	add    $0x10,%esp
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)
400011ca:	a3 18 42 00 40       	mov    %eax,0x40004218

400011cf:	89 5d 0c             	mov    %ebx,0xc(%ebp)
400011d2:	89 45 08             	mov    %eax,0x8(%ebp)
400011d5:	eb 0a                	jmp    400011e1 <strtok+0x47>
uint32_t key_flags[256];

400011d7:	89 5d 0c             	mov    %ebx,0xc(%ebp)
400011da:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
HANDLE charout = 0;
400011e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
400011e4:	5b                   	pop    %ebx
400011e5:	5e                   	pop    %esi
400011e6:	5d                   	pop    %ebp
};

#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

400011e7:	e9 d0 fe ff ff       	jmp    400010bc <strtoknc>

400011ec <free>:
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
400011ec:	55                   	push   %ebp
400011ed:	89 e5                	mov    %esp,%ebp
400011ef:	57                   	push   %edi
400011f0:	56                   	push   %esi
400011f1:	53                   	push   %ebx
400011f2:	83 ec 08             	sub    $0x8,%esp
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
400011f5:	8b 15 20 42 00 40    	mov    0x40004220,%edx
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
400011fb:	8b 4d 08             	mov    0x8(%ebp),%ecx
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
400011fe:	89 d0                	mov    %edx,%eax
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
40001200:	e9 b8 00 00 00       	jmp    400012bd <free+0xd1>
        e1_prev = scancode;
40001205:	3b 48 04             	cmp    0x4(%eax),%ecx
40001208:	0f 85 ac 00 00 00    	jne    400012ba <free+0xce>
4000120e:	31 c9                	xor    %ecx,%ecx
40001210:	eb 23                	jmp    40001235 <free+0x49>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001212:	39 c2                	cmp    %eax,%edx
40001214:	75 1a                	jne    40001230 <free+0x44>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001216:	85 c9                	test   %ecx,%ecx
40001218:	8b 50 08             	mov    0x8(%eax),%edx
4000121b:	75 0e                	jne    4000122b <free+0x3f>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000121d:	89 15 20 42 00 40    	mov    %edx,0x40004220
40001223:	8b 0d 24 42 00 40    	mov    0x40004224,%ecx
40001229:	eb 10                	jmp    4000123b <free+0x4f>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
4000122b:	89 51 08             	mov    %edx,0x8(%ecx)
4000122e:	eb f3                	jmp    40001223 <free+0x37>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
40001230:	89 d1                	mov    %edx,%ecx
40001232:	8b 52 08             	mov    0x8(%edx),%edx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001235:	85 d2                	test   %edx,%edx
40001237:	75 d9                	jne    40001212 <free+0x26>
40001239:	eb e8                	jmp    40001223 <free+0x37>
4000123b:	89 ca                	mov    %ecx,%edx
4000123d:	eb 6d                	jmp    400012ac <free+0xc0>
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000123f:	8b 5a 04             	mov    0x4(%edx),%ebx
40001242:	8b 32                	mov    (%edx),%esi
40001244:	8b 78 04             	mov    0x4(%eax),%edi
40001247:	89 7d ec             	mov    %edi,-0x14(%ebp)
4000124a:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
4000124d:	89 7d f0             	mov    %edi,-0x10(%ebp)
40001250:	8b 7d ec             	mov    -0x14(%ebp),%edi
40001253:	39 7d f0             	cmp    %edi,-0x10(%ebp)
40001256:	75 18                	jne    40001270 <free+0x84>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40001258:	89 58 04             	mov    %ebx,0x4(%eax)
4000125b:	31 f6                	xor    %esi,%esi
4000125d:	89 cb                	mov    %ecx,%ebx
4000125f:	eb 09                	jmp    4000126a <free+0x7e>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001261:	39 d3                	cmp    %edx,%ebx
40001263:	74 29                	je     4000128e <free+0xa2>
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
40001265:	89 de                	mov    %ebx,%esi
40001267:	8b 5b 08             	mov    0x8(%ebx),%ebx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
4000126a:	85 db                	test   %ebx,%ebx
4000126c:	75 f3                	jne    40001261 <free+0x75>
4000126e:	eb cb                	jmp    4000123b <free+0x4f>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001270:	8b 38                	mov    (%eax),%edi
40001272:	89 7d f0             	mov    %edi,-0x10(%ebp)
40001275:	8b 7d ec             	mov    -0x14(%ebp),%edi
40001278:	03 7d f0             	add    -0x10(%ebp),%edi
4000127b:	39 fb                	cmp    %edi,%ebx
4000127d:	75 2a                	jne    400012a9 <free+0xbd>
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000127f:	03 75 f0             	add    -0x10(%ebp),%esi
40001282:	89 cb                	mov    %ecx,%ebx
40001284:	89 30                	mov    %esi,(%eax)
40001286:	31 f6                	xor    %esi,%esi
40001288:	eb 19                	jmp    400012a3 <free+0xb7>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000128a:	39 d3                	cmp    %edx,%ebx
4000128c:	75 10                	jne    4000129e <free+0xb2>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
4000128e:	85 f6                	test   %esi,%esi
40001290:	8b 53 08             	mov    0x8(%ebx),%edx
40001293:	75 04                	jne    40001299 <free+0xad>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001295:	89 d1                	mov    %edx,%ecx
40001297:	eb a2                	jmp    4000123b <free+0x4f>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001299:	89 56 08             	mov    %edx,0x8(%esi)
4000129c:	eb 9d                	jmp    4000123b <free+0x4f>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
4000129e:	89 de                	mov    %ebx,%esi
400012a0:	8b 5b 08             	mov    0x8(%ebx),%ebx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400012a3:	85 db                	test   %ebx,%ebx
400012a5:	75 e3                	jne    4000128a <free+0x9e>
400012a7:	eb 92                	jmp    4000123b <free+0x4f>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)

400012a9:	8b 52 08             	mov    0x8(%edx),%edx
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
400012ac:	85 d2                	test   %edx,%edx
400012ae:	75 8f                	jne    4000123f <free+0x53>
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400012b0:	89 48 08             	mov    %ecx,0x8(%eax)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400012b3:	a3 24 42 00 40       	mov    %eax,0x40004224
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
        e1_code++;
    } else if (scancode == 0xE0) {
400012b8:	eb 0b                	jmp    400012c5 <free+0xd9>
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
400012ba:	8b 40 08             	mov    0x8(%eax),%eax
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
400012bd:	85 c0                	test   %eax,%eax
400012bf:	0f 85 40 ff ff ff    	jne    40001205 <free+0x19>
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
400012c5:	58                   	pop    %eax
400012c6:	5a                   	pop    %edx
400012c7:	5b                   	pop    %ebx
400012c8:	5e                   	pop    %esi
400012c9:	5f                   	pop    %edi
400012ca:	5d                   	pop    %ebp
400012cb:	c3                   	ret    

400012cc <pop_unused_node>:
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
400012cc:	55                   	push   %ebp
400012cd:	89 e5                	mov    %esp,%ebp
400012cf:	53                   	push   %ebx
400012d0:	83 ec 04             	sub    $0x4,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400012d3:	a1 1c 42 00 40       	mov    0x4000421c,%eax
400012d8:	eb 45                	jmp    4000131f <pop_unused_node+0x53>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400012da:	83 ec 0c             	sub    $0xc,%esp
400012dd:	6a 01                	push   $0x1
400012df:	e8 5b 02 00 00       	call   4000153f <vmm_alloc_cont>

400012e4:	83 c4 0c             	add    $0xc,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400012e7:	89 c3                	mov    %eax,%ebx

400012e9:	68 00 10 00 00       	push   $0x1000
400012ee:	6a 00                	push   $0x0
400012f0:	50                   	push   %eax
400012f1:	e8 a6 fc ff ff       	call   40000f9c <memset>
400012f6:	8b 15 1c 42 00 40    	mov    0x4000421c,%edx
400012fc:	8d 43 0c             	lea    0xc(%ebx),%eax
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
400012ff:	8d 8b fc 0f 00 00    	lea    0xffc(%ebx),%ecx
40001305:	83 c4 10             	add    $0x10,%esp
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001308:	89 50 08             	mov    %edx,0x8(%eax)
4000130b:	89 c2                	mov    %eax,%edx
4000130d:	83 c0 0c             	add    $0xc,%eax
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
40001310:	39 c8                	cmp    %ecx,%eax
40001312:	75 f4                	jne    40001308 <pop_unused_node+0x3c>
40001314:	8d 83 f0 0f 00 00    	lea    0xff0(%ebx),%eax
4000131a:	a3 1c 42 00 40       	mov    %eax,0x4000421c
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000131f:	85 c0                	test   %eax,%eax
40001321:	74 b7                	je     400012da <pop_unused_node+0xe>
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001323:	8b 50 08             	mov    0x8(%eax),%edx
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001326:	85 c0                	test   %eax,%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001328:	89 15 1c 42 00 40    	mov    %edx,0x4000421c
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000132e:	74 aa                	je     400012da <pop_unused_node+0xe>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001330:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40001333:	c9                   	leave  
40001334:	c3                   	ret    

40001335 <malloc>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40001335:	55                   	push   %ebp
40001336:	89 e5                	mov    %esp,%ebp
40001338:	57                   	push   %edi
40001339:	56                   	push   %esi
4000133a:	53                   	push   %ebx
4000133b:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t keycode = 0;

4000133e:	a1 24 42 00 40       	mov    0x40004224,%eax
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40001343:	8b 75 08             	mov    0x8(%ebp),%esi
    uint8_t keycode = 0;

40001346:	89 c3                	mov    %eax,%ebx
    switch (set) {
        // Normal scancodes
40001348:	eb 07                	jmp    40001351 <malloc+0x1c>
        case 0:
4000134a:	39 33                	cmp    %esi,(%ebx)
4000134c:	73 0c                	jae    4000135a <malloc+0x25>
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
4000134e:	8b 5b 08             	mov    0x8(%ebx),%ebx
static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
40001351:	85 db                	test   %ebx,%ebx
40001353:	75 f5                	jne    4000134a <malloc+0x15>
40001355:	e9 93 00 00 00       	jmp    400013ed <malloc+0xb8>
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
4000135a:	8b 3b                	mov    (%ebx),%edi
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

4000135c:	31 d2                	xor    %edx,%edx
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
4000135e:	29 f7                	sub    %esi,%edi
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

40001360:	89 33                	mov    %esi,(%ebx)
40001362:	eb 4b                	jmp    400013af <malloc+0x7a>

                default:
                    keycode = 0x0;
            };
            break;
    }
40001364:	e8 63 ff ff ff       	call   400012cc <pop_unused_node>

    if (keycode == 0) {
40001369:	8b 13                	mov    (%ebx),%edx
4000136b:	03 53 04             	add    0x4(%ebx),%edx
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
4000136e:	29 f7                	sub    %esi,%edi
                    keycode = 0x0;
            };
            break;
    }

    if (keycode == 0) {
40001370:	89 50 04             	mov    %edx,0x4(%eax)
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001373:	8b 15 24 42 00 40    	mov    0x40004224,%edx
40001379:	89 50 08             	mov    %edx,0x8(%eax)
            };
            break;
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
4000137c:	89 38                	mov    %edi,(%eax)

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000137e:	a3 24 42 00 40       	mov    %eax,0x40004224
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001383:	a1 20 42 00 40       	mov    0x40004220,%eax
40001388:	89 43 08             	mov    %eax,0x8(%ebx)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000138b:	89 1d 20 42 00 40    	mov    %ebx,0x40004220
40001391:	eb 4f                	jmp    400013e2 <malloc+0xad>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001393:	39 d8                	cmp    %ebx,%eax
40001395:	75 13                	jne    400013aa <malloc+0x75>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001397:	85 d2                	test   %edx,%edx
40001399:	8b 43 08             	mov    0x8(%ebx),%eax
4000139c:	75 07                	jne    400013a5 <malloc+0x70>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000139e:	a3 24 42 00 40       	mov    %eax,0x40004224
400013a3:	eb 0e                	jmp    400013b3 <malloc+0x7e>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
400013a5:	89 42 08             	mov    %eax,0x8(%edx)
400013a8:	eb 09                	jmp    400013b3 <malloc+0x7e>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400013aa:	89 c2                	mov    %eax,%edx
400013ac:	8b 40 08             	mov    0x8(%eax),%eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400013af:	85 c0                	test   %eax,%eax
400013b1:	75 e0                	jne    40001393 <malloc+0x5e>
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013b3:	a1 20 42 00 40       	mov    0x40004220,%eax

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
400013b8:	85 ff                	test   %edi,%edi
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013ba:	89 43 08             	mov    %eax,0x8(%ebx)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013bd:	89 1d 20 42 00 40    	mov    %ebx,0x40004220

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
400013c3:	74 1d                	je     400013e2 <malloc+0xad>
    do {
400013c5:	e8 02 ff ff ff       	call   400012cc <pop_unused_node>
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
400013ca:	8b 13                	mov    (%ebx),%edx
400013cc:	03 53 04             	add    0x4(%ebx),%edx
400013cf:	89 50 04             	mov    %edx,0x4(%eax)
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013d2:	8b 15 24 42 00 40    	mov    0x40004224,%edx
400013d8:	89 50 08             	mov    %edx,0x8(%eax)
static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

400013db:	89 38                	mov    %edi,(%eax)

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013dd:	a3 24 42 00 40       	mov    %eax,0x40004224

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
400013e2:	8b 43 04             	mov    0x4(%ebx),%eax
}

400013e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
400013e8:	5b                   	pop    %ebx
400013e9:	5e                   	pop    %esi
400013ea:	5f                   	pop    %edi
400013eb:	5d                   	pop    %ebp
400013ec:	c3                   	ret    
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

        // e1-Scancodes
        case 2:
400013ed:	89 f0                	mov    %esi,%eax

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

400013ef:	89 f7                	mov    %esi,%edi
400013f1:	c1 ef 0c             	shr    $0xc,%edi
        // e1-Scancodes
        case 2:
400013f4:	25 ff 0f 00 00       	and    $0xfff,%eax
            switch (scancode) {
400013f9:	83 f8 01             	cmp    $0x1,%eax
400013fc:	83 df ff             	sbb    $0xffffffff,%edi
                // Pause
                case 0x451D:
400013ff:	83 ec 0c             	sub    $0xc,%esp
40001402:	57                   	push   %edi
40001403:	e8 37 01 00 00       	call   4000153f <vmm_alloc_cont>
                    break;

                default:
                    keycode = 0x0;
            };
            break;
40001408:	c1 e7 0c             	shl    $0xc,%edi
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
                    break;
4000140b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000140e:	e8 b9 fe ff ff       	call   400012cc <pop_unused_node>

                default:
40001413:	8b 55 e4             	mov    -0x1c(%ebp),%edx
                    keycode = 0x0;
            };
            break;
40001416:	83 c4 10             	add    $0x10,%esp
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
                    break;
40001419:	89 c3                	mov    %eax,%ebx

                default:
4000141b:	89 50 04             	mov    %edx,0x4(%eax)
                    keycode = 0x0;
4000141e:	89 30                	mov    %esi,(%eax)
            };
            break;
40001420:	39 f7                	cmp    %esi,%edi
40001422:	0f 86 5b ff ff ff    	jbe    40001383 <malloc+0x4e>
40001428:	e9 37 ff ff ff       	jmp    40001364 <malloc+0x2f>

4000142d <realloc>:
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

4000142d:	55                   	push   %ebp
4000142e:	89 e5                	mov    %esp,%ebp
40001430:	56                   	push   %esi
40001431:	53                   	push   %ebx
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
40001432:	8b 1d 20 42 00 40    	mov    0x40004220,%ebx
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

40001438:	8b 55 08             	mov    0x8(%ebp),%edx
4000143b:	8b 45 0c             	mov    0xc(%ebp),%eax
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
4000143e:	eb 3e                	jmp    4000147e <realloc+0x51>
        (e0_code || (scancode != 0xE0)))
40001440:	3b 53 04             	cmp    0x4(%ebx),%edx
40001443:	75 36                	jne    4000147b <realloc+0x4e>
    {
40001445:	85 c0                	test   %eax,%eax
40001447:	75 0b                	jne    40001454 <realloc+0x27>
        break_code = 1;
40001449:	52                   	push   %edx
4000144a:	31 f6                	xor    %esi,%esi
4000144c:	e8 9b fd ff ff       	call   400011ec <free>
        scancode &= ~0x80;
40001451:	5b                   	pop    %ebx
40001452:	eb 30                	jmp    40001484 <realloc+0x57>
    }

40001454:	83 ec 0c             	sub    $0xc,%esp
40001457:	50                   	push   %eax
40001458:	e8 d8 fe ff ff       	call   40001335 <malloc>
    if (e0_code) {
4000145d:	83 c4 0c             	add    $0xc,%esp
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }

40001460:	89 c6                	mov    %eax,%esi
    if (e0_code) {
40001462:	ff 33                	pushl  (%ebx)
40001464:	ff 73 04             	pushl  0x4(%ebx)
40001467:	50                   	push   %eax
40001468:	e8 4b fb ff ff       	call   40000fb8 <memcpy>
        // Fake shift abfangen und ignorieren
4000146d:	59                   	pop    %ecx
4000146e:	ff 73 04             	pushl  0x4(%ebx)
40001471:	e8 76 fd ff ff       	call   400011ec <free>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40001476:	83 c4 10             	add    $0x10,%esp
40001479:	eb 09                	jmp    40001484 <realloc+0x57>
            return;
        }

        keycode = translate_scancode(1, scancode);
4000147b:	8b 5b 08             	mov    0x8(%ebx),%ebx
    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
4000147e:	85 db                	test   %ebx,%ebx
40001480:	75 be                	jne    40001440 <realloc+0x13>
40001482:	31 f6                	xor    %esi,%esi
        }

        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
40001484:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001487:	89 f0                	mov    %esi,%eax
40001489:	5b                   	pop    %ebx
4000148a:	5e                   	pop    %esi
4000148b:	5d                   	pop    %ebp
4000148c:	c3                   	ret    

4000148d <calloc>:
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
4000148d:	55                   	push   %ebp
4000148e:	89 e5                	mov    %esp,%ebp
40001490:	56                   	push   %esi
40001491:	53                   	push   %ebx
40001492:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    uint8_t keycode = 0;
    int break_code = 0;
40001495:	83 ec 0c             	sub    $0xc,%esp
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40001498:	0f af 5d 08          	imul   0x8(%ebp),%ebx
    int break_code = 0;
4000149c:	53                   	push   %ebx
4000149d:	e8 93 fe ff ff       	call   40001335 <malloc>

    static int      e0_code = 0;
400014a2:	83 c4 10             	add    $0x10,%esp
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
    int break_code = 0;
400014a5:	89 c6                	mov    %eax,%esi

    static int      e0_code = 0;
400014a7:	85 c0                	test   %eax,%eax
400014a9:	74 0d                	je     400014b8 <calloc+0x2b>
    static int      e1_code = 0;
400014ab:	50                   	push   %eax
400014ac:	53                   	push   %ebx
400014ad:	6a 00                	push   $0x0
400014af:	56                   	push   %esi
400014b0:	e8 e7 fa ff ff       	call   40000f9c <memset>
400014b5:	83 c4 10             	add    $0x10,%esp
    static uint16_t e1_prev = 0;

    if(!init_done) return;

400014b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
400014bb:	89 f0                	mov    %esi,%eax
400014bd:	5b                   	pop    %ebx
400014be:	5e                   	pop    %esi
400014bf:	5d                   	pop    %ebp
400014c0:	c3                   	ret    
400014c1:	00 00                	add    %al,(%eax)
	...

400014c4 <print_memstat>:
    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400014c4:	55                   	push   %ebp
400014c5:	89 e5                	mov    %esp,%ebp
400014c7:	83 ec 34             	sub    $0x34,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
400014ca:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400014cd:	c7 45 e0 cd 00 00 00 	movl   $0xcd,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00
    },
400014d4:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400014d5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400014dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400014e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400014ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400014f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00
    },
400014f8:	e8 37 01 00 00       	call   40001634 <syscall>
400014fd:	83 c4 10             	add    $0x10,%esp
};
40001500:	c9                   	leave  
40001501:	c3                   	ret    

40001502 <vmm_free>:
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001502:	55                   	push   %ebp
40001503:	89 e5                	mov    %esp,%ebp
40001505:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
40001508:	8b 45 08             	mov    0x8(%ebp),%eax
4000150b:	c7 45 e0 cc 00 00 00 	movl   $0xcc,-0x20(%ebp)
40001512:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001515:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001518:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
40001519:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001520:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001527:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000152e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001535:	e8 fa 00 00 00       	call   40001634 <syscall>
4000153a:	83 c4 10             	add    $0x10,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000153d:	c9                   	leave  
4000153e:	c3                   	ret    

4000153f <vmm_alloc_cont>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
4000153f:	55                   	push   %ebp
40001540:	89 e5                	mov    %esp,%ebp
40001542:	83 ec 34             	sub    $0x34,%esp
 
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
40001545:	8b 45 08             	mov    0x8(%ebp),%eax
40001548:	c7 45 e0 cb 00 00 00 	movl   $0xcb,-0x20(%ebp)
4000154f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001552:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001555:	50                   	push   %eax
 
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
40001556:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000155d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001564:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000156b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40001572:	e8 bd 00 00 00       	call   40001634 <syscall>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
40001577:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000157a:	c9                   	leave  
4000157b:	c3                   	ret    

4000157c <port_in>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000157c:	55                   	push   %ebp
4000157d:	89 e5                	mov    %esp,%ebp
4000157f:	83 ec 34             	sub    $0x34,%esp
40001582:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40001586:	8b 55 08             	mov    0x8(%ebp),%edx
40001589:	89 45 e8             	mov    %eax,-0x18(%ebp)

static char kc_to_char[][128] = {
4000158c:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
4000158f:	c7 45 e0 34 00 00 00 	movl   $0x34,-0x20(%ebp)

static char kc_to_char[][128] = {
40001596:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40001597:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4000159a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400015a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400015a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

static char kc_to_char[][128] = {
400015af:	e8 80 00 00 00       	call   40001634 <syscall>
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
400015b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
400015b7:	c9                   	leave  
400015b8:	c3                   	ret    

400015b9 <port_out>:
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
400015b9:	55                   	push   %ebp
400015ba:	89 e5                	mov    %esp,%ebp
400015bc:	83 ec 34             	sub    $0x34,%esp
400015bf:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
400015c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
400015c6:	8b 45 10             	mov    0x10(%ebp),%eax
400015c9:	8b 55 08             	mov    0x8(%ebp),%edx
400015cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015cf:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
400015d2:	c7 45 e0 33 00 00 00 	movl   $0x33,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015d9:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
400015da:	89 55 e4             	mov    %edx,-0x1c(%ebp)
400015dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400015e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015eb:	e8 44 00 00 00       	call   40001634 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400015f3:	c9                   	leave  
400015f4:	c3                   	ret    

400015f5 <require_port>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
400015f5:	55                   	push   %ebp
400015f6:	89 e5                	mov    %esp,%ebp
400015f8:	83 ec 34             	sub    $0x34,%esp
400015fb:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400015ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001602:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001605:	50                   	push   %eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001606:	c7 45 e0 32 00 00 00 	movl   $0x32,-0x20(%ebp)
4000160d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001614:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000161b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001622:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001629:	e8 06 00 00 00       	call   40001634 <syscall>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000162e:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001631:	c9                   	leave  
40001632:	c3                   	ret    
	...

40001634 <syscall>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
40001634:	55                   	push   %ebp
40001635:	89 e5                	mov    %esp,%ebp
40001637:	57                   	push   %edi
40001638:	56                   	push   %esi
40001639:	53                   	push   %ebx
4000163a:	83 ec 10             	sub    $0x10,%esp
#include "process.h"
4000163d:	8b 55 08             	mov    0x8(%ebp),%edx
40001640:	8b 45 08             	mov    0x8(%ebp),%eax
40001643:	8b 72 0c             	mov    0xc(%edx),%esi
40001646:	8b 00                	mov    (%eax),%eax
40001648:	89 75 e4             	mov    %esi,-0x1c(%ebp)
4000164b:	8b 5a 04             	mov    0x4(%edx),%ebx
4000164e:	8b 4a 08             	mov    0x8(%edx),%ecx
40001651:	8b 72 10             	mov    0x10(%edx),%esi
40001654:	8b 7a 14             	mov    0x14(%edx),%edi
40001657:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000165a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
4000165d:	cd 30                	int    $0x30
4000165f:	89 55 e8             	mov    %edx,-0x18(%ebp)
40001662:	8b 55 08             	mov    0x8(%ebp),%edx
40001665:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001668:	89 02                	mov    %eax,(%edx)
4000166a:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000166d:	89 5a 04             	mov    %ebx,0x4(%edx)
40001670:	89 4a 08             	mov    %ecx,0x8(%edx)
40001673:	89 42 0c             	mov    %eax,0xc(%edx)
40001676:	89 72 10             	mov    %esi,0x10(%edx)
40001679:	89 7a 14             	mov    %edi,0x14(%edx)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
4000167c:	83 c4 10             	add    $0x10,%esp
4000167f:	5b                   	pop    %ebx
40001680:	5e                   	pop    %esi
40001681:	5f                   	pop    %edi
40001682:	5d                   	pop    %ebp
40001683:	c3                   	ret    
