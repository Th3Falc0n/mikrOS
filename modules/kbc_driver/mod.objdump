
../../initrfs/ibin/drivers/kbc:     file format elf32-i386
../../initrfs/ibin/drivers/kbc
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x4000082f

Program Header:
    LOAD off    0x00001000 vaddr 0x40000000 paddr 0x40000000 align 2**12
         filesz 0x000016c0 memsz 0x000016c0 flags r-x
    LOAD off    0x00003000 vaddr 0x40002000 paddr 0x40002000 align 2**12
         filesz 0x000012b2 memsz 0x00002640 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000016c0  40000000  40000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000200  40002000  40002000  00003000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       00000128  40003000  40003000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 0000018a  40003128  40003128  00004128  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          00000640  40004000  40004000  000042b2  2**5
                  ALLOC
  5 .stab         00005244  00000000  00000000  000042b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000090  00000000  00000000  000094f8  2**0
                  CONTENTS, READONLY
  7 .stabstr      00001b40  00000000  00000000  00009588  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
40000000 l    d  .text	00000000 .text
40002000 l    d  .data	00000000 .data
40003000 l    d  .rodata	00000000 .rodata
40003128 l    d  .rodata.str1.1	00000000 .rodata.str1.1
40004000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 kbc_driver.c
40002000 l     O .data	00000100 sc_to_kc
40002100 l     O .data	00000100 kc_to_char
40000000 l     F .text	00000088 translate_scancode
40000088 l     F .text	00000053 getcharfromkc
400000db l     F .text	00000068 send_command
40004008 l     O .bss	00000004 e1_code.1038
4000400c l     O .bss	00000004 e0_code.1037
40004010 l     O .bss	00000002 e1_prev.1039
00000000 l    df *ABS*	00000000 process.c
40004014 l     O .bss	00000200 irq_handlers
40003110 l     O .rodata	00000018 C.7.1015
400008a1 l     F .text	000000c0 _handle_rpc
00000000 l    df *ABS*	00000000 stdio.c
40000964 l     F .text	00000047 resolveHandle
40000e14 l     F .text	0000004a printrwerror
40000c61 l     F .text	0000003f putn
00000000 l    df *ABS*	00000000 string.c
00000000 l    df *ABS*	00000000 stdlib.c
40001308 l     F .text	00000069 pop_unused_node
00000000 l    df *ABS*	00000000 vmmcall.c
00000000 l    df *ABS*	00000000 ports.c
00000000 l    df *ABS*	00000000 syscall.c
40000625 g     F .text	0000003d getExecPath
40000d18 g     F .text	00000014 putchar
400010c5 g     F .text	00000033 strcpy
400006a8 g     F .text	0000003e yield
40000d2c g     F .text	000000e8 printf
40001670 g     F .text	00000050 syscall
40004000 g     O .bss	00000004 init_done
40000f29 g     F .text	00000042 fgets
40000f1d g     F .text	0000000c getc
40000ff4 g     F .text	00000026 memcpy
40000c4f g     F .text	00000012 puts
400006e6 g     F .text	0000003d pexists
40001371 g     F .text	000000f8 malloc
4000077b g     F .text	0000003d fetch_rpc_data
400010f8 g     F .text	000000a5 strtoknc
400005bb g     F .text	0000003d changeExecPath
40001631 g     F .text	0000003e require_port
400015b8 g     F .text	0000003d port_in
40004224 g     O .bss	00000004 first_free
400015f5 g     F .text	0000003c port_out
40000afe g     F .text	00000012 setstdout
400014c9 g     F .text	00000034 calloc
4000057f g     F .text	0000003c getExecPathChild
4000157b g     F .text	0000003d vmm_alloc_cont
4000050d g     F .text	0000003c exec
4000082f g     F .text	00000072 _start
40001469 g     F .text	00000060 realloc
400007f2 g     F .text	0000003d set_rpc_handler
400011d6 g     F .text	00000052 strtok
4000101a g     F .text	00000047 memcmp
40000e5e g     F .text	00000085 fread
4000421c g     O .bss	00000004 first_unused
40000a62 g     F .text	0000003c fopen
40000fd8 g     F .text	0000001c memset
40000328 g     F .text	00000171 main
40000a25 g     F .text	0000003d fclose
40000f0e g     F .text	0000000f getchar
40004240 g     O .bss	00000400 key_flags
40000f6b g     F .text	0000006c getln
40004218 g     O .bss	00000004 fr
400009e8 g     F .text	0000003d favailable
40000d05 g     F .text	00000013 putc
40004004 g     O .bss	00000004 charout
40001061 g     F .text	00000049 strcmp
40000ee3 g     F .text	0000002b fgetc
40004214 g     O .bss	00000004 sp
400005f8 g     F .text	0000002d cd
40000143 g     F .text	000001e5 irq_handler
40004220 g     O .bss	00000004 first_used
40000ca0 g     F .text	00000065 fputc
40000b4e g     F .text	00000093 fwrite
40000aec g     F .text	00000012 setstdin
40000549 g     F .text	00000036 texec
4000119d g     F .text	00000039 strclone
40000662 g     F .text	00000046 exit
40000723 g     F .text	00000058 register_irq_handler
40000a9e g     F .text	0000003c fopenpmhandle
4000153e g     F .text	0000003d vmm_free
4000049c g     F .text	00000071 printFilesystemError
400010aa g     F .text	0000001b strlen
40000b10 g     F .text	0000003e getLastVFSErr
40000be1 g     F .text	0000006e fputs
400009ab g     F .text	0000003d fmkfifo
400007b8 g     F .text	0000003a call_rpc
40000ada g     F .text	00000012 setstderr
40001500 g     F .text	0000003e print_memstat
40001228 g     F .text	000000e0 free



Disassembly of section .text:

40000000 <translate_scancode>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000000:	55                   	push   %ebp
40000001:	89 e5                	mov    %esp,%ebp
40000003:	83 ec 28             	sub    $0x28,%esp
40000006:	8b 45 0c             	mov    0xc(%ebp),%eax
40000009:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    uint8_t keycode = 0;
4000000d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    switch (set) {
40000011:	8b 45 08             	mov    0x8(%ebp),%eax
40000014:	83 f8 01             	cmp    $0x1,%eax
40000017:	74 1c                	je     40000035 <translate_scancode+0x35>
40000019:	83 f8 02             	cmp    $0x2,%eax
4000001c:	74 2a                	je     40000048 <translate_scancode+0x48>
4000001e:	85 c0                	test   %eax,%eax
40000020:	75 3f                	jne    40000061 <translate_scancode+0x61>
        // Normal scancodes
        case 0:
            keycode = sc_to_kc[0][scancode];
40000022:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000025:	25 ff ff 00 00       	and    $0xffff,%eax
4000002a:	8a 80 00 20 00 40    	mov    0x40002000(%eax),%al
40000030:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
40000033:	eb 2c                	jmp    40000061 <translate_scancode+0x61>

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
40000035:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000038:	25 ff ff 00 00       	and    $0xffff,%eax
4000003d:	8a 80 80 20 00 40    	mov    0x40002080(%eax),%al
40000043:	88 45 f7             	mov    %al,-0x9(%ebp)
            break;
40000046:	eb 19                	jmp    40000061 <translate_scancode+0x61>

        // e1-Scancodes
        case 2:
            switch (scancode) {
40000048:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000004b:	25 ff ff 00 00       	and    $0xffff,%eax
40000050:	3d 1d 45 00 00       	cmp    $0x451d,%eax
40000055:	75 06                	jne    4000005d <translate_scancode+0x5d>
                // Pause
                case 0x451D:
                    keycode = 119;
40000057:	c6 45 f7 77          	movb   $0x77,-0x9(%ebp)
                    break;
4000005b:	eb 04                	jmp    40000061 <translate_scancode+0x61>

                default:
                    keycode = 0x0;
4000005d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
            };
            break;
    }

    if (keycode == 0) {
40000061:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
40000065:	75 1c                	jne    40000083 <translate_scancode+0x83>
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
40000067:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000006a:	25 ff ff 00 00       	and    $0xffff,%eax
4000006f:	83 ec 04             	sub    $0x4,%esp
40000072:	ff 75 08             	pushl  0x8(%ebp)
40000075:	50                   	push   %eax
40000076:	68 00 30 00 40       	push   $0x40003000
4000007b:	e8 ac 0c 00 00       	call   40000d2c <printf>
40000080:	83 c4 10             	add    $0x10,%esp
    }

    return keycode;
40000083:	8a 45 f7             	mov    -0x9(%ebp),%al
}
40000086:	c9                   	leave  
40000087:	c3                   	ret    

40000088 <getcharfromkc>:

static char getcharfromkc(uint8_t keycode) {
40000088:	55                   	push   %ebp
40000089:	89 e5                	mov    %esp,%ebp
4000008b:	83 ec 14             	sub    $0x14,%esp
4000008e:	8b 45 08             	mov    0x8(%ebp),%eax
40000091:	88 45 ec             	mov    %al,-0x14(%ebp)
    uint32_t index = 0;
40000094:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
4000009b:	a1 e8 42 00 40       	mov    0x400042e8,%eax
400000a0:	83 e0 01             	and    $0x1,%eax
400000a3:	84 c0                	test   %al,%al
400000a5:	74 07                	je     400000ae <getcharfromkc+0x26>
400000a7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
400000ae:	a1 18 43 00 40       	mov    0x40004318,%eax
400000b3:	83 e0 01             	and    $0x1,%eax
400000b6:	84 c0                	test   %al,%al
400000b8:	74 07                	je     400000c1 <getcharfromkc+0x39>
400000ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

    return kc_to_char[index][keycode];
400000c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
400000c4:	b8 00 00 00 00       	mov    $0x0,%eax
400000c9:	8a 45 ec             	mov    -0x14(%ebp),%al
400000cc:	c1 e2 07             	shl    $0x7,%edx
400000cf:	8d 04 02             	lea    (%edx,%eax,1),%eax
400000d2:	05 00 21 00 40       	add    $0x40002100,%eax
400000d7:	8a 00                	mov    (%eax),%al
}
400000d9:	c9                   	leave  
400000da:	c3                   	ret    

400000db <send_command>:

static void send_command(uint8_t command)
{
400000db:	55                   	push   %ebp
400000dc:	89 e5                	mov    %esp,%ebp
400000de:	83 ec 18             	sub    $0x18,%esp
400000e1:	8b 45 08             	mov    0x8(%ebp),%eax
400000e4:	88 45 f4             	mov    %al,-0xc(%ebp)
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
400000e7:	83 ec 08             	sub    $0x8,%esp
400000ea:	6a 64                	push   $0x64
400000ec:	6a 00                	push   $0x0
400000ee:	e8 c5 14 00 00       	call   400015b8 <port_in>
400000f3:	83 c4 10             	add    $0x10,%esp
400000f6:	83 e0 02             	and    $0x2,%eax
400000f9:	85 c0                	test   %eax,%eax
400000fb:	75 ea                	jne    400000e7 <send_command+0xc>
        }

        port_out(PORTM_BYTE, 0x60, command);
400000fd:	b8 00 00 00 00       	mov    $0x0,%eax
40000102:	8a 45 f4             	mov    -0xc(%ebp),%al
40000105:	83 ec 04             	sub    $0x4,%esp
40000108:	50                   	push   %eax
40000109:	6a 60                	push   $0x60
4000010b:	6a 00                	push   $0x0
4000010d:	e8 e3 14 00 00       	call   400015f5 <port_out>
40000112:	83 c4 10             	add    $0x10,%esp

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000115:	83 ec 08             	sub    $0x8,%esp
40000118:	6a 64                	push   $0x64
4000011a:	6a 00                	push   $0x0
4000011c:	e8 97 14 00 00       	call   400015b8 <port_in>
40000121:	83 c4 10             	add    $0x10,%esp
40000124:	83 e0 01             	and    $0x1,%eax
40000127:	85 c0                	test   %eax,%eax
40000129:	74 ea                	je     40000115 <send_command+0x3a>
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000012b:	83 ec 08             	sub    $0x8,%esp
4000012e:	6a 60                	push   $0x60
40000130:	6a 00                	push   $0x0
40000132:	e8 81 14 00 00       	call   400015b8 <port_in>
40000137:	83 c4 10             	add    $0x10,%esp
4000013a:	3d fe 00 00 00       	cmp    $0xfe,%eax
4000013f:	74 a6                	je     400000e7 <send_command+0xc>
}
40000141:	c9                   	leave  
40000142:	c3                   	ret    

40000143 <irq_handler>:

void irq_handler(uint32_t irq) {
40000143:	55                   	push   %ebp
40000144:	89 e5                	mov    %esp,%ebp
40000146:	83 ec 18             	sub    $0x18,%esp
    uint8_t scancode;
    uint8_t keycode = 0;
40000149:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int break_code = 0;
4000014d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000154:	a1 00 40 00 40       	mov    0x40004000,%eax
40000159:	85 c0                	test   %eax,%eax
4000015b:	0f 84 c4 01 00 00    	je     40000325 <irq_handler+0x1e2>

    scancode = port_in(PORTM_BYTE, 0x60);
40000161:	83 ec 08             	sub    $0x8,%esp
40000164:	6a 60                	push   $0x60
40000166:	6a 00                	push   $0x0
40000168:	e8 4b 14 00 00       	call   400015b8 <port_in>
4000016d:	83 c4 10             	add    $0x10,%esp
40000170:	88 45 f2             	mov    %al,-0xe(%ebp)

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
40000173:	8a 45 f2             	mov    -0xe(%ebp),%al
40000176:	84 c0                	test   %al,%al
40000178:	79 29                	jns    400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
4000017a:	a1 08 40 00 40       	mov    0x40004008,%eax

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000017f:	85 c0                	test   %eax,%eax
40000181:	75 06                	jne    40000189 <irq_handler+0x46>
40000183:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
40000187:	74 1a                	je     400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
40000189:	a1 0c 40 00 40       	mov    0x4000400c,%eax

    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
4000018e:	85 c0                	test   %eax,%eax
40000190:	75 06                	jne    40000198 <irq_handler+0x55>
40000192:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
40000196:	74 0b                	je     400001a3 <irq_handler+0x60>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000198:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        scancode &= ~0x80;
4000019f:	80 65 f2 7f          	andb   $0x7f,-0xe(%ebp)
    }

    if (e0_code) {
400001a3:	a1 0c 40 00 40       	mov    0x4000400c,%eax
400001a8:	85 c0                	test   %eax,%eax
400001aa:	74 43                	je     400001ef <irq_handler+0xac>
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
400001ac:	80 7d f2 2a          	cmpb   $0x2a,-0xe(%ebp)
400001b0:	74 06                	je     400001b8 <irq_handler+0x75>
400001b2:	80 7d f2 36          	cmpb   $0x36,-0xe(%ebp)
400001b6:	75 0f                	jne    400001c7 <irq_handler+0x84>
            e0_code = 0;
400001b8:	c7 05 0c 40 00 40 00 	movl   $0x0,0x4000400c
400001bf:	00 00 00 
            return;
400001c2:	e9 5f 01 00 00       	jmp    40000326 <irq_handler+0x1e3>
        }

        keycode = translate_scancode(1, scancode);
400001c7:	b8 00 00 00 00       	mov    $0x0,%eax
400001cc:	8a 45 f2             	mov    -0xe(%ebp),%al
400001cf:	83 ec 08             	sub    $0x8,%esp
400001d2:	50                   	push   %eax
400001d3:	6a 01                	push   $0x1
400001d5:	e8 26 fe ff ff       	call   40000000 <translate_scancode>
400001da:	83 c4 10             	add    $0x10,%esp
400001dd:	88 45 f3             	mov    %al,-0xd(%ebp)
        e0_code = 0;
400001e0:	c7 05 0c 40 00 40 00 	movl   $0x0,0x4000400c
400001e7:	00 00 00 
400001ea:	e9 af 00 00 00       	jmp    4000029e <irq_handler+0x15b>
    } else if (e1_code == 2) {
400001ef:	a1 08 40 00 40       	mov    0x40004008,%eax
400001f4:	83 f8 02             	cmp    $0x2,%eax
400001f7:	75 43                	jne    4000023c <irq_handler+0xf9>
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
400001f9:	b8 00 00 00 00       	mov    $0x0,%eax
400001fe:	8a 45 f2             	mov    -0xe(%ebp),%al
40000201:	c1 e0 08             	shl    $0x8,%eax
40000204:	89 c2                	mov    %eax,%edx
40000206:	66 a1 10 40 00 40    	mov    0x40004010,%ax
4000020c:	09 d0                	or     %edx,%eax
4000020e:	66 a3 10 40 00 40    	mov    %ax,0x40004010
        keycode = translate_scancode(2, e1_prev);
40000214:	66 a1 10 40 00 40    	mov    0x40004010,%ax
4000021a:	25 ff ff 00 00       	and    $0xffff,%eax
4000021f:	83 ec 08             	sub    $0x8,%esp
40000222:	50                   	push   %eax
40000223:	6a 02                	push   $0x2
40000225:	e8 d6 fd ff ff       	call   40000000 <translate_scancode>
4000022a:	83 c4 10             	add    $0x10,%esp
4000022d:	88 45 f3             	mov    %al,-0xd(%ebp)
        e1_code = 0;
40000230:	c7 05 08 40 00 40 00 	movl   $0x0,0x40004008
40000237:	00 00 00 
4000023a:	eb 62                	jmp    4000029e <irq_handler+0x15b>
    } else if (e1_code == 1) {
4000023c:	a1 08 40 00 40       	mov    0x40004008,%eax
40000241:	83 f8 01             	cmp    $0x1,%eax
40000244:	75 1b                	jne    40000261 <irq_handler+0x11e>
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
40000246:	b8 00 00 00 00       	mov    $0x0,%eax
4000024b:	8a 45 f2             	mov    -0xe(%ebp),%al
4000024e:	66 a3 10 40 00 40    	mov    %ax,0x40004010
        e1_code++;
40000254:	a1 08 40 00 40       	mov    0x40004008,%eax
40000259:	40                   	inc    %eax
4000025a:	a3 08 40 00 40       	mov    %eax,0x40004008
4000025f:	eb 3d                	jmp    4000029e <irq_handler+0x15b>
    } else if (scancode == 0xE0) {
40000261:	80 7d f2 e0          	cmpb   $0xe0,-0xe(%ebp)
40000265:	75 0c                	jne    40000273 <irq_handler+0x130>
        // Anfang eines e0-Codes
        e0_code = 1;
40000267:	c7 05 0c 40 00 40 01 	movl   $0x1,0x4000400c
4000026e:	00 00 00 
40000271:	eb 2b                	jmp    4000029e <irq_handler+0x15b>
    } else if (scancode == 0xE1) {
40000273:	80 7d f2 e1          	cmpb   $0xe1,-0xe(%ebp)
40000277:	75 0c                	jne    40000285 <irq_handler+0x142>
        // Anfang eines e1-Codes
        e1_code = 1;
40000279:	c7 05 08 40 00 40 01 	movl   $0x1,0x40004008
40000280:	00 00 00 
40000283:	eb 19                	jmp    4000029e <irq_handler+0x15b>
    } else {
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
40000285:	b8 00 00 00 00       	mov    $0x0,%eax
4000028a:	8a 45 f2             	mov    -0xe(%ebp),%al
4000028d:	83 ec 08             	sub    $0x8,%esp
40000290:	50                   	push   %eax
40000291:	6a 00                	push   $0x0
40000293:	e8 68 fd ff ff       	call   40000000 <translate_scancode>
40000298:	83 c4 10             	add    $0x10,%esp
4000029b:	88 45 f3             	mov    %al,-0xd(%ebp)
    }

    if(break_code) {
4000029e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400002a2:	74 23                	je     400002c7 <irq_handler+0x184>
        key_flags[keycode] &= ~KF_PRESSED;
400002a4:	b8 00 00 00 00       	mov    $0x0,%eax
400002a9:	8a 45 f3             	mov    -0xd(%ebp),%al
400002ac:	ba 00 00 00 00       	mov    $0x0,%edx
400002b1:	8a 55 f3             	mov    -0xd(%ebp),%dl
400002b4:	8b 14 95 40 42 00 40 	mov    0x40004240(,%edx,4),%edx
400002bb:	83 e2 fe             	and    $0xfffffffe,%edx
400002be:	89 14 85 40 42 00 40 	mov    %edx,0x40004240(,%eax,4)
400002c5:	eb 21                	jmp    400002e8 <irq_handler+0x1a5>
    }
    else
    {
        key_flags[keycode] |= KF_PRESSED;
400002c7:	b8 00 00 00 00       	mov    $0x0,%eax
400002cc:	8a 45 f3             	mov    -0xd(%ebp),%al
400002cf:	ba 00 00 00 00       	mov    $0x0,%edx
400002d4:	8a 55 f3             	mov    -0xd(%ebp),%dl
400002d7:	8b 14 95 40 42 00 40 	mov    0x40004240(,%edx,4),%edx
400002de:	83 ca 01             	or     $0x1,%edx
400002e1:	89 14 85 40 42 00 40 	mov    %edx,0x40004240(,%eax,4)
    }

    char chr = getcharfromkc(keycode);
400002e8:	b8 00 00 00 00       	mov    $0x0,%eax
400002ed:	8a 45 f3             	mov    -0xd(%ebp),%al
400002f0:	83 ec 0c             	sub    $0xc,%esp
400002f3:	50                   	push   %eax
400002f4:	e8 8f fd ff ff       	call   40000088 <getcharfromkc>
400002f9:	83 c4 10             	add    $0x10,%esp
400002fc:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(!break_code && chr) {
400002ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40000303:	75 21                	jne    40000326 <irq_handler+0x1e3>
40000305:	8a 45 f1             	mov    -0xf(%ebp),%al
40000308:	84 c0                	test   %al,%al
4000030a:	74 1a                	je     40000326 <irq_handler+0x1e3>
        fwrite(charout, &chr, sizeof(char));
4000030c:	a1 04 40 00 40       	mov    0x40004004,%eax
40000311:	83 ec 04             	sub    $0x4,%esp
40000314:	6a 01                	push   $0x1
40000316:	8d 55 f1             	lea    -0xf(%ebp),%edx
40000319:	52                   	push   %edx
4000031a:	50                   	push   %eax
4000031b:	e8 2e 08 00 00       	call   40000b4e <fwrite>
40000320:	83 c4 10             	add    $0x10,%esp
40000323:	eb 01                	jmp    40000326 <irq_handler+0x1e3>

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000325:	90                   	nop    
    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
    }
}
40000326:	c9                   	leave  
40000327:	c3                   	ret    

40000328 <main>:

int main(int argc, char* args[])
{
40000328:	8d 4c 24 04          	lea    0x4(%esp),%ecx
4000032c:	83 e4 f0             	and    $0xfffffff0,%esp
4000032f:	ff 71 fc             	pushl  -0x4(%ecx)
40000332:	55                   	push   %ebp
40000333:	89 e5                	mov    %esp,%ebp
40000335:	51                   	push   %ecx
40000336:	83 ec 14             	sub    $0x14,%esp
    printf("[kbcdrv] requesting neccesary resources...\n");
40000339:	83 ec 0c             	sub    $0xc,%esp
4000033c:	68 24 30 00 40       	push   $0x40003024
40000341:	e8 e6 09 00 00       	call   40000d2c <printf>
40000346:	83 c4 10             	add    $0x10,%esp

    register_irq_handler(0x21, &irq_handler);
40000349:	83 ec 08             	sub    $0x8,%esp
4000034c:	68 43 01 00 40       	push   $0x40000143
40000351:	6a 21                	push   $0x21
40000353:	e8 cb 03 00 00       	call   40000723 <register_irq_handler>
40000358:	83 c4 10             	add    $0x10,%esp
    require_port(0x64);
4000035b:	83 ec 0c             	sub    $0xc,%esp
4000035e:	6a 64                	push   $0x64
40000360:	e8 cc 12 00 00       	call   40001631 <require_port>
40000365:	83 c4 10             	add    $0x10,%esp
    require_port(0x60);
40000368:	83 ec 0c             	sub    $0xc,%esp
4000036b:	6a 60                	push   $0x60
4000036d:	e8 bf 12 00 00       	call   40001631 <require_port>
40000372:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] emptying keyboard buffer...\n");
40000375:	83 ec 0c             	sub    $0xc,%esp
40000378:	68 50 30 00 40       	push   $0x40003050
4000037d:	e8 aa 09 00 00       	call   40000d2c <printf>
40000382:	83 c4 10             	add    $0x10,%esp

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
40000385:	eb 0f                	jmp    40000396 <main+0x6e>
        port_in(PORTM_BYTE, 0x60);
40000387:	83 ec 08             	sub    $0x8,%esp
4000038a:	6a 60                	push   $0x60
4000038c:	6a 00                	push   $0x0
4000038e:	e8 25 12 00 00       	call   400015b8 <port_in>
40000393:	83 c4 10             	add    $0x10,%esp
    require_port(0x64);
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
40000396:	83 ec 08             	sub    $0x8,%esp
40000399:	6a 64                	push   $0x64
4000039b:	6a 00                	push   $0x0
4000039d:	e8 16 12 00 00       	call   400015b8 <port_in>
400003a2:	83 c4 10             	add    $0x10,%esp
400003a5:	83 e0 01             	and    $0x1,%eax
400003a8:	84 c0                	test   %al,%al
400003aa:	75 db                	jne    40000387 <main+0x5f>
        port_in(PORTM_BYTE, 0x60);
    }

    printf("[kbcdrv] initializing KBC...\n");
400003ac:	83 ec 0c             	sub    $0xc,%esp
400003af:	68 76 30 00 40       	push   $0x40003076
400003b4:	e8 73 09 00 00       	call   40000d2c <printf>
400003b9:	83 c4 10             	add    $0x10,%esp

    memset(key_flags, 0, 256 * sizeof(uint32_t));
400003bc:	83 ec 04             	sub    $0x4,%esp
400003bf:	68 00 04 00 00       	push   $0x400
400003c4:	6a 00                	push   $0x0
400003c6:	68 40 42 00 40       	push   $0x40004240
400003cb:	e8 08 0c 00 00       	call   40000fd8 <memset>
400003d0:	83 c4 10             	add    $0x10,%esp

    // Leds alle ausloeschen
    send_command(0xED);
400003d3:	83 ec 0c             	sub    $0xc,%esp
400003d6:	68 ed 00 00 00       	push   $0xed
400003db:	e8 fb fc ff ff       	call   400000db <send_command>
400003e0:	83 c4 10             	add    $0x10,%esp
    send_command(0);
400003e3:	83 ec 0c             	sub    $0xc,%esp
400003e6:	6a 00                	push   $0x0
400003e8:	e8 ee fc ff ff       	call   400000db <send_command>
400003ed:	83 c4 10             	add    $0x10,%esp

    // Schnellste Wiederholrate
    send_command(0xF3);
400003f0:	83 ec 0c             	sub    $0xc,%esp
400003f3:	68 f3 00 00 00       	push   $0xf3
400003f8:	e8 de fc ff ff       	call   400000db <send_command>
400003fd:	83 c4 10             	add    $0x10,%esp
    send_command(0);
40000400:	83 ec 0c             	sub    $0xc,%esp
40000403:	6a 00                	push   $0x0
40000405:	e8 d1 fc ff ff       	call   400000db <send_command>
4000040a:	83 c4 10             	add    $0x10,%esp

    send_command(0xF4);
4000040d:	83 ec 0c             	sub    $0xc,%esp
40000410:	68 f4 00 00 00       	push   $0xf4
40000415:	e8 c1 fc ff ff       	call   400000db <send_command>
4000041a:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
4000041d:	83 ec 0c             	sub    $0xc,%esp
40000420:	68 94 30 00 40       	push   $0x40003094
40000425:	e8 02 09 00 00       	call   40000d2c <printf>
4000042a:	83 c4 10             	add    $0x10,%esp

    charout = fmkfifo("/dev/keyboard");
4000042d:	83 ec 0c             	sub    $0xc,%esp
40000430:	68 c9 30 00 40       	push   $0x400030c9
40000435:	e8 71 05 00 00       	call   400009ab <fmkfifo>
4000043a:	83 c4 10             	add    $0x10,%esp
4000043d:	a3 04 40 00 40       	mov    %eax,0x40004004

    init_done = 1;
40000442:	c7 05 00 40 00 40 01 	movl   $0x1,0x40004000
40000449:	00 00 00 

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
4000044c:	83 ec 08             	sub    $0x8,%esp
4000044f:	6a 02                	push   $0x2
40000451:	68 d7 30 00 40       	push   $0x400030d7
40000456:	e8 07 06 00 00       	call   40000a62 <fopen>
4000045b:	83 c4 10             	add    $0x10,%esp
4000045e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000461:	c6 45 f3 4b          	movb   $0x4b,-0xd(%ebp)
40000465:	83 ec 04             	sub    $0x4,%esp
40000468:	6a 01                	push   $0x1
4000046a:	8d 45 f3             	lea    -0xd(%ebp),%eax
4000046d:	50                   	push   %eax
4000046e:	ff 75 f4             	pushl  -0xc(%ebp)
40000471:	e8 d8 06 00 00       	call   40000b4e <fwrite>
40000476:	83 c4 10             	add    $0x10,%esp
    fclose(initCtrl);
40000479:	83 ec 0c             	sub    $0xc,%esp
4000047c:	ff 75 f4             	pushl  -0xc(%ebp)
4000047f:	e8 a1 05 00 00       	call   40000a25 <fclose>
40000484:	83 c4 10             	add    $0x10,%esp

    printf("[kbcdrv] Done!\n");
40000487:	83 ec 0c             	sub    $0xc,%esp
4000048a:	68 e7 30 00 40       	push   $0x400030e7
4000048f:	e8 98 08 00 00       	call   40000d2c <printf>
40000494:	83 c4 10             	add    $0x10,%esp

    while(1);
40000497:	eb fe                	jmp    40000497 <main+0x16f>
40000499:	00 00                	add    %al,(%eax)
	...

4000049c <printFilesystemError>:
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

4000049c:	55                   	push   %ebp
4000049d:	89 e5                	mov    %esp,%ebp
4000049f:	83 ec 08             	sub    $0x8,%esp
400004a2:	8b 55 0c             	mov    0xc(%ebp),%edx
400004a5:	8b 45 08             	mov    0x8(%ebp),%eax
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
400004a8:	83 fa 05             	cmp    $0x5,%edx
400004ab:	77 43                	ja     400004f0 <printFilesystemError+0x54>
400004ad:	ff 24 95 f8 30 00 40 	jmp    *0x400030f8(,%edx,4)
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
400004b4:	52                   	push   %edx
400004b5:	52                   	push   %edx
400004b6:	50                   	push   %eax
400004b7:	68 28 31 00 40       	push   $0x40003128
400004bc:	eb 3a                	jmp    400004f8 <printFilesystemError+0x5c>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
400004be:	51                   	push   %ecx
400004bf:	51                   	push   %ecx
400004c0:	50                   	push   %eax
400004c1:	68 3a 31 00 40       	push   $0x4000313a
400004c6:	eb 30                	jmp    400004f8 <printFilesystemError+0x5c>
        break_code = 1;
        scancode &= ~0x80;
    }
400004c8:	52                   	push   %edx
400004c9:	52                   	push   %edx
400004ca:	50                   	push   %eax
400004cb:	68 59 31 00 40       	push   $0x40003159
400004d0:	eb 26                	jmp    400004f8 <printFilesystemError+0x5c>

    if (e0_code) {
        // Fake shift abfangen und ignorieren
400004d2:	51                   	push   %ecx
400004d3:	51                   	push   %ecx
400004d4:	50                   	push   %eax
400004d5:	68 83 31 00 40       	push   $0x40003183
400004da:	eb 1c                	jmp    400004f8 <printFilesystemError+0x5c>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
400004dc:	52                   	push   %edx
400004dd:	52                   	push   %edx
400004de:	50                   	push   %eax
400004df:	68 98 31 00 40       	push   $0x40003198
400004e4:	eb 12                	jmp    400004f8 <printFilesystemError+0x5c>
        }

        keycode = translate_scancode(1, scancode);
400004e6:	51                   	push   %ecx
400004e7:	51                   	push   %ecx
400004e8:	50                   	push   %eax
400004e9:	68 d3 31 00 40       	push   $0x400031d3
400004ee:	eb 08                	jmp    400004f8 <printFilesystemError+0x5c>
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
400004f0:	52                   	push   %edx
400004f1:	52                   	push   %edx
400004f2:	50                   	push   %eax
400004f3:	68 e6 31 00 40       	push   $0x400031e6
400004f8:	e8 2f 08 00 00       	call   40000d2c <printf>
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
400004fd:	c7 45 08 03 32 00 40 	movl   $0x40003203,0x8(%ebp)
        }

        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
40000504:	83 c4 10             	add    $0x10,%esp
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
40000507:	c9                   	leave  
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
40000508:	e9 1f 08 00 00       	jmp    40000d2c <printf>

4000050d <exec>:
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
4000050d:	55                   	push   %ebp
4000050e:	89 e5                	mov    %esp,%ebp
40000510:	83 ec 34             	sub    $0x34,%esp
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
40000513:	8b 45 08             	mov    0x8(%ebp),%eax
40000516:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%ebp)
4000051d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000520:	8b 45 0c             	mov    0xc(%ebp),%eax
40000523:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000526:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000529:	50                   	push   %eax
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
4000052a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000531:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000538:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000053f:	e8 2c 11 00 00       	call   40001670 <syscall>
}

void irq_handler(uint32_t irq) {
40000544:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000547:	c9                   	leave  
40000548:	c3                   	ret    

40000549 <texec>:
    uint8_t scancode;
    uint8_t keycode = 0;
40000549:	55                   	push   %ebp
4000054a:	89 e5                	mov    %esp,%ebp
4000054c:	56                   	push   %esi
4000054d:	53                   	push   %ebx
    int break_code = 0;
4000054e:	53                   	push   %ebx
4000054f:	53                   	push   %ebx
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40000550:	8b 75 08             	mov    0x8(%ebp),%esi
    int break_code = 0;
40000553:	ff 75 0c             	pushl  0xc(%ebp)
40000556:	56                   	push   %esi
40000557:	e8 b1 ff ff ff       	call   4000050d <exec>

    static int      e0_code = 0;
4000055c:	83 c4 10             	add    $0x10,%esp
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
    int break_code = 0;
4000055f:	89 c3                	mov    %eax,%ebx

    static int      e0_code = 0;
40000561:	85 c0                	test   %eax,%eax
40000563:	75 11                	jne    40000576 <texec+0x2d>
    static int      e1_code = 0;
40000565:	e8 a6 05 00 00       	call   40000b10 <getLastVFSErr>
4000056a:	51                   	push   %ecx
4000056b:	51                   	push   %ecx
4000056c:	50                   	push   %eax
4000056d:	56                   	push   %esi
4000056e:	e8 29 ff ff ff       	call   4000049c <printFilesystemError>
40000573:	83 c4 10             	add    $0x10,%esp
    static uint16_t e1_prev = 0;

    if(!init_done) return;

40000576:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000579:	89 d8                	mov    %ebx,%eax
4000057b:	5b                   	pop    %ebx
4000057c:	5e                   	pop    %esi
4000057d:	5d                   	pop    %ebp
4000057e:	c3                   	ret    

4000057f <getExecPathChild>:
                    break;

                default:
                    keycode = 0x0;
            };
            break;
4000057f:	55                   	push   %ebp
40000580:	89 e5                	mov    %esp,%ebp
40000582:	83 ec 34             	sub    $0x34,%esp
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
40000585:	8b 45 08             	mov    0x8(%ebp),%eax
40000588:	c7 45 e0 11 00 00 00 	movl   $0x11,-0x20(%ebp)
4000058f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000592:	8b 45 0c             	mov    0xc(%ebp),%eax
40000595:	89 45 e8             	mov    %eax,-0x18(%ebp)

static char getcharfromkc(uint8_t keycode) {
40000598:	8d 45 e0             	lea    -0x20(%ebp),%eax
4000059b:	50                   	push   %eax
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
4000059c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400005a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400005aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

static char getcharfromkc(uint8_t keycode) {
400005b1:	e8 ba 10 00 00       	call   40001670 <syscall>
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
400005b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
400005b9:	c9                   	leave  
400005ba:	c3                   	ret    

400005bb <changeExecPath>:
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400005bb:	55                   	push   %ebp
400005bc:	89 e5                	mov    %esp,%ebp
400005be:	83 ec 34             	sub    $0x34,%esp

        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
400005c1:	8b 45 08             	mov    0x8(%ebp),%eax
400005c4:	c7 45 e0 07 00 00 00 	movl   $0x7,-0x20(%ebp)
400005cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    keycode = 119;
                    break;
400005ce:	8d 45 e0             	lea    -0x20(%ebp),%eax
400005d1:	50                   	push   %eax

        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
400005d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400005d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400005e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400005e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                    keycode = 119;
                    break;
400005ee:	e8 7d 10 00 00       	call   40001670 <syscall>

                default:
                    keycode = 0x0;
400005f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
400005f6:	c9                   	leave  
400005f7:	c3                   	ret    

400005f8 <cd>:
static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

400005f8:	55                   	push   %ebp
400005f9:	89 e5                	mov    %esp,%ebp
400005fb:	53                   	push   %ebx
400005fc:	83 ec 10             	sub    $0x10,%esp
400005ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
    return kc_to_char[index][keycode];
40000602:	53                   	push   %ebx
40000603:	e8 b3 ff ff ff       	call   400005bb <changeExecPath>
40000608:	83 c4 10             	add    $0x10,%esp
4000060b:	85 c0                	test   %eax,%eax
4000060d:	75 11                	jne    40000620 <cd+0x28>
4000060f:	e8 fc 04 00 00       	call   40000b10 <getLastVFSErr>
40000614:	52                   	push   %edx
40000615:	52                   	push   %edx
40000616:	50                   	push   %eax
40000617:	53                   	push   %ebx
40000618:	e8 7f fe ff ff       	call   4000049c <printFilesystemError>
4000061d:	83 c4 10             	add    $0x10,%esp
}
40000620:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000623:	c9                   	leave  
40000624:	c3                   	ret    

40000625 <getExecPath>:

#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;
40000625:	55                   	push   %ebp
40000626:	89 e5                	mov    %esp,%ebp
40000628:	83 ec 34             	sub    $0x34,%esp
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
4000062b:	8b 45 08             	mov    0x8(%ebp),%eax
4000062e:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
40000635:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            keycode = sc_to_kc[0][scancode];
            break;
40000638:	8d 45 e0             	lea    -0x20(%ebp),%eax
4000063b:	50                   	push   %eax
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
4000063c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000643:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000064a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000651:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            keycode = sc_to_kc[0][scancode];
            break;
40000658:	e8 13 10 00 00       	call   40001670 <syscall>
4000065d:	83 c4 10             	add    $0x10,%esp

40000660:	c9                   	leave  
40000661:	c3                   	ret    

40000662 <exit>:
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
40000662:	55                   	push   %ebp
40000663:	89 e5                	mov    %esp,%ebp
40000665:	83 ec 34             	sub    $0x34,%esp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000668:	8b 45 08             	mov    0x8(%ebp),%eax
4000066b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
40000672:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
40000675:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000678:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000067f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000686:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000068d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
40000694:	50                   	push   %eax
40000695:	e8 d6 0f 00 00       	call   40001670 <syscall>
};

#define KF_PRESSED (1 << 0)
4000069a:	c7 04 24 ee 31 00 40 	movl   $0x400031ee,(%esp)
400006a1:	e8 86 06 00 00       	call   40000d2c <printf>
400006a6:	eb f2                	jmp    4000069a <exit+0x38>

400006a8 <yield>:
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400006a8:	55                   	push   %ebp
400006a9:	89 e5                	mov    %esp,%ebp
400006ab:	83 ec 34             	sub    $0x34,%esp
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006ae:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400006b1:	c7 45 e0 05 00 00 00 	movl   $0x5,-0x20(%ebp)
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006b8:	50                   	push   %eax
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400006b9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400006c0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400006c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400006ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400006d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
400006dc:	e8 8f 0f 00 00       	call   40001670 <syscall>
400006e1:	83 c4 10             	add    $0x10,%esp
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400006e4:	c9                   	leave  
400006e5:	c3                   	ret    

400006e6 <pexists>:
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400006e6:	55                   	push   %ebp
400006e7:	89 e5                	mov    %esp,%ebp
400006e9:	83 ec 34             	sub    $0x34,%esp

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400006ec:	8b 45 08             	mov    0x8(%ebp),%eax
400006ef:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
400006f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400006f9:	8d 45 e0             	lea    -0x20(%ebp),%eax
400006fc:	50                   	push   %eax

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400006fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000704:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000070b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000712:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000719:	e8 52 0f 00 00       	call   40001670 <syscall>
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
4000071e:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000721:	c9                   	leave  
40000722:	c3                   	ret    

40000723 <register_irq_handler>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000723:	55                   	push   %ebp
40000724:	89 e5                	mov    %esp,%ebp
40000726:	53                   	push   %ebx
40000727:	83 ec 30             	sub    $0x30,%esp
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000072a:	8d 45 e0             	lea    -0x20(%ebp),%eax
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
4000072d:	8b 5d 08             	mov    0x8(%ebp),%ebx
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000730:	50                   	push   %eax
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000731:	c7 45 e0 28 00 00 00 	movl   $0x28,-0x20(%ebp)
40000738:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
4000073b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000742:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000749:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000750:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000757:	e8 14 0f 00 00       	call   40001670 <syscall>
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000075c:	83 c4 10             	add    $0x10,%esp
4000075f:	31 c0                	xor    %eax,%eax
40000761:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
40000765:	74 0f                	je     40000776 <register_irq_handler+0x53>
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
40000767:	8b 45 0c             	mov    0xc(%ebp),%eax
4000076a:	89 04 9d 14 40 00 40 	mov    %eax,0x40004014(,%ebx,4)
40000771:	b8 01 00 00 00       	mov    $0x1,%eax
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000776:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000779:	c9                   	leave  
4000077a:	c3                   	ret    

4000077b <fetch_rpc_data>:
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
4000077b:	55                   	push   %ebp
4000077c:	89 e5                	mov    %esp,%ebp
4000077e:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

40000781:	8b 45 08             	mov    0x8(%ebp),%eax
40000784:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
4000078b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
4000078e:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000791:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

40000792:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000799:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400007a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400007a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
400007ae:	e8 bd 0e 00 00       	call   40001670 <syscall>
400007b3:	83 c4 10             	add    $0x10,%esp
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
400007b6:	c9                   	leave  
400007b7:	c3                   	ret    

400007b8 <call_rpc>:
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007b8:	55                   	push   %ebp
400007b9:	89 e5                	mov    %esp,%ebp
400007bb:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007be:	8b 45 08             	mov    0x8(%ebp),%eax
400007c1:	c7 45 e0 1f 00 00 00 	movl   $0x1f,-0x20(%ebp)
400007c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400007cb:	8b 45 0c             	mov    0xc(%ebp),%eax
400007ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
400007d1:	8b 45 10             	mov    0x10(%ebp),%eax
400007d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
400007d7:	8b 45 14             	mov    0x14(%ebp),%eax
400007da:	89 45 f0             	mov    %eax,-0x10(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400007dd:	8d 45 e0             	lea    -0x20(%ebp),%eax
400007e0:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400007e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400007e8:	e8 83 0e 00 00       	call   40001670 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
400007ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
400007f0:	c9                   	leave  
400007f1:	c3                   	ret    

400007f2 <set_rpc_handler>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
400007f2:	55                   	push   %ebp
400007f3:	89 e5                	mov    %esp,%ebp
400007f5:	57                   	push   %edi
400007f6:	56                   	push   %esi
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400007f7:	be 10 31 00 40       	mov    $0x40003110,%esi
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
400007fc:	83 ec 24             	sub    $0x24,%esp
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
400007ff:	8d 7d e0             	lea    -0x20(%ebp),%edi

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;
40000802:	68 00 02 00 00       	push   $0x200
40000807:	6a 00                	push   $0x0
40000809:	68 14 40 00 40       	push   $0x40004014
4000080e:	e8 c5 07 00 00       	call   40000fd8 <memset>
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
40000813:	b9 06 00 00 00       	mov    $0x6,%ecx
            keycode = sc_to_kc[1][scancode];
            break;
40000818:	8d 45 e0             	lea    -0x20(%ebp),%eax
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
        case 1:
4000081b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
            keycode = sc_to_kc[1][scancode];
            break;
4000081d:	89 04 24             	mov    %eax,(%esp)
40000820:	e8 4b 0e 00 00       	call   40001670 <syscall>
40000825:	83 c4 10             	add    $0x10,%esp

40000828:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000082b:	5e                   	pop    %esi
4000082c:	5f                   	pop    %edi
4000082d:	5d                   	pop    %ebp
4000082e:	c3                   	ret    

4000082f <_start>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000082f:	55                   	push   %ebp
40000830:	89 e5                	mov    %esp,%ebp
40000832:	56                   	push   %esi
40000833:	53                   	push   %ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40000834:	31 db                	xor    %ebx,%ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000836:	83 ec 2c             	sub    $0x2c,%esp
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
40000839:	8d 45 e0             	lea    -0x20(%ebp),%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000083c:	c7 45 e0 04 00 00 00 	movl   $0x4,-0x20(%ebp)
40000843:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000084a:	50                   	push   %eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000084b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000852:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000859:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000860:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
40000867:	e8 04 0e 00 00       	call   40001670 <syscall>
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
4000086c:	8b 75 e0             	mov    -0x20(%ebp),%esi
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
4000086f:	83 c4 10             	add    $0x10,%esp
40000872:	85 f6                	test   %esi,%esi
40000874:	75 05                	jne    4000087b <_start+0x4c>
40000876:	89 f3                	mov    %esi,%ebx
40000878:	eb 07                	jmp    40000881 <_start+0x52>

static char kc_to_char[][128] = {
4000087a:	43                   	inc    %ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

4000087b:	83 3c 9e 00          	cmpl   $0x0,(%esi,%ebx,4)
4000087f:	75 f9                	jne    4000087a <_start+0x4b>
static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
40000881:	e8 6c ff ff ff       	call   400007f2 <set_rpc_handler>
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
40000886:	51                   	push   %ecx
40000887:	51                   	push   %ecx
40000888:	56                   	push   %esi
40000889:	53                   	push   %ebx
4000088a:	e8 99 fa ff ff       	call   40000328 <main>
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
4000088f:	89 04 24             	mov    %eax,(%esp)
40000892:	e8 cb fd ff ff       	call   40000662 <exit>
40000897:	83 c4 10             	add    $0x10,%esp
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000089a:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000089d:	5b                   	pop    %ebx
4000089e:	5e                   	pop    %esi
4000089f:	5d                   	pop    %ebp
400008a0:	c3                   	ret    

400008a1 <_handle_rpc>:
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400008a1:	55                   	push   %ebp
400008a2:	89 e5                	mov    %esp,%ebp
400008a4:	56                   	push   %esi
400008a5:	53                   	push   %ebx
400008a6:	83 ec 2c             	sub    $0x2c,%esp
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400008a9:	ff 75 10             	pushl  0x10(%ebp)
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400008ac:	8b 75 0c             	mov    0xc(%ebp),%esi
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400008af:	e8 bd 0a 00 00       	call   40001371 <malloc>
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008b4:	89 04 24             	mov    %eax,(%esp)
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
400008b7:	89 c3                	mov    %eax,%ebx
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008b9:	e8 bd fe ff ff       	call   4000077b <fetch_rpc_data>
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008be:	83 c4 10             	add    $0x10,%esp
400008c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400008c5:	75 4b                	jne    40000912 <_handle_rpc+0x71>
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008c7:	8b 04 b5 14 40 00 40 	mov    0x40004014(,%esi,4),%eax
400008ce:	85 c0                	test   %eax,%eax
400008d0:	74 40                	je     40000912 <_handle_rpc+0x71>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400008d2:	83 ec 0c             	sub    $0xc,%esp
400008d5:	56                   	push   %esi
400008d6:	ff d0                	call   *%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400008d8:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400008db:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400008e2:	89 04 24             	mov    %eax,(%esp)
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400008e5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400008ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400008f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400008fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000901:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000908:	e8 63 0d 00 00       	call   40001670 <syscall>
4000090d:	83 c4 10             	add    $0x10,%esp
40000910:	eb fe                	jmp    40000910 <_handle_rpc+0x6f>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)

40000912:	83 ec 0c             	sub    $0xc,%esp
40000915:	68 f5 31 00 40       	push   $0x400031f5
4000091a:	e8 0d 04 00 00       	call   40000d2c <printf>
uint32_t key_flags[256];

4000091f:	89 1c 24             	mov    %ebx,(%esp)
40000922:	e8 01 09 00 00       	call   40001228 <free>
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000927:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000092a:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000931:	89 04 24             	mov    %eax,(%esp)
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000934:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
4000093b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000942:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000949:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000950:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000957:	e8 14 0d 00 00       	call   40001670 <syscall>
4000095c:	83 c4 10             	add    $0x10,%esp
4000095f:	eb fe                	jmp    4000095f <_handle_rpc+0xbe>
40000961:	00 00                	add    %al,(%eax)
	...

40000964 <resolveHandle>:
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
40000964:	55                   	push   %ebp
40000965:	89 e5                	mov    %esp,%ebp
40000967:	83 ec 28             	sub    $0x28,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
4000096a:	3d fe 0f 00 00       	cmp    $0xffe,%eax
4000096f:	77 38                	ja     400009a9 <resolveHandle+0x45>

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000971:	83 ec 0c             	sub    $0xc,%esp
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000974:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000977:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000097a:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40000981:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40000982:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000989:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000990:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000997:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
4000099e:	e8 cd 0c 00 00       	call   40001670 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400009a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
400009a6:	83 c4 10             	add    $0x10,%esp
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400009a9:	c9                   	leave  
400009aa:	c3                   	ret    

400009ab <fmkfifo>:
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
400009ab:	55                   	push   %ebp
400009ac:	89 e5                	mov    %esp,%ebp
400009ae:	83 ec 34             	sub    $0x34,%esp
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
400009b1:	8b 45 08             	mov    0x8(%ebp),%eax
400009b4:	c7 45 e0 0e 00 00 00 	movl   $0xe,-0x20(%ebp)
400009bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    } else {
        // Normaler Scancode
400009be:	8d 45 e0             	lea    -0x20(%ebp),%eax
400009c1:	50                   	push   %eax
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
400009c2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400009c9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400009d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400009d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    } else {
        // Normaler Scancode
400009de:	e8 8d 0c 00 00       	call   40001670 <syscall>
        keycode = translate_scancode(0, scancode);
    }

400009e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
400009e6:	c9                   	leave  
400009e7:	c3                   	ret    

400009e8 <favailable>:
                case 0x451D:
                    keycode = 119;
                    break;

                default:
                    keycode = 0x0;
400009e8:	55                   	push   %ebp
400009e9:	89 e5                	mov    %esp,%ebp
400009eb:	83 ec 34             	sub    $0x34,%esp
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

400009ee:	8b 45 08             	mov    0x8(%ebp),%eax
400009f1:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
400009f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    return keycode;
}
400009fb:	8d 45 e0             	lea    -0x20(%ebp),%eax
400009fe:	50                   	push   %eax
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

400009ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a06:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a14:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    return keycode;
}
40000a1b:	e8 50 0c 00 00       	call   40001670 <syscall>

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;
40000a20:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a23:	c9                   	leave  
40000a24:	c3                   	ret    

40000a25 <fclose>:
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
40000a25:	55                   	push   %ebp
40000a26:	89 e5                	mov    %esp,%ebp
40000a28:	83 ec 34             	sub    $0x34,%esp
#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;

40000a2b:	8b 45 08             	mov    0x8(%ebp),%eax
40000a2e:	c7 45 e0 0b 00 00 00 	movl   $0xb,-0x20(%ebp)
40000a35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000a38:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000a3b:	50                   	push   %eax
#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

HANDLE charout = 0;

40000a3c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
static uint8_t translate_scancode(int set, uint16_t scancode)
{
40000a58:	e8 13 0c 00 00       	call   40001670 <syscall>
    uint8_t keycode = 0;

    switch (set) {
40000a5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a60:	c9                   	leave  
40000a61:	c3                   	ret    

40000a62 <fopen>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
40000a62:	55                   	push   %ebp
40000a63:	89 e5                	mov    %esp,%ebp
40000a65:	83 ec 34             	sub    $0x34,%esp
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000a68:	8b 45 08             	mov    0x8(%ebp),%eax
40000a6b:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
40000a72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000a75:	8b 45 0c             	mov    0xc(%ebp),%eax
40000a78:	89 45 e8             	mov    %eax,-0x18(%ebp)
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a7b:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000a7e:	50                   	push   %eax
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40000a7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000a8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a94:	e8 d7 0b 00 00       	call   40001670 <syscall>
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000a99:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000a9c:	c9                   	leave  
40000a9d:	c3                   	ret    

40000a9e <fopenpmhandle>:
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40000a9e:	55                   	push   %ebp
40000a9f:	89 e5                	mov    %esp,%ebp
40000aa1:	83 ec 34             	sub    $0x34,%esp
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40000aa4:	8b 45 08             	mov    0x8(%ebp),%eax
40000aa7:	c7 45 e0 15 00 00 00 	movl   $0x15,-0x20(%ebp)
40000aae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ab4:	89 45 e8             	mov    %eax,-0x18(%ebp)
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000ab7:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000aba:	50                   	push   %eax
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40000abb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000ac2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000ac9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
40000ad0:	e8 9b 0b 00 00       	call   40001670 <syscall>
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000ad5:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000ad8:	c9                   	leave  
40000ad9:	c3                   	ret    

40000ada <setstderr>:
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
40000ada:	55                   	push   %ebp
40000adb:	89 e5                	mov    %esp,%ebp
40000add:	83 ec 10             	sub    $0x10,%esp
40000ae0:	ff 75 08             	pushl  0x8(%ebp)
40000ae3:	6a 03                	push   $0x3
40000ae5:	e8 b4 ff ff ff       	call   40000a9e <fopenpmhandle>
40000aea:	c9                   	leave  
40000aeb:	c3                   	ret    

40000aec <setstdin>:
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
40000aec:	55                   	push   %ebp
40000aed:	89 e5                	mov    %esp,%ebp
40000aef:	83 ec 10             	sub    $0x10,%esp
40000af2:	ff 75 08             	pushl  0x8(%ebp)
40000af5:	6a 02                	push   $0x2
40000af7:	e8 a2 ff ff ff       	call   40000a9e <fopenpmhandle>
40000afc:	c9                   	leave  
40000afd:	c3                   	ret    

40000afe <setstdout>:
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40000afe:	55                   	push   %ebp
40000aff:	89 e5                	mov    %esp,%ebp
40000b01:	83 ec 10             	sub    $0x10,%esp
40000b04:	ff 75 08             	pushl  0x8(%ebp)
40000b07:	6a 01                	push   $0x1
40000b09:	e8 90 ff ff ff       	call   40000a9e <fopenpmhandle>
40000b0e:	c9                   	leave  
40000b0f:	c3                   	ret    

40000b10 <getLastVFSErr>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ports.h"
40000b10:	55                   	push   %ebp
40000b11:	89 e5                	mov    %esp,%ebp
40000b13:	83 ec 34             	sub    $0x34,%esp
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b16:	8d 45 e0             	lea    -0x20(%ebp),%eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000b19:	c7 45 e0 0f 00 00 00 	movl   $0xf,-0x20(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b20:	50                   	push   %eax
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
40000b21:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000b28:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000b2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000b36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000b3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40000b44:	e8 27 0b 00 00       	call   40001670 <syscall>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40000b49:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000b4c:	c9                   	leave  
40000b4d:	c3                   	ret    

40000b4e <fwrite>:
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40000b4e:	55                   	push   %ebp
40000b4f:	89 e5                	mov    %esp,%ebp
40000b51:	57                   	push   %edi
40000b52:	56                   	push   %esi
40000b53:	53                   	push   %ebx
40000b54:	83 ec 3c             	sub    $0x3c,%esp
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b57:	8b 45 08             	mov    0x8(%ebp),%eax
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40000b5a:	8b 7d 10             	mov    0x10(%ebp),%edi
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b5d:	e8 02 fe ff ff       	call   40000964 <resolveHandle>

static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b62:	83 ec 0c             	sub    $0xc,%esp

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
40000b65:	89 c6                	mov    %eax,%esi
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40000b6a:	8b 45 0c             	mov    0xc(%ebp),%eax
40000b6d:	c7 45 d0 0c 00 00 00 	movl   $0xc,-0x30(%ebp)
40000b74:	89 45 d8             	mov    %eax,-0x28(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b77:	8d 45 d0             	lea    -0x30(%ebp),%eax
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b7a:	89 7d dc             	mov    %edi,-0x24(%ebp)
40000b7d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000b84:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b8b:	50                   	push   %eax
40000b8c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
40000b8f:	eb 2d                	jmp    40000bbe <fwrite+0x70>
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
40000b91:	e8 12 fb ff ff       	call   400006a8 <yield>
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b96:	8b 45 0c             	mov    0xc(%ebp),%eax
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b99:	83 ec 0c             	sub    $0xc,%esp
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000b9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000b9f:	8d 45 d0             	lea    -0x30(%ebp),%eax
    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
    do {
40000ba2:	c7 45 d0 0c 00 00 00 	movl   $0xc,-0x30(%ebp)
40000ba9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000bac:	89 7d dc             	mov    %edi,-0x24(%ebp)
40000baf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000bb6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40000bbd:	50                   	push   %eax
40000bbe:	e8 ad 0a 00 00       	call   40001670 <syscall>

        port_out(PORTM_BYTE, 0x60, command);
40000bc3:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40000bc6:	83 c4 10             	add    $0x10,%esp
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
40000bc9:	83 fb 01             	cmp    $0x1,%ebx
40000bcc:	74 c3                	je     40000b91 <fwrite+0x43>
    uint8_t keycode = 0;
    int break_code = 0;

    static int      e0_code = 0;
    static int      e1_code = 0;
40000bce:	89 f0                	mov    %esi,%eax
40000bd0:	89 da                	mov    %ebx,%edx
40000bd2:	e8 3d 02 00 00       	call   40000e14 <printrwerror>
    static uint16_t e1_prev = 0;

    if(!init_done) return;
40000bd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000bda:	89 d8                	mov    %ebx,%eax
40000bdc:	5b                   	pop    %ebx
40000bdd:	5e                   	pop    %esi
40000bde:	5f                   	pop    %edi
40000bdf:	5d                   	pop    %ebp
40000be0:	c3                   	ret    

40000be1 <fputs>:
40000be1:	55                   	push   %ebp
40000be2:	89 e5                	mov    %esp,%ebp
40000be4:	56                   	push   %esi
40000be5:	53                   	push   %ebx
40000be6:	83 ec 20             	sub    $0x20,%esp
40000be9:	8b 45 0c             	mov    0xc(%ebp),%eax
40000bec:	8b 5d 08             	mov    0x8(%ebp),%ebx
40000bef:	e8 70 fd ff ff       	call   40000964 <resolveHandle>
40000bf4:	89 c6                	mov    %eax,%esi
40000bf6:	85 c0                	test   %eax,%eax
40000bf8:	74 16                	je     40000c10 <fputs+0x2f>
40000bfa:	83 ec 0c             	sub    $0xc,%esp
40000bfd:	53                   	push   %ebx
40000bfe:	e8 a7 04 00 00       	call   400010aa <strlen>
40000c03:	83 c4 0c             	add    $0xc,%esp
40000c06:	50                   	push   %eax
40000c07:	53                   	push   %ebx
40000c08:	56                   	push   %esi
40000c09:	e8 40 ff ff ff       	call   40000b4e <fwrite>
40000c0e:	eb 35                	jmp    40000c45 <fputs+0x64>
40000c10:	83 ec 0c             	sub    $0xc,%esp
40000c13:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000c16:	c7 45 e0 ca 00 00 00 	movl   $0xca,-0x20(%ebp)
40000c1d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40000c20:	50                   	push   %eax
40000c21:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000c28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000c2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000c36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40000c3d:	e8 2e 0a 00 00       	call   40001670 <syscall>
40000c42:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c45:	83 c4 10             	add    $0x10,%esp
40000c48:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000c4b:	5b                   	pop    %ebx
40000c4c:	5e                   	pop    %esi
40000c4d:	5d                   	pop    %ebp
40000c4e:	c3                   	ret    

40000c4f <puts>:
40000c4f:	55                   	push   %ebp
40000c50:	89 e5                	mov    %esp,%ebp
40000c52:	83 ec 10             	sub    $0x10,%esp
40000c55:	6a 01                	push   $0x1
40000c57:	ff 75 08             	pushl  0x8(%ebp)
40000c5a:	e8 82 ff ff ff       	call   40000be1 <fputs>
40000c5f:	c9                   	leave  
40000c60:	c3                   	ret    

40000c61 <putn>:
40000c61:	55                   	push   %ebp
40000c62:	89 e5                	mov    %esp,%ebp
40000c64:	56                   	push   %esi
40000c65:	53                   	push   %ebx
40000c66:	31 f6                	xor    %esi,%esi
40000c68:	83 ec 50             	sub    $0x50,%esp
40000c6b:	89 d3                	mov    %edx,%ebx
40000c6d:	83 fa 24             	cmp    $0x24,%edx
40000c70:	7f 25                	jg     40000c97 <putn+0x36>
40000c72:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
40000c76:	8d 4d f7             	lea    -0x9(%ebp),%ecx
40000c79:	31 d2                	xor    %edx,%edx
40000c7b:	49                   	dec    %ecx
40000c7c:	f7 f3                	div    %ebx
40000c7e:	46                   	inc    %esi
40000c7f:	85 c0                	test   %eax,%eax
40000c81:	8a 92 05 32 00 40    	mov    0x40003205(%edx),%dl
40000c87:	88 11                	mov    %dl,(%ecx)
40000c89:	75 ee                	jne    40000c79 <putn+0x18>
40000c8b:	83 ec 0c             	sub    $0xc,%esp
40000c8e:	51                   	push   %ecx
40000c8f:	e8 bb ff ff ff       	call   40000c4f <puts>
40000c94:	83 c4 10             	add    $0x10,%esp
40000c97:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000c9a:	89 f0                	mov    %esi,%eax
40000c9c:	5b                   	pop    %ebx
40000c9d:	5e                   	pop    %esi
40000c9e:	5d                   	pop    %ebp
40000c9f:	c3                   	ret    

40000ca0 <fputc>:
40000ca0:	55                   	push   %ebp
40000ca1:	89 e5                	mov    %esp,%ebp
40000ca3:	83 ec 38             	sub    $0x38,%esp
40000ca6:	8b 45 08             	mov    0x8(%ebp),%eax
40000ca9:	88 45 d4             	mov    %al,-0x2c(%ebp)
40000cac:	8b 45 0c             	mov    0xc(%ebp),%eax
40000caf:	e8 b0 fc ff ff       	call   40000964 <resolveHandle>
40000cb4:	85 c0                	test   %eax,%eax
40000cb6:	74 0f                	je     40000cc7 <fputc+0x27>
40000cb8:	52                   	push   %edx
40000cb9:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40000cbc:	6a 01                	push   $0x1
40000cbe:	52                   	push   %edx
40000cbf:	50                   	push   %eax
40000cc0:	e8 89 fe ff ff       	call   40000b4e <fwrite>
40000cc5:	eb 39                	jmp    40000d00 <fputc+0x60>
40000cc7:	0f be 45 d4          	movsbl -0x2c(%ebp),%eax
40000ccb:	83 ec 0c             	sub    $0xc,%esp
40000cce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000cd1:	8d 45 e0             	lea    -0x20(%ebp),%eax
40000cd4:	c7 45 e0 c9 00 00 00 	movl   $0xc9,-0x20(%ebp)
40000cdb:	50                   	push   %eax
40000cdc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000ce3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000cea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000cf1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40000cf8:	e8 73 09 00 00       	call   40001670 <syscall>
40000cfd:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000d00:	83 c4 10             	add    $0x10,%esp
40000d03:	c9                   	leave  
40000d04:	c3                   	ret    

40000d05 <putc>:
40000d05:	55                   	push   %ebp
40000d06:	89 e5                	mov    %esp,%ebp
40000d08:	83 ec 08             	sub    $0x8,%esp
40000d0b:	0f be 45 08          	movsbl 0x8(%ebp),%eax
40000d0f:	89 45 08             	mov    %eax,0x8(%ebp)
40000d12:	c9                   	leave  
40000d13:	e9 88 ff ff ff       	jmp    40000ca0 <fputc>

40000d18 <putchar>:
40000d18:	55                   	push   %ebp
40000d19:	89 e5                	mov    %esp,%ebp
40000d1b:	83 ec 10             	sub    $0x10,%esp
40000d1e:	0f be 45 08          	movsbl 0x8(%ebp),%eax
40000d22:	6a 01                	push   $0x1
40000d24:	50                   	push   %eax
40000d25:	e8 76 ff ff ff       	call   40000ca0 <fputc>
40000d2a:	c9                   	leave  
40000d2b:	c3                   	ret    

40000d2c <printf>:
40000d2c:	55                   	push   %ebp
40000d2d:	89 e5                	mov    %esp,%ebp
40000d2f:	57                   	push   %edi
40000d30:	56                   	push   %esi
40000d31:	53                   	push   %ebx
40000d32:	83 ec 1c             	sub    $0x1c,%esp
40000d35:	8d 75 0c             	lea    0xc(%ebp),%esi
40000d38:	8b 7d 08             	mov    0x8(%ebp),%edi
40000d3b:	31 db                	xor    %ebx,%ebx
40000d3d:	e9 be 00 00 00       	jmp    40000e00 <printf+0xd4>
40000d42:	3c 25                	cmp    $0x25,%al
40000d44:	0f 85 a4 00 00 00    	jne    40000dee <printf+0xc2>
40000d4a:	47                   	inc    %edi
40000d4b:	8a 07                	mov    (%edi),%al
40000d4d:	3c 70                	cmp    $0x70,%al
40000d4f:	74 47                	je     40000d98 <printf+0x6c>
40000d51:	7f 1a                	jg     40000d6d <printf+0x41>
40000d53:	3c 63                	cmp    $0x63,%al
40000d55:	74 5a                	je     40000db1 <printf+0x85>
40000d57:	7f 0e                	jg     40000d67 <printf+0x3b>
40000d59:	84 c0                	test   %al,%al
40000d5b:	0f 84 a9 00 00 00    	je     40000e0a <printf+0xde>
40000d61:	3c 25                	cmp    $0x25,%al
40000d63:	75 6c                	jne    40000dd1 <printf+0xa5>
40000d65:	eb 63                	jmp    40000dca <printf+0x9e>
40000d67:	3c 64                	cmp    $0x64,%al
40000d69:	75 66                	jne    40000dd1 <printf+0xa5>
40000d6b:	eb 1e                	jmp    40000d8b <printf+0x5f>
40000d6d:	3c 75                	cmp    $0x75,%al
40000d6f:	74 1a                	je     40000d8b <printf+0x5f>
40000d71:	3c 78                	cmp    $0x78,%al
40000d73:	74 23                	je     40000d98 <printf+0x6c>
40000d75:	3c 73                	cmp    $0x73,%al
40000d77:	75 58                	jne    40000dd1 <printf+0xa5>
40000d79:	83 ec 0c             	sub    $0xc,%esp
40000d7c:	8d 46 04             	lea    0x4(%esi),%eax
40000d7f:	ff 36                	pushl  (%esi)
40000d81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d84:	e8 c6 fe ff ff       	call   40000c4f <puts>
40000d89:	eb 38                	jmp    40000dc3 <printf+0x97>
40000d8b:	8d 46 04             	lea    0x4(%esi),%eax
40000d8e:	ba 0a 00 00 00       	mov    $0xa,%edx
40000d93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000d96:	eb 0b                	jmp    40000da3 <printf+0x77>
40000d98:	8d 46 04             	lea    0x4(%esi),%eax
40000d9b:	ba 10 00 00 00       	mov    $0x10,%edx
40000da0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000da3:	8b 06                	mov    (%esi),%eax
40000da5:	e8 b7 fe ff ff       	call   40000c61 <putn>
40000daa:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40000dad:	01 c3                	add    %eax,%ebx
40000daf:	eb 4e                	jmp    40000dff <printf+0xd3>
40000db1:	8d 46 04             	lea    0x4(%esi),%eax
40000db4:	83 ec 0c             	sub    $0xc,%esp
40000db7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000dba:	0f be 06             	movsbl (%esi),%eax
40000dbd:	50                   	push   %eax
40000dbe:	e8 55 ff ff ff       	call   40000d18 <putchar>
40000dc3:	01 c3                	add    %eax,%ebx
40000dc5:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40000dc8:	eb 32                	jmp    40000dfc <printf+0xd0>
40000dca:	83 ec 0c             	sub    $0xc,%esp
40000dcd:	6a 25                	push   $0x25
40000dcf:	eb 24                	jmp    40000df5 <printf+0xc9>
40000dd1:	83 ec 0c             	sub    $0xc,%esp
40000dd4:	6a 25                	push   $0x25
40000dd6:	e8 3d ff ff ff       	call   40000d18 <putchar>
40000ddb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000dde:	0f be 07             	movsbl (%edi),%eax
40000de1:	89 04 24             	mov    %eax,(%esp)
40000de4:	e8 2f ff ff ff       	call   40000d18 <putchar>
40000de9:	03 45 e4             	add    -0x1c(%ebp),%eax
40000dec:	eb 0c                	jmp    40000dfa <printf+0xce>
40000dee:	83 ec 0c             	sub    $0xc,%esp
40000df1:	0f be c0             	movsbl %al,%eax
40000df4:	50                   	push   %eax
40000df5:	e8 1e ff ff ff       	call   40000d18 <putchar>
40000dfa:	01 c3                	add    %eax,%ebx
40000dfc:	83 c4 10             	add    $0x10,%esp
40000dff:	47                   	inc    %edi
40000e00:	8a 07                	mov    (%edi),%al
40000e02:	84 c0                	test   %al,%al
40000e04:	0f 85 38 ff ff ff    	jne    40000d42 <printf+0x16>
40000e0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000e0d:	89 d8                	mov    %ebx,%eax
40000e0f:	5b                   	pop    %ebx
40000e10:	5e                   	pop    %esi
40000e11:	5f                   	pop    %edi
40000e12:	5d                   	pop    %ebp
40000e13:	c3                   	ret    

40000e14 <printrwerror>:
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
        case 0:
40000e14:	55                   	push   %ebp
40000e15:	89 e5                	mov    %esp,%ebp
40000e17:	83 ec 08             	sub    $0x8,%esp
            keycode = sc_to_kc[0][scancode];
40000e1a:	83 fa 02             	cmp    $0x2,%edx
40000e1d:	75 0a                	jne    40000e29 <printrwerror+0x15>
            break;
40000e1f:	52                   	push   %edx
40000e20:	52                   	push   %edx
40000e21:	50                   	push   %eax
40000e22:	68 2a 32 00 40       	push   $0x4000322a
40000e27:	eb 2b                	jmp    40000e54 <printrwerror+0x40>

        // e0-Scancodes
        case 1:
40000e29:	83 fa 03             	cmp    $0x3,%edx
40000e2c:	75 0a                	jne    40000e38 <printrwerror+0x24>
            keycode = sc_to_kc[1][scancode];
40000e2e:	51                   	push   %ecx
40000e2f:	51                   	push   %ecx
40000e30:	50                   	push   %eax
40000e31:	68 42 32 00 40       	push   $0x40003242
40000e36:	eb 1c                	jmp    40000e54 <printrwerror+0x40>
            break;

        // e1-Scancodes
40000e38:	83 fa 04             	cmp    $0x4,%edx
40000e3b:	75 0a                	jne    40000e47 <printrwerror+0x33>
        case 2:
40000e3d:	52                   	push   %edx
40000e3e:	52                   	push   %edx
40000e3f:	50                   	push   %eax
40000e40:	68 5d 32 00 40       	push   $0x4000325d
40000e45:	eb 0d                	jmp    40000e54 <printrwerror+0x40>
            switch (scancode) {
                // Pause
                case 0x451D:
40000e47:	83 fa 05             	cmp    $0x5,%edx
40000e4a:	75 10                	jne    40000e5c <printrwerror+0x48>
                    keycode = 119;
40000e4c:	51                   	push   %ecx
40000e4d:	51                   	push   %ecx
40000e4e:	50                   	push   %eax
40000e4f:	68 87 32 00 40       	push   $0x40003287
40000e54:	e8 d3 fe ff ff       	call   40000d2c <printf>
40000e59:	83 c4 10             	add    $0x10,%esp
                    break;

40000e5c:	c9                   	leave  
40000e5d:	c3                   	ret    

40000e5e <fread>:
    }

    if (e0_code) {
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40000e5e:	55                   	push   %ebp
40000e5f:	89 e5                	mov    %esp,%ebp
40000e61:	57                   	push   %edi
40000e62:	56                   	push   %esi
40000e63:	53                   	push   %ebx
40000e64:	83 ec 38             	sub    $0x38,%esp
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }
40000e67:	8d 7d d0             	lea    -0x30(%ebp),%edi
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    }

    if (e0_code) {
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
40000e6d:	8b 75 08             	mov    0x8(%ebp),%esi
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e70:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000e73:	8b 45 10             	mov    0x10(%ebp),%eax
40000e76:	c7 45 d0 0d 00 00 00 	movl   $0xd,-0x30(%ebp)
40000e7d:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000e80:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000e83:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000e8a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40000e91:	eb 2c                	jmp    40000ebf <fread+0x61>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
        }

        keycode = translate_scancode(1, scancode);
40000e93:	e8 10 f8 ff ff       	call   400006a8 <yield>
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
40000e98:	8b 45 0c             	mov    0xc(%ebp),%eax
40000e9b:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000e9e:	8b 45 10             	mov    0x10(%ebp),%eax
40000ea1:	c7 45 d0 0d 00 00 00 	movl   $0xd,-0x30(%ebp)
40000ea8:	89 75 d4             	mov    %esi,-0x2c(%ebp)
40000eab:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000eae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40000eb5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        scancode &= ~0x80;
    }
40000ebc:	83 ec 0c             	sub    $0xc,%esp
40000ebf:	57                   	push   %edi
40000ec0:	e8 ab 07 00 00       	call   40001670 <syscall>

    if (e0_code) {
40000ec5:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40000ec8:	83 c4 10             	add    $0x10,%esp
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
            return;
        }

40000ecb:	83 fb 01             	cmp    $0x1,%ebx
40000ece:	74 c3                	je     40000e93 <fread+0x35>
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
40000ed0:	89 f0                	mov    %esi,%eax
40000ed2:	89 da                	mov    %ebx,%edx
40000ed4:	e8 3b ff ff ff       	call   40000e14 <printrwerror>
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
40000ed9:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000edc:	89 d8                	mov    %ebx,%eax
40000ede:	5b                   	pop    %ebx
40000edf:	5e                   	pop    %esi
40000ee0:	5f                   	pop    %edi
40000ee1:	5d                   	pop    %ebp
40000ee2:	c3                   	ret    

40000ee3 <fgetc>:
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
    }

    if(break_code) {
        key_flags[keycode] &= ~KF_PRESSED;
40000ee3:	55                   	push   %ebp
40000ee4:	89 e5                	mov    %esp,%ebp
40000ee6:	83 ec 18             	sub    $0x18,%esp
    }
40000ee9:	8b 45 08             	mov    0x8(%ebp),%eax
40000eec:	e8 73 fa ff ff       	call   40000964 <resolveHandle>
    else
40000ef1:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
    {
40000ef5:	85 c0                	test   %eax,%eax
40000ef7:	74 10                	je     40000f09 <fgetc+0x26>
        key_flags[keycode] |= KF_PRESSED;
40000ef9:	8d 55 f7             	lea    -0x9(%ebp),%edx
40000efc:	51                   	push   %ecx
40000efd:	6a 01                	push   $0x1
40000eff:	52                   	push   %edx
40000f00:	50                   	push   %eax
40000f01:	e8 58 ff ff ff       	call   40000e5e <fread>
40000f06:	83 c4 10             	add    $0x10,%esp
    }

    char chr = getcharfromkc(keycode);
40000f09:	8a 45 f7             	mov    -0x9(%ebp),%al
40000f0c:	c9                   	leave  
40000f0d:	c3                   	ret    

40000f0e <getchar>:
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");

    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
        port_in(PORTM_BYTE, 0x60);
40000f0e:	55                   	push   %ebp
40000f0f:	89 e5                	mov    %esp,%ebp
40000f11:	83 ec 14             	sub    $0x14,%esp
    }
40000f14:	6a 02                	push   $0x2
40000f16:	e8 c8 ff ff ff       	call   40000ee3 <fgetc>

40000f1b:	c9                   	leave  
40000f1c:	c3                   	ret    

40000f1d <getc>:
    printf("[kbcdrv] requesting neccesary resources...\n");

    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
    require_port(0x60);

40000f1d:	55                   	push   %ebp
40000f1e:	89 e5                	mov    %esp,%ebp
40000f20:	83 ec 08             	sub    $0x8,%esp
    printf("[kbcdrv] emptying keyboard buffer...\n");

40000f23:	c9                   	leave  

    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
    require_port(0x60);

    printf("[kbcdrv] emptying keyboard buffer...\n");
40000f24:	e9 ba ff ff ff       	jmp    40000ee3 <fgetc>

40000f29 <fgets>:
        key_flags[keycode] |= KF_PRESSED;
    }

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
40000f29:	55                   	push   %ebp
40000f2a:	89 e5                	mov    %esp,%ebp
40000f2c:	57                   	push   %edi
40000f2d:	56                   	push   %esi
40000f2e:	53                   	push   %ebx
40000f2f:	83 ec 1c             	sub    $0x1c,%esp
40000f32:	31 db                	xor    %ebx,%ebx
40000f34:	8b 7d 0c             	mov    0xc(%ebp),%edi
40000f37:	8b 75 08             	mov    0x8(%ebp),%esi
        fwrite(charout, &chr, sizeof(char));
40000f3a:	8d 47 ff             	lea    -0x1(%edi),%eax
40000f3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000f40:	eb 16                	jmp    40000f58 <fgets+0x2f>
    }
40000f42:	83 ec 0c             	sub    $0xc,%esp
40000f45:	ff 75 10             	pushl  0x10(%ebp)
40000f48:	e8 96 ff ff ff       	call   40000ee3 <fgetc>
}
40000f4d:	83 c4 10             	add    $0x10,%esp

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
    }
40000f50:	88 04 1e             	mov    %al,(%esi,%ebx,1)
}
40000f53:	84 c0                	test   %al,%al
40000f55:	74 0a                	je     40000f61 <fgets+0x38>
    }

    char chr = getcharfromkc(keycode);

    if(!break_code && chr) {
        fwrite(charout, &chr, sizeof(char));
40000f57:	43                   	inc    %ebx
40000f58:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
40000f5b:	7c e5                	jl     40000f42 <fgets+0x19>
}

int main(int argc, char* args[])
{
    printf("[kbcdrv] requesting neccesary resources...\n");

40000f5d:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
    register_irq_handler(0x21, &irq_handler);
    require_port(0x64);
40000f61:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000f64:	89 f0                	mov    %esi,%eax
40000f66:	5b                   	pop    %ebx
40000f67:	5e                   	pop    %esi
40000f68:	5f                   	pop    %edi
40000f69:	5d                   	pop    %ebp
40000f6a:	c3                   	ret    

40000f6b <getln>:
    while (port_in(PORTM_BYTE, 0x64) & 0x1) {
        port_in(PORTM_BYTE, 0x60);
    }

    printf("[kbcdrv] initializing KBC...\n");

40000f6b:	55                   	push   %ebp
40000f6c:	89 e5                	mov    %esp,%ebp
40000f6e:	56                   	push   %esi
40000f6f:	53                   	push   %ebx
40000f70:	31 db                	xor    %ebx,%ebx
40000f72:	8b 75 08             	mov    0x8(%ebp),%esi
    memset(key_flags, 0, 256 * sizeof(uint32_t));

    // Leds alle ausloeschen
    send_command(0xED);
40000f75:	eb 42                	jmp    40000fb9 <getln+0x4e>
    send_command(0);
40000f77:	3c 0a                	cmp    $0xa,%al
40000f79:	75 0f                	jne    40000f8a <getln+0x1f>

40000f7b:	83 ec 0c             	sub    $0xc,%esp
40000f7e:	6a 0a                	push   $0xa
40000f80:	e8 93 fd ff ff       	call   40000d18 <putchar>
    // Schnellste Wiederholrate
40000f85:	83 c4 10             	add    $0x10,%esp
40000f88:	eb 40                	jmp    40000fca <getln+0x5f>
    send_command(0xF3);
    send_command(0);

40000f8a:	3c 08                	cmp    $0x8,%al
40000f8c:	75 18                	jne    40000fa6 <getln+0x3b>
    send_command(0xF4);
40000f8e:	85 db                	test   %ebx,%ebx
40000f90:	74 0e                	je     40000fa0 <getln+0x35>

    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
40000f92:	83 ec 0c             	sub    $0xc,%esp
    // Schnellste Wiederholrate
    send_command(0xF3);
    send_command(0);

    send_command(0xF4);

40000f95:	4b                   	dec    %ebx
    printf("[kbcdrv] creating output buffer at /dev/keyboard...\n");
40000f96:	6a 08                	push   $0x8
40000f98:	e8 7b fd ff ff       	call   40000d18 <putchar>
40000f9d:	83 c4 10             	add    $0x10,%esp

    charout = fmkfifo("/dev/keyboard");
40000fa0:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)

40000fa4:	eb 13                	jmp    40000fb9 <getln+0x4e>
    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000fa6:	83 ec 0c             	sub    $0xc,%esp

    charout = fmkfifo("/dev/keyboard");

    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
40000fa9:	88 04 1e             	mov    %al,(%esi,%ebx,1)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000fac:	0f be c0             	movsbl %al,%eax
40000faf:	50                   	push   %eax
    fclose(initCtrl);

40000fb0:	43                   	inc    %ebx
    charout = fmkfifo("/dev/keyboard");

    init_done = 1;

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
40000fb1:	e8 62 fd ff ff       	call   40000d18 <putchar>
    fclose(initCtrl);

40000fb6:	83 c4 10             	add    $0x10,%esp
    printf("[kbcdrv] initializing KBC...\n");

    memset(key_flags, 0, 256 * sizeof(uint32_t));

    // Leds alle ausloeschen
    send_command(0xED);
40000fb9:	83 ec 0c             	sub    $0xc,%esp
40000fbc:	6a 02                	push   $0x2
40000fbe:	e8 20 ff ff ff       	call   40000ee3 <fgetc>
40000fc3:	83 c4 10             	add    $0x10,%esp
40000fc6:	84 c0                	test   %al,%al
40000fc8:	75 ad                	jne    40000f77 <getln+0xc>
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
    fclose(initCtrl);

    printf("[kbcdrv] Done!\n");

    while(1);
40000fca:	c6 04 1e 00          	movb   $0x0,(%esi,%ebx,1)
}
40000fce:	8d 65 f8             	lea    -0x8(%ebp),%esp
40000fd1:	89 f0                	mov    %esi,%eax
40000fd3:	5b                   	pop    %ebx
40000fd4:	5e                   	pop    %esi
40000fd5:	5d                   	pop    %ebp
40000fd6:	c3                   	ret    
	...

40000fd8 <memset>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
40000fd8:	55                   	push   %ebp
40000fd9:	89 e5                	mov    %esp,%ebp
40000fdb:	53                   	push   %ebx
40000fdc:	8b 45 08             	mov    0x8(%ebp),%eax
40000fdf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40000fe2:	8b 4d 10             	mov    0x10(%ebp),%ecx
#include "ports.h"
40000fe5:	89 c2                	mov    %eax,%edx
 
uint32_t init_done = 0;
40000fe7:	eb 04                	jmp    40000fed <memset+0x15>
static uint8_t sc_to_kc[][128] = {
40000fe9:	88 1a                	mov    %bl,(%edx)
40000feb:	49                   	dec    %ecx
40000fec:	42                   	inc    %edx
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ports.h"
 
uint32_t init_done = 0;
40000fed:	85 c9                	test   %ecx,%ecx
40000fef:	75 f8                	jne    40000fe9 <memset+0x11>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40000ff1:	5b                   	pop    %ebx
40000ff2:	5d                   	pop    %ebp
40000ff3:	c3                   	ret    

40000ff4 <memcpy>:
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40000ff4:	55                   	push   %ebp
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40000ff5:	31 c9                	xor    %ecx,%ecx
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40000ff7:	89 e5                	mov    %esp,%ebp
40000ff9:	56                   	push   %esi
40000ffa:	53                   	push   %ebx
40000ffb:	8b 75 10             	mov    0x10(%ebp),%esi
40000ffe:	8b 45 08             	mov    0x8(%ebp),%eax
40001001:	8b 5d 0c             	mov    0xc(%ebp),%ebx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001004:	85 f6                	test   %esi,%esi
40001006:	75 04                	jne    4000100c <memcpy+0x18>
40001008:	31 c0                	xor    %eax,%eax
4000100a:	eb 0a                	jmp    40001016 <memcpy+0x22>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000100c:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
4000100f:	88 14 08             	mov    %dl,(%eax,%ecx,1)
40001012:	41                   	inc    %ecx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001013:	4e                   	dec    %esi
40001014:	75 f6                	jne    4000100c <memcpy+0x18>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

40001016:	5b                   	pop    %ebx
40001017:	5e                   	pop    %esi
40001018:	5d                   	pop    %ebp
40001019:	c3                   	ret    

4000101a <memcmp>:
    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
4000101a:	55                   	push   %ebp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000101b:	83 c8 ff             	or     $0xffffffff,%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
4000101e:	89 e5                	mov    %esp,%ebp
40001020:	57                   	push   %edi
40001021:	56                   	push   %esi
40001022:	53                   	push   %ebx
40001023:	8b 75 08             	mov    0x8(%ebp),%esi
40001026:	8b 7d 0c             	mov    0xc(%ebp),%edi
40001029:	8b 5d 10             	mov    0x10(%ebp),%ebx
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000102c:	85 f6                	test   %esi,%esi
4000102e:	74 2c                	je     4000105c <memcmp+0x42>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40001030:	b8 01 00 00 00       	mov    $0x1,%eax
40001035:	85 ff                	test   %edi,%edi
40001037:	74 23                	je     4000105c <memcmp+0x42>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001039:	31 d2                	xor    %edx,%edx
4000103b:	85 db                	test   %ebx,%ebx
4000103d:	75 17                	jne    40001056 <memcmp+0x3c>
4000103f:	eb 19                	jmp    4000105a <memcmp+0x40>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001041:	8a 04 16             	mov    (%esi,%edx,1),%al
40001044:	8a 0c 17             	mov    (%edi,%edx,1),%cl
40001047:	38 c8                	cmp    %cl,%al
40001049:	74 0a                	je     40001055 <memcmp+0x3b>
         00,  00,  00,  00,  00,  00,  00,  00
4000104b:	0f b6 c0             	movzbl %al,%eax
4000104e:	0f b6 c9             	movzbl %cl,%ecx
40001051:	29 c8                	sub    %ecx,%eax
40001053:	eb 07                	jmp    4000105c <memcmp+0x42>
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001055:	42                   	inc    %edx
40001056:	39 da                	cmp    %ebx,%edx
40001058:	72 e7                	jb     40001041 <memcmp+0x27>
4000105a:	31 c0                	xor    %eax,%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

static char kc_to_char[][128] = {
4000105c:	5b                   	pop    %ebx
4000105d:	5e                   	pop    %esi
4000105e:	5f                   	pop    %edi
4000105f:	5d                   	pop    %ebp
40001060:	c3                   	ret    

40001061 <strcmp>:
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40001061:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001062:	31 c0                	xor    %eax,%eax
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
40001064:	89 e5                	mov    %esp,%ebp
40001066:	56                   	push   %esi
40001067:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001068:	31 db                	xor    %ebx,%ebx
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
4000106a:	8b 55 08             	mov    0x8(%ebp),%edx
4000106d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001070:	85 d2                	test   %edx,%edx
40001072:	75 03                	jne    40001077 <strcmp+0x16>
40001074:	eb 09                	jmp    4000107f <strcmp+0x1e>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001076:	40                   	inc    %eax
40001077:	89 c3                	mov    %eax,%ebx
40001079:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
4000107d:	75 f7                	jne    40001076 <strcmp+0x15>
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000107f:	31 c0                	xor    %eax,%eax
40001081:	31 f6                	xor    %esi,%esi
40001083:	85 c9                	test   %ecx,%ecx
40001085:	75 03                	jne    4000108a <strcmp+0x29>
40001087:	eb 09                	jmp    40001092 <strcmp+0x31>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001089:	40                   	inc    %eax
4000108a:	89 c6                	mov    %eax,%esi
4000108c:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
40001090:	75 f7                	jne    40001089 <strcmp+0x28>
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
40001092:	89 f0                	mov    %esi,%eax
40001094:	39 de                	cmp    %ebx,%esi
40001096:	7e 02                	jle    4000109a <strcmp+0x39>
40001098:	89 d8                	mov    %ebx,%eax
4000109a:	40                   	inc    %eax
4000109b:	50                   	push   %eax
4000109c:	51                   	push   %ecx
4000109d:	52                   	push   %edx
4000109e:	e8 77 ff ff ff       	call   4000101a <memcmp>
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
400010a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
400010a6:	5b                   	pop    %ebx
400010a7:	5e                   	pop    %esi
400010a8:	5d                   	pop    %ebp
400010a9:	c3                   	ret    

400010aa <strlen>:
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400010aa:	55                   	push   %ebp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010ab:	31 d2                	xor    %edx,%edx
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400010ad:	89 e5                	mov    %esp,%ebp
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010af:	31 c0                	xor    %eax,%eax
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
400010b1:	8b 4d 08             	mov    0x8(%ebp),%ecx
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010b4:	85 c9                	test   %ecx,%ecx
400010b6:	75 03                	jne    400010bb <strlen+0x11>
400010b8:	eb 09                	jmp    400010c3 <strlen+0x19>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010ba:	42                   	inc    %edx
400010bb:	89 d0                	mov    %edx,%eax
400010bd:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
400010c1:	75 f7                	jne    400010ba <strlen+0x10>
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010c3:	5d                   	pop    %ebp
400010c4:	c3                   	ret    

400010c5 <strcpy>:
        },
        {   /* 1 Table: With shift */
400010c5:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010c6:	31 d2                	xor    %edx,%edx
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400010c8:	89 e5                	mov    %esp,%ebp
400010ca:	56                   	push   %esi
400010cb:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010cc:	31 c9                	xor    %ecx,%ecx
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
400010ce:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400010d1:	8b 45 08             	mov    0x8(%ebp),%eax
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010d4:	85 db                	test   %ebx,%ebx
400010d6:	75 03                	jne    400010db <strcpy+0x16>
400010d8:	eb 09                	jmp    400010e3 <strcpy+0x1e>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400010da:	42                   	inc    %edx
400010db:	89 d1                	mov    %edx,%ecx
400010dd:	80 3c 13 00          	cmpb   $0x0,(%ebx,%edx,1)
400010e1:	75 f7                	jne    400010da <strcpy+0x15>
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
400010e3:	89 ce                	mov    %ecx,%esi
400010e5:	46                   	inc    %esi
400010e6:	74 0c                	je     400010f4 <strcpy+0x2f>
400010e8:	31 d2                	xor    %edx,%edx
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400010ea:	8a 0c 13             	mov    (%ebx,%edx,1),%cl
400010ed:	88 0c 10             	mov    %cl,(%eax,%edx,1)
400010f0:	42                   	inc    %edx
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400010f1:	4e                   	dec    %esi
400010f2:	75 f6                	jne    400010ea <strcpy+0x25>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        },
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
400010f4:	5b                   	pop    %ebx
400010f5:	5e                   	pop    %esi
400010f6:	5d                   	pop    %ebp
400010f7:	c3                   	ret    

400010f8 <strtoknc>:

uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
400010f8:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400010f9:	31 c0                	xor    %eax,%eax

uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
400010fb:	89 e5                	mov    %esp,%ebp
400010fd:	57                   	push   %edi
400010fe:	56                   	push   %esi
400010ff:	53                   	push   %ebx
40001100:	83 ec 04             	sub    $0x4,%esp
40001103:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40001106:	8b 4d 08             	mov    0x8(%ebp),%ecx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
40001109:	85 db                	test   %ebx,%ebx
4000110b:	75 06                	jne    40001113 <strtoknc+0x1b>
4000110d:	e9 83 00 00 00       	jmp    40001195 <strtoknc+0x9d>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001112:	40                   	inc    %eax
40001113:	89 c7                	mov    %eax,%edi
40001115:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
40001119:	75 f7                	jne    40001112 <strtoknc+0x1a>
static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
4000111b:	85 c0                	test   %eax,%eax
4000111d:	74 76                	je     40001195 <strtoknc+0x9d>
        case 0:
            keycode = sc_to_kc[0][scancode];
            break;

4000111f:	85 c9                	test   %ecx,%ecx
40001121:	75 0b                	jne    4000112e <strtoknc+0x36>
40001123:	83 3d 14 42 00 40 00 	cmpl   $0x0,0x40004214
4000112a:	75 08                	jne    40001134 <strtoknc+0x3c>
4000112c:	eb 67                	jmp    40001195 <strtoknc+0x9d>
        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

4000112e:	89 0d 14 42 00 40    	mov    %ecx,0x40004214
        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
40001134:	a1 14 42 00 40       	mov    0x40004214,%eax
40001139:	31 c9                	xor    %ecx,%ecx
                case 0x451D:
                    keycode = 119;
4000113b:	eb 0b                	jmp    40001148 <strtoknc+0x50>
                    break;
4000113d:	8a 10                	mov    (%eax),%dl
4000113f:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
40001142:	75 03                	jne    40001147 <strtoknc+0x4f>

40001144:	40                   	inc    %eax
                default:
40001145:	eb 05                	jmp    4000114c <strtoknc+0x54>
        // e1-Scancodes
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
40001147:	41                   	inc    %ecx
40001148:	39 f9                	cmp    %edi,%ecx
4000114a:	7c f1                	jl     4000113d <strtoknc+0x45>

                default:
                    keycode = 0x0;
            };
            break;
    }
4000114c:	39 f9                	cmp    %edi,%ecx
4000114e:	75 e9                	jne    40001139 <strtoknc+0x41>

40001150:	a3 14 42 00 40       	mov    %eax,0x40004214
    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
    }

    return keycode;
}
40001155:	80 38 00             	cmpb   $0x0,(%eax)
40001158:	75 28                	jne    40001182 <strtoknc+0x8a>

4000115a:	c7 05 14 42 00 40 00 	movl   $0x0,0x40004214
40001161:	00 00 00 
40001164:	eb 2f                	jmp    40001195 <strtoknc+0x9d>
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

    return kc_to_char[index][keycode];
40001166:	8a 55 f3             	mov    -0xd(%ebp),%dl
40001169:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
4000116c:	75 05                	jne    40001173 <strtoknc+0x7b>
}
4000116e:	c6 06 00             	movb   $0x0,(%esi)

40001171:	eb 05                	jmp    40001178 <strtoknc+0x80>
static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

40001173:	41                   	inc    %ecx
40001174:	39 f9                	cmp    %edi,%ecx
40001176:	7c ee                	jl     40001166 <strtoknc+0x6e>
}

static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
40001178:	ff 05 14 42 00 40    	incl   0x40004214
        }
4000117e:	39 f9                	cmp    %edi,%ecx
40001180:	7c 15                	jl     40001197 <strtoknc+0x9f>

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
40001182:	8b 35 14 42 00 40    	mov    0x40004214,%esi
40001188:	8a 16                	mov    (%esi),%dl
4000118a:	88 55 f3             	mov    %dl,-0xd(%ebp)
4000118d:	84 d2                	test   %dl,%dl
4000118f:	74 06                	je     40001197 <strtoknc+0x9f>
40001191:	31 c9                	xor    %ecx,%ecx
40001193:	eb df                	jmp    40001174 <strtoknc+0x7c>
40001195:	31 c0                	xor    %eax,%eax
        }

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
40001197:	5a                   	pop    %edx
40001198:	5b                   	pop    %ebx
40001199:	5e                   	pop    %esi
4000119a:	5f                   	pop    %edi
4000119b:	5d                   	pop    %ebp
4000119c:	c3                   	ret    

4000119d <strclone>:
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
4000119d:	55                   	push   %ebp
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
4000119e:	31 c0                	xor    %eax,%eax
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400011a0:	89 e5                	mov    %esp,%ebp
400011a2:	56                   	push   %esi
400011a3:	53                   	push   %ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400011a4:	31 d2                	xor    %edx,%edx
        {   /* 1 Table: With shift */
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
400011a6:	8b 5d 08             	mov    0x8(%ebp),%ebx
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400011a9:	85 db                	test   %ebx,%ebx
400011ab:	75 03                	jne    400011b0 <strclone+0x13>
400011ad:	eb 09                	jmp    400011b8 <strclone+0x1b>
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400011af:	40                   	inc    %eax
400011b0:	89 c2                	mov    %eax,%edx
400011b2:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
400011b6:	75 f7                	jne    400011af <strclone+0x12>
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
400011b8:	83 ec 0c             	sub    $0xc,%esp
400011bb:	42                   	inc    %edx
400011bc:	52                   	push   %edx
400011bd:	e8 af 01 00 00       	call   40001371 <malloc>
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
400011c2:	59                   	pop    %ecx
            /* 0x00 */  0 , '^', '!', '"', 000, '$', '%', '&', //000 = § TODO find out ISO-8859-1 code
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
400011c3:	89 c6                	mov    %eax,%esi
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
400011c5:	58                   	pop    %eax
400011c6:	53                   	push   %ebx
400011c7:	56                   	push   %esi
400011c8:	e8 f8 fe ff ff       	call   400010c5 <strcpy>
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
400011cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
400011d0:	89 f0                	mov    %esi,%eax
400011d2:	5b                   	pop    %ebx
400011d3:	5e                   	pop    %esi
400011d4:	5d                   	pop    %ebp
400011d5:	c3                   	ret    

400011d6 <strtok>:
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400011d6:	55                   	push   %ebp
400011d7:	89 e5                	mov    %esp,%ebp
400011d9:	56                   	push   %esi
400011da:	53                   	push   %ebx
400011db:	8b 75 08             	mov    0x8(%ebp),%esi
400011de:	8b 5d 0c             	mov    0xc(%ebp),%ebx
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400011e1:	85 f6                	test   %esi,%esi
400011e3:	74 2e                	je     40001213 <strtok+0x3d>
        }
400011e5:	a1 18 42 00 40       	mov    0x40004218,%eax
400011ea:	85 c0                	test   %eax,%eax
400011ec:	74 0c                	je     400011fa <strtok+0x24>
};
400011ee:	83 ec 0c             	sub    $0xc,%esp
400011f1:	50                   	push   %eax
400011f2:	e8 31 00 00 00       	call   40001228 <free>
400011f7:	83 c4 10             	add    $0x10,%esp

#define KF_PRESSED (1 << 0)
400011fa:	83 ec 0c             	sub    $0xc,%esp
400011fd:	56                   	push   %esi
400011fe:	e8 9a ff ff ff       	call   4000119d <strclone>

40001203:	83 c4 10             	add    $0x10,%esp
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)
40001206:	a3 18 42 00 40       	mov    %eax,0x40004218

4000120b:	89 5d 0c             	mov    %ebx,0xc(%ebp)
4000120e:	89 45 08             	mov    %eax,0x8(%ebp)
40001211:	eb 0a                	jmp    4000121d <strtok+0x47>
uint32_t key_flags[256];

40001213:	89 5d 0c             	mov    %ebx,0xc(%ebp)
40001216:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
HANDLE charout = 0;
4000121d:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001220:	5b                   	pop    %ebx
40001221:	5e                   	pop    %esi
40001222:	5d                   	pop    %ebp
};

#define KF_PRESSED (1 << 0)

uint32_t key_flags[256];

40001223:	e9 d0 fe ff ff       	jmp    400010f8 <strtoknc>

40001228 <free>:
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
40001228:	55                   	push   %ebp
40001229:	89 e5                	mov    %esp,%ebp
4000122b:	57                   	push   %edi
4000122c:	56                   	push   %esi
4000122d:	53                   	push   %ebx
4000122e:	83 ec 08             	sub    $0x8,%esp
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
40001231:	8b 15 20 42 00 40    	mov    0x40004220,%edx
        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
40001237:	8b 4d 08             	mov    0x8(%ebp),%ecx
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
4000123a:	89 d0                	mov    %edx,%eax
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
4000123c:	e9 b8 00 00 00       	jmp    400012f9 <free+0xd1>
        e1_prev = scancode;
40001241:	3b 48 04             	cmp    0x4(%eax),%ecx
40001244:	0f 85 ac 00 00 00    	jne    400012f6 <free+0xce>
4000124a:	31 c9                	xor    %ecx,%ecx
4000124c:	eb 23                	jmp    40001271 <free+0x49>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000124e:	39 c2                	cmp    %eax,%edx
40001250:	75 1a                	jne    4000126c <free+0x44>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001252:	85 c9                	test   %ecx,%ecx
40001254:	8b 50 08             	mov    0x8(%eax),%edx
40001257:	75 0e                	jne    40001267 <free+0x3f>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001259:	89 15 20 42 00 40    	mov    %edx,0x40004220
4000125f:	8b 0d 24 42 00 40    	mov    0x40004224,%ecx
40001265:	eb 10                	jmp    40001277 <free+0x4f>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
40001267:	89 51 08             	mov    %edx,0x8(%ecx)
4000126a:	eb f3                	jmp    4000125f <free+0x37>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
4000126c:	89 d1                	mov    %edx,%ecx
4000126e:	8b 52 08             	mov    0x8(%edx),%edx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001271:	85 d2                	test   %edx,%edx
40001273:	75 d9                	jne    4000124e <free+0x26>
40001275:	eb e8                	jmp    4000125f <free+0x37>
40001277:	89 ca                	mov    %ecx,%edx
40001279:	eb 6d                	jmp    400012e8 <free+0xc0>
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000127b:	8b 5a 04             	mov    0x4(%edx),%ebx
4000127e:	8b 32                	mov    (%edx),%esi
40001280:	8b 78 04             	mov    0x4(%eax),%edi
40001283:	89 7d ec             	mov    %edi,-0x14(%ebp)
40001286:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
40001289:	89 7d f0             	mov    %edi,-0x10(%ebp)
4000128c:	8b 7d ec             	mov    -0x14(%ebp),%edi
4000128f:	39 7d f0             	cmp    %edi,-0x10(%ebp)
40001292:	75 18                	jne    400012ac <free+0x84>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
40001294:	89 58 04             	mov    %ebx,0x4(%eax)
40001297:	31 f6                	xor    %esi,%esi
40001299:	89 cb                	mov    %ecx,%ebx
4000129b:	eb 09                	jmp    400012a6 <free+0x7e>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000129d:	39 d3                	cmp    %edx,%ebx
4000129f:	74 29                	je     400012ca <free+0xa2>
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400012a1:	89 de                	mov    %ebx,%esi
400012a3:	8b 5b 08             	mov    0x8(%ebx),%ebx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400012a6:	85 db                	test   %ebx,%ebx
400012a8:	75 f3                	jne    4000129d <free+0x75>
400012aa:	eb cb                	jmp    40001277 <free+0x4f>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400012ac:	8b 38                	mov    (%eax),%edi
400012ae:	89 7d f0             	mov    %edi,-0x10(%ebp)
400012b1:	8b 7d ec             	mov    -0x14(%ebp),%edi
400012b4:	03 7d f0             	add    -0x10(%ebp),%edi
400012b7:	39 fb                	cmp    %edi,%ebx
400012b9:	75 2a                	jne    400012e5 <free+0xbd>
            /* 0x70 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
400012bb:	03 75 f0             	add    -0x10(%ebp),%esi
400012be:	89 cb                	mov    %ecx,%ebx
400012c0:	89 30                	mov    %esi,(%eax)
400012c2:	31 f6                	xor    %esi,%esi
400012c4:	eb 19                	jmp    400012df <free+0xb7>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400012c6:	39 d3                	cmp    %edx,%ebx
400012c8:	75 10                	jne    400012da <free+0xb2>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
400012ca:	85 f6                	test   %esi,%esi
400012cc:	8b 53 08             	mov    0x8(%ebx),%edx
400012cf:	75 04                	jne    400012d5 <free+0xad>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400012d1:	89 d1                	mov    %edx,%ecx
400012d3:	eb a2                	jmp    40001277 <free+0x4f>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
400012d5:	89 56 08             	mov    %edx,0x8(%esi)
400012d8:	eb 9d                	jmp    40001277 <free+0x4f>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400012da:	89 de                	mov    %ebx,%esi
400012dc:	8b 5b 08             	mov    0x8(%ebx),%ebx
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400012df:	85 db                	test   %ebx,%ebx
400012e1:	75 e3                	jne    400012c6 <free+0x9e>
400012e3:	eb 92                	jmp    40001277 <free+0x4f>
            /* 0x78 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
        }
};

#define KF_PRESSED (1 << 0)

400012e5:	8b 52 08             	mov    0x8(%edx),%edx
            /* 0x08 */ '/', '(', ')', '=', '?', '`',  8 ,  9 ,
            /* 0x10 */ 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I',
            /* 0x18 */ 'O', 'P', 252, '*','\n',  0 , 'A', 'S', //252 = ü TODO change to upper case
            /* 0x20 */ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 246, //246 = ö
            /* 0x28 */ 228,'\'',  0 , '>', 'Y', 'X', 'C', 'V', //228 = ä
            /* 0x30 */ 'B', 'N', 'M', ';', ':', '_',  0 , '*',
400012e8:	85 d2                	test   %edx,%edx
400012ea:	75 8f                	jne    4000127b <free+0x53>
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400012ec:	89 48 08             	mov    %ecx,0x8(%eax)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400012ef:	a3 24 42 00 40       	mov    %eax,0x40004224
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
        e1_code++;
    } else if (scancode == 0xE0) {
400012f4:	eb 0b                	jmp    40001301 <free+0xd9>
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
400012f6:	8b 40 08             	mov    0x8(%eax),%eax
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
        keycode = translate_scancode(2, e1_prev);
        e1_code = 0;
    } else if (e1_code == 1) {
        // Erstes Byte fuer e1-Scancode
400012f9:	85 c0                	test   %eax,%eax
400012fb:	0f 85 40 ff ff ff    	jne    40001241 <free+0x19>
    } else if (scancode == 0xE0) {
        // Anfang eines e0-Codes
        e0_code = 1;
    } else if (scancode == 0xE1) {
        // Anfang eines e1-Codes
        e1_code = 1;
40001301:	58                   	pop    %eax
40001302:	5a                   	pop    %edx
40001303:	5b                   	pop    %ebx
40001304:	5e                   	pop    %esi
40001305:	5f                   	pop    %edi
40001306:	5d                   	pop    %ebp
40001307:	c3                   	ret    

40001308 <pop_unused_node>:
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
40001308:	55                   	push   %ebp
40001309:	89 e5                	mov    %esp,%ebp
4000130b:	53                   	push   %ebx
4000130c:	83 ec 04             	sub    $0x4,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000130f:	a1 1c 42 00 40       	mov    0x4000421c,%eax
40001314:	eb 45                	jmp    4000135b <pop_unused_node+0x53>
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40001316:	83 ec 0c             	sub    $0xc,%esp
40001319:	6a 01                	push   $0x1
4000131b:	e8 5b 02 00 00       	call   4000157b <vmm_alloc_cont>

40001320:	83 c4 0c             	add    $0xc,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
40001323:	89 c3                	mov    %eax,%ebx

40001325:	68 00 10 00 00       	push   $0x1000
4000132a:	6a 00                	push   $0x0
4000132c:	50                   	push   %eax
4000132d:	e8 a6 fc ff ff       	call   40000fd8 <memset>
40001332:	8b 15 1c 42 00 40    	mov    0x4000421c,%edx
40001338:	8d 43 0c             	lea    0xc(%ebx),%eax
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
4000133b:	8d 8b fc 0f 00 00    	lea    0xffc(%ebx),%ecx
40001341:	83 c4 10             	add    $0x10,%esp
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001344:	89 50 08             	mov    %edx,0x8(%eax)
40001347:	89 c2                	mov    %eax,%edx
40001349:	83 c0 0c             	add    $0xc,%eax
         00,  00,  00,  00,  00,  00,  00,  00
    },
};

static char kc_to_char[][128] = {
        {   /* 0 Table: No special key */
4000134c:	39 c8                	cmp    %ecx,%eax
4000134e:	75 f4                	jne    40001344 <pop_unused_node+0x3c>
40001350:	8d 83 f0 0f 00 00    	lea    0xff0(%ebx),%eax
40001356:	a3 1c 42 00 40       	mov    %eax,0x4000421c
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000135b:	85 c0                	test   %eax,%eax
4000135d:	74 b7                	je     40001316 <pop_unused_node+0xe>
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
4000135f:	8b 50 08             	mov    0x8(%eax),%edx
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
40001362:	85 c0                	test   %eax,%eax
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
40001364:	89 15 1c 42 00 40    	mov    %edx,0x4000421c
            /* 0x10 */ 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i',
            /* 0x18 */ 'o', 'p', 252, '+','\n',  0 , 'a', 's', //252 = ü
            /* 0x20 */ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 246, //246 = ö
            /* 0x28 */ 228, '#',  0 , '<', 'y', 'x', 'c', 'v', //228 = ä
            /* 0x30 */ 'b', 'n', 'm', ',', '.', '-',  0 , '*',
            /* 0x38 */  0 , ' ',  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000136a:	74 aa                	je     40001316 <pop_unused_node+0xe>
            /* 0x40 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 , '7',
            /* 0x48 */ '8', '9', '-', '4', '5', '6', '+', '1',
            /* 0x50 */ '2', '3', '0', '.',  0 ,  0 ,  0 ,  0 ,
            /* 0x58 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x60 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
            /* 0x68 */  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,
4000136c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000136f:	c9                   	leave  
40001370:	c3                   	ret    

40001371 <malloc>:
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
40001371:	55                   	push   %ebp
40001372:	89 e5                	mov    %esp,%ebp
40001374:	57                   	push   %edi
40001375:	56                   	push   %esi
40001376:	53                   	push   %ebx
40001377:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t keycode = 0;

4000137a:	a1 24 42 00 40       	mov    0x40004224,%eax
uint32_t key_flags[256];

HANDLE charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
4000137f:	8b 75 08             	mov    0x8(%ebp),%esi
    uint8_t keycode = 0;

40001382:	89 c3                	mov    %eax,%ebx
    switch (set) {
        // Normal scancodes
40001384:	eb 07                	jmp    4000138d <malloc+0x1c>
        case 0:
40001386:	39 33                	cmp    %esi,(%ebx)
40001388:	73 0c                	jae    40001396 <malloc+0x25>
            keycode = sc_to_kc[0][scancode];
            break;

        // e0-Scancodes
4000138a:	8b 5b 08             	mov    0x8(%ebx),%ebx
static uint8_t translate_scancode(int set, uint16_t scancode)
{
    uint8_t keycode = 0;

    switch (set) {
        // Normal scancodes
4000138d:	85 db                	test   %ebx,%ebx
4000138f:	75 f5                	jne    40001386 <malloc+0x15>
40001391:	e9 93 00 00 00       	jmp    40001429 <malloc+0xb8>
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
40001396:	8b 3b                	mov    (%ebx),%edi
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

40001398:	31 d2                	xor    %edx,%edx
}

static char getcharfromkc(uint8_t keycode) {
    uint32_t index = 0;

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
4000139a:	29 f7                	sub    %esi,%edi
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT

4000139c:	89 33                	mov    %esi,(%ebx)
4000139e:	eb 4b                	jmp    400013eb <malloc+0x7a>

                default:
                    keycode = 0x0;
            };
            break;
    }
400013a0:	e8 63 ff ff ff       	call   40001308 <pop_unused_node>

    if (keycode == 0) {
400013a5:	8b 13                	mov    (%ebx),%edx
400013a7:	03 53 04             	add    0x4(%ebx),%edx
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
400013aa:	29 f7                	sub    %esi,%edi
                    keycode = 0x0;
            };
            break;
    }

    if (keycode == 0) {
400013ac:	89 50 04             	mov    %edx,0x4(%eax)
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013af:	8b 15 24 42 00 40    	mov    0x40004224,%edx
400013b5:	89 50 08             	mov    %edx,0x8(%eax)
            };
            break;
    }

    if (keycode == 0) {
        printf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
400013b8:	89 38                	mov    %edi,(%eax)

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013ba:	a3 24 42 00 40       	mov    %eax,0x40004224
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013bf:	a1 20 42 00 40       	mov    0x40004220,%eax
400013c4:	89 43 08             	mov    %eax,0x8(%ebx)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013c7:	89 1d 20 42 00 40    	mov    %ebx,0x40004220
400013cd:	eb 4f                	jmp    4000141e <malloc+0xad>
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400013cf:	39 d8                	cmp    %ebx,%eax
400013d1:	75 13                	jne    400013e6 <malloc+0x75>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
400013d3:	85 d2                	test   %edx,%edx
400013d5:	8b 43 08             	mov    0x8(%ebx),%eax
400013d8:	75 07                	jne    400013e1 <malloc+0x70>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
400013da:	a3 24 42 00 40       	mov    %eax,0x40004224
400013df:	eb 0e                	jmp    400013ef <malloc+0x7e>
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
400013e1:	89 42 08             	mov    %eax,0x8(%edx)
400013e4:	eb 09                	jmp    400013ef <malloc+0x7e>
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
400013e6:	89 c2                	mov    %eax,%edx
400013e8:	8b 40 08             	mov    0x8(%eax),%eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
400013eb:	85 c0                	test   %eax,%eax
400013ed:	75 e0                	jne    400013cf <malloc+0x5e>
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013ef:	a1 20 42 00 40       	mov    0x40004220,%eax

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
400013f4:	85 ff                	test   %edi,%edi
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400013f6:	89 43 08             	mov    %eax,0x8(%ebx)
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
400013f9:	89 1d 20 42 00 40    	mov    %ebx,0x40004220

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
400013ff:	74 1d                	je     4000141e <malloc+0xad>
    do {
40001401:	e8 02 ff ff ff       	call   40001308 <pop_unused_node>
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }
40001406:	8b 13                	mov    (%ebx),%edx
40001408:	03 53 04             	add    0x4(%ebx),%edx
4000140b:	89 50 04             	mov    %edx,0x4(%eax)
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000140e:	8b 15 24 42 00 40    	mov    0x40004224,%edx
40001414:	89 50 08             	mov    %edx,0x8(%eax)
static void send_command(uint8_t command)
{
    do {
        while (port_in(PORTM_BYTE, 0x64) & 0x2) {
        }

40001417:	89 38                	mov    %edi,(%eax)

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
40001419:	a3 24 42 00 40       	mov    %eax,0x40004224

        port_out(PORTM_BYTE, 0x60, command);

        while ((port_in(PORTM_BYTE, 0x64) & 0x1) == 0) {
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
4000141e:	8b 43 04             	mov    0x4(%ebx),%eax
}

40001421:	8d 65 f4             	lea    -0xc(%ebp),%esp
40001424:	5b                   	pop    %ebx
40001425:	5e                   	pop    %esi
40001426:	5f                   	pop    %edi
40001427:	5d                   	pop    %ebp
40001428:	c3                   	ret    
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

        // e1-Scancodes
        case 2:
40001429:	89 f0                	mov    %esi,%eax

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
            break;

4000142b:	89 f7                	mov    %esi,%edi
4000142d:	c1 ef 0c             	shr    $0xc,%edi
        // e1-Scancodes
        case 2:
40001430:	25 ff 0f 00 00       	and    $0xfff,%eax
            switch (scancode) {
40001435:	83 f8 01             	cmp    $0x1,%eax
40001438:	83 df ff             	sbb    $0xffffffff,%edi
                // Pause
                case 0x451D:
4000143b:	83 ec 0c             	sub    $0xc,%esp
4000143e:	57                   	push   %edi
4000143f:	e8 37 01 00 00       	call   4000157b <vmm_alloc_cont>
                    break;

                default:
                    keycode = 0x0;
            };
            break;
40001444:	c1 e7 0c             	shl    $0xc,%edi
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
                    break;
40001447:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000144a:	e8 b9 fe ff ff       	call   40001308 <pop_unused_node>

                default:
4000144f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
                    keycode = 0x0;
            };
            break;
40001452:	83 c4 10             	add    $0x10,%esp
        case 2:
            switch (scancode) {
                // Pause
                case 0x451D:
                    keycode = 119;
                    break;
40001455:	89 c3                	mov    %eax,%ebx

                default:
40001457:	89 50 04             	mov    %edx,0x4(%eax)
                    keycode = 0x0;
4000145a:	89 30                	mov    %esi,(%eax)
            };
            break;
4000145c:	39 f7                	cmp    %esi,%edi
4000145e:	0f 86 5b ff ff ff    	jbe    400013bf <malloc+0x4e>
40001464:	e9 37 ff ff ff       	jmp    400013a0 <malloc+0x2f>

40001469 <realloc>:
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

40001469:	55                   	push   %ebp
4000146a:	89 e5                	mov    %esp,%ebp
4000146c:	56                   	push   %esi
4000146d:	53                   	push   %ebx
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
4000146e:	8b 1d 20 42 00 40    	mov    0x40004220,%ebx
    static uint16_t e1_prev = 0;

    if(!init_done) return;

    scancode = port_in(PORTM_BYTE, 0x60);

40001474:	8b 55 08             	mov    0x8(%ebp),%edx
40001477:	8b 45 0c             	mov    0xc(%ebp),%eax
    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
4000147a:	eb 3e                	jmp    400014ba <realloc+0x51>
        (e0_code || (scancode != 0xE0)))
4000147c:	3b 53 04             	cmp    0x4(%ebx),%edx
4000147f:	75 36                	jne    400014b7 <realloc+0x4e>
    {
40001481:	85 c0                	test   %eax,%eax
40001483:	75 0b                	jne    40001490 <realloc+0x27>
        break_code = 1;
40001485:	52                   	push   %edx
40001486:	31 f6                	xor    %esi,%esi
40001488:	e8 9b fd ff ff       	call   40001228 <free>
        scancode &= ~0x80;
4000148d:	5b                   	pop    %ebx
4000148e:	eb 30                	jmp    400014c0 <realloc+0x57>
    }

40001490:	83 ec 0c             	sub    $0xc,%esp
40001493:	50                   	push   %eax
40001494:	e8 d8 fe ff ff       	call   40001371 <malloc>
    if (e0_code) {
40001499:	83 c4 0c             	add    $0xc,%esp
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
        scancode &= ~0x80;
    }

4000149c:	89 c6                	mov    %eax,%esi
    if (e0_code) {
4000149e:	ff 33                	pushl  (%ebx)
400014a0:	ff 73 04             	pushl  0x4(%ebx)
400014a3:	50                   	push   %eax
400014a4:	e8 4b fb ff ff       	call   40000ff4 <memcpy>
        // Fake shift abfangen und ignorieren
400014a9:	59                   	pop    %ecx
400014aa:	ff 73 04             	pushl  0x4(%ebx)
400014ad:	e8 76 fd ff ff       	call   40001228 <free>
        if ((scancode == 0x2A) || (scancode == 0x36)) {
            e0_code = 0;
400014b2:	83 c4 10             	add    $0x10,%esp
400014b5:	eb 09                	jmp    400014c0 <realloc+0x57>
            return;
        }

        keycode = translate_scancode(1, scancode);
400014b7:	8b 5b 08             	mov    0x8(%ebx),%ebx
    scancode = port_in(PORTM_BYTE, 0x60);

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
        (e1_code || (scancode != 0xE1)) &&
400014ba:	85 db                	test   %ebx,%ebx
400014bc:	75 be                	jne    4000147c <realloc+0x13>
400014be:	31 f6                	xor    %esi,%esi
        }

        keycode = translate_scancode(1, scancode);
        e0_code = 0;
    } else if (e1_code == 2) {
        // Fertiger e1-Scancode
400014c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
400014c3:	89 f0                	mov    %esi,%eax
400014c5:	5b                   	pop    %ebx
400014c6:	5e                   	pop    %esi
400014c7:	5d                   	pop    %ebp
400014c8:	c3                   	ret    

400014c9 <calloc>:
        }
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
400014c9:	55                   	push   %ebp
400014ca:	89 e5                	mov    %esp,%ebp
400014cc:	56                   	push   %esi
400014cd:	53                   	push   %ebx
400014ce:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    uint8_t keycode = 0;
    int break_code = 0;
400014d1:	83 ec 0c             	sub    $0xc,%esp
    } while (port_in(PORTM_BYTE, 0x60) == 0xfe);
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
400014d4:	0f af 5d 08          	imul   0x8(%ebp),%ebx
    int break_code = 0;
400014d8:	53                   	push   %ebx
400014d9:	e8 93 fe ff ff       	call   40001371 <malloc>

    static int      e0_code = 0;
400014de:	83 c4 10             	add    $0x10,%esp
}

void irq_handler(uint32_t irq) {
    uint8_t scancode;
    uint8_t keycode = 0;
    int break_code = 0;
400014e1:	89 c6                	mov    %eax,%esi

    static int      e0_code = 0;
400014e3:	85 c0                	test   %eax,%eax
400014e5:	74 0d                	je     400014f4 <calloc+0x2b>
    static int      e1_code = 0;
400014e7:	50                   	push   %eax
400014e8:	53                   	push   %ebx
400014e9:	6a 00                	push   $0x0
400014eb:	56                   	push   %esi
400014ec:	e8 e7 fa ff ff       	call   40000fd8 <memset>
400014f1:	83 c4 10             	add    $0x10,%esp
    static uint16_t e1_prev = 0;

    if(!init_done) return;

400014f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
400014f7:	89 f0                	mov    %esi,%eax
400014f9:	5b                   	pop    %ebx
400014fa:	5e                   	pop    %esi
400014fb:	5d                   	pop    %ebp
400014fc:	c3                   	ret    
400014fd:	00 00                	add    %al,(%eax)
	...

40001500 <print_memstat>:
    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001500:	55                   	push   %ebp
40001501:	89 e5                	mov    %esp,%ebp
40001503:	83 ec 34             	sub    $0x34,%esp
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
40001506:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001509:	c7 45 e0 cd 00 00 00 	movl   $0xcd,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00
    },
40001510:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00, 102, 103, 104,  00, 105,  00, 106,  00, 107,
        108, 109, 110, 111,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001511:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40001518:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000151f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001526:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000152d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00
    },
40001534:	e8 37 01 00 00       	call   40001670 <syscall>
40001539:	83 c4 10             	add    $0x10,%esp
};
4000153c:	c9                   	leave  
4000153d:	c3                   	ret    

4000153e <vmm_free>:
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
4000153e:	55                   	push   %ebp
4000153f:	89 e5                	mov    %esp,%ebp
40001541:	83 ec 34             	sub    $0x34,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
40001544:	8b 45 08             	mov    0x8(%ebp),%eax
40001547:	c7 45 e0 cc 00 00 00 	movl   $0xcc,-0x20(%ebp)
4000154e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001551:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001554:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
40001555:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000155c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001563:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000156a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    {
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001571:	e8 fa 00 00 00       	call   40001670 <syscall>
40001576:	83 c4 10             	add    $0x10,%esp
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001579:	c9                   	leave  
4000157a:	c3                   	ret    

4000157b <vmm_alloc_cont>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
4000157b:	55                   	push   %ebp
4000157c:	89 e5                	mov    %esp,%ebp
4000157e:	83 ec 34             	sub    $0x34,%esp
 
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
40001581:	8b 45 08             	mov    0x8(%ebp),%eax
40001584:	c7 45 e0 cb 00 00 00 	movl   $0xcb,-0x20(%ebp)
4000158b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
4000158e:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001591:	50                   	push   %eax
 
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
40001592:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001599:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400015a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400015a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
400015ae:	e8 bd 00 00 00       	call   40001670 <syscall>
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
400015b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
400015b6:	c9                   	leave  
400015b7:	c3                   	ret    

400015b8 <port_in>:
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  99,  00,  00, 100,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
400015b8:	55                   	push   %ebp
400015b9:	89 e5                	mov    %esp,%ebp
400015bb:	83 ec 34             	sub    $0x34,%esp
400015be:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400015c2:	8b 55 08             	mov    0x8(%ebp),%edx
400015c5:	89 45 e8             	mov    %eax,-0x18(%ebp)

static char kc_to_char[][128] = {
400015c8:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400015cb:	c7 45 e0 34 00 00 00 	movl   $0x34,-0x20(%ebp)

static char kc_to_char[][128] = {
400015d2:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },
};
400015d3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
400015d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400015dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400015e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

static char kc_to_char[][128] = {
400015eb:	e8 80 00 00 00       	call   40001670 <syscall>
        {   /* 0 Table: No special key */
            /* 0x00 */  0 ,  0 , '1', '2', '3', '4', '5', '6',
            /* 0x08 */ '7', '8', '9', '0', '-', '`',  8 ,  9 ,
400015f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400015f3:	c9                   	leave  
400015f4:	c3                   	ret    

400015f5 <port_out>:
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
400015f5:	55                   	push   %ebp
400015f6:	89 e5                	mov    %esp,%ebp
400015f8:	83 ec 34             	sub    $0x34,%esp
400015fb:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
400015ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
40001602:	8b 45 10             	mov    0x10(%ebp),%eax
40001605:	8b 55 08             	mov    0x8(%ebp),%edx
40001608:	89 45 ec             	mov    %eax,-0x14(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000160b:	8d 45 e0             	lea    -0x20(%ebp),%eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
4000160e:	c7 45 e0 33 00 00 00 	movl   $0x33,-0x20(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001615:	50                   	push   %eax
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00
    },

    // Extended0-Scancodes (werden mit e0 eingeleitet)
    {
40001616:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40001619:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001620:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
40001627:	e8 44 00 00 00       	call   40001670 <syscall>
         00,  00,  00,  00,  00,  00,  00,  00,  96,  97,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
         00,  00,  00,  00,  00,  00,  00,  00,  00,  00,
4000162c:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000162f:	c9                   	leave  
40001630:	c3                   	ret    

40001631 <require_port>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
40001631:	55                   	push   %ebp
40001632:	89 e5                	mov    %esp,%ebp
40001634:	83 ec 34             	sub    $0x34,%esp
40001637:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
4000163b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
4000163e:	8d 45 e0             	lea    -0x20(%ebp),%eax
40001641:	50                   	push   %eax
uint32_t init_done = 0;
static uint8_t sc_to_kc[][128] = {
    // Normale Scancodes
    {
          0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
         10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
40001642:	c7 45 e0 32 00 00 00 	movl   $0x32,-0x20(%ebp)
40001649:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001650:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001657:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000165e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
         20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
40001665:	e8 06 00 00 00       	call   40001670 <syscall>
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
4000166a:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000166d:	c9                   	leave  
4000166e:	c3                   	ret    
	...

40001670 <syscall>:
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
40001670:	55                   	push   %ebp
40001671:	89 e5                	mov    %esp,%ebp
40001673:	57                   	push   %edi
40001674:	56                   	push   %esi
40001675:	53                   	push   %ebx
40001676:	83 ec 10             	sub    $0x10,%esp
#include "process.h"
40001679:	8b 55 08             	mov    0x8(%ebp),%edx
4000167c:	8b 45 08             	mov    0x8(%ebp),%eax
4000167f:	8b 72 0c             	mov    0xc(%edx),%esi
40001682:	8b 00                	mov    (%eax),%eax
40001684:	89 75 e4             	mov    %esi,-0x1c(%ebp)
40001687:	8b 5a 04             	mov    0x4(%edx),%ebx
4000168a:	8b 4a 08             	mov    0x8(%edx),%ecx
4000168d:	8b 72 10             	mov    0x10(%edx),%esi
40001690:	8b 7a 14             	mov    0x14(%edx),%edi
40001693:	89 45 ec             	mov    %eax,-0x14(%ebp)
40001696:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40001699:	cd 30                	int    $0x30
4000169b:	89 55 e8             	mov    %edx,-0x18(%ebp)
4000169e:	8b 55 08             	mov    0x8(%ebp),%edx
400016a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
400016a4:	89 02                	mov    %eax,(%edx)
400016a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
400016a9:	89 5a 04             	mov    %ebx,0x4(%edx)
400016ac:	89 4a 08             	mov    %ecx,0x8(%edx)
400016af:	89 42 0c             	mov    %eax,0xc(%edx)
400016b2:	89 72 10             	mov    %esi,0x10(%edx)
400016b5:	89 7a 14             	mov    %edi,0x14(%edx)
         30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
         40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
         50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
         60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
         70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
         80,  81,  82,  84,  00,  00,  86,  87,  88,  00,
400016b8:	83 c4 10             	add    $0x10,%esp
400016bb:	5b                   	pop    %ebx
400016bc:	5e                   	pop    %esi
400016bd:	5f                   	pop    %edi
400016be:	5d                   	pop    %ebp
400016bf:	c3                   	ret    
