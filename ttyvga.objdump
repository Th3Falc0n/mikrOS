
initrfs/ibin/ttytovga:     file format elf32-i386


Disassembly of section .text:

40000000 <sendCommand>:

struct vga_command vgac = { .command = 0, .offset = 0, .value = 0 };

HANDLE vgaController;

void sendCommand(uint16_t c, uint16_t o, uint16_t v) {
40000000:	55                   	push   %ebp
40000001:	89 e5                	mov    %esp,%ebp
40000003:	53                   	push   %ebx
40000004:	57                   	push   %edi
40000005:	56                   	push   %esi
40000006:	83 ec 1c             	sub    $0x1c,%esp
40000009:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
4000000d:	66 89 c1             	mov    %ax,%cx
40000010:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
40000014:	66 89 c2             	mov    %ax,%dx
40000017:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
4000001b:	66 89 c6             	mov    %ax,%si
4000001e:	8d 05 00 50 00 40    	lea    0x40005000,%eax
40000024:	bf 06 00 00 00       	mov    $0x6,%edi
40000029:	66 89 75 f2          	mov    %si,-0xe(%ebp)
4000002d:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
40000031:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
    vgac.command = c;
40000035:	66 8b 4d f2          	mov    -0xe(%ebp),%cx
40000039:	66 89 0d 00 50 00 40 	mov    %cx,0x40005000
    vgac.offset = o;
40000040:	66 8b 4d f0          	mov    -0x10(%ebp),%cx
40000044:	66 89 0d 02 50 00 40 	mov    %cx,0x40005002
    vgac.value = v;
4000004b:	66 8b 4d ee          	mov    -0x12(%ebp),%cx
4000004f:	66 89 0d 04 50 00 40 	mov    %cx,0x40005004

    fwrite(vgaController, &vgac, sizeof(struct vga_command));
40000056:	8b 1d 20 50 00 40    	mov    0x40005020,%ebx
4000005c:	89 1c 24             	mov    %ebx,(%esp)
4000005f:	89 44 24 04          	mov    %eax,0x4(%esp)
40000063:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
4000006a:	00 
4000006b:	89 7d e8             	mov    %edi,-0x18(%ebp)
4000006e:	e8 4d 09 00 00       	call   400009c0 <fwrite>
}
40000073:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000076:	83 c4 1c             	add    $0x1c,%esp
40000079:	5e                   	pop    %esi
4000007a:	5f                   	pop    %edi
4000007b:	5b                   	pop    %ebx
4000007c:	5d                   	pop    %ebp
4000007d:	c3                   	ret    
4000007e:	66 90                	xchg   %ax,%ax

40000080 <main>:

int main(int argc, char* args[])
{
40000080:	55                   	push   %ebp
40000081:	89 e5                	mov    %esp,%ebp
40000083:	53                   	push   %ebx
40000084:	57                   	push   %edi
40000085:	56                   	push   %esi
40000086:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
4000008c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000008f:	8b 4d 08             	mov    0x8(%ebp),%ecx
40000092:	8d 15 9c 40 00 40    	lea    0x4000409c,%edx
40000098:	be 02 00 00 00       	mov    $0x2,%esi
4000009d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400000a4:	89 4d ec             	mov    %ecx,-0x14(%ebp)
400000a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    vgaController   = fopen("/dev/vga", FM_WRITE);
400000aa:	89 14 24             	mov    %edx,(%esp)
400000ad:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
400000b4:	00 
400000b5:	89 75 cc             	mov    %esi,-0x34(%ebp)
400000b8:	e8 63 08 00 00       	call   40000920 <fopen>
400000bd:	8d 0d a5 40 00 40    	lea    0x400040a5,%ecx
400000c3:	a3 20 50 00 40       	mov    %eax,0x40005020
    HANDLE fifoInpt = fmkfifo("/dev/tty0");
400000c8:	89 0c 24             	mov    %ecx,(%esp)
400000cb:	e8 80 0b 00 00       	call   40000c50 <fmkfifo>
400000d0:	8d 0d af 40 00 40    	lea    0x400040af,%ecx
400000d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    printf("vgaController: %x\n", vgaController);
400000d9:	a1 20 50 00 40       	mov    0x40005020,%eax
400000de:	89 0c 24             	mov    %ecx,(%esp)
400000e1:	89 44 24 04          	mov    %eax,0x4(%esp)
400000e5:	e8 56 10 00 00       	call   40001140 <printf>
400000ea:	8d 0d c2 40 00 40    	lea    0x400040c2,%ecx
    printf("fifoInpt: %x\n", fifoInpt);
400000f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400000f3:	89 0c 24             	mov    %ecx,(%esp)
400000f6:	89 54 24 04          	mov    %edx,0x4(%esp)
400000fa:	89 45 c8             	mov    %eax,-0x38(%ebp)
400000fd:	e8 3e 10 00 00       	call   40001140 <printf>
40000102:	b9 06 00 00 00       	mov    $0x6,%ecx

    struct vga_command* vgac = malloc(sizeof(struct vga_command));
40000107:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
4000010e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
40000111:	89 4d c0             	mov    %ecx,-0x40(%ebp)
40000114:	e8 17 19 00 00       	call   40001a30 <malloc>
40000119:	8d 0d a5 40 00 40    	lea    0x400040a5,%ecx
4000011f:	89 45 e0             	mov    %eax,-0x20(%ebp)

    setstdout("/dev/tty0");
40000122:	89 0c 24             	mov    %ecx,(%esp)
40000125:	e8 66 07 00 00       	call   40000890 <setstdout>
4000012a:	8d 0d a5 40 00 40    	lea    0x400040a5,%ecx
    setstderr("/dev/tty0");
40000130:	89 0c 24             	mov    %ecx,(%esp)
40000133:	89 45 bc             	mov    %eax,-0x44(%ebp)
40000136:	e8 b5 07 00 00       	call   400008f0 <setstderr>
4000013b:	8d 0d d0 40 00 40    	lea    0x400040d0,%ecx

    printf("[ttytovga] Switched to TTY to VGA (userspace terminal)\n");
40000141:	89 0c 24             	mov    %ecx,(%esp)
40000144:	89 45 b8             	mov    %eax,-0x48(%ebp)
40000147:	e8 f4 0f 00 00       	call   40001140 <printf>
4000014c:	b9 01 00 00 00       	mov    $0x1,%ecx
40000151:	ba 00 00 00 00       	mov    $0x0,%edx

    sendCommand(CMD_CLEAR, 0, 0);
40000156:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
4000015d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000164:	00 
40000165:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
4000016c:	00 
4000016d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
40000170:	89 4d b0             	mov    %ecx,-0x50(%ebp)
40000173:	89 55 ac             	mov    %edx,-0x54(%ebp)
40000176:	e8 85 fe ff ff       	call   40000000 <sendCommand>
4000017b:	8d 05 08 41 00 40    	lea    0x40004108,%eax
40000181:	b9 02 00 00 00       	mov    $0x2,%ecx

    HANDLE initCtrl = fopen("/var/cntrl/init", FM_WRITE);
40000186:	89 04 24             	mov    %eax,(%esp)
40000189:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
40000190:	00 
40000191:	89 4d a8             	mov    %ecx,-0x58(%ebp)
40000194:	e8 87 07 00 00       	call   40000920 <fopen>
40000199:	8d 4d db             	lea    -0x25(%ebp),%ecx
4000019c:	ba 01 00 00 00       	mov    $0x1,%edx
400001a1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    fwrite(initCtrl, &(char){'K'}, sizeof(char));
400001a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
400001a7:	c6 45 db 4b          	movb   $0x4b,-0x25(%ebp)
400001ab:	89 04 24             	mov    %eax,(%esp)
400001ae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400001b2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
400001b9:	00 
400001ba:	89 55 a4             	mov    %edx,-0x5c(%ebp)
400001bd:	e8 fe 07 00 00       	call   400009c0 <fwrite>
    fclose(initCtrl);
400001c2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400001c5:	89 0c 24             	mov    %ecx,(%esp)
400001c8:	89 45 a0             	mov    %eax,-0x60(%ebp)
400001cb:	e8 a0 07 00 00       	call   40000970 <fclose>

    char nchar = '\0';
400001d0:	c6 45 da 00          	movb   $0x0,-0x26(%ebp)
    char ochar = '\0';
400001d4:	c6 45 d9 00          	movb   $0x0,-0x27(%ebp)
400001d8:	89 45 9c             	mov    %eax,-0x64(%ebp)
400001db:	8d 45 da             	lea    -0x26(%ebp),%eax
400001de:	b9 01 00 00 00       	mov    $0x1,%ecx

    while(1) {
        fread(fifoInpt, &nchar, sizeof(char));
400001e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400001e6:	89 14 24             	mov    %edx,(%esp)
400001e9:	89 44 24 04          	mov    %eax,0x4(%esp)
400001ed:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
400001f4:	00 
400001f5:	89 4d 98             	mov    %ecx,-0x68(%ebp)
400001f8:	e8 63 09 00 00       	call   40000b60 <fread>
        ochar = nchar;
400001fd:	8a 5d da             	mov    -0x26(%ebp),%bl
40000200:	88 5d d9             	mov    %bl,-0x27(%ebp)

        if ((nchar == '\n') || (x > 79)) {
40000203:	0f be 4d da          	movsbl -0x26(%ebp),%ecx
40000207:	81 f9 0a 00 00 00    	cmp    $0xa,%ecx
4000020d:	89 45 94             	mov    %eax,-0x6c(%ebp)
40000210:	0f 84 10 00 00 00    	je     40000226 <main+0x1a6>
40000216:	81 3d 08 50 00 40 4f 	cmpl   $0x4f,0x40005008
4000021d:	00 00 00 
40000220:	0f 8e 19 00 00 00    	jle    4000023f <main+0x1bf>
            x = 0;
40000226:	c7 05 08 50 00 40 00 	movl   $0x0,0x40005008
4000022d:	00 00 00 
            y++;
40000230:	a1 0c 50 00 40       	mov    0x4000500c,%eax
40000235:	05 01 00 00 00       	add    $0x1,%eax
4000023a:	a3 0c 50 00 40       	mov    %eax,0x4000500c
        }

        if (y > 24) {
4000023f:	81 3d 0c 50 00 40 18 	cmpl   $0x18,0x4000500c
40000246:	00 00 00 
40000249:	0f 8e 3b 00 00 00    	jle    4000028a <main+0x20a>
4000024f:	b8 02 00 00 00       	mov    $0x2,%eax
40000254:	b9 00 00 00 00       	mov    $0x0,%ecx
            sendCommand(CMD_SCROLL, 0, 0);
40000259:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
40000260:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000267:	00 
40000268:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
4000026f:	00 
40000270:	89 45 90             	mov    %eax,-0x70(%ebp)
40000273:	89 4d 8c             	mov    %ecx,-0x74(%ebp)
40000276:	e8 85 fd ff ff       	call   40000000 <sendCommand>
            y--;
4000027b:	a1 0c 50 00 40       	mov    0x4000500c,%eax
40000280:	05 ff ff ff ff       	add    $0xffffffff,%eax
40000285:	a3 0c 50 00 40       	mov    %eax,0x4000500c
        }

        if (nchar == '\n') {
4000028a:	0f be 45 da          	movsbl -0x26(%ebp),%eax
4000028e:	3d 0a 00 00 00       	cmp    $0xa,%eax
40000293:	0f 85 0c 00 00 00    	jne    400002a5 <main+0x225>
            color = 0x09;
40000299:	c6 05 00 30 00 40 09 	movb   $0x9,0x40003000
            continue;
400002a0:	e9 36 ff ff ff       	jmp    400001db <main+0x15b>
        }

        if(nchar == 0x11) { //0x11 = SETCLR
400002a5:	0f be 45 da          	movsbl -0x26(%ebp),%eax
400002a9:	3d 11 00 00 00       	cmp    $0x11,%eax
400002ae:	0f 85 33 00 00 00    	jne    400002e7 <main+0x267>
400002b4:	8d 45 da             	lea    -0x26(%ebp),%eax
400002b7:	b9 01 00 00 00       	mov    $0x1,%ecx
            fread(fifoInpt, &nchar, sizeof(char));
400002bc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400002bf:	89 14 24             	mov    %edx,(%esp)
400002c2:	89 44 24 04          	mov    %eax,0x4(%esp)
400002c6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
400002cd:	00 
400002ce:	89 4d 88             	mov    %ecx,-0x78(%ebp)
400002d1:	e8 8a 08 00 00       	call   40000b60 <fread>
            color = nchar;
400002d6:	8a 5d da             	mov    -0x26(%ebp),%bl
400002d9:	88 1d 00 30 00 40    	mov    %bl,0x40003000
            continue;
400002df:	89 45 84             	mov    %eax,-0x7c(%ebp)
400002e2:	e9 f4 fe ff ff       	jmp    400001db <main+0x15b>
        }

        if(nchar == 8) { //8 = BACKSPACE
400002e7:	0f be 45 da          	movsbl -0x26(%ebp),%eax
400002eb:	3d 08 00 00 00       	cmp    $0x8,%eax
400002f0:	0f 85 4c 00 00 00    	jne    40000342 <main+0x2c2>
            if(x == 0) {
400002f6:	81 3d 08 50 00 40 00 	cmpl   $0x0,0x40005008
400002fd:	00 00 00 
40000300:	0f 85 1e 00 00 00    	jne    40000324 <main+0x2a4>
                y--;
40000306:	a1 0c 50 00 40       	mov    0x4000500c,%eax
4000030b:	05 ff ff ff ff       	add    $0xffffffff,%eax
40000310:	a3 0c 50 00 40       	mov    %eax,0x4000500c
                x = 79;
40000315:	c7 05 08 50 00 40 4f 	movl   $0x4f,0x40005008
4000031c:	00 00 00 
            }
4000031f:	e9 0f 00 00 00       	jmp    40000333 <main+0x2b3>
            else
            {
                x--;
40000324:	a1 08 50 00 40       	mov    0x40005008,%eax
40000329:	05 ff ff ff ff       	add    $0xffffffff,%eax
4000032e:	a3 08 50 00 40       	mov    %eax,0x40005008
            }
            ochar = ' ';
40000333:	c6 45 d9 20          	movb   $0x20,-0x27(%ebp)
            nchar = 0;
40000337:	c6 45 da 00          	movb   $0x0,-0x26(%ebp)
            color = 0x09;
4000033b:	c6 05 00 30 00 40 09 	movb   $0x9,0x40003000
40000342:	b8 00 00 00 00       	mov    $0x0,%eax
40000347:	8d 4d d6             	lea    -0x2a(%ebp),%ecx
        }

        uint16_t send = 0;
4000034a:	66 c7 45 d6 00 00    	movw   $0x0,-0x2a(%ebp)
        char* sndChr = (char*) &send;
40000350:	89 4d d0             	mov    %ecx,-0x30(%ebp)

        sndChr[0] = ochar;
40000353:	8a 55 d9             	mov    -0x27(%ebp),%dl
40000356:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40000359:	88 11                	mov    %dl,(%ecx)
        sndChr[1] = color;
4000035b:	8a 15 00 30 00 40    	mov    0x40003000,%dl
40000361:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40000364:	88 51 01             	mov    %dl,0x1(%ecx)

        color = 0x09;
40000367:	c6 05 00 30 00 40 09 	movb   $0x9,0x40003000

        sendCommand(CMD_SET, x + y * 80, send);
4000036e:	8b 0d 08 50 00 40    	mov    0x40005008,%ecx
40000374:	69 35 0c 50 00 40 50 	imul   $0x50,0x4000500c,%esi
4000037b:	00 00 00 
4000037e:	01 f1                	add    %esi,%ecx
40000380:	66 89 cf             	mov    %cx,%di
40000383:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
4000038a:	0f b7 cf             	movzwl %di,%ecx
4000038d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000391:	0f b7 4d d6          	movzwl -0x2a(%ebp),%ecx
40000395:	89 4c 24 08          	mov    %ecx,0x8(%esp)
40000399:	89 45 80             	mov    %eax,-0x80(%ebp)
4000039c:	e8 5f fc ff ff       	call   40000000 <sendCommand>

        if(nchar != 0) {
400003a1:	0f be 45 da          	movsbl -0x26(%ebp),%eax
400003a5:	3d 00 00 00 00       	cmp    $0x0,%eax
400003aa:	0f 84 0f 00 00 00    	je     400003bf <main+0x33f>
            x++;
400003b0:	a1 08 50 00 40       	mov    0x40005008,%eax
400003b5:	05 01 00 00 00       	add    $0x1,%eax
400003ba:	a3 08 50 00 40       	mov    %eax,0x40005008
        }
    }
400003bf:	e9 17 fe ff ff       	jmp    400001db <main+0x15b>
400003c4:	66 90                	xchg   %ax,%ax
400003c6:	66 90                	xchg   %ax,%ax
400003c8:	66 90                	xchg   %ax,%ax
400003ca:	66 90                	xchg   %ax,%ax
400003cc:	66 90                	xchg   %ax,%ax
400003ce:	66 90                	xchg   %ax,%ax

400003d0 <_start>:
    syscall(&state);

    return state.eax;
}

void _start() {
400003d0:	55                   	push   %ebp
400003d1:	89 e5                	mov    %esp,%ebp
  char** args = (char**) getargs();
400003d3:	83 ec 18             	sub    $0x18,%esp
400003d6:	e8 c5 03 00 00       	call   400007a0 <getargs>
400003db:	89 45 fc             	mov    %eax,-0x4(%ebp)

  int argc = 0;
400003de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

  if(args != 0) {
400003e5:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
400003ec:	0f 84 2d 00 00 00    	je     4000041f <_start+0x4f>
      while(args[argc] != 0) {
400003f2:	e9 00 00 00 00       	jmp    400003f7 <_start+0x27>
400003f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
400003fa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400003fd:	81 3c 81 00 00 00 00 	cmpl   $0x0,(%ecx,%eax,4)
40000404:	0f 84 10 00 00 00    	je     4000041a <_start+0x4a>
          argc++;
4000040a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000040d:	05 01 00 00 00       	add    $0x1,%eax
40000412:	89 45 f8             	mov    %eax,-0x8(%ebp)
      }
40000415:	e9 dd ff ff ff       	jmp    400003f7 <_start+0x27>
  }
4000041a:	e9 00 00 00 00       	jmp    4000041f <_start+0x4f>

  int result = main(argc, args);
4000041f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000422:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000425:	89 04 24             	mov    %eax,(%esp)
40000428:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000042c:	e8 4f fc ff ff       	call   40000080 <main>
40000431:	89 45 f4             	mov    %eax,-0xc(%ebp)

  exit(result);
40000434:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000437:	89 04 24             	mov    %eax,(%esp)
4000043a:	e8 01 00 00 00       	call   40000440 <exit>
4000043f:	90                   	nop

40000440 <exit>:
    syscall(&state);

    return;
}

void exit(int returncode) {
40000440:	55                   	push   %ebp
40000441:	89 e5                	mov    %esp,%ebp
40000443:	83 ec 28             	sub    $0x28,%esp
40000446:	8b 45 08             	mov    0x8(%ebp),%eax
40000449:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000044c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000044f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
40000456:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000459:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000045c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000463:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000046a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000471:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
40000478:	89 0c 24             	mov    %ecx,(%esp)
4000047b:	e8 f0 1c 00 00       	call   40002170 <syscall>
40000480:	8d 05 18 41 00 40    	lea    0x40004118,%eax

    while(1) {
      printf("error\n");
40000486:	89 04 24             	mov    %eax,(%esp)
40000489:	e8 b2 0c 00 00       	call   40001140 <printf>
    }
4000048e:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000491:	e9 ea ff ff ff       	jmp    40000480 <exit+0x40>
40000496:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
4000049d:	00 00 00 

400004a0 <yield>:
  int result = main(argc, args);

  exit(result);
}

void yield() {
400004a0:	55                   	push   %ebp
400004a1:	89 e5                	mov    %esp,%ebp
400004a3:	56                   	push   %esi
400004a4:	83 ec 34             	sub    $0x34,%esp
400004a7:	8d 45 e0             	lea    -0x20(%ebp),%eax
400004aa:	8d 0d 18 40 00 40    	lea    0x40004018,%ecx
400004b0:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
400004b5:	89 c6                	mov    %eax,%esi
400004b7:	89 34 24             	mov    %esi,(%esp)
400004ba:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400004be:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
400004c5:	00 
400004c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
400004c9:	89 55 d8             	mov    %edx,-0x28(%ebp)
400004cc:	e8 3f 10 00 00       	call   40001510 <memcpy>
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
400004d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
400004d4:	89 04 24             	mov    %eax,(%esp)
400004d7:	e8 94 1c 00 00       	call   40002170 <syscall>

    return;
400004dc:	83 c4 34             	add    $0x34,%esp
400004df:	5e                   	pop    %esi
400004e0:	5d                   	pop    %ebp
400004e1:	c3                   	ret    
400004e2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
400004e9:	1f 84 00 00 00 00 00 

400004f0 <getExecPath>:
    while(1) {
      printf("error\n");
    }
}

void getExecPath(char* dest) {
400004f0:	55                   	push   %ebp
400004f1:	89 e5                	mov    %esp,%ebp
400004f3:	83 ec 28             	sub    $0x28,%esp
400004f6:	8b 45 08             	mov    0x8(%ebp),%eax
400004f9:	8d 4d e0             	lea    -0x20(%ebp),%ecx
400004fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
400004ff:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
40000506:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000509:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000050c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000513:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000051a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000521:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
40000528:	89 0c 24             	mov    %ecx,(%esp)
4000052b:	e8 40 1c 00 00       	call   40002170 <syscall>
}
40000530:	83 c4 28             	add    $0x28,%esp
40000533:	5d                   	pop    %ebp
40000534:	c3                   	ret    
40000535:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
4000053c:	00 00 00 00 

40000540 <changeExecPath>:

int changeExecPath(char* path) {
40000540:	55                   	push   %ebp
40000541:	89 e5                	mov    %esp,%ebp
40000543:	83 ec 28             	sub    $0x28,%esp
40000546:	8b 45 08             	mov    0x8(%ebp),%eax
40000549:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000054c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000054f:	c7 45 e0 07 00 00 00 	movl   $0x7,-0x20(%ebp)
40000556:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000559:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000055c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000563:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000056a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000571:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
40000578:	89 0c 24             	mov    %ecx,(%esp)
4000057b:	e8 f0 1b 00 00       	call   40002170 <syscall>

    return state.eax;
40000580:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000583:	83 c4 28             	add    $0x28,%esp
40000586:	5d                   	pop    %ebp
40000587:	c3                   	ret    
40000588:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
4000058f:	00 

40000590 <cd>:
}

void cd(char* path) {
40000590:	55                   	push   %ebp
40000591:	89 e5                	mov    %esp,%ebp
40000593:	83 ec 18             	sub    $0x18,%esp
40000596:	8b 45 08             	mov    0x8(%ebp),%eax
40000599:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(!changeExecPath(path)) printexecerror(path, getLastVFSErr());
4000059c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000059f:	89 04 24             	mov    %eax,(%esp)
400005a2:	e8 99 ff ff ff       	call   40000540 <changeExecPath>
400005a7:	3d 00 00 00 00       	cmp    $0x0,%eax
400005ac:	0f 85 1a 00 00 00    	jne    400005cc <cd+0x3c>
400005b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
400005b5:	89 45 f8             	mov    %eax,-0x8(%ebp)
400005b8:	e8 33 02 00 00       	call   400007f0 <getLastVFSErr>
400005bd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400005c0:	89 0c 24             	mov    %ecx,(%esp)
400005c3:	89 44 24 04          	mov    %eax,0x4(%esp)
400005c7:	e8 14 00 00 00       	call   400005e0 <printexecerror>
}
400005cc:	83 c4 18             	add    $0x18,%esp
400005cf:	5d                   	pop    %ebp
400005d0:	c3                   	ret    
400005d1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
400005d8:	0f 1f 84 00 00 00 00 
400005df:	00 

400005e0 <printexecerror>:
    }

    return res;
}

void printexecerror(char* path, uint32_t code) {
400005e0:	55                   	push   %ebp
400005e1:	89 e5                	mov    %esp,%ebp
400005e3:	83 ec 38             	sub    $0x38,%esp
400005e6:	8b 45 0c             	mov    0xc(%ebp),%eax
400005e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
400005ec:	89 4d fc             	mov    %ecx,-0x4(%ebp)
400005ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
400005f2:	89 c1                	mov    %eax,%ecx
400005f4:	83 e9 05             	sub    $0x5,%ecx
    switch(code) {
400005f7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
400005fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
400005fd:	0f 87 ba 00 00 00    	ja     400006bd <printexecerror+0xdd>
40000603:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000606:	8b 0c 85 00 40 00 40 	mov    0x40004000(,%eax,4),%ecx
4000060d:	ff e1                	jmp    *%ecx
4000060f:	8d 05 1f 41 00 40    	lea    0x4000411f,%eax
    case PE_NO_ERROR:
        printf("%s: Unknown error", path);
40000615:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000618:	89 04 24             	mov    %eax,(%esp)
4000061b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000061f:	e8 1c 0b 00 00       	call   40001140 <printf>
        break;
40000624:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000627:	e9 a9 00 00 00       	jmp    400006d5 <printexecerror+0xf5>
4000062c:	8d 05 31 41 00 40    	lea    0x40004131,%eax
    case PE_INVALID:
        printf("%s: Specified path was invalid", path);
40000632:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000635:	89 04 24             	mov    %eax,(%esp)
40000638:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000063c:	e8 ff 0a 00 00       	call   40001140 <printf>
        break;
40000641:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000644:	e9 8c 00 00 00       	jmp    400006d5 <printexecerror+0xf5>
40000649:	8d 05 50 41 00 40    	lea    0x40004150,%eax
    case PE_CORRUPT_FILE:
        printf("%s: File is not a valid executable binary", path);
4000064f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000652:	89 04 24             	mov    %eax,(%esp)
40000655:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000659:	e8 e2 0a 00 00       	call   40001140 <printf>
        break;
4000065e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000661:	e9 6f 00 00 00       	jmp    400006d5 <printexecerror+0xf5>
40000666:	8d 05 7a 41 00 40    	lea    0x4000417a,%eax
    case PE_FILESYSTEM:
        printf("%s: Filesystem error", path);
4000066c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
4000066f:	89 04 24             	mov    %eax,(%esp)
40000672:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000676:	e8 c5 0a 00 00       	call   40001140 <printf>
        break;
4000067b:	89 45 e0             	mov    %eax,-0x20(%ebp)
4000067e:	e9 52 00 00 00       	jmp    400006d5 <printexecerror+0xf5>
40000683:	8d 05 8f 41 00 40    	lea    0x4000418f,%eax
    case PE_PERM_DENIED:
        printf("%s: Permission to execute path denied (maybe a directory?)", path);
40000689:	8b 4d fc             	mov    -0x4(%ebp),%ecx
4000068c:	89 04 24             	mov    %eax,(%esp)
4000068f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000693:	e8 a8 0a 00 00       	call   40001140 <printf>
        break;
40000698:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000069b:	e9 35 00 00 00       	jmp    400006d5 <printexecerror+0xf5>
400006a0:	8d 05 ca 41 00 40    	lea    0x400041ca,%eax
    case PE_FILE_NOT_FOUND:
        printf("%s: File not found", path);
400006a6:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400006a9:	89 04 24             	mov    %eax,(%esp)
400006ac:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400006b0:	e8 8b 0a 00 00       	call   40001140 <printf>
        break;
400006b5:	89 45 d8             	mov    %eax,-0x28(%ebp)
400006b8:	e9 18 00 00 00       	jmp    400006d5 <printexecerror+0xf5>
400006bd:	8d 05 dd 41 00 40    	lea    0x400041dd,%eax
    default:
        printf("%s: WTF", path);
400006c3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400006c6:	89 04 24             	mov    %eax,(%esp)
400006c9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400006cd:	e8 6e 0a 00 00       	call   40001140 <printf>
400006d2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400006d5:	8d 05 06 41 00 40    	lea    0x40004106,%eax
        break;

    }
    printf("\n");
400006db:	89 04 24             	mov    %eax,(%esp)
400006de:	e8 5d 0a 00 00       	call   40001140 <printf>
}
400006e3:	89 45 d0             	mov    %eax,-0x30(%ebp)
400006e6:	83 c4 38             	add    $0x38,%esp
400006e9:	5d                   	pop    %ebp
400006ea:	c3                   	ret    
400006eb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

400006f0 <exec>:

void cd(char* path) {
    if(!changeExecPath(path)) printexecerror(path, getLastVFSErr());
}

int exec(char* path, char** args) {
400006f0:	55                   	push   %ebp
400006f1:	89 e5                	mov    %esp,%ebp
400006f3:	83 ec 28             	sub    $0x28,%esp
400006f6:	8b 45 0c             	mov    0xc(%ebp),%eax
400006f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
400006fc:	8d 55 e0             	lea    -0x20(%ebp),%edx
400006ff:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40000702:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct regstate state = {
40000705:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%ebp)
4000070c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000070f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000712:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000715:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000718:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000071f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000726:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
4000072d:	89 14 24             	mov    %edx,(%esp)
40000730:	e8 3b 1a 00 00       	call   40002170 <syscall>

    return state.eax;
40000735:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000738:	83 c4 28             	add    $0x28,%esp
4000073b:	5d                   	pop    %ebp
4000073c:	c3                   	ret    
4000073d:	0f 1f 00             	nopl   (%eax)

40000740 <texec>:
}

int texec(char* path, char** args) {
40000740:	55                   	push   %ebp
40000741:	89 e5                	mov    %esp,%ebp
40000743:	83 ec 18             	sub    $0x18,%esp
40000746:	8b 45 0c             	mov    0xc(%ebp),%eax
40000749:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000074c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
4000074f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t res = exec(path, args);
40000752:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000755:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000758:	89 04 24             	mov    %eax,(%esp)
4000075b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000075f:	e8 8c ff ff ff       	call   400006f0 <exec>
40000764:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!res) {
40000767:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
4000076e:	0f 85 1a 00 00 00    	jne    4000078e <texec+0x4e>
        printexecerror(path, getLastVFSErr());
40000774:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000777:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000077a:	e8 71 00 00 00       	call   400007f0 <getLastVFSErr>
4000077f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40000782:	89 0c 24             	mov    %ecx,(%esp)
40000785:	89 44 24 04          	mov    %eax,0x4(%esp)
40000789:	e8 52 fe ff ff       	call   400005e0 <printexecerror>
    }

    return res;
4000078e:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000791:	83 c4 18             	add    $0x18,%esp
40000794:	5d                   	pop    %ebp
40000795:	c3                   	ret    
40000796:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
4000079d:	00 00 00 

400007a0 <getargs>:
#include "process.h"
#include "stdio.h"

extern int main(int argc, char* args[]);

static uint32_t getargs() {
400007a0:	55                   	push   %ebp
400007a1:	89 e5                	mov    %esp,%ebp
400007a3:	56                   	push   %esi
400007a4:	83 ec 34             	sub    $0x34,%esp
400007a7:	8d 45 e0             	lea    -0x20(%ebp),%eax
400007aa:	8d 0d 30 40 00 40    	lea    0x40004030,%ecx
400007b0:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
400007b5:	89 c6                	mov    %eax,%esi
400007b7:	89 34 24             	mov    %esi,(%esp)
400007ba:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400007be:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
400007c5:	00 
400007c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
400007c9:	89 55 d8             	mov    %edx,-0x28(%ebp)
400007cc:	e8 3f 0d 00 00       	call   40001510 <memcpy>
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
400007d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
400007d4:	89 04 24             	mov    %eax,(%esp)
400007d7:	e8 94 19 00 00       	call   40002170 <syscall>

    return state.eax;
400007dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
400007df:	83 c4 34             	add    $0x34,%esp
400007e2:	5e                   	pop    %esi
400007e3:	5d                   	pop    %ebp
400007e4:	c3                   	ret    
400007e5:	66 90                	xchg   %ax,%ax
400007e7:	66 90                	xchg   %ax,%ax
400007e9:	66 90                	xchg   %ax,%ax
400007eb:	66 90                	xchg   %ax,%ax
400007ed:	66 90                	xchg   %ax,%ax
400007ef:	90                   	nop

400007f0 <getLastVFSErr>:
#include "stdio.h"
#include "string.h"
#include "process.h"

uint32_t getLastVFSErr() {
400007f0:	55                   	push   %ebp
400007f1:	89 e5                	mov    %esp,%ebp
400007f3:	56                   	push   %esi
400007f4:	83 ec 34             	sub    $0x34,%esp
400007f7:	8d 45 e0             	lea    -0x20(%ebp),%eax
400007fa:	8d 0d 6c 40 00 40    	lea    0x4000406c,%ecx
40000800:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
40000805:	89 c6                	mov    %eax,%esi
40000807:	89 34 24             	mov    %esi,(%esp)
4000080a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000080e:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
40000815:	00 
40000816:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000819:	89 55 d8             	mov    %edx,-0x28(%ebp)
4000081c:	e8 ef 0c 00 00       	call   40001510 <memcpy>
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
40000821:	8b 45 dc             	mov    -0x24(%ebp),%eax
40000824:	89 04 24             	mov    %eax,(%esp)
40000827:	e8 44 19 00 00       	call   40002170 <syscall>

    return state.eax;
4000082c:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000082f:	83 c4 34             	add    $0x34,%esp
40000832:	5e                   	pop    %esi
40000833:	5d                   	pop    %ebp
40000834:	c3                   	ret    
40000835:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
4000083c:	00 00 00 00 

40000840 <fopenpmhandle>:

static HANDLE getstdout() { return getpmhandle(PMID_STDOUT); };
static HANDLE getstdin() { return getpmhandle(PMID_STDIN); };
static HANDLE getstderr() { return getpmhandle(PMID_STDERR); };

int fopenpmhandle (uint32_t pmid, char* path) {
40000840:	55                   	push   %ebp
40000841:	89 e5                	mov    %esp,%ebp
40000843:	83 ec 28             	sub    $0x28,%esp
40000846:	8b 45 0c             	mov    0xc(%ebp),%eax
40000849:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000084c:	8d 55 e0             	lea    -0x20(%ebp),%edx
4000084f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40000852:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct regstate state = {
40000855:	c7 45 e0 15 00 00 00 	movl   $0x15,-0x20(%ebp)
4000085c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000085f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000862:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000865:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000868:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000086f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000876:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
4000087d:	89 14 24             	mov    %edx,(%esp)
40000880:	e8 eb 18 00 00       	call   40002170 <syscall>

    return (HANDLE)state.eax;
40000885:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000888:	83 c4 28             	add    $0x28,%esp
4000088b:	5d                   	pop    %ebp
4000088c:	c3                   	ret    
4000088d:	0f 1f 00             	nopl   (%eax)

40000890 <setstdout>:
}

int setstdout(char* path) { return fopenpmhandle(PMID_STDOUT, path); };
40000890:	55                   	push   %ebp
40000891:	89 e5                	mov    %esp,%ebp
40000893:	83 ec 18             	sub    $0x18,%esp
40000896:	8b 45 08             	mov    0x8(%ebp),%eax
40000899:	b9 00 00 00 00       	mov    $0x0,%ecx
4000089e:	89 45 fc             	mov    %eax,-0x4(%ebp)
400008a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
400008a4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
400008ab:	89 44 24 04          	mov    %eax,0x4(%esp)
400008af:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400008b2:	e8 89 ff ff ff       	call   40000840 <fopenpmhandle>
400008b7:	83 c4 18             	add    $0x18,%esp
400008ba:	5d                   	pop    %ebp
400008bb:	c3                   	ret    
400008bc:	0f 1f 40 00          	nopl   0x0(%eax)

400008c0 <setstdin>:
int setstdin (char* path) { return fopenpmhandle(PMID_STDIN , path); };
400008c0:	55                   	push   %ebp
400008c1:	89 e5                	mov    %esp,%ebp
400008c3:	83 ec 18             	sub    $0x18,%esp
400008c6:	8b 45 08             	mov    0x8(%ebp),%eax
400008c9:	b9 01 00 00 00       	mov    $0x1,%ecx
400008ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
400008d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
400008d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
400008db:	89 44 24 04          	mov    %eax,0x4(%esp)
400008df:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400008e2:	e8 59 ff ff ff       	call   40000840 <fopenpmhandle>
400008e7:	83 c4 18             	add    $0x18,%esp
400008ea:	5d                   	pop    %ebp
400008eb:	c3                   	ret    
400008ec:	0f 1f 40 00          	nopl   0x0(%eax)

400008f0 <setstderr>:
int setstderr(char* path) { return fopenpmhandle(PMID_STDERR, path); };
400008f0:	55                   	push   %ebp
400008f1:	89 e5                	mov    %esp,%ebp
400008f3:	83 ec 18             	sub    $0x18,%esp
400008f6:	8b 45 08             	mov    0x8(%ebp),%eax
400008f9:	b9 02 00 00 00       	mov    $0x2,%ecx
400008fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000901:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000904:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
4000090b:	89 44 24 04          	mov    %eax,0x4(%esp)
4000090f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000912:	e8 29 ff ff ff       	call   40000840 <fopenpmhandle>
40000917:	83 c4 18             	add    $0x18,%esp
4000091a:	5d                   	pop    %ebp
4000091b:	c3                   	ret    
4000091c:	0f 1f 40 00          	nopl   0x0(%eax)

40000920 <fopen>:

HANDLE fopen(char* path, uint32_t mode) {
40000920:	55                   	push   %ebp
40000921:	89 e5                	mov    %esp,%ebp
40000923:	83 ec 28             	sub    $0x28,%esp
40000926:	8b 45 0c             	mov    0xc(%ebp),%eax
40000929:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000092c:	8d 55 e0             	lea    -0x20(%ebp),%edx
4000092f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40000932:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct regstate state = {
40000935:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
4000093c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000093f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000942:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000945:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000948:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000094f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000956:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
4000095d:	89 14 24             	mov    %edx,(%esp)
40000960:	e8 0b 18 00 00       	call   40002170 <syscall>

    return (HANDLE)state.eax;
40000965:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000968:	83 c4 28             	add    $0x28,%esp
4000096b:	5d                   	pop    %ebp
4000096c:	c3                   	ret    
4000096d:	0f 1f 00             	nopl   (%eax)

40000970 <fclose>:
}

int fclose(uint32_t handle) {
40000970:	55                   	push   %ebp
40000971:	89 e5                	mov    %esp,%ebp
40000973:	83 ec 28             	sub    $0x28,%esp
40000976:	8b 45 08             	mov    0x8(%ebp),%eax
40000979:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000097c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000097f:	c7 45 e0 0b 00 00 00 	movl   $0xb,-0x20(%ebp)
40000986:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000989:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000098c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000993:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000099a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400009a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
400009a8:	89 0c 24             	mov    %ecx,(%esp)
400009ab:	e8 c0 17 00 00       	call   40002170 <syscall>

    return (int)state.eax;
400009b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400009b3:	83 c4 28             	add    $0x28,%esp
400009b6:	5d                   	pop    %ebp
400009b7:	c3                   	ret    
400009b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
400009bf:	00 

400009c0 <fwrite>:
    syscall(&state);

    return (int)state.eax;
}

uint32_t fwrite(uint32_t handle, const void* src, uint32_t length) {
400009c0:	55                   	push   %ebp
400009c1:	89 e5                	mov    %esp,%ebp
400009c3:	83 ec 28             	sub    $0x28,%esp
400009c6:	8b 45 10             	mov    0x10(%ebp),%eax
400009c9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400009cc:	8b 55 08             	mov    0x8(%ebp),%edx
400009cf:	89 55 fc             	mov    %edx,-0x4(%ebp)
400009d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400009d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t res = frwrite(handle, src, length);
400009d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
400009db:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400009de:	8b 55 f4             	mov    -0xc(%ebp),%edx
400009e1:	89 04 24             	mov    %eax,(%esp)
400009e4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400009e8:	89 54 24 08          	mov    %edx,0x8(%esp)
400009ec:	e8 5f 00 00 00       	call   40000a50 <frwrite>
400009f1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(res == RW_BLOCK) {
400009f4:	81 7d f0 01 00 00 00 	cmpl   $0x1,-0x10(%ebp)
400009fb:	0f 85 26 00 00 00    	jne    40000a27 <fwrite+0x67>
        yield();
40000a01:	e8 9a fa ff ff       	call   400004a0 <yield>
        res = frwrite(handle, src, length);
40000a06:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000a09:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000a0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000a0f:	89 04 24             	mov    %eax,(%esp)
40000a12:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000a16:	89 54 24 08          	mov    %edx,0x8(%esp)
40000a1a:	e8 31 00 00 00       	call   40000a50 <frwrite>
40000a1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40000a22:	e9 cd ff ff ff       	jmp    400009f4 <fwrite+0x34>

    printrwerror(handle, res);
40000a27:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000a2a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40000a2d:	89 04 24             	mov    %eax,(%esp)
40000a30:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000a34:	e8 77 00 00 00       	call   40000ab0 <printrwerror>

    return res;
40000a39:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000a3c:	83 c4 28             	add    $0x28,%esp
40000a3f:	5d                   	pop    %ebp
40000a40:	c3                   	ret    
40000a41:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000a48:	0f 1f 84 00 00 00 00 
40000a4f:	00 

40000a50 <frwrite>:
    if(res == RW_NOFM_WRITE) {
        printf("HANDLE[0x%x] FILEMODE doesn't allow write\n", handle);
    }
}

static uint32_t frwrite(uint32_t handle, const void* src, uint32_t length) {
40000a50:	55                   	push   %ebp
40000a51:	89 e5                	mov    %esp,%ebp
40000a53:	56                   	push   %esi
40000a54:	83 ec 34             	sub    $0x34,%esp
40000a57:	8b 45 10             	mov    0x10(%ebp),%eax
40000a5a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000a5d:	8b 55 08             	mov    0x8(%ebp),%edx
40000a60:	8d 75 d8             	lea    -0x28(%ebp),%esi
40000a63:	89 55 f8             	mov    %edx,-0x8(%ebp)
40000a66:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000a69:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct regstate state = {
40000a6c:	c7 45 d8 0c 00 00 00 	movl   $0xc,-0x28(%ebp)
40000a73:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000a76:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000a79:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000a7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
40000a7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000a82:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000a85:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a8c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
      .edx = length,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000a93:	89 34 24             	mov    %esi,(%esp)
40000a96:	e8 d5 16 00 00       	call   40002170 <syscall>

    return (int)state.eax;
40000a9b:	8b 45 d8             	mov    -0x28(%ebp),%eax
40000a9e:	83 c4 34             	add    $0x34,%esp
40000aa1:	5e                   	pop    %esi
40000aa2:	5d                   	pop    %ebp
40000aa3:	c3                   	ret    
40000aa4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000aab:	00 00 00 00 00 

40000ab0 <printrwerror>:
    syscall(&state);

    return (int)state.eax;
}

static void printrwerror(HANDLE handle, uint32_t res) {
40000ab0:	55                   	push   %ebp
40000ab1:	89 e5                	mov    %esp,%ebp
40000ab3:	83 ec 28             	sub    $0x28,%esp
40000ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ab9:	8b 4d 08             	mov    0x8(%ebp),%ecx
40000abc:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40000abf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(res == RW_ERR_VFS) {
40000ac2:	81 7d f8 02 00 00 00 	cmpl   $0x2,-0x8(%ebp)
40000ac9:	0f 85 18 00 00 00    	jne    40000ae7 <printrwerror+0x37>
40000acf:	8d 05 0a 42 00 40    	lea    0x4000420a,%eax
        printf("HANDLE[0x%x] VFS_ERROR\n", handle);
40000ad5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000ad8:	89 04 24             	mov    %eax,(%esp)
40000adb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000adf:	e8 5c 06 00 00       	call   40001140 <printf>
40000ae4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if(res == RW_ERR_DRIVER) {
40000ae7:	81 7d f8 03 00 00 00 	cmpl   $0x3,-0x8(%ebp)
40000aee:	0f 85 18 00 00 00    	jne    40000b0c <printrwerror+0x5c>
40000af4:	8d 05 22 42 00 40    	lea    0x40004222,%eax
        printf("HANDLE[0x%x] DRIVER_ERROR\n", handle);
40000afa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000afd:	89 04 24             	mov    %eax,(%esp)
40000b00:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b04:	e8 37 06 00 00       	call   40001140 <printf>
40000b09:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    if(res == RW_NOFM_READ) {
40000b0c:	81 7d f8 04 00 00 00 	cmpl   $0x4,-0x8(%ebp)
40000b13:	0f 85 18 00 00 00    	jne    40000b31 <printrwerror+0x81>
40000b19:	8d 05 3d 42 00 40    	lea    0x4000423d,%eax
        printf("HANDLE[0x%x] FILEMODE doesn't allow read\n", handle);
40000b1f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000b22:	89 04 24             	mov    %eax,(%esp)
40000b25:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b29:	e8 12 06 00 00       	call   40001140 <printf>
40000b2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }

    if(res == RW_NOFM_WRITE) {
40000b31:	81 7d f8 05 00 00 00 	cmpl   $0x5,-0x8(%ebp)
40000b38:	0f 85 18 00 00 00    	jne    40000b56 <printrwerror+0xa6>
40000b3e:	8d 05 67 42 00 40    	lea    0x40004267,%eax
        printf("HANDLE[0x%x] FILEMODE doesn't allow write\n", handle);
40000b44:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000b47:	89 04 24             	mov    %eax,(%esp)
40000b4a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b4e:	e8 ed 05 00 00       	call   40001140 <printf>
40000b53:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }
}
40000b56:	83 c4 28             	add    $0x28,%esp
40000b59:	5d                   	pop    %ebp
40000b5a:	c3                   	ret    
40000b5b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40000b60 <fread>:
    syscall(&state);

    return (int)state.eax;
}

uint32_t fread(uint32_t handle, void* dest, uint32_t length) {
40000b60:	55                   	push   %ebp
40000b61:	89 e5                	mov    %esp,%ebp
40000b63:	83 ec 28             	sub    $0x28,%esp
40000b66:	8b 45 10             	mov    0x10(%ebp),%eax
40000b69:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000b6c:	8b 55 08             	mov    0x8(%ebp),%edx
40000b6f:	89 55 fc             	mov    %edx,-0x4(%ebp)
40000b72:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000b75:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t res = frread(handle, dest, length);
40000b78:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000b7b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000b7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000b81:	89 04 24             	mov    %eax,(%esp)
40000b84:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b88:	89 54 24 08          	mov    %edx,0x8(%esp)
40000b8c:	e8 5f 00 00 00       	call   40000bf0 <frread>
40000b91:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(res == RW_BLOCK) {
40000b94:	81 7d f0 01 00 00 00 	cmpl   $0x1,-0x10(%ebp)
40000b9b:	0f 85 26 00 00 00    	jne    40000bc7 <fread+0x67>
        yield();
40000ba1:	e8 fa f8 ff ff       	call   400004a0 <yield>
        res = frread(handle, dest, length);
40000ba6:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000ba9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000bac:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000baf:	89 04 24             	mov    %eax,(%esp)
40000bb2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000bb6:	89 54 24 08          	mov    %edx,0x8(%esp)
40000bba:	e8 31 00 00 00       	call   40000bf0 <frread>
40000bbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40000bc2:	e9 cd ff ff ff       	jmp    40000b94 <fread+0x34>

    printrwerror(handle, res);
40000bc7:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000bca:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40000bcd:	89 04 24             	mov    %eax,(%esp)
40000bd0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000bd4:	e8 d7 fe ff ff       	call   40000ab0 <printrwerror>

    return res;
40000bd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000bdc:	83 c4 28             	add    $0x28,%esp
40000bdf:	5d                   	pop    %ebp
40000be0:	c3                   	ret    
40000be1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000be8:	0f 1f 84 00 00 00 00 
40000bef:	00 

40000bf0 <frread>:
    printrwerror(handle, res);

    return res;
}

static uint32_t frread(uint32_t handle, void* dest, uint32_t length) {
40000bf0:	55                   	push   %ebp
40000bf1:	89 e5                	mov    %esp,%ebp
40000bf3:	56                   	push   %esi
40000bf4:	83 ec 34             	sub    $0x34,%esp
40000bf7:	8b 45 10             	mov    0x10(%ebp),%eax
40000bfa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000bfd:	8b 55 08             	mov    0x8(%ebp),%edx
40000c00:	8d 75 d8             	lea    -0x28(%ebp),%esi
40000c03:	89 55 f8             	mov    %edx,-0x8(%ebp)
40000c06:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000c09:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct regstate state = {
40000c0c:	c7 45 d8 0d 00 00 00 	movl   $0xd,-0x28(%ebp)
40000c13:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000c16:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000c19:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000c1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
40000c1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000c22:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000c25:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000c2c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
      .edx = length,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000c33:	89 34 24             	mov    %esi,(%esp)
40000c36:	e8 35 15 00 00       	call   40002170 <syscall>

    return (int)state.eax;
40000c3b:	8b 45 d8             	mov    -0x28(%ebp),%eax
40000c3e:	83 c4 34             	add    $0x34,%esp
40000c41:	5e                   	pop    %esi
40000c42:	5d                   	pop    %ebp
40000c43:	c3                   	ret    
40000c44:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000c4b:	00 00 00 00 00 

40000c50 <fmkfifo>:
    printrwerror(handle, res);

    return res;
}

HANDLE fmkfifo(char* path) {
40000c50:	55                   	push   %ebp
40000c51:	89 e5                	mov    %esp,%ebp
40000c53:	83 ec 28             	sub    $0x28,%esp
40000c56:	8b 45 08             	mov    0x8(%ebp),%eax
40000c59:	8d 4d e0             	lea    -0x20(%ebp),%ecx
40000c5c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
40000c5f:	c7 45 e0 0e 00 00 00 	movl   $0xe,-0x20(%ebp)
40000c66:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000c69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000c6c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000c73:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000c7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000c81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000c88:	89 0c 24             	mov    %ecx,(%esp)
40000c8b:	e8 e0 14 00 00       	call   40002170 <syscall>

    return (HANDLE)state.eax;
40000c90:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c93:	83 c4 28             	add    $0x28,%esp
40000c96:	5d                   	pop    %ebp
40000c97:	c3                   	ret    
40000c98:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
40000c9f:	00 

40000ca0 <fgetc>:
        hdl = getpmhandle(hdl);
    }
    return hdl;
}

char fgetc(HANDLE hdl) {
40000ca0:	55                   	push   %ebp
40000ca1:	89 e5                	mov    %esp,%ebp
40000ca3:	83 ec 28             	sub    $0x28,%esp
40000ca6:	8b 45 08             	mov    0x8(%ebp),%eax
40000ca9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    hdl = resolveHandle(hdl);
40000cac:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000caf:	89 04 24             	mov    %eax,(%esp)
40000cb2:	e8 49 00 00 00       	call   40000d00 <resolveHandle>
40000cb7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char in = 0;
40000cba:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
    if(hdl != 0) {
40000cbe:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
40000cc5:	0f 84 25 00 00 00    	je     40000cf0 <fgetc+0x50>
40000ccb:	8d 45 fb             	lea    -0x5(%ebp),%eax
40000cce:	b9 01 00 00 00       	mov    $0x1,%ecx
        fread(hdl, &in, sizeof(char));
40000cd3:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000cd6:	89 14 24             	mov    %edx,(%esp)
40000cd9:	89 44 24 04          	mov    %eax,0x4(%esp)
40000cdd:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
40000ce4:	00 
40000ce5:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000ce8:	e8 73 fe ff ff       	call   40000b60 <fread>
40000ced:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    return in;
40000cf0:	0f be 45 fb          	movsbl -0x5(%ebp),%eax
40000cf4:	83 c4 28             	add    $0x28,%esp
40000cf7:	5d                   	pop    %ebp
40000cf8:	c3                   	ret    
40000cf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40000d00 <resolveHandle>:
    syscall(&state);

    return (HANDLE)state.eax;
}

static HANDLE resolveHandle(HANDLE hdl) {
40000d00:	55                   	push   %ebp
40000d01:	89 e5                	mov    %esp,%ebp
40000d03:	83 ec 08             	sub    $0x8,%esp
40000d06:	8b 45 08             	mov    0x8(%ebp),%eax
40000d09:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(hdl < 0xFFF) {
40000d0c:	81 7d fc ff 0f 00 00 	cmpl   $0xfff,-0x4(%ebp)
40000d13:	0f 83 0e 00 00 00    	jae    40000d27 <resolveHandle+0x27>
        hdl = getpmhandle(hdl);
40000d19:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000d1c:	89 04 24             	mov    %eax,(%esp)
40000d1f:	e8 3c 07 00 00       	call   40001460 <getpmhandle>
40000d24:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    return hdl;
40000d27:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000d2a:	83 c4 08             	add    $0x8,%esp
40000d2d:	5d                   	pop    %ebp
40000d2e:	c3                   	ret    
40000d2f:	90                   	nop

40000d30 <fgets>:
        fread(hdl, &in, sizeof(char));
    }
    return in;
}

char* fgets(char* str, int num, HANDLE hdl) {
40000d30:	55                   	push   %ebp
40000d31:	89 e5                	mov    %esp,%ebp
40000d33:	83 ec 18             	sub    $0x18,%esp
40000d36:	8b 45 10             	mov    0x10(%ebp),%eax
40000d39:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000d3c:	8b 55 08             	mov    0x8(%ebp),%edx
40000d3f:	89 55 f8             	mov    %edx,-0x8(%ebp)
40000d42:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000d45:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int n = 0; n < (num - 1); n++) {
40000d48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000d52:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40000d55:	81 e9 01 00 00 00    	sub    $0x1,%ecx
40000d5b:	39 c8                	cmp    %ecx,%eax
40000d5d:	0f 8d 5f 00 00 00    	jge    40000dc2 <fgets+0x92>
        str[n] = fgetc(hdl);
40000d63:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000d66:	89 04 24             	mov    %eax,(%esp)
40000d69:	e8 32 ff ff ff       	call   40000ca0 <fgetc>
40000d6e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40000d71:	8b 55 f8             	mov    -0x8(%ebp),%edx
40000d74:	88 04 0a             	mov    %al,(%edx,%ecx,1)
        if(str[n] == 0 || str[n] == '\0') {
40000d77:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40000d7a:	8b 55 f8             	mov    -0x8(%ebp),%edx
40000d7d:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
40000d81:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
40000d87:	0f 84 15 00 00 00    	je     40000da2 <fgets+0x72>
40000d8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000d90:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000d93:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
40000d97:	3d 00 00 00 00       	cmp    $0x0,%eax
40000d9c:	0f 85 0b 00 00 00    	jne    40000dad <fgets+0x7d>
            return str;
40000da2:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000da5:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000da8:	e9 25 00 00 00       	jmp    40000dd2 <fgets+0xa2>
        }
    }
40000dad:	e9 00 00 00 00       	jmp    40000db2 <fgets+0x82>
    }
    return in;
}

char* fgets(char* str, int num, HANDLE hdl) {
    for(int n = 0; n < (num - 1); n++) {
40000db2:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000db5:	05 01 00 00 00       	add    $0x1,%eax
40000dba:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000dbd:	e9 8d ff ff ff       	jmp    40000d4f <fgets+0x1f>
        if(str[n] == 0 || str[n] == '\0') {
            return str;
        }
    }

    str[num] = '\0';
40000dc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000dc5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000dc8:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    return str;
40000dcc:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000dcf:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40000dd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000dd5:	83 c4 18             	add    $0x18,%esp
40000dd8:	5d                   	pop    %ebp
40000dd9:	c3                   	ret    
40000dda:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

40000de0 <getc>:

char getc(HANDLE hdl) {
40000de0:	55                   	push   %ebp
40000de1:	89 e5                	mov    %esp,%ebp
40000de3:	83 ec 08             	sub    $0x8,%esp
40000de6:	8b 45 08             	mov    0x8(%ebp),%eax
40000de9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return fgetc(hdl);
40000dec:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000def:	89 04 24             	mov    %eax,(%esp)
40000df2:	e8 a9 fe ff ff       	call   40000ca0 <fgetc>
40000df7:	0f be c0             	movsbl %al,%eax
40000dfa:	83 c4 08             	add    $0x8,%esp
40000dfd:	5d                   	pop    %ebp
40000dfe:	c3                   	ret    
40000dff:	90                   	nop

40000e00 <getchar>:
}

char getchar() {
40000e00:	55                   	push   %ebp
40000e01:	89 e5                	mov    %esp,%ebp
40000e03:	83 ec 08             	sub    $0x8,%esp
40000e06:	b8 01 00 00 00       	mov    $0x1,%eax
    return fgetc(PMID_STDIN);
40000e0b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
40000e12:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000e15:	e8 86 fe ff ff       	call   40000ca0 <fgetc>
40000e1a:	0f be c0             	movsbl %al,%eax
40000e1d:	83 c4 08             	add    $0x8,%esp
40000e20:	5d                   	pop    %ebp
40000e21:	c3                   	ret    
40000e22:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000e29:	1f 84 00 00 00 00 00 

40000e30 <getln>:
}

char* getln(char* str) {
40000e30:	55                   	push   %ebp
40000e31:	89 e5                	mov    %esp,%ebp
40000e33:	83 ec 28             	sub    $0x28,%esp
40000e36:	8b 45 08             	mov    0x8(%ebp),%eax
40000e39:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t index = 0;
40000e3c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    char lastChar = 0;
40000e43:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
40000e47:	b8 01 00 00 00       	mov    $0x1,%eax

    while((lastChar = fgetc(PMID_STDIN))) {
40000e4c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
40000e53:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000e56:	e8 45 fe ff ff       	call   40000ca0 <fgetc>
40000e5b:	88 45 f7             	mov    %al,-0x9(%ebp)
40000e5e:	3c 00                	cmp    $0x0,%al
40000e60:	0f 84 a5 00 00 00    	je     40000f0b <getln+0xdb>
        if(lastChar == '\n') {
40000e66:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
40000e6a:	3d 0a 00 00 00       	cmp    $0xa,%eax
40000e6f:	0f 85 1c 00 00 00    	jne    40000e91 <getln+0x61>
40000e75:	b8 0a 00 00 00       	mov    $0xa,%eax
            putchar('\n');
40000e7a:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
40000e81:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000e84:	e8 97 00 00 00       	call   40000f20 <putchar>
            break;
40000e89:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000e8c:	e9 7a 00 00 00       	jmp    40000f0b <getln+0xdb>
        }

        if(lastChar == 8) {
40000e91:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
40000e95:	3d 08 00 00 00       	cmp    $0x8,%eax
40000e9a:	0f 85 3f 00 00 00    	jne    40000edf <getln+0xaf>
            if(index != 0) {
40000ea0:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
40000ea7:	0f 84 23 00 00 00    	je     40000ed0 <getln+0xa0>
40000ead:	b8 08 00 00 00       	mov    $0x8,%eax
                index--;
40000eb2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000eb5:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
40000ebb:	89 4d f8             	mov    %ecx,-0x8(%ebp)
                putchar(8);
40000ebe:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
40000ec5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000ec8:	e8 53 00 00 00       	call   40000f20 <putchar>
40000ecd:	89 45 e0             	mov    %eax,-0x20(%ebp)
            }
            str[index] = 0;
40000ed0:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000ed3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000ed6:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
            continue;
40000eda:	e9 68 ff ff ff       	jmp    40000e47 <getln+0x17>
        }

        str[index] = lastChar;
40000edf:	8a 45 f7             	mov    -0x9(%ebp),%al
40000ee2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000ee5:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000ee8:	88 04 0a             	mov    %al,(%edx,%ecx,1)
        putchar(lastChar);
40000eeb:	0f be 4d f7          	movsbl -0x9(%ebp),%ecx
40000eef:	89 0c 24             	mov    %ecx,(%esp)
40000ef2:	e8 29 00 00 00       	call   40000f20 <putchar>

        index++;
40000ef7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000efa:	81 c1 01 00 00 00    	add    $0x1,%ecx
40000f00:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    }
40000f03:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000f06:	e9 3c ff ff ff       	jmp    40000e47 <getln+0x17>

    str[index] = 0;
40000f0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000f0e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000f11:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)

    return str;
40000f15:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000f18:	83 c4 28             	add    $0x28,%esp
40000f1b:	5d                   	pop    %ebp
40000f1c:	c3                   	ret    
40000f1d:	0f 1f 00             	nopl   (%eax)

40000f20 <putchar>:
  syscall(&state);
  
  return state.eax;
}

int putchar(char c) {
40000f20:	55                   	push   %ebp
40000f21:	89 e5                	mov    %esp,%ebp
40000f23:	83 ec 18             	sub    $0x18,%esp
40000f26:	8a 45 08             	mov    0x8(%ebp),%al
40000f29:	b9 00 00 00 00       	mov    $0x0,%ecx
40000f2e:	88 45 ff             	mov    %al,-0x1(%ebp)
    return fputc(c, PMID_STDOUT);
40000f31:	0f be 55 ff          	movsbl -0x1(%ebp),%edx
40000f35:	89 14 24             	mov    %edx,(%esp)
40000f38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000f3f:	00 
40000f40:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000f43:	e8 08 00 00 00       	call   40000f50 <fputc>
40000f48:	83 c4 18             	add    $0x18,%esp
40000f4b:	5d                   	pop    %ebp
40000f4c:	c3                   	ret    
40000f4d:	0f 1f 00             	nopl   (%eax)

40000f50 <fputc>:

int putc(char c, HANDLE hdl) {
    return fputc(c, hdl);
}

int fputc(char c, HANDLE hdl) {
40000f50:	55                   	push   %ebp
40000f51:	89 e5                	mov    %esp,%ebp
40000f53:	83 ec 28             	sub    $0x28,%esp
40000f56:	8b 45 0c             	mov    0xc(%ebp),%eax
40000f59:	8a 4d 08             	mov    0x8(%ebp),%cl
40000f5c:	88 4d fb             	mov    %cl,-0x5(%ebp)
40000f5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    hdl = resolveHandle(hdl);
40000f62:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000f65:	89 04 24             	mov    %eax,(%esp)
40000f68:	e8 93 fd ff ff       	call   40000d00 <resolveHandle>
40000f6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(hdl != 0) {
40000f70:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40000f77:	0f 84 2a 00 00 00    	je     40000fa7 <fputc+0x57>
40000f7d:	8d 45 fb             	lea    -0x5(%ebp),%eax
40000f80:	b9 01 00 00 00       	mov    $0x1,%ecx
        return fwrite(hdl, &c, sizeof(char));
40000f85:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000f88:	89 14 24             	mov    %edx,(%esp)
40000f8b:	89 44 24 04          	mov    %eax,0x4(%esp)
40000f8f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
40000f96:	00 
40000f97:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40000f9a:	e8 21 fa ff ff       	call   400009c0 <fwrite>
40000f9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000fa2:	e9 0f 00 00 00       	jmp    40000fb6 <fputc+0x66>
    }
    return kputc(c);
40000fa7:	0f be 45 fb          	movsbl -0x5(%ebp),%eax
40000fab:	89 04 24             	mov    %eax,(%esp)
40000fae:	e8 3d 00 00 00       	call   40000ff0 <kputc>
40000fb3:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40000fb6:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000fb9:	83 c4 28             	add    $0x28,%esp
40000fbc:	5d                   	pop    %ebp
40000fbd:	c3                   	ret    
40000fbe:	66 90                	xchg   %ax,%ax

40000fc0 <putc>:

int putchar(char c) {
    return fputc(c, PMID_STDOUT);
}

int putc(char c, HANDLE hdl) {
40000fc0:	55                   	push   %ebp
40000fc1:	89 e5                	mov    %esp,%ebp
40000fc3:	83 ec 18             	sub    $0x18,%esp
40000fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
40000fc9:	8a 4d 08             	mov    0x8(%ebp),%cl
40000fcc:	88 4d ff             	mov    %cl,-0x1(%ebp)
40000fcf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return fputc(c, hdl);
40000fd2:	8a 4d ff             	mov    -0x1(%ebp),%cl
40000fd5:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000fd8:	0f be d1             	movsbl %cl,%edx
40000fdb:	89 14 24             	mov    %edx,(%esp)
40000fde:	89 44 24 04          	mov    %eax,0x4(%esp)
40000fe2:	e8 69 ff ff ff       	call   40000f50 <fputc>
40000fe7:	83 c4 18             	add    $0x18,%esp
40000fea:	5d                   	pop    %ebp
40000feb:	c3                   	ret    
40000fec:	0f 1f 40 00          	nopl   0x0(%eax)

40000ff0 <kputc>:
    str[index] = 0;

    return str;
}

static int kputc(char c) {
40000ff0:	55                   	push   %ebp
40000ff1:	89 e5                	mov    %esp,%ebp
40000ff3:	83 ec 28             	sub    $0x28,%esp
40000ff6:	8a 45 08             	mov    0x8(%ebp),%al
40000ff9:	8d 4d e0             	lea    -0x20(%ebp),%ecx
40000ffc:	88 45 ff             	mov    %al,-0x1(%ebp)
  struct regstate state = {
40000fff:	c7 45 e0 c9 00 00 00 	movl   $0xc9,-0x20(%ebp)
40001006:	0f be 55 ff          	movsbl -0x1(%ebp),%edx
4000100a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4000100d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001014:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000101b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001022:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);
40001029:	89 0c 24             	mov    %ecx,(%esp)
4000102c:	e8 3f 11 00 00       	call   40002170 <syscall>
  
  return state.eax;
40001031:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001034:	83 c4 28             	add    $0x28,%esp
40001037:	5d                   	pop    %ebp
40001038:	c3                   	ret    
40001039:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40001040 <puts>:
  syscall(&state);
  
  return state.eax;
}

int puts(const char* c) {
40001040:	55                   	push   %ebp
40001041:	89 e5                	mov    %esp,%ebp
40001043:	83 ec 18             	sub    $0x18,%esp
40001046:	8b 45 08             	mov    0x8(%ebp),%eax
40001049:	b9 00 00 00 00       	mov    $0x0,%ecx
4000104e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return fputs(c, PMID_STDOUT);
40001051:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001054:	89 04 24             	mov    %eax,(%esp)
40001057:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
4000105e:	00 
4000105f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001062:	e8 09 00 00 00       	call   40001070 <fputs>
40001067:	83 c4 18             	add    $0x18,%esp
4000106a:	5d                   	pop    %ebp
4000106b:	c3                   	ret    
4000106c:	0f 1f 40 00          	nopl   0x0(%eax)

40001070 <fputs>:
}

int fputs(const char* c, HANDLE hdl) {
40001070:	55                   	push   %ebp
40001071:	89 e5                	mov    %esp,%ebp
40001073:	56                   	push   %esi
40001074:	83 ec 24             	sub    $0x24,%esp
40001077:	8b 45 0c             	mov    0xc(%ebp),%eax
4000107a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000107d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40001080:	89 45 f0             	mov    %eax,-0x10(%ebp)
    hdl = resolveHandle(hdl);
40001083:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001086:	89 04 24             	mov    %eax,(%esp)
40001089:	e8 72 fc ff ff       	call   40000d00 <resolveHandle>
4000108e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(hdl != 0) {
40001091:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001098:	0f 84 36 00 00 00    	je     400010d4 <fputs+0x64>
        return fwrite(hdl, c, strlen(c));
4000109e:	8b 45 f0             	mov    -0x10(%ebp),%eax
400010a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
400010a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
400010a7:	89 e6                	mov    %esp,%esi
400010a9:	89 16                	mov    %edx,(%esi)
400010ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
400010ae:	89 4d e8             	mov    %ecx,-0x18(%ebp)
400010b1:	e8 2a 06 00 00       	call   400016e0 <strlen>
400010b6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400010b9:	89 0c 24             	mov    %ecx,(%esp)
400010bc:	8b 55 e8             	mov    -0x18(%ebp),%edx
400010bf:	89 54 24 04          	mov    %edx,0x4(%esp)
400010c3:	89 44 24 08          	mov    %eax,0x8(%esp)
400010c7:	e8 f4 f8 ff ff       	call   400009c0 <fwrite>
400010cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
400010cf:	e9 0e 00 00 00       	jmp    400010e2 <fputs+0x72>
    }
    return kputs(c);
400010d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
400010d7:	89 04 24             	mov    %eax,(%esp)
400010da:	e8 11 00 00 00       	call   400010f0 <kputs>
400010df:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
400010e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
400010e5:	83 c4 24             	add    $0x24,%esp
400010e8:	5e                   	pop    %esi
400010e9:	5d                   	pop    %ebp
400010ea:	c3                   	ret    
400010eb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

400010f0 <kputs>:
        return fwrite(hdl, &c, sizeof(char));
    }
    return kputc(c);
}

static int kputs(const char* cp) {
400010f0:	55                   	push   %ebp
400010f1:	89 e5                	mov    %esp,%ebp
400010f3:	83 ec 28             	sub    $0x28,%esp
400010f6:	8b 45 08             	mov    0x8(%ebp),%eax
400010f9:	8d 4d e0             	lea    -0x20(%ebp),%ecx
400010fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct regstate state = {
400010ff:	c7 45 e0 ca 00 00 00 	movl   $0xca,-0x20(%ebp)
40001106:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001109:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000110c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001113:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000111a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001121:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);
40001128:	89 0c 24             	mov    %ecx,(%esp)
4000112b:	e8 40 10 00 00       	call   40002170 <syscall>
  
  return state.eax;
40001130:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001133:	83 c4 28             	add    $0x28,%esp
40001136:	5d                   	pop    %ebp
40001137:	c3                   	ret    
40001138:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
4000113f:	00 

40001140 <printf>:
  
  return wrt;
}

int printf(const char* fmt, ...)
{
40001140:	55                   	push   %ebp
40001141:	89 e5                	mov    %esp,%ebp
40001143:	83 ec 58             	sub    $0x58,%esp
40001146:	8b 45 08             	mov    0x8(%ebp),%eax
40001149:	8d 4d f8             	lea    -0x8(%ebp),%ecx
4000114c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  va_list ap;
  const char* s;
  unsigned long n;
	char c;
	int wrt = 0;
4000114f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001156:	8d 45 0c             	lea    0xc(%ebp),%eax

  va_start(ap, fmt);
40001159:	89 01                	mov    %eax,(%ecx)
  while (*fmt) {
4000115b:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000115e:	80 38 00             	cmpb   $0x0,(%eax)
40001161:	0f 84 1d 02 00 00    	je     40001384 <printf+0x244>
    if (*fmt == '%') {
40001167:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000116a:	0f be 00             	movsbl (%eax),%eax
4000116d:	3d 25 00 00 00       	cmp    $0x25,%eax
40001172:	0f 85 e6 01 00 00    	jne    4000135e <printf+0x21e>
      fmt++;
40001178:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000117b:	89 c1                	mov    %eax,%ecx
4000117d:	41                   	inc    %ecx
4000117e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
      switch (*fmt) {
40001181:	0f be 40 01          	movsbl 0x1(%eax),%eax
40001185:	89 c1                	mov    %eax,%ecx
40001187:	83 e9 24             	sub    $0x24,%ecx
4000118a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000118d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
40001190:	0f 8f 15 00 00 00    	jg     400011ab <printf+0x6b>
40001196:	e9 00 00 00 00       	jmp    4000119b <printf+0x5b>
4000119b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000119e:	85 c0                	test   %eax,%eax
400011a0:	0f 84 7c 01 00 00    	je     40001322 <printf+0x1e2>
400011a6:	e9 7c 01 00 00       	jmp    40001327 <printf+0x1e7>
400011ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400011ae:	83 e8 62             	sub    $0x62,%eax
400011b1:	89 45 dc             	mov    %eax,-0x24(%ebp)
400011b4:	0f 8f 19 00 00 00    	jg     400011d3 <printf+0x93>
400011ba:	e9 00 00 00 00       	jmp    400011bf <printf+0x7f>
400011bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400011c2:	83 e8 25             	sub    $0x25,%eax
400011c5:	89 45 d8             	mov    %eax,-0x28(%ebp)
400011c8:	0f 84 33 01 00 00    	je     40001301 <printf+0x1c1>
400011ce:	e9 54 01 00 00       	jmp    40001327 <printf+0x1e7>
400011d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400011d6:	83 e8 6f             	sub    $0x6f,%eax
400011d9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400011dc:	0f 8f 2d 00 00 00    	jg     4000120f <printf+0xcf>
400011e2:	e9 00 00 00 00       	jmp    400011e7 <printf+0xa7>
400011e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400011ea:	83 e8 63             	sub    $0x63,%eax
400011ed:	89 45 d0             	mov    %eax,-0x30(%ebp)
400011f0:	0f 84 dd 00 00 00    	je     400012d3 <printf+0x193>
400011f6:	e9 00 00 00 00       	jmp    400011fb <printf+0xbb>
400011fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400011fe:	83 e8 64             	sub    $0x64,%eax
40001201:	89 45 cc             	mov    %eax,-0x34(%ebp)
40001204:	0f 84 53 00 00 00    	je     4000125d <printf+0x11d>
4000120a:	e9 18 01 00 00       	jmp    40001327 <printf+0x1e7>
4000120f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001212:	83 c0 90             	add    $0xffffff90,%eax
40001215:	89 c1                	mov    %eax,%ecx
40001217:	83 e9 08             	sub    $0x8,%ecx
4000121a:	89 45 c8             	mov    %eax,-0x38(%ebp)
4000121d:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
40001220:	0f 87 01 01 00 00    	ja     40001327 <printf+0x1e7>
40001226:	8b 45 c8             	mov    -0x38(%ebp),%eax
40001229:	8b 0c 85 48 40 00 40 	mov    0x40004048(,%eax,4),%ecx
40001230:	ff e1                	jmp    *%ecx
        case 's':
          s = va_arg(ap, char*);
40001232:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001235:	89 c1                	mov    %eax,%ecx
40001237:	81 c1 04 00 00 00    	add    $0x4,%ecx
4000123d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001240:	8b 00                	mov    (%eax),%eax
40001242:	89 45 f4             	mov    %eax,-0xc(%ebp)
          wrt += puts(s);
40001245:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001248:	89 04 24             	mov    %eax,(%esp)
4000124b:	e8 f0 fd ff ff       	call   40001040 <puts>
40001250:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40001253:	01 c1                	add    %eax,%ecx
40001255:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
40001258:	e9 fc 00 00 00       	jmp    40001359 <printf+0x219>
4000125d:	b8 0a 00 00 00       	mov    $0xa,%eax
        case 'd':
        case 'u':
          n = va_arg(ap, unsigned long int);
40001262:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001265:	89 ca                	mov    %ecx,%edx
40001267:	81 c2 04 00 00 00    	add    $0x4,%edx
4000126d:	89 55 f8             	mov    %edx,-0x8(%ebp)
40001270:	8b 09                	mov    (%ecx),%ecx
40001272:	89 4d f0             	mov    %ecx,-0x10(%ebp)
          wrt += putn(n, 10);
40001275:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001278:	89 0c 24             	mov    %ecx,(%esp)
4000127b:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
40001282:	00 
40001283:	89 45 c0             	mov    %eax,-0x40(%ebp)
40001286:	e8 15 01 00 00       	call   400013a0 <putn>
4000128b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000128e:	01 c1                	add    %eax,%ecx
40001290:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
40001293:	e9 c1 00 00 00       	jmp    40001359 <printf+0x219>
40001298:	b8 10 00 00 00       	mov    $0x10,%eax
        case 'x':
        case 'p':
          n = va_arg(ap, unsigned long int);
4000129d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400012a0:	89 ca                	mov    %ecx,%edx
400012a2:	81 c2 04 00 00 00    	add    $0x4,%edx
400012a8:	89 55 f8             	mov    %edx,-0x8(%ebp)
400012ab:	8b 09                	mov    (%ecx),%ecx
400012ad:	89 4d f0             	mov    %ecx,-0x10(%ebp)
          wrt += putn(n, 16);
400012b0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400012b3:	89 0c 24             	mov    %ecx,(%esp)
400012b6:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
400012bd:	00 
400012be:	89 45 bc             	mov    %eax,-0x44(%ebp)
400012c1:	e8 da 00 00 00       	call   400013a0 <putn>
400012c6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400012c9:	01 c1                	add    %eax,%ecx
400012cb:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
400012ce:	e9 86 00 00 00       	jmp    40001359 <printf+0x219>
        case 'c':
          c = va_arg(ap, int);
400012d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
400012d6:	89 c1                	mov    %eax,%ecx
400012d8:	81 c1 04 00 00 00    	add    $0x4,%ecx
400012de:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400012e1:	8b 00                	mov    (%eax),%eax
400012e3:	88 c2                	mov    %al,%dl
400012e5:	88 55 ef             	mov    %dl,-0x11(%ebp)
          wrt += putchar(c);
400012e8:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
400012ec:	89 04 24             	mov    %eax,(%esp)
400012ef:	e8 2c fc ff ff       	call   40000f20 <putchar>
400012f4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400012f7:	01 c1                	add    %eax,%ecx
400012f9:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
400012fc:	e9 58 00 00 00       	jmp    40001359 <printf+0x219>
40001301:	b8 25 00 00 00       	mov    $0x25,%eax
        case '%':
          wrt += putchar('%');
40001306:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
4000130d:	89 45 b8             	mov    %eax,-0x48(%ebp)
40001310:	e8 0b fc ff ff       	call   40000f20 <putchar>
40001315:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40001318:	01 c1                	add    %eax,%ecx
4000131a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
4000131d:	e9 37 00 00 00       	jmp    40001359 <printf+0x219>
        case '\0':
          goto out;
40001322:	e9 62 00 00 00       	jmp    40001389 <printf+0x249>
40001327:	b8 25 00 00 00       	mov    $0x25,%eax
        default:
          wrt += putchar('%');
4000132c:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
40001333:	89 45 b4             	mov    %eax,-0x4c(%ebp)
40001336:	e8 e5 fb ff ff       	call   40000f20 <putchar>
4000133b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000133e:	01 c1                	add    %eax,%ecx
40001340:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          wrt += putchar(*fmt);
40001343:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001346:	0f be 00             	movsbl (%eax),%eax
40001349:	89 04 24             	mov    %eax,(%esp)
4000134c:	e8 cf fb ff ff       	call   40000f20 <putchar>
40001351:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40001354:	01 c1                	add    %eax,%ecx
40001356:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
      }
    } else {
40001359:	e9 16 00 00 00       	jmp    40001374 <printf+0x234>
      wrt += putchar(*fmt);
4000135e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001361:	0f be 00             	movsbl (%eax),%eax
40001364:	89 04 24             	mov    %eax,(%esp)
40001367:	e8 b4 fb ff ff       	call   40000f20 <putchar>
4000136c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000136f:	01 c1                	add    %eax,%ecx
40001371:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    }

    fmt++;
40001374:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001377:	05 01 00 00 00       	add    $0x1,%eax
4000137c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  }
4000137f:	e9 d7 fd ff ff       	jmp    4000115b <printf+0x1b>
40001384:	e9 00 00 00 00       	jmp    40001389 <printf+0x249>

out:
  va_end(ap);

  return wrt;
40001389:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000138c:	83 c4 58             	add    $0x58,%esp
4000138f:	5d                   	pop    %ebp
40001390:	c3                   	ret    
40001391:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001398:	0f 1f 84 00 00 00 00 
4000139f:	00 

400013a0 <putn>:
    }
    return kputs(c);
}

static int putn(unsigned long x, int base)
{
400013a0:	55                   	push   %ebp
400013a1:	89 e5                	mov    %esp,%ebp
400013a3:	56                   	push   %esi
400013a4:	83 ec 74             	sub    $0x74,%esp
400013a7:	8b 45 0c             	mov    0xc(%ebp),%eax
400013aa:	8b 4d 08             	mov    0x8(%ebp),%ecx
400013ad:	8d 15 e5 41 00 40    	lea    0x400041e5,%edx
400013b3:	89 4d f4             	mov    %ecx,-0xc(%ebp)
400013b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char buf[65];
  const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
400013b9:	89 55 a8             	mov    %edx,-0x58(%ebp)
  char* p;
  int wrt = 0;
400013bc:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)

  if (base > 36) {
400013c3:	81 7d f0 24 00 00 00 	cmpl   $0x24,-0x10(%ebp)
400013ca:	0f 8e 0c 00 00 00    	jle    400013dc <putn+0x3c>
    return 0;
400013d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
400013d7:	e9 71 00 00 00       	jmp    4000144d <putn+0xad>
400013dc:	8d 45 af             	lea    -0x51(%ebp),%eax
  }

  p = buf + 64;
400013df:	05 40 00 00 00       	add    $0x40,%eax
400013e4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  *p = '\0';
400013e7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
400013ea:	c6 00 00             	movb   $0x0,(%eax)
  do {
    wrt++;
400013ed:	8b 45 a0             	mov    -0x60(%ebp),%eax
400013f0:	05 01 00 00 00       	add    $0x1,%eax
400013f5:	89 45 a0             	mov    %eax,-0x60(%ebp)
    *--p = digits[x % base];
400013f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
400013fb:	31 d2                	xor    %edx,%edx
400013fd:	f7 75 f0             	divl   -0x10(%ebp)
40001400:	8b 45 a8             	mov    -0x58(%ebp),%eax
40001403:	8a 0c 10             	mov    (%eax,%edx,1),%cl
40001406:	8b 45 a4             	mov    -0x5c(%ebp),%eax
40001409:	89 c2                	mov    %eax,%edx
4000140b:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
40001411:	89 55 a4             	mov    %edx,-0x5c(%ebp)
40001414:	88 48 ff             	mov    %cl,-0x1(%eax)
    x /= base;
40001417:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000141a:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000141d:	89 45 9c             	mov    %eax,-0x64(%ebp)
40001420:	89 d0                	mov    %edx,%eax
40001422:	31 d2                	xor    %edx,%edx
40001424:	8b 75 9c             	mov    -0x64(%ebp),%esi
40001427:	f7 f6                	div    %esi
40001429:	89 45 f4             	mov    %eax,-0xc(%ebp)
  } while (x);
4000142c:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001433:	0f 85 b4 ff ff ff    	jne    400013ed <putn+0x4d>
  puts(p);
40001439:	8b 45 a4             	mov    -0x5c(%ebp),%eax
4000143c:	89 04 24             	mov    %eax,(%esp)
4000143f:	e8 fc fb ff ff       	call   40001040 <puts>
  
  return wrt;
40001444:	8b 4d a0             	mov    -0x60(%ebp),%ecx
40001447:	89 4d f8             	mov    %ecx,-0x8(%ebp)
4000144a:	89 45 98             	mov    %eax,-0x68(%ebp)
}
4000144d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001450:	83 c4 74             	add    $0x74,%esp
40001453:	5e                   	pop    %esi
40001454:	5d                   	pop    %ebp
40001455:	c3                   	ret    
40001456:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
4000145d:	00 00 00 

40001460 <getpmhandle>:
    syscall(&state);

    return state.eax;
}

static HANDLE getpmhandle   (uint32_t pmid) {
40001460:	55                   	push   %ebp
40001461:	89 e5                	mov    %esp,%ebp
40001463:	83 ec 28             	sub    $0x28,%esp
40001466:	8b 45 08             	mov    0x8(%ebp),%eax
40001469:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000146c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000146f:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
40001476:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001479:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000147c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001483:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000148a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001491:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40001498:	89 0c 24             	mov    %ecx,(%esp)
4000149b:	e8 d0 0c 00 00       	call   40002170 <syscall>

    return (HANDLE)state.eax;
400014a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400014a3:	83 c4 28             	add    $0x28,%esp
400014a6:	5d                   	pop    %ebp
400014a7:	c3                   	ret    
400014a8:	66 90                	xchg   %ax,%ax
400014aa:	66 90                	xchg   %ax,%ax
400014ac:	66 90                	xchg   %ax,%ax
400014ae:	66 90                	xchg   %ax,%ax

400014b0 <memset>:
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
400014b0:	55                   	push   %ebp
400014b1:	89 e5                	mov    %esp,%ebp
400014b3:	83 ec 10             	sub    $0x10,%esp
400014b6:	8b 45 10             	mov    0x10(%ebp),%eax
400014b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400014bc:	8b 55 08             	mov    0x8(%ebp),%edx
400014bf:	89 55 fc             	mov    %edx,-0x4(%ebp)
400014c2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400014c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char* p = buf;
400014c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
400014cb:	89 45 f0             	mov    %eax,-0x10(%ebp)

	while (n--) {
400014ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
400014d1:	89 c1                	mov    %eax,%ecx
400014d3:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
400014d9:	89 4d f4             	mov    %ecx,-0xc(%ebp)
400014dc:	3d 00 00 00 00       	cmp    $0x0,%eax
400014e1:	0f 84 1a 00 00 00    	je     40001501 <memset+0x51>
		*p++ = c;
400014e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
400014ea:	88 c1                	mov    %al,%cl
400014ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
400014ef:	89 c2                	mov    %eax,%edx
400014f1:	81 c2 01 00 00 00    	add    $0x1,%edx
400014f7:	89 55 f0             	mov    %edx,-0x10(%ebp)
400014fa:	88 08                	mov    %cl,(%eax)
	}
400014fc:	e9 cd ff ff ff       	jmp    400014ce <memset+0x1e>

	return buf;
40001501:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001504:	83 c4 10             	add    $0x10,%esp
40001507:	5d                   	pop    %ebp
40001508:	c3                   	ret    
40001509:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40001510 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
40001510:	55                   	push   %ebp
40001511:	89 e5                	mov    %esp,%ebp
40001513:	83 ec 14             	sub    $0x14,%esp
40001516:	8b 45 10             	mov    0x10(%ebp),%eax
40001519:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000151c:	8b 55 08             	mov    0x8(%ebp),%edx
4000151f:	89 55 fc             	mov    %edx,-0x4(%ebp)
40001522:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001525:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char* d = dest;
40001528:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000152b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	const unsigned char* s = src;
4000152e:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001531:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (n--) {
40001534:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001537:	89 c1                	mov    %eax,%ecx
40001539:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
4000153f:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40001542:	3d 00 00 00 00       	cmp    $0x0,%eax
40001547:	0f 84 25 00 00 00    	je     40001572 <memcpy+0x62>
		*d++ = *s++;
4000154d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001550:	89 c1                	mov    %eax,%ecx
40001552:	81 c1 01 00 00 00    	add    $0x1,%ecx
40001558:	89 4d ec             	mov    %ecx,-0x14(%ebp)
4000155b:	8a 10                	mov    (%eax),%dl
4000155d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001560:	89 c1                	mov    %eax,%ecx
40001562:	81 c1 01 00 00 00    	add    $0x1,%ecx
40001568:	89 4d f0             	mov    %ecx,-0x10(%ebp)
4000156b:	88 10                	mov    %dl,(%eax)
	}
4000156d:	e9 c2 ff ff ff       	jmp    40001534 <memcpy+0x24>

	return dest;
40001572:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001575:	83 c4 14             	add    $0x14,%esp
40001578:	5d                   	pop    %ebp
40001579:	c3                   	ret    
4000157a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

40001580 <memcmp>:
}

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
40001580:	55                   	push   %ebp
40001581:	89 e5                	mov    %esp,%ebp
40001583:	83 ec 1c             	sub    $0x1c,%esp
40001586:	8b 45 10             	mov    0x10(%ebp),%eax
40001589:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000158c:	8b 55 08             	mov    0x8(%ebp),%edx
4000158f:	89 55 f8             	mov    %edx,-0x8(%ebp)
40001592:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40001595:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
40001598:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
4000159f:	0f 85 0c 00 00 00    	jne    400015b1 <memcmp+0x31>
        return -1;
400015a5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
400015ac:	e9 a7 00 00 00       	jmp    40001658 <memcmp+0xd8>
    if (ptr2 == 0)
400015b1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
400015b8:	0f 85 0c 00 00 00    	jne    400015ca <memcmp+0x4a>
        return 1;
400015be:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
400015c5:	e9 8e 00 00 00       	jmp    40001658 <memcmp+0xd8>
    if (num == 0)
400015ca:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
400015d1:	0f 85 0c 00 00 00    	jne    400015e3 <memcmp+0x63>
        return 0;
400015d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400015de:	e9 75 00 00 00       	jmp    40001658 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
400015e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
400015e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
400015e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
400015ec:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
400015ef:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400015f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400015f9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
400015fc:	0f 83 4f 00 00 00    	jae    40001651 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
40001602:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001605:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40001608:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
4000160c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4000160f:	8b 55 e8             	mov    -0x18(%ebp),%edx
40001612:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
40001616:	39 c8                	cmp    %ecx,%eax
40001618:	0f 84 1e 00 00 00    	je     4000163c <memcmp+0xbc>
            return pa[i] - pb[i];
4000161e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001621:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40001624:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
40001628:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4000162b:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000162e:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
40001632:	29 c8                	sub    %ecx,%eax
40001634:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001637:	e9 1c 00 00 00       	jmp    40001658 <memcmp+0xd8>
        }
    }
4000163c:	e9 00 00 00 00       	jmp    40001641 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
40001641:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001644:	05 01 00 00 00       	add    $0x1,%eax
40001649:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000164c:	e9 a5 ff ff ff       	jmp    400015f6 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
40001651:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
40001658:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000165b:	83 c4 1c             	add    $0x1c,%esp
4000165e:	5d                   	pop    %ebp
4000165f:	c3                   	ret    

40001660 <strcmp>:

int strcmp(const char* str1, const char* str2) {
40001660:	55                   	push   %ebp
40001661:	89 e5                	mov    %esp,%ebp
40001663:	56                   	push   %esi
40001664:	83 ec 24             	sub    $0x24,%esp
40001667:	8b 45 0c             	mov    0xc(%ebp),%eax
4000166a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000166d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001670:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
40001673:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001676:	89 e1                	mov    %esp,%ecx
40001678:	89 01                	mov    %eax,(%ecx)
4000167a:	e8 61 00 00 00       	call   400016e0 <strlen>
4000167f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
40001682:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001685:	89 e1                	mov    %esp,%ecx
40001687:	89 01                	mov    %eax,(%ecx)
40001689:	e8 52 00 00 00       	call   400016e0 <strlen>
4000168e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
40001691:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001694:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40001697:	0f 8d 0b 00 00 00    	jge    400016a8 <strcmp+0x48>
4000169d:	8b 45 f0             	mov    -0x10(%ebp),%eax
400016a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
400016a3:	e9 06 00 00 00       	jmp    400016ae <strcmp+0x4e>
400016a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
400016ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
400016ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
400016b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
400016b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
400016b7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
400016ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
400016bd:	81 c2 01 00 00 00    	add    $0x1,%edx
400016c3:	c1 e2 00             	shl    $0x0,%edx
400016c6:	89 e6                	mov    %esp,%esi
400016c8:	89 56 08             	mov    %edx,0x8(%esi)
400016cb:	89 4e 04             	mov    %ecx,0x4(%esi)
400016ce:	89 06                	mov    %eax,(%esi)
400016d0:	e8 ab fe ff ff       	call   40001580 <memcmp>
400016d5:	83 c4 24             	add    $0x24,%esp
400016d8:	5e                   	pop    %esi
400016d9:	5d                   	pop    %ebp
400016da:	c3                   	ret    
400016db:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

400016e0 <strlen>:
}

unsigned int strlen(const char* str) {
400016e0:	55                   	push   %ebp
400016e1:	89 e5                	mov    %esp,%ebp
400016e3:	83 ec 0c             	sub    $0xc,%esp
400016e6:	8b 45 08             	mov    0x8(%ebp),%eax
400016e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
400016ec:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
400016f3:	0f 85 0c 00 00 00    	jne    40001705 <strlen+0x25>
        return 0;
400016f9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001700:	e9 37 00 00 00       	jmp    4000173c <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
40001705:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
4000170c:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000170f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001712:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
40001716:	3d 00 00 00 00       	cmp    $0x0,%eax
4000171b:	0f 84 15 00 00 00    	je     40001736 <strlen+0x56>
40001721:	e9 00 00 00 00       	jmp    40001726 <strlen+0x46>
40001726:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001729:	05 01 00 00 00       	add    $0x1,%eax
4000172e:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001731:	e9 d6 ff ff ff       	jmp    4000170c <strlen+0x2c>
        ;
    return i;
40001736:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001739:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
4000173c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000173f:	83 c4 0c             	add    $0xc,%esp
40001742:	5d                   	pop    %ebp
40001743:	c3                   	ret    
40001744:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
4000174b:	00 00 00 00 00 

40001750 <strcpy>:

char* strcpy(char* dest, const char* src) {
40001750:	55                   	push   %ebp
40001751:	89 e5                	mov    %esp,%ebp
40001753:	56                   	push   %esi
40001754:	83 ec 24             	sub    $0x24,%esp
40001757:	8b 45 0c             	mov    0xc(%ebp),%eax
4000175a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000175d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001760:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
40001763:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001766:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001769:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000176c:	89 e6                	mov    %esp,%esi
4000176e:	89 16                	mov    %edx,(%esi)
40001770:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001773:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40001776:	e8 65 ff ff ff       	call   400016e0 <strlen>
4000177b:	c1 e0 00             	shl    $0x0,%eax
4000177e:	05 01 00 00 00       	add    $0x1,%eax
40001783:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001786:	89 0c 24             	mov    %ecx,(%esp)
40001789:	8b 55 ec             	mov    -0x14(%ebp),%edx
4000178c:	89 54 24 04          	mov    %edx,0x4(%esp)
40001790:	89 44 24 08          	mov    %eax,0x8(%esp)
40001794:	e8 77 fd ff ff       	call   40001510 <memcpy>
    return dest;
40001799:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000179c:	83 c4 24             	add    $0x24,%esp
4000179f:	5e                   	pop    %esi
400017a0:	5d                   	pop    %ebp
400017a1:	c3                   	ret    
400017a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
400017a9:	1f 84 00 00 00 00 00 

400017b0 <strclone>:
}

char* strclone(char* str) {
400017b0:	55                   	push   %ebp
400017b1:	89 e5                	mov    %esp,%ebp
400017b3:	83 ec 18             	sub    $0x18,%esp
400017b6:	8b 45 08             	mov    0x8(%ebp),%eax
400017b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
400017bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
400017bf:	89 e1                	mov    %esp,%ecx
400017c1:	89 01                	mov    %eax,(%ecx)
400017c3:	e8 18 ff ff ff       	call   400016e0 <strlen>
400017c8:	c1 e0 00             	shl    $0x0,%eax
400017cb:	05 01 00 00 00       	add    $0x1,%eax
400017d0:	89 04 24             	mov    %eax,(%esp)
400017d3:	e8 58 02 00 00       	call   40001a30 <malloc>
400017d8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
400017db:	8b 45 f8             	mov    -0x8(%ebp),%eax
400017de:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400017e1:	89 e2                	mov    %esp,%edx
400017e3:	89 4a 04             	mov    %ecx,0x4(%edx)
400017e6:	89 02                	mov    %eax,(%edx)
400017e8:	e8 63 ff ff ff       	call   40001750 <strcpy>

    return ret;
400017ed:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400017f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
400017f3:	89 c8                	mov    %ecx,%eax
400017f5:	83 c4 18             	add    $0x18,%esp
400017f8:	5d                   	pop    %ebp
400017f9:	c3                   	ret    
400017fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

40001800 <strtok>:
}

char* sp = NULL; /* the start position of the string */

char* strtok(char* str, const char* delimiters) {
40001800:	55                   	push   %ebp
40001801:	89 e5                	mov    %esp,%ebp
40001803:	83 ec 18             	sub    $0x18,%esp
40001806:	8b 45 0c             	mov    0xc(%ebp),%eax
40001809:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000180c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
4000180f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) {
40001812:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
40001819:	0f 84 22 00 00 00    	je     40001841 <strtok+0x41>
        return strtoknc(strclone(str), delimiters);
4000181f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001822:	89 04 24             	mov    %eax,(%esp)
40001825:	e8 86 ff ff ff       	call   400017b0 <strclone>
4000182a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
4000182d:	89 04 24             	mov    %eax,(%esp)
40001830:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001834:	e8 37 00 00 00       	call   40001870 <strtoknc>
40001839:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000183c:	e9 1e 00 00 00       	jmp    4000185f <strtok+0x5f>
40001841:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
40001846:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001849:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
40001850:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001854:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001857:	e8 14 00 00 00       	call   40001870 <strtoknc>
4000185c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
4000185f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001862:	83 c4 18             	add    $0x18,%esp
40001865:	5d                   	pop    %ebp
40001866:	c3                   	ret    
40001867:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
4000186e:	00 00 

40001870 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
40001870:	55                   	push   %ebp
40001871:	89 e5                	mov    %esp,%ebp
40001873:	83 ec 28             	sub    $0x28,%esp
40001876:	8b 45 0c             	mov    0xc(%ebp),%eax
40001879:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000187c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
4000187f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
40001882:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
40001889:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000188c:	89 e1                	mov    %esp,%ecx
4000188e:	89 01                	mov    %eax,(%ecx)
40001890:	e8 4b fe ff ff       	call   400016e0 <strlen>
40001895:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
40001898:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
4000189f:	0f 85 0c 00 00 00    	jne    400018b1 <strtoknc+0x41>
        return 0;
400018a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400018ac:	e9 70 01 00 00       	jmp    40001a21 <strtoknc+0x1b1>

    /* if the original string has nothing left */
    if (!str && !sp)
400018b1:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
400018b8:	0f 85 1c 00 00 00    	jne    400018da <strtoknc+0x6a>
400018be:	81 3d 10 50 00 40 00 	cmpl   $0x0,0x40005010
400018c5:	00 00 00 
400018c8:	0f 85 0c 00 00 00    	jne    400018da <strtoknc+0x6a>
        return 0;
400018ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400018d5:	e9 47 01 00 00       	jmp    40001a21 <strtoknc+0x1b1>

    /* initialize the sp during the first call */
    if (str)
400018da:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
400018e1:	0f 84 08 00 00 00    	je     400018ef <strtoknc+0x7f>
        sp = str;
400018e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
400018ea:	a3 10 50 00 40       	mov    %eax,0x40005010

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
400018ef:	a1 10 50 00 40       	mov    0x40005010,%eax
400018f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
400018f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400018fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001901:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40001904:	0f 8d 3d 00 00 00    	jge    40001947 <strtoknc+0xd7>
            if (*p_start == delimiters[i]) {
4000190a:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000190d:	0f be 00             	movsbl (%eax),%eax
40001910:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001913:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001916:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
4000191a:	39 c8                	cmp    %ecx,%eax
4000191c:	0f 85 10 00 00 00    	jne    40001932 <strtoknc+0xc2>
                p_start++;
40001922:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001925:	05 01 00 00 00       	add    $0x1,%eax
4000192a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
4000192d:	e9 15 00 00 00       	jmp    40001947 <strtoknc+0xd7>
            }
        }
40001932:	e9 00 00 00 00       	jmp    40001937 <strtoknc+0xc7>
        sp = str;

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
40001937:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000193a:	05 01 00 00 00       	add    $0x1,%eax
4000193f:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001942:	e9 b7 ff ff ff       	jmp    400018fe <strtoknc+0x8e>
                p_start++;
                break;
            }
        }

        if (i == len) {
40001947:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000194a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
4000194d:	0f 85 0d 00 00 00    	jne    40001960 <strtoknc+0xf0>
            sp = p_start;
40001953:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001956:	a3 10 50 00 40       	mov    %eax,0x40005010
            break;
4000195b:	e9 05 00 00 00       	jmp    40001965 <strtoknc+0xf5>
        }
    }
40001960:	e9 92 ff ff ff       	jmp    400018f7 <strtoknc+0x87>

    /* return NULL if nothing left */
    if (*sp == '\0') {
40001965:	a1 10 50 00 40       	mov    0x40005010,%eax
4000196a:	0f be 00             	movsbl (%eax),%eax
4000196d:	3d 00 00 00 00       	cmp    $0x0,%eax
40001972:	0f 85 17 00 00 00    	jne    4000198f <strtoknc+0x11f>
        sp = NULL;
40001978:	c7 05 10 50 00 40 00 	movl   $0x0,0x40005010
4000197f:	00 00 00 
        return sp;
40001982:	a1 10 50 00 40       	mov    0x40005010,%eax
40001987:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000198a:	e9 92 00 00 00       	jmp    40001a21 <strtoknc+0x1b1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
4000198f:	e9 00 00 00 00       	jmp    40001994 <strtoknc+0x124>
40001994:	a1 10 50 00 40       	mov    0x40005010,%eax
40001999:	0f be 00             	movsbl (%eax),%eax
4000199c:	3d 00 00 00 00       	cmp    $0x0,%eax
400019a1:	0f 84 74 00 00 00    	je     40001a1b <strtoknc+0x1ab>
        for (i = 0; i < len; i++) {
400019a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400019ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
400019b1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
400019b4:	0f 8d 3c 00 00 00    	jge    400019f6 <strtoknc+0x186>
            if (*sp == delimiters[i]) {
400019ba:	a1 10 50 00 40       	mov    0x40005010,%eax
400019bf:	0f be 00             	movsbl (%eax),%eax
400019c2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400019c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
400019c8:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
400019cc:	39 c8                	cmp    %ecx,%eax
400019ce:	0f 85 0d 00 00 00    	jne    400019e1 <strtoknc+0x171>
                *sp = '\0';
400019d4:	a1 10 50 00 40       	mov    0x40005010,%eax
400019d9:	c6 00 00             	movb   $0x0,(%eax)
                break;
400019dc:	e9 15 00 00 00       	jmp    400019f6 <strtoknc+0x186>
            }
        }
400019e1:	e9 00 00 00 00       	jmp    400019e6 <strtoknc+0x176>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
400019e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400019e9:	05 01 00 00 00       	add    $0x1,%eax
400019ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
400019f1:	e9 b8 ff ff ff       	jmp    400019ae <strtoknc+0x13e>
                *sp = '\0';
                break;
            }
        }

        sp++;
400019f6:	a1 10 50 00 40       	mov    0x40005010,%eax
400019fb:	05 01 00 00 00       	add    $0x1,%eax
40001a00:	a3 10 50 00 40       	mov    %eax,0x40005010
        if (i < len)
40001a05:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a08:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40001a0b:	0f 8d 05 00 00 00    	jge    40001a16 <strtoknc+0x1a6>
            break;
40001a11:	e9 05 00 00 00       	jmp    40001a1b <strtoknc+0x1ab>
    }
40001a16:	e9 79 ff ff ff       	jmp    40001994 <strtoknc+0x124>

    return p_start;
40001a1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001a1e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40001a21:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001a24:	83 c4 28             	add    $0x28,%esp
40001a27:	5d                   	pop    %ebp
40001a28:	c3                   	ret    
40001a29:	66 90                	xchg   %ax,%ax
40001a2b:	66 90                	xchg   %ax,%ax
40001a2d:	66 90                	xchg   %ax,%ax
40001a2f:	90                   	nop

40001a30 <malloc>:
    }

    append_to_list(&first_free, tf);
}

void* malloc(size_t size) {
40001a30:	55                   	push   %ebp
40001a31:	89 e5                	mov    %esp,%ebp
40001a33:	83 ec 38             	sub    $0x38,%esp
40001a36:	8b 45 08             	mov    0x8(%ebp),%eax
40001a39:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
40001a3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
40001a43:	a1 1c 50 00 40       	mov    0x4000501c,%eax
40001a48:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
40001a4b:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001a52:	0f 84 27 00 00 00    	je     40001a7f <malloc+0x4f>
        if (cur->size >= size) {
40001a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a5b:	8b 00                	mov    (%eax),%eax
40001a5d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40001a60:	0f 82 05 00 00 00    	jb     40001a6b <malloc+0x3b>
            break;
40001a66:	e9 14 00 00 00       	jmp    40001a7f <malloc+0x4f>
        }
        last = cur;
40001a6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
40001a71:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a74:	8b 40 08             	mov    0x8(%eax),%eax
40001a77:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001a7a:	e9 cc ff ff ff       	jmp    40001a4b <malloc+0x1b>

    if (cur == 0) {
40001a7f:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001a86:	0f 85 bc 00 00 00    	jne    40001b48 <malloc+0x118>
        uint32_t pgs = size / PAGESIZE;
40001a8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001a8f:	c1 e8 0c             	shr    $0xc,%eax
40001a92:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
40001a95:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001a98:	25 ff 0f 00 00       	and    $0xfff,%eax
40001a9d:	3d 00 00 00 00       	cmp    $0x0,%eax
40001aa2:	0f 84 0b 00 00 00    	je     40001ab3 <malloc+0x83>
            pgs++;
40001aa8:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001aab:	05 01 00 00 00       	add    $0x1,%eax
40001ab0:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
40001ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001ab6:	89 04 24             	mov    %eax,(%esp)
40001ab9:	e8 c2 05 00 00       	call   40002080 <vmm_alloc_cont>
40001abe:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
40001ac1:	e8 7a 04 00 00       	call   40001f40 <pop_unused_node>
40001ac6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
40001ac9:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001acc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40001acf:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
40001ad2:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001ad5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40001ad8:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
40001ada:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001add:	c1 e0 0c             	shl    $0xc,%eax
40001ae0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40001ae3:	0f 86 3c 00 00 00    	jbe    40001b25 <malloc+0xf5>
            struct memory_node* free = pop_unused_node();
40001ae9:	e8 52 04 00 00       	call   40001f40 <pop_unused_node>
40001aee:	8d 0d 1c 50 00 40    	lea    0x4000501c,%ecx
40001af4:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
40001af7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001afa:	8b 40 04             	mov    0x4(%eax),%eax
40001afd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40001b00:	03 02                	add    (%edx),%eax
40001b02:	8b 55 e0             	mov    -0x20(%ebp),%edx
40001b05:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
40001b08:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001b0b:	c1 e0 0c             	shl    $0xc,%eax
40001b0e:	2b 45 f8             	sub    -0x8(%ebp),%eax
40001b11:	8b 55 e0             	mov    -0x20(%ebp),%edx
40001b14:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
40001b16:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001b19:	89 0c 24             	mov    %ecx,(%esp)
40001b1c:	89 44 24 04          	mov    %eax,0x4(%esp)
40001b20:	e8 bb 00 00 00       	call   40001be0 <append_to_list>
40001b25:	8d 05 18 50 00 40    	lea    0x40005018,%eax
        }

        append_to_list(&first_used, fill);
40001b2b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40001b2e:	89 04 24             	mov    %eax,(%esp)
40001b31:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001b35:	e8 a6 00 00 00       	call   40001be0 <append_to_list>

        return (void*) fill->address;
40001b3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001b3d:	8b 40 04             	mov    0x4(%eax),%eax
40001b40:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001b43:	e9 89 00 00 00       	jmp    40001bd1 <malloc+0x1a1>
40001b48:	8d 05 1c 50 00 40    	lea    0x4000501c,%eax
    } else {
        uint32_t freesize = cur->size - size;
40001b4e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001b51:	8b 09                	mov    (%ecx),%ecx
40001b53:	2b 4d f8             	sub    -0x8(%ebp),%ecx
40001b56:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
40001b59:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001b5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
40001b5f:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
40001b61:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001b64:	89 04 24             	mov    %eax,(%esp)
40001b67:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001b6b:	e8 a0 00 00 00       	call   40001c10 <remove_from_list>
40001b70:	8d 05 18 50 00 40    	lea    0x40005018,%eax
        append_to_list(&first_used, cur);
40001b76:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001b79:	89 04 24             	mov    %eax,(%esp)
40001b7c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001b80:	e8 5b 00 00 00       	call   40001be0 <append_to_list>

        if (freesize > 0) {
40001b85:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
40001b8c:	0f 86 36 00 00 00    	jbe    40001bc8 <malloc+0x198>
            struct memory_node* free = pop_unused_node();
40001b92:	e8 a9 03 00 00       	call   40001f40 <pop_unused_node>
40001b97:	8d 0d 1c 50 00 40    	lea    0x4000501c,%ecx
40001b9d:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
40001ba0:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001ba3:	8b 40 04             	mov    0x4(%eax),%eax
40001ba6:	8b 55 f0             	mov    -0x10(%ebp),%edx
40001ba9:	03 02                	add    (%edx),%eax
40001bab:	8b 55 d8             	mov    -0x28(%ebp),%edx
40001bae:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
40001bb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001bb4:	8b 55 d8             	mov    -0x28(%ebp),%edx
40001bb7:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
40001bb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
40001bbc:	89 0c 24             	mov    %ecx,(%esp)
40001bbf:	89 44 24 04          	mov    %eax,0x4(%esp)
40001bc3:	e8 18 00 00 00       	call   40001be0 <append_to_list>
        }

        return (void*) cur->address;
40001bc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001bcb:	8b 40 04             	mov    0x4(%eax),%eax
40001bce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
40001bd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001bd4:	83 c4 38             	add    $0x38,%esp
40001bd7:	5d                   	pop    %ebp
40001bd8:	c3                   	ret    
40001bd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40001be0 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
40001be0:	55                   	push   %ebp
40001be1:	89 e5                	mov    %esp,%ebp
40001be3:	83 ec 08             	sub    $0x8,%esp
40001be6:	8b 45 0c             	mov    0xc(%ebp),%eax
40001be9:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001bec:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40001bef:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
40001bf2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001bf5:	8b 00                	mov    (%eax),%eax
40001bf7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001bfa:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
40001bfd:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001c00:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001c03:	89 01                	mov    %eax,(%ecx)
}
40001c05:	83 c4 08             	add    $0x8,%esp
40001c08:	5d                   	pop    %ebp
40001c09:	c3                   	ret    
40001c0a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

40001c10 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
40001c10:	55                   	push   %ebp
40001c11:	89 e5                	mov    %esp,%ebp
40001c13:	83 ec 10             	sub    $0x10,%esp
40001c16:	8b 45 0c             	mov    0xc(%ebp),%eax
40001c19:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001c1c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40001c1f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
40001c22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
40001c29:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001c2c:	8b 00                	mov    (%eax),%eax
40001c2e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
40001c31:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001c38:	0f 84 4e 00 00 00    	je     40001c8c <remove_from_list+0x7c>
        if (cur == element) {
40001c3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c41:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40001c44:	0f 85 2e 00 00 00    	jne    40001c78 <remove_from_list+0x68>
            if (last == 0) {
40001c4a:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001c51:	0f 85 10 00 00 00    	jne    40001c67 <remove_from_list+0x57>
                *root = cur->next;
40001c57:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c5a:	8b 40 08             	mov    0x8(%eax),%eax
40001c5d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001c60:	89 01                	mov    %eax,(%ecx)
                return;
40001c62:	e9 25 00 00 00       	jmp    40001c8c <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
40001c67:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c6a:	8b 40 08             	mov    0x8(%eax),%eax
40001c6d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001c70:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
40001c73:	e9 14 00 00 00       	jmp    40001c8c <remove_from_list+0x7c>
            }
        }
        last = cur;
40001c78:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
40001c7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c81:	8b 40 08             	mov    0x8(%eax),%eax
40001c84:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001c87:	e9 a5 ff ff ff       	jmp    40001c31 <remove_from_list+0x21>
}
40001c8c:	83 c4 10             	add    $0x10,%esp
40001c8f:	5d                   	pop    %ebp
40001c90:	c3                   	ret    
40001c91:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001c98:	0f 1f 84 00 00 00 00 
40001c9f:	00 

40001ca0 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
40001ca0:	55                   	push   %ebp
40001ca1:	89 e5                	mov    %esp,%ebp
40001ca3:	83 ec 28             	sub    $0x28,%esp
40001ca6:	8b 45 0c             	mov    0xc(%ebp),%eax
40001ca9:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001cac:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40001caf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
40001cb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001cb5:	0f af 45 f8          	imul   -0x8(%ebp),%eax
40001cb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
40001cbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001cbf:	89 04 24             	mov    %eax,(%esp)
40001cc2:	e8 69 fd ff ff       	call   40001a30 <malloc>
40001cc7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
40001cca:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001cd1:	0f 84 22 00 00 00    	je     40001cf9 <calloc+0x59>
40001cd7:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
40001cdc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001cdf:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001ce2:	89 0c 24             	mov    %ecx,(%esp)
40001ce5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40001cec:	00 
40001ced:	89 54 24 08          	mov    %edx,0x8(%esp)
40001cf1:	89 45 ec             	mov    %eax,-0x14(%ebp)
40001cf4:	e8 b7 f7 ff ff       	call   400014b0 <memset>
    }

    return p;
40001cf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001cfc:	83 c4 28             	add    $0x28,%esp
40001cff:	5d                   	pop    %ebp
40001d00:	c3                   	ret    
40001d01:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001d08:	0f 1f 84 00 00 00 00 
40001d0f:	00 

40001d10 <realloc>:
}

void* realloc(void* ptr, size_t size) {
40001d10:	55                   	push   %ebp
40001d11:	89 e5                	mov    %esp,%ebp
40001d13:	83 ec 28             	sub    $0x28,%esp
40001d16:	8b 45 0c             	mov    0xc(%ebp),%eax
40001d19:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001d1c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001d1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
40001d22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
40001d29:	a1 18 50 00 40       	mov    0x40005018,%eax
40001d2e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
40001d31:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
40001d38:	0f 84 8e 00 00 00    	je     40001dcc <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
40001d3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001d41:	8b 40 04             	mov    0x4(%eax),%eax
40001d44:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001d47:	39 c8                	cmp    %ecx,%eax
40001d49:	0f 85 69 00 00 00    	jne    40001db8 <realloc+0xa8>
            if (size == 0) {
40001d4f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001d56:	0f 85 17 00 00 00    	jne    40001d73 <realloc+0x63>
                free(ptr);
40001d5c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001d5f:	89 04 24             	mov    %eax,(%esp)
40001d62:	e8 79 00 00 00       	call   40001de0 <free>
                return 0;
40001d67:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001d6e:	e9 60 00 00 00       	jmp    40001dd3 <realloc+0xc3>
            } else {
                void* new = malloc(size);
40001d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001d76:	89 04 24             	mov    %eax,(%esp)
40001d79:	e8 b2 fc ff ff       	call   40001a30 <malloc>
40001d7e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
40001d81:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001d84:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40001d87:	8b 49 04             	mov    0x4(%ecx),%ecx
40001d8a:	8b 55 ec             	mov    -0x14(%ebp),%edx
40001d8d:	8b 12                	mov    (%edx),%edx
40001d8f:	89 04 24             	mov    %eax,(%esp)
40001d92:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001d96:	89 54 24 08          	mov    %edx,0x8(%esp)
40001d9a:	e8 71 f7 ff ff       	call   40001510 <memcpy>
                free((void*) cur->address);
40001d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001da2:	8b 40 04             	mov    0x4(%eax),%eax
40001da5:	89 04 24             	mov    %eax,(%esp)
40001da8:	e8 33 00 00 00       	call   40001de0 <free>

                return new;
40001dad:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001db0:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001db3:	e9 1b 00 00 00       	jmp    40001dd3 <realloc+0xc3>
            }
        }
        last = cur;
40001db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001dbb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
40001dbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001dc1:	8b 40 08             	mov    0x8(%eax),%eax
40001dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
40001dc7:	e9 65 ff ff ff       	jmp    40001d31 <realloc+0x21>
    return 0;
40001dcc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
40001dd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001dd6:	83 c4 28             	add    $0x28,%esp
40001dd9:	5d                   	pop    %ebp
40001dda:	c3                   	ret    
40001ddb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40001de0 <free>:

void free(void* ptr) {
40001de0:	55                   	push   %ebp
40001de1:	89 e5                	mov    %esp,%ebp
40001de3:	83 ec 18             	sub    $0x18,%esp
40001de6:	8b 45 08             	mov    0x8(%ebp),%eax
40001de9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
40001dec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
40001df3:	a1 18 50 00 40       	mov    0x40005018,%eax
40001df8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
40001dfb:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001e02:	0f 84 35 00 00 00    	je     40001e3d <free+0x5d>
        if (cur->address == (uint32_t) ptr) {
40001e08:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001e0b:	8b 40 04             	mov    0x4(%eax),%eax
40001e0e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001e11:	39 c8                	cmp    %ecx,%eax
40001e13:	0f 85 10 00 00 00    	jne    40001e29 <free+0x49>
            merge_into_frees(cur);
40001e19:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001e1c:	89 04 24             	mov    %eax,(%esp)
40001e1f:	e8 2c 00 00 00       	call   40001e50 <merge_into_frees>
            break;
40001e24:	e9 14 00 00 00       	jmp    40001e3d <free+0x5d>
        }
        last = cur;
40001e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001e2c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
40001e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001e32:	8b 40 08             	mov    0x8(%eax),%eax
40001e35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
40001e38:	e9 be ff ff ff       	jmp    40001dfb <free+0x1b>
}
40001e3d:	83 c4 18             	add    $0x18,%esp
40001e40:	5d                   	pop    %ebp
40001e41:	c3                   	ret    
40001e42:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001e49:	1f 84 00 00 00 00 00 

40001e50 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
40001e50:	55                   	push   %ebp
40001e51:	89 e5                	mov    %esp,%ebp
40001e53:	56                   	push   %esi
40001e54:	83 ec 14             	sub    $0x14,%esp
40001e57:	8b 45 08             	mov    0x8(%ebp),%eax
40001e5a:	8d 0d 18 50 00 40    	lea    0x40005018,%ecx
40001e60:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
40001e63:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001e66:	89 0c 24             	mov    %ecx,(%esp)
40001e69:	89 44 24 04          	mov    %eax,0x4(%esp)
40001e6d:	e8 9e fd ff ff       	call   40001c10 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
40001e72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
40001e79:	a1 1c 50 00 40       	mov    0x4000501c,%eax
40001e7e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
40001e81:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001e88:	0f 84 92 00 00 00    	je     40001f20 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
40001e8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001e91:	8b 40 04             	mov    0x4(%eax),%eax
40001e94:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001e97:	03 01                	add    (%ecx),%eax
40001e99:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001e9c:	3b 41 04             	cmp    0x4(%ecx),%eax
40001e9f:	0f 85 26 00 00 00    	jne    40001ecb <merge_into_frees+0x7b>
40001ea5:	8d 05 1c 50 00 40    	lea    0x4000501c,%eax
            tf->address = cur->address;
40001eab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001eae:	8b 49 04             	mov    0x4(%ecx),%ecx
40001eb1:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001eb4:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
40001eb7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001eba:	89 04 24             	mov    %eax,(%esp)
40001ebd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001ec1:	e8 4a fd ff ff       	call   40001c10 <remove_from_list>
            goto editedList;
40001ec6:	e9 a7 ff ff ff       	jmp    40001e72 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
40001ecb:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001ece:	8b 40 04             	mov    0x4(%eax),%eax
40001ed1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001ed4:	8b 49 04             	mov    0x4(%ecx),%ecx
40001ed7:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001eda:	03 0a                	add    (%edx),%ecx
40001edc:	39 c8                	cmp    %ecx,%eax
40001ede:	0f 85 28 00 00 00    	jne    40001f0c <merge_into_frees+0xbc>
40001ee4:	8d 05 1c 50 00 40    	lea    0x4000501c,%eax
            tf->size += cur->size;
40001eea:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001eed:	8b 09                	mov    (%ecx),%ecx
40001eef:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001ef2:	8b 32                	mov    (%edx),%esi
40001ef4:	01 ce                	add    %ecx,%esi
40001ef6:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
40001ef8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001efb:	89 04 24             	mov    %eax,(%esp)
40001efe:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001f02:	e8 09 fd ff ff       	call   40001c10 <remove_from_list>
            goto editedList;
40001f07:	e9 66 ff ff ff       	jmp    40001e72 <merge_into_frees+0x22>
        }

        last = cur;
40001f0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001f0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
40001f12:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001f15:	8b 40 08             	mov    0x8(%eax),%eax
40001f18:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001f1b:	e9 61 ff ff ff       	jmp    40001e81 <merge_into_frees+0x31>
40001f20:	8d 05 1c 50 00 40    	lea    0x4000501c,%eax

    append_to_list(&first_free, tf);
40001f26:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001f29:	89 04 24             	mov    %eax,(%esp)
40001f2c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001f30:	e8 ab fc ff ff       	call   40001be0 <append_to_list>
}
40001f35:	83 c4 14             	add    $0x14,%esp
40001f38:	5e                   	pop    %esi
40001f39:	5d                   	pop    %ebp
40001f3a:	c3                   	ret    
40001f3b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40001f40 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
40001f40:	55                   	push   %ebp
40001f41:	89 e5                	mov    %esp,%ebp
40001f43:	83 ec 08             	sub    $0x8,%esp
40001f46:	8d 05 14 50 00 40    	lea    0x40005014,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
40001f4c:	89 04 24             	mov    %eax,(%esp)
40001f4f:	e8 3c 00 00 00       	call   40001f90 <pop_from_list>
40001f54:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
40001f57:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
40001f5e:	0f 85 1b 00 00 00    	jne    40001f7f <pop_unused_node+0x3f>
        allocate_unused_nodes();
40001f64:	e8 77 00 00 00       	call   40001fe0 <allocate_unused_nodes>
40001f69:	8d 05 14 50 00 40    	lea    0x40005014,%eax
        ret = pop_from_list(&first_unused);
40001f6f:	89 04 24             	mov    %eax,(%esp)
40001f72:	e8 19 00 00 00       	call   40001f90 <pop_from_list>
40001f77:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
40001f7a:	e9 d8 ff ff ff       	jmp    40001f57 <pop_unused_node+0x17>

    return ret;
40001f7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001f82:	83 c4 08             	add    $0x8,%esp
40001f85:	5d                   	pop    %ebp
40001f86:	c3                   	ret    
40001f87:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
40001f8e:	00 00 

40001f90 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
40001f90:	55                   	push   %ebp
40001f91:	89 e5                	mov    %esp,%ebp
40001f93:	83 ec 18             	sub    $0x18,%esp
40001f96:	8b 45 08             	mov    0x8(%ebp),%eax
40001f99:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
40001f9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001f9f:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
40001fa5:	0f 85 0c 00 00 00    	jne    40001fb7 <pop_from_list+0x27>
        return 0;
40001fab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001fb2:	e9 20 00 00 00       	jmp    40001fd7 <pop_from_list+0x47>
    struct memory_node* pop = *root;
40001fb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001fba:	8b 00                	mov    (%eax),%eax
40001fbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
40001fbf:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001fc2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001fc5:	89 04 24             	mov    %eax,(%esp)
40001fc8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001fcc:	e8 3f fc ff ff       	call   40001c10 <remove_from_list>
    return pop;
40001fd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001fd4:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40001fd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001fda:	83 c4 18             	add    $0x18,%esp
40001fdd:	5d                   	pop    %ebp
40001fde:	c3                   	ret    
40001fdf:	90                   	nop

40001fe0 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
40001fe0:	55                   	push   %ebp
40001fe1:	89 e5                	mov    %esp,%ebp
40001fe3:	83 ec 28             	sub    $0x28,%esp
40001fe6:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
40001feb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
40001ff2:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001ff5:	e8 86 00 00 00       	call   40002080 <vmm_alloc_cont>
40001ffa:	b9 00 00 00 00       	mov    $0x0,%ecx
40001fff:	ba 00 10 00 00       	mov    $0x1000,%edx
40002004:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
40002007:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000200a:	89 04 24             	mov    %eax,(%esp)
4000200d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40002014:	00 
40002015:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
4000201c:	00 
4000201d:	89 55 f0             	mov    %edx,-0x10(%ebp)
40002020:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40002023:	e8 88 f4 ff ff       	call   400014b0 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
40002028:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
4000202f:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
40002036:	0f 83 30 00 00 00    	jae    4000206c <allocate_unused_nodes+0x8c>
4000203c:	8d 05 14 50 00 40    	lea    0x40005014,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
40002042:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40002045:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002048:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
4000204e:	01 ca                	add    %ecx,%edx
40002050:	89 04 24             	mov    %eax,(%esp)
40002053:	89 54 24 04          	mov    %edx,0x4(%esp)
40002057:	e8 84 fb ff ff       	call   40001be0 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
4000205c:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000205f:	05 01 00 00 00       	add    $0x1,%eax
40002064:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002067:	e9 c3 ff ff ff       	jmp    4000202f <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
4000206c:	83 c4 28             	add    $0x28,%esp
4000206f:	5d                   	pop    %ebp
40002070:	c3                   	ret    
40002071:	66 90                	xchg   %ax,%ax
40002073:	66 90                	xchg   %ax,%ax
40002075:	66 90                	xchg   %ax,%ax
40002077:	66 90                	xchg   %ax,%ax
40002079:	66 90                	xchg   %ax,%ax
4000207b:	66 90                	xchg   %ax,%ax
4000207d:	66 90                	xchg   %ax,%ax
4000207f:	90                   	nop

40002080 <vmm_alloc_cont>:
#include "vmmcall.h"

void* vmm_alloc_cont (uint32_t cont) {
40002080:	55                   	push   %ebp
40002081:	89 e5                	mov    %esp,%ebp
40002083:	83 ec 28             	sub    $0x28,%esp
40002086:	8b 45 08             	mov    0x8(%ebp),%eax
40002089:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000208c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct regstate state = {
4000208f:	c7 45 e0 cb 00 00 00 	movl   $0xcb,-0x20(%ebp)
40002096:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002099:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000209c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400020a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400020aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400020b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);  
400020b8:	89 0c 24             	mov    %ecx,(%esp)
400020bb:	e8 b0 00 00 00       	call   40002170 <syscall>
  
  return (void*)state.eax;
400020c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400020c3:	83 c4 28             	add    $0x28,%esp
400020c6:	5d                   	pop    %ebp
400020c7:	c3                   	ret    
400020c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
400020cf:	00 

400020d0 <vmm_free>:
}

void vmm_free (void* vaddr) {
400020d0:	55                   	push   %ebp
400020d1:	89 e5                	mov    %esp,%ebp
400020d3:	83 ec 28             	sub    $0x28,%esp
400020d6:	8b 45 08             	mov    0x8(%ebp),%eax
400020d9:	8d 4d e0             	lea    -0x20(%ebp),%ecx
400020dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct regstate state = {
400020df:	c7 45 e0 cc 00 00 00 	movl   $0xcc,-0x20(%ebp)
400020e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
400020e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400020ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400020f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400020fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40002101:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);  
40002108:	89 0c 24             	mov    %ecx,(%esp)
4000210b:	e8 60 00 00 00       	call   40002170 <syscall>
}
40002110:	83 c4 28             	add    $0x28,%esp
40002113:	5d                   	pop    %ebp
40002114:	c3                   	ret    
40002115:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
4000211c:	00 00 00 00 

40002120 <print_memstat>:

void print_memstat() {
40002120:	55                   	push   %ebp
40002121:	89 e5                	mov    %esp,%ebp
40002123:	56                   	push   %esi
40002124:	83 ec 34             	sub    $0x34,%esp
40002127:	8d 45 e0             	lea    -0x20(%ebp),%eax
4000212a:	8d 0d 84 40 00 40    	lea    0x40004084,%ecx
40002130:	ba 18 00 00 00       	mov    $0x18,%edx
  struct regstate state = {
40002135:	89 c6                	mov    %eax,%esi
40002137:	89 34 24             	mov    %esi,(%esp)
4000213a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000213e:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
40002145:	00 
40002146:	89 45 dc             	mov    %eax,-0x24(%ebp)
40002149:	89 55 d8             	mov    %edx,-0x28(%ebp)
4000214c:	e8 bf f3 ff ff       	call   40001510 <memcpy>
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);  
40002151:	8b 45 dc             	mov    -0x24(%ebp),%eax
40002154:	89 04 24             	mov    %eax,(%esp)
40002157:	e8 14 00 00 00       	call   40002170 <syscall>
}
4000215c:	83 c4 34             	add    $0x34,%esp
4000215f:	5e                   	pop    %esi
40002160:	5d                   	pop    %ebp
40002161:	c3                   	ret    
40002162:	66 90                	xchg   %ax,%ax
40002164:	66 90                	xchg   %ax,%ax
40002166:	66 90                	xchg   %ax,%ax
40002168:	66 90                	xchg   %ax,%ax
4000216a:	66 90                	xchg   %ax,%ax
4000216c:	66 90                	xchg   %ax,%ax
4000216e:	66 90                	xchg   %ax,%ax

40002170 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
40002170:	55                   	push   %ebp
40002171:	89 e5                	mov    %esp,%ebp
40002173:	53                   	push   %ebx
40002174:	57                   	push   %edi
40002175:	56                   	push   %esi
40002176:	83 ec 3c             	sub    $0x3c,%esp
40002179:	8b 45 08             	mov    0x8(%ebp),%eax
4000217c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	asm("int $0x30"
4000217f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002182:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40002185:	8b 55 f0             	mov    -0x10(%ebp),%edx
40002188:	8b 75 f0             	mov    -0x10(%ebp),%esi
4000218b:	8b 7d f0             	mov    -0x10(%ebp),%edi
4000218e:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40002191:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002194:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002197:	8b 00                	mov    (%eax),%eax
40002199:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000219c:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000219f:	8b 40 04             	mov    0x4(%eax),%eax
400021a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400021a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400021a8:	8b 40 08             	mov    0x8(%eax),%eax
400021ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
400021ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
400021b1:	8b 40 0c             	mov    0xc(%eax),%eax
400021b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
400021b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400021ba:	8b 40 10             	mov    0x10(%eax),%eax
400021bd:	89 45 d8             	mov    %eax,-0x28(%ebp)
400021c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400021c3:	8b 40 14             	mov    0x14(%eax),%eax
400021c6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400021c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
400021cc:	89 4d d0             	mov    %ecx,-0x30(%ebp)
400021cf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400021d2:	89 5d cc             	mov    %ebx,-0x34(%ebp)
400021d5:	89 cb                	mov    %ecx,%ebx
400021d7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400021da:	89 55 c8             	mov    %edx,-0x38(%ebp)
400021dd:	8b 55 dc             	mov    -0x24(%ebp),%edx
400021e0:	89 75 c4             	mov    %esi,-0x3c(%ebp)
400021e3:	8b 75 d8             	mov    -0x28(%ebp),%esi
400021e6:	89 7d c0             	mov    %edi,-0x40(%ebp)
400021e9:	8b 7d d4             	mov    -0x2c(%ebp),%edi
400021ec:	cd 30                	int    $0x30
400021ee:	89 45 bc             	mov    %eax,-0x44(%ebp)
400021f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400021f4:	89 4d b8             	mov    %ecx,-0x48(%ebp)
400021f7:	8b 4d bc             	mov    -0x44(%ebp),%ecx
400021fa:	89 08                	mov    %ecx,(%eax)
400021fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
400021ff:	89 58 04             	mov    %ebx,0x4(%eax)
40002202:	8b 5d c8             	mov    -0x38(%ebp),%ebx
40002205:	8b 45 b8             	mov    -0x48(%ebp),%eax
40002208:	89 43 08             	mov    %eax,0x8(%ebx)
4000220b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000220e:	89 50 0c             	mov    %edx,0xc(%eax)
40002211:	8b 55 c0             	mov    -0x40(%ebp),%edx
40002214:	89 72 10             	mov    %esi,0x10(%edx)
40002217:	8b 75 cc             	mov    -0x34(%ebp),%esi
4000221a:	89 7e 14             	mov    %edi,0x14(%esi)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
4000221d:	83 c4 3c             	add    $0x3c,%esp
40002220:	5e                   	pop    %esi
40002221:	5f                   	pop    %edi
40002222:	5b                   	pop    %ebx
40002223:	5d                   	pop    %ebp
40002224:	c3                   	ret    
