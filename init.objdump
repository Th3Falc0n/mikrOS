
initrfs/ibin/init:     file format elf32-i386


Disassembly of section .text:

40000000 <main>:
        fread(cntrl, &resp, sizeof(char));
    }
}

int main(int argc, char* args[])
{
40000000:	55                   	push   %ebp
40000001:	89 e5                	mov    %esp,%ebp
40000003:	56                   	push   %esi
40000004:	83 ec 64             	sub    $0x64,%esp
40000007:	8b 45 0c             	mov    0xc(%ebp),%eax
4000000a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000000d:	8d 15 c0 30 00 40    	lea    0x400030c0,%edx
40000013:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
4000001a:	89 4d f4             	mov    %ecx,-0xc(%ebp)
4000001d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    printf("[ibin/init] Init process started... :) Thats so good!\n");
40000020:	89 14 24             	mov    %edx,(%esp)
40000023:	e8 a8 10 00 00       	call   400010d0 <printf>
40000028:	8d 0d f7 30 00 40    	lea    0x400030f7,%ecx
    printf("[ibin/init] Switching into TTY to VGA mode.\nIf you see this something probably went wrong.\n");
4000002e:	89 0c 24             	mov    %ecx,(%esp)
40000031:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000034:	e8 97 10 00 00       	call   400010d0 <printf>
40000039:	8d 0d 53 31 00 40    	lea    0x40003153,%ecx

    HANDLE cntrl = fmkfifo("/var/cntrl/init");
4000003f:	89 0c 24             	mov    %ecx,(%esp)
40000042:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000045:	e8 96 0b 00 00       	call   40000be0 <fmkfifo>
4000004a:	8d 0d 63 31 00 40    	lea    0x40003163,%ecx
40000050:	ba 00 00 00 00       	mov    $0x0,%edx
40000055:	89 45 ec             	mov    %eax,-0x14(%ebp)

    texec("/ibin/ttytovga", 0);
40000058:	89 0c 24             	mov    %ecx,(%esp)
4000005b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000062:	00 
40000063:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40000066:	e8 15 06 00 00       	call   40000680 <texec>
    waitResp(cntrl);
4000006b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
4000006e:	89 0c 24             	mov    %ecx,(%esp)
40000071:	89 45 d0             	mov    %eax,-0x30(%ebp)
40000074:	e8 d7 00 00 00       	call   40000150 <waitResp>
40000079:	8d 05 72 31 00 40    	lea    0x40003172,%eax

    setstdout("/dev/tty0");
4000007f:	89 04 24             	mov    %eax,(%esp)
40000082:	e8 99 07 00 00       	call   40000820 <setstdout>
40000087:	8d 0d 7c 31 00 40    	lea    0x4000317c,%ecx
    setstdin ("/dev/keyboard");
4000008d:	89 0c 24             	mov    %ecx,(%esp)
40000090:	89 45 cc             	mov    %eax,-0x34(%ebp)
40000093:	e8 b8 07 00 00       	call   40000850 <setstdin>
40000098:	8d 0d 72 31 00 40    	lea    0x40003172,%ecx
    setstderr("/dev/tty0");
4000009e:	89 0c 24             	mov    %ecx,(%esp)
400000a1:	89 45 c8             	mov    %eax,-0x38(%ebp)
400000a4:	e8 d7 07 00 00       	call   40000880 <setstderr>
400000a9:	8d 0d 8a 31 00 40    	lea    0x4000318a,%ecx

    printf("[init] now working on tty0\n");
400000af:	89 0c 24             	mov    %ecx,(%esp)
400000b2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
400000b5:	e8 16 10 00 00       	call   400010d0 <printf>
400000ba:	8d 0d a6 31 00 40    	lea    0x400031a6,%ecx

    printf("[init] executing virtual file drivers\n");
400000c0:	89 0c 24             	mov    %ecx,(%esp)
400000c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
400000c6:	e8 05 10 00 00       	call   400010d0 <printf>
400000cb:	8d 0d cd 31 00 40    	lea    0x400031cd,%ecx
400000d1:	ba 00 00 00 00       	mov    $0x0,%edx
    texec("/ibin/urnd_prov", 0);
400000d6:	89 0c 24             	mov    %ecx,(%esp)
400000d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
400000e0:	00 
400000e1:	89 45 bc             	mov    %eax,-0x44(%ebp)
400000e4:	89 55 b8             	mov    %edx,-0x48(%ebp)
400000e7:	e8 94 05 00 00       	call   40000680 <texec>
    waitResp(cntrl);
400000ec:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400000ef:	89 0c 24             	mov    %ecx,(%esp)
400000f2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
400000f5:	e8 56 00 00 00       	call   40000150 <waitResp>
400000fa:	8d 05 dd 31 00 40    	lea    0x400031dd,%eax

    printf("[init] switching to shell\n");
40000100:	89 04 24             	mov    %eax,(%esp)
40000103:	e8 c8 0f 00 00       	call   400010d0 <printf>
40000108:	8d 0d 04 32 00 40    	lea    0x40003204,%ecx
4000010e:	ba 00 00 00 00       	mov    $0x0,%edx

    char* testparams[] = {
40000113:	8b 35 00 30 00 40    	mov    0x40003000,%esi
40000119:	89 75 e0             	mov    %esi,-0x20(%ebp)
4000011c:	8b 35 04 30 00 40    	mov    0x40003004,%esi
40000122:	89 75 e4             	mov    %esi,-0x1c(%ebp)
40000125:	8b 35 08 30 00 40    	mov    0x40003008,%esi
4000012b:	89 75 e8             	mov    %esi,-0x18(%ebp)
        "test1",
        "test2",
        0
    };

    texec("/ibin/csh", 0);
4000012e:	89 0c 24             	mov    %ecx,(%esp)
40000131:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000138:	00 
40000139:	89 45 b0             	mov    %eax,-0x50(%ebp)
4000013c:	89 55 ac             	mov    %edx,-0x54(%ebp)
4000013f:	e8 3c 05 00 00       	call   40000680 <texec>
40000144:	89 45 a8             	mov    %eax,-0x58(%ebp)

    while(1);
40000147:	e9 fb ff ff ff       	jmp    40000147 <main+0x147>
4000014c:	0f 1f 40 00          	nopl   0x0(%eax)

40000150 <waitResp>:
#include "stdint.h"
#include "stdio.h"
#include "process.h"
#include "stdlib.h"

static void waitResp(HANDLE cntrl) {
40000150:	55                   	push   %ebp
40000151:	89 e5                	mov    %esp,%ebp
40000153:	83 ec 28             	sub    $0x28,%esp
40000156:	8b 45 08             	mov    0x8(%ebp),%eax
40000159:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char resp = 0;
4000015c:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)

    while(resp != 'K') {
40000160:	0f be 45 fb          	movsbl -0x5(%ebp),%eax
40000164:	3d 4b 00 00 00       	cmp    $0x4b,%eax
40000169:	0f 84 2a 00 00 00    	je     40000199 <waitResp+0x49>
4000016f:	8d 45 fb             	lea    -0x5(%ebp),%eax
40000172:	b9 01 00 00 00       	mov    $0x1,%ecx
        fread(cntrl, &resp, sizeof(char));
40000177:	8b 55 fc             	mov    -0x4(%ebp),%edx
4000017a:	89 14 24             	mov    %edx,(%esp)
4000017d:	89 44 24 04          	mov    %eax,0x4(%esp)
40000181:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
40000188:	00 
40000189:	89 4d f4             	mov    %ecx,-0xc(%ebp)
4000018c:	e8 5f 09 00 00       	call   40000af0 <fread>
    }
40000191:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000194:	e9 c7 ff ff ff       	jmp    40000160 <waitResp+0x10>
}
40000199:	83 c4 28             	add    $0x28,%esp
4000019c:	5d                   	pop    %ebp
4000019d:	c3                   	ret    
4000019e:	66 90                	xchg   %ax,%ax

400001a0 <call_rpc>:
    syscall(&state);

    while(1);
}

uint32_t call_rpc(int pid, uint32_t funcID, uint32_t datasize, void* data) {
400001a0:	55                   	push   %ebp
400001a1:	89 e5                	mov    %esp,%ebp
400001a3:	57                   	push   %edi
400001a4:	56                   	push   %esi
400001a5:	83 ec 30             	sub    $0x30,%esp
400001a8:	8b 45 14             	mov    0x14(%ebp),%eax
400001ab:	8b 4d 10             	mov    0x10(%ebp),%ecx
400001ae:	8b 55 0c             	mov    0xc(%ebp),%edx
400001b1:	8b 75 08             	mov    0x8(%ebp),%esi
400001b4:	8d 7d d0             	lea    -0x30(%ebp),%edi
400001b7:	89 75 f4             	mov    %esi,-0xc(%ebp)
400001ba:	89 55 f0             	mov    %edx,-0x10(%ebp)
400001bd:	89 4d ec             	mov    %ecx,-0x14(%ebp)
400001c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    struct regstate state = {
400001c3:	c7 45 d0 1f 00 00 00 	movl   $0x1f,-0x30(%ebp)
400001ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
400001cd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400001d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400001d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
400001d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
400001d9:	89 45 dc             	mov    %eax,-0x24(%ebp)
400001dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
400001df:	89 45 e0             	mov    %eax,-0x20(%ebp)
400001e2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
      .edx = datasize,
      .esi = (uint32_t)data,
      .edi = 0
    };

    syscall(&state);
400001e9:	89 3c 24             	mov    %edi,(%esp)
400001ec:	e8 2f 1f 00 00       	call   40002120 <syscall>

    return state.eax;
400001f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
400001f4:	83 c4 30             	add    $0x30,%esp
400001f7:	5e                   	pop    %esi
400001f8:	5f                   	pop    %edi
400001f9:	5d                   	pop    %ebp
400001fa:	c3                   	ret    
400001fb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40000200 <fetch_rpc_data>:
}

void fetch_rpc_data(void* dest) {
40000200:	55                   	push   %ebp
40000201:	89 e5                	mov    %esp,%ebp
40000203:	83 ec 28             	sub    $0x28,%esp
40000206:	8b 45 08             	mov    0x8(%ebp),%eax
40000209:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000020c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000020f:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
40000216:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000219:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000021c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000223:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000022a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000231:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000238:	89 0c 24             	mov    %ecx,(%esp)
4000023b:	e8 e0 1e 00 00       	call   40002120 <syscall>
}
40000240:	83 c4 28             	add    $0x28,%esp
40000243:	5d                   	pop    %ebp
40000244:	c3                   	ret    
40000245:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
4000024c:	00 00 00 00 

40000250 <set_rpc_handler>:

    //free(localData);
    return_rpc(0);
}

void set_rpc_handler() {
40000250:	55                   	push   %ebp
40000251:	89 e5                	mov    %esp,%ebp
40000253:	56                   	push   %esi
40000254:	83 ec 34             	sub    $0x34,%esp
40000257:	8d 45 e0             	lea    -0x20(%ebp),%eax
4000025a:	8d 0d 24 30 00 40    	lea    0x40003024,%ecx
40000260:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
40000265:	89 c6                	mov    %eax,%esi
40000267:	89 34 24             	mov    %esi,(%esp)
4000026a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000026e:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
40000275:	00 
40000276:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000279:	89 55 d8             	mov    %edx,-0x28(%ebp)
4000027c:	e8 1f 12 00 00       	call   400014a0 <memcpy>
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000281:	8b 45 dc             	mov    -0x24(%ebp),%eax
40000284:	89 04 24             	mov    %eax,(%esp)
40000287:	e8 94 1e 00 00       	call   40002120 <syscall>
}
4000028c:	83 c4 34             	add    $0x34,%esp
4000028f:	5e                   	pop    %esi
40000290:	5d                   	pop    %ebp
40000291:	c3                   	ret    
40000292:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000299:	1f 84 00 00 00 00 00 

400002a0 <_handle_rpc>:

    syscall(&state);
}


static void _handle_rpc(uint32_t type, uint32_t funcID, uint32_t datasize) {
400002a0:	55                   	push   %ebp
400002a1:	89 e5                	mov    %esp,%ebp
400002a3:	56                   	push   %esi
400002a4:	83 ec 14             	sub    $0x14,%esp
400002a7:	8b 45 10             	mov    0x10(%ebp),%eax
400002aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400002ad:	8b 55 08             	mov    0x8(%ebp),%edx
400002b0:	be 00 00 00 00       	mov    $0x0,%esi
400002b5:	89 55 f8             	mov    %edx,-0x8(%ebp)
400002b8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
400002bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
   // void* localData = malloc(datasize);
    //fetch_rpc_data(localData);

    type++;
400002be:	8b 45 f8             	mov    -0x8(%ebp),%eax
400002c1:	05 01 00 00 00       	add    $0x1,%eax
400002c6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    funcID++;
400002c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
400002cc:	05 01 00 00 00       	add    $0x1,%eax
400002d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    datasize++;
400002d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400002d7:	05 01 00 00 00       	add    $0x1,%eax
400002dc:	89 45 f0             	mov    %eax,-0x10(%ebp)

    //printf("RPC received! type:%x=%d funcID:%x=%d datasize:%x=%d\n", (uint32_t)&type, type, (uint32_t)&funcID, funcID, (uint32_t)&datasize, datasize);

    asm("cli; hlt;");
400002df:	fa                   	cli    
400002e0:	f4                   	hlt    

    //free(localData);
    return_rpc(0);
400002e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
400002e8:	89 75 ec             	mov    %esi,-0x14(%ebp)
400002eb:	e8 40 04 00 00       	call   40000730 <return_rpc>
}
400002f0:	83 c4 14             	add    $0x14,%esp
400002f3:	5e                   	pop    %esi
400002f4:	5d                   	pop    %ebp
400002f5:	c3                   	ret    
400002f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
400002fd:	00 00 00 

40000300 <_start>:
    syscall(&state);

    return state.eax;
}

void _start() {
40000300:	55                   	push   %ebp
40000301:	89 e5                	mov    %esp,%ebp
  char** args = (char**) getargs();
40000303:	83 ec 18             	sub    $0x18,%esp
40000306:	e8 d5 03 00 00       	call   400006e0 <getargs>
4000030b:	89 45 fc             	mov    %eax,-0x4(%ebp)

  int argc = 0;
4000030e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

  if(args != 0) {
40000315:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
4000031c:	0f 84 2d 00 00 00    	je     4000034f <_start+0x4f>
      while(args[argc] != 0) {
40000322:	e9 00 00 00 00       	jmp    40000327 <_start+0x27>
40000327:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000032a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
4000032d:	81 3c 81 00 00 00 00 	cmpl   $0x0,(%ecx,%eax,4)
40000334:	0f 84 10 00 00 00    	je     4000034a <_start+0x4a>
          argc++;
4000033a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000033d:	05 01 00 00 00       	add    $0x1,%eax
40000342:	89 45 f8             	mov    %eax,-0x8(%ebp)
      }
40000345:	e9 dd ff ff ff       	jmp    40000327 <_start+0x27>
  }
4000034a:	e9 00 00 00 00       	jmp    4000034f <_start+0x4f>

  set_rpc_handler();
4000034f:	e8 fc fe ff ff       	call   40000250 <set_rpc_handler>

  int result = main(argc, args);
40000354:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000357:	8b 4d fc             	mov    -0x4(%ebp),%ecx
4000035a:	89 04 24             	mov    %eax,(%esp)
4000035d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000361:	e8 9a fc ff ff       	call   40000000 <main>
40000366:	89 45 f4             	mov    %eax,-0xc(%ebp)

  exit(result);
40000369:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000036c:	89 04 24             	mov    %eax,(%esp)
4000036f:	e8 0c 00 00 00       	call   40000380 <exit>
40000374:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
4000037b:	00 00 00 00 00 

40000380 <exit>:
    syscall(&state);

    return;
}

void exit(int returncode) {
40000380:	55                   	push   %ebp
40000381:	89 e5                	mov    %esp,%ebp
40000383:	83 ec 28             	sub    $0x28,%esp
40000386:	8b 45 08             	mov    0x8(%ebp),%eax
40000389:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000038c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000038f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
40000396:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000399:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000039c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400003a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400003aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400003b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
400003b8:	89 0c 24             	mov    %ecx,(%esp)
400003bb:	e8 60 1d 00 00       	call   40002120 <syscall>
400003c0:	8d 05 0e 32 00 40    	lea    0x4000320e,%eax

    while(1) {
      printf("error\n");
400003c6:	89 04 24             	mov    %eax,(%esp)
400003c9:	e8 02 0d 00 00       	call   400010d0 <printf>
    }
400003ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
400003d1:	e9 ea ff ff ff       	jmp    400003c0 <exit+0x40>
400003d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
400003dd:	00 00 00 

400003e0 <yield>:
  int result = main(argc, args);

  exit(result);
}

void yield() {
400003e0:	55                   	push   %ebp
400003e1:	89 e5                	mov    %esp,%ebp
400003e3:	56                   	push   %esi
400003e4:	83 ec 34             	sub    $0x34,%esp
400003e7:	8d 45 e0             	lea    -0x20(%ebp),%eax
400003ea:	8d 0d 3c 30 00 40    	lea    0x4000303c,%ecx
400003f0:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
400003f5:	89 c6                	mov    %eax,%esi
400003f7:	89 34 24             	mov    %esi,(%esp)
400003fa:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400003fe:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
40000405:	00 
40000406:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000409:	89 55 d8             	mov    %edx,-0x28(%ebp)
4000040c:	e8 8f 10 00 00       	call   400014a0 <memcpy>
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000411:	8b 45 dc             	mov    -0x24(%ebp),%eax
40000414:	89 04 24             	mov    %eax,(%esp)
40000417:	e8 04 1d 00 00       	call   40002120 <syscall>

    return;
4000041c:	83 c4 34             	add    $0x34,%esp
4000041f:	5e                   	pop    %esi
40000420:	5d                   	pop    %ebp
40000421:	c3                   	ret    
40000422:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000429:	1f 84 00 00 00 00 00 

40000430 <getExecPath>:
    while(1) {
      printf("error\n");
    }
}

void getExecPath(char* dest) {
40000430:	55                   	push   %ebp
40000431:	89 e5                	mov    %esp,%ebp
40000433:	83 ec 28             	sub    $0x28,%esp
40000436:	8b 45 08             	mov    0x8(%ebp),%eax
40000439:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000043c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000043f:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%ebp)
40000446:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000449:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000044c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000453:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000045a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000461:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
40000468:	89 0c 24             	mov    %ecx,(%esp)
4000046b:	e8 b0 1c 00 00       	call   40002120 <syscall>
}
40000470:	83 c4 28             	add    $0x28,%esp
40000473:	5d                   	pop    %ebp
40000474:	c3                   	ret    
40000475:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
4000047c:	00 00 00 00 

40000480 <changeExecPath>:

int changeExecPath(char* path) {
40000480:	55                   	push   %ebp
40000481:	89 e5                	mov    %esp,%ebp
40000483:	83 ec 28             	sub    $0x28,%esp
40000486:	8b 45 08             	mov    0x8(%ebp),%eax
40000489:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000048c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000048f:	c7 45 e0 07 00 00 00 	movl   $0x7,-0x20(%ebp)
40000496:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000499:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000049c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400004a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400004aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400004b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
400004b8:	89 0c 24             	mov    %ecx,(%esp)
400004bb:	e8 60 1c 00 00       	call   40002120 <syscall>

    return state.eax;
400004c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400004c3:	83 c4 28             	add    $0x28,%esp
400004c6:	5d                   	pop    %ebp
400004c7:	c3                   	ret    
400004c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
400004cf:	00 

400004d0 <cd>:
}

void cd(char* path) {
400004d0:	55                   	push   %ebp
400004d1:	89 e5                	mov    %esp,%ebp
400004d3:	83 ec 18             	sub    $0x18,%esp
400004d6:	8b 45 08             	mov    0x8(%ebp),%eax
400004d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(!changeExecPath(path)) printFilesystemError(path, getLastVFSErr());
400004dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
400004df:	89 04 24             	mov    %eax,(%esp)
400004e2:	e8 99 ff ff ff       	call   40000480 <changeExecPath>
400004e7:	3d 00 00 00 00       	cmp    $0x0,%eax
400004ec:	0f 85 1a 00 00 00    	jne    4000050c <cd+0x3c>
400004f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
400004f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
400004f8:	e8 83 02 00 00       	call   40000780 <getLastVFSErr>
400004fd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000500:	89 0c 24             	mov    %ecx,(%esp)
40000503:	89 44 24 04          	mov    %eax,0x4(%esp)
40000507:	e8 14 00 00 00       	call   40000520 <printFilesystemError>
}
4000050c:	83 c4 18             	add    $0x18,%esp
4000050f:	5d                   	pop    %ebp
40000510:	c3                   	ret    
40000511:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000518:	0f 1f 84 00 00 00 00 
4000051f:	00 

40000520 <printFilesystemError>:
    }

    return res;
}

void printFilesystemError(char* path, uint32_t code) {
40000520:	55                   	push   %ebp
40000521:	89 e5                	mov    %esp,%ebp
40000523:	83 ec 38             	sub    $0x38,%esp
40000526:	8b 45 0c             	mov    0xc(%ebp),%eax
40000529:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000052c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
4000052f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40000532:	89 c1                	mov    %eax,%ecx
40000534:	83 e9 05             	sub    $0x5,%ecx
    switch(code) {
40000537:	89 4d f4             	mov    %ecx,-0xc(%ebp)
4000053a:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000053d:	0f 87 ba 00 00 00    	ja     400005fd <printFilesystemError+0xdd>
40000543:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000546:	8b 0c 85 0c 30 00 40 	mov    0x4000300c(,%eax,4),%ecx
4000054d:	ff e1                	jmp    *%ecx
4000054f:	8d 05 15 32 00 40    	lea    0x40003215,%eax
    case PE_NO_ERROR:
        printf("%s: Unknown error", path);
40000555:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000558:	89 04 24             	mov    %eax,(%esp)
4000055b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000055f:	e8 6c 0b 00 00       	call   400010d0 <printf>
        break;
40000564:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000567:	e9 a9 00 00 00       	jmp    40000615 <printFilesystemError+0xf5>
4000056c:	8d 05 27 32 00 40    	lea    0x40003227,%eax
    case PE_INVALID:
        printf("%s: Specified path was invalid", path);
40000572:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000575:	89 04 24             	mov    %eax,(%esp)
40000578:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000057c:	e8 4f 0b 00 00       	call   400010d0 <printf>
        break;
40000581:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000584:	e9 8c 00 00 00       	jmp    40000615 <printFilesystemError+0xf5>
40000589:	8d 05 46 32 00 40    	lea    0x40003246,%eax
    case PE_CORRUPT_FILE:
        printf("%s: File is not a valid executable binary", path);
4000058f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000592:	89 04 24             	mov    %eax,(%esp)
40000595:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000599:	e8 32 0b 00 00       	call   400010d0 <printf>
        break;
4000059e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400005a1:	e9 6f 00 00 00       	jmp    40000615 <printFilesystemError+0xf5>
400005a6:	8d 05 70 32 00 40    	lea    0x40003270,%eax
    case PE_FILESYSTEM:
        printf("%s: Filesystem error", path);
400005ac:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400005af:	89 04 24             	mov    %eax,(%esp)
400005b2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400005b6:	e8 15 0b 00 00       	call   400010d0 <printf>
        break;
400005bb:	89 45 e0             	mov    %eax,-0x20(%ebp)
400005be:	e9 52 00 00 00       	jmp    40000615 <printFilesystemError+0xf5>
400005c3:	8d 05 85 32 00 40    	lea    0x40003285,%eax
    case PE_PERM_DENIED:
        printf("%s: Permission to execute path denied (maybe a directory?)", path);
400005c9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400005cc:	89 04 24             	mov    %eax,(%esp)
400005cf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400005d3:	e8 f8 0a 00 00       	call   400010d0 <printf>
        break;
400005d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
400005db:	e9 35 00 00 00       	jmp    40000615 <printFilesystemError+0xf5>
400005e0:	8d 05 c0 32 00 40    	lea    0x400032c0,%eax
    case PE_FILE_NOT_FOUND:
        printf("%s: File not found", path);
400005e6:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400005e9:	89 04 24             	mov    %eax,(%esp)
400005ec:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400005f0:	e8 db 0a 00 00       	call   400010d0 <printf>
        break;
400005f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
400005f8:	e9 18 00 00 00       	jmp    40000615 <printFilesystemError+0xf5>
400005fd:	8d 05 d3 32 00 40    	lea    0x400032d3,%eax
    default:
        printf("%s: WTF", path);
40000603:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000606:	89 04 24             	mov    %eax,(%esp)
40000609:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000060d:	e8 be 0a 00 00       	call   400010d0 <printf>
40000612:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40000615:	8d 05 f5 30 00 40    	lea    0x400030f5,%eax
        break;

    }
    printf("\n");
4000061b:	89 04 24             	mov    %eax,(%esp)
4000061e:	e8 ad 0a 00 00       	call   400010d0 <printf>
}
40000623:	89 45 d0             	mov    %eax,-0x30(%ebp)
40000626:	83 c4 38             	add    $0x38,%esp
40000629:	5d                   	pop    %ebp
4000062a:	c3                   	ret    
4000062b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40000630 <exec>:

void cd(char* path) {
    if(!changeExecPath(path)) printFilesystemError(path, getLastVFSErr());
}

int exec(char* path, char** args) {
40000630:	55                   	push   %ebp
40000631:	89 e5                	mov    %esp,%ebp
40000633:	83 ec 28             	sub    $0x28,%esp
40000636:	8b 45 0c             	mov    0xc(%ebp),%eax
40000639:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000063c:	8d 55 e0             	lea    -0x20(%ebp),%edx
4000063f:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40000642:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct regstate state = {
40000645:	c7 45 e0 03 00 00 00 	movl   $0x3,-0x20(%ebp)
4000064c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000064f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000652:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000655:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000658:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000065f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000666:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
4000066d:	89 14 24             	mov    %edx,(%esp)
40000670:	e8 ab 1a 00 00       	call   40002120 <syscall>

    return state.eax;
40000675:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000678:	83 c4 28             	add    $0x28,%esp
4000067b:	5d                   	pop    %ebp
4000067c:	c3                   	ret    
4000067d:	0f 1f 00             	nopl   (%eax)

40000680 <texec>:
}

int texec(char* path, char** args) {
40000680:	55                   	push   %ebp
40000681:	89 e5                	mov    %esp,%ebp
40000683:	83 ec 18             	sub    $0x18,%esp
40000686:	8b 45 0c             	mov    0xc(%ebp),%eax
40000689:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000068c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
4000068f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t res = exec(path, args);
40000692:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000695:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000698:	89 04 24             	mov    %eax,(%esp)
4000069b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000069f:	e8 8c ff ff ff       	call   40000630 <exec>
400006a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!res) {
400006a7:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
400006ae:	0f 85 1a 00 00 00    	jne    400006ce <texec+0x4e>
        printFilesystemError(path, getLastVFSErr());
400006b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
400006b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
400006ba:	e8 c1 00 00 00       	call   40000780 <getLastVFSErr>
400006bf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400006c2:	89 0c 24             	mov    %ecx,(%esp)
400006c5:	89 44 24 04          	mov    %eax,0x4(%esp)
400006c9:	e8 52 fe ff ff       	call   40000520 <printFilesystemError>
    }

    return res;
400006ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
400006d1:	83 c4 18             	add    $0x18,%esp
400006d4:	5d                   	pop    %ebp
400006d5:	c3                   	ret    
400006d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
400006dd:	00 00 00 

400006e0 <getargs>:
#include "stdio.h"
#include "process_rpc.c"

extern int main(int argc, char* args[]);

static uint32_t getargs() {
400006e0:	55                   	push   %ebp
400006e1:	89 e5                	mov    %esp,%ebp
400006e3:	56                   	push   %esi
400006e4:	83 ec 34             	sub    $0x34,%esp
400006e7:	8d 45 e0             	lea    -0x20(%ebp),%eax
400006ea:	8d 0d 54 30 00 40    	lea    0x40003054,%ecx
400006f0:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
400006f5:	89 c6                	mov    %eax,%esi
400006f7:	89 34 24             	mov    %esi,(%esp)
400006fa:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400006fe:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
40000705:	00 
40000706:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000709:	89 55 d8             	mov    %edx,-0x28(%ebp)
4000070c:	e8 8f 0d 00 00       	call   400014a0 <memcpy>
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000711:	8b 45 dc             	mov    -0x24(%ebp),%eax
40000714:	89 04 24             	mov    %eax,(%esp)
40000717:	e8 04 1a 00 00       	call   40002120 <syscall>

    return state.eax;
4000071c:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000071f:	83 c4 34             	add    $0x34,%esp
40000722:	5e                   	pop    %esi
40000723:	5d                   	pop    %ebp
40000724:	c3                   	ret    
40000725:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
4000072c:	00 00 00 00 

40000730 <return_rpc>:
#include "process.h"
#include "stdio.h"
#include "stdlib.h"

static void return_rpc(int code) {
40000730:	55                   	push   %ebp
40000731:	89 e5                	mov    %esp,%ebp
40000733:	83 ec 28             	sub    $0x28,%esp
40000736:	8b 45 08             	mov    0x8(%ebp),%eax
40000739:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000073c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000073f:	c7 45 e0 1e 00 00 00 	movl   $0x1e,-0x20(%ebp)
40000746:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000749:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000074c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000753:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000075a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000761:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000768:	89 0c 24             	mov    %ecx,(%esp)
4000076b:	e8 b0 19 00 00       	call   40002120 <syscall>

    while(1);
40000770:	e9 fb ff ff ff       	jmp    40000770 <return_rpc+0x40>
40000775:	66 90                	xchg   %ax,%ax
40000777:	66 90                	xchg   %ax,%ax
40000779:	66 90                	xchg   %ax,%ax
4000077b:	66 90                	xchg   %ax,%ax
4000077d:	66 90                	xchg   %ax,%ax
4000077f:	90                   	nop

40000780 <getLastVFSErr>:
#include "stdio.h"
#include "string.h"
#include "process.h"

uint32_t getLastVFSErr() {
40000780:	55                   	push   %ebp
40000781:	89 e5                	mov    %esp,%ebp
40000783:	56                   	push   %esi
40000784:	83 ec 34             	sub    $0x34,%esp
40000787:	8d 45 e0             	lea    -0x20(%ebp),%eax
4000078a:	8d 0d 90 30 00 40    	lea    0x40003090,%ecx
40000790:	ba 18 00 00 00       	mov    $0x18,%edx
    struct regstate state = {
40000795:	89 c6                	mov    %eax,%esi
40000797:	89 34 24             	mov    %esi,(%esp)
4000079a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4000079e:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
400007a5:	00 
400007a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
400007a9:	89 55 d8             	mov    %edx,-0x28(%ebp)
400007ac:	e8 ef 0c 00 00       	call   400014a0 <memcpy>
        .edx = 0,
        .esi = 0,
        .edi = 0
    };

    syscall(&state);
400007b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
400007b4:	89 04 24             	mov    %eax,(%esp)
400007b7:	e8 64 19 00 00       	call   40002120 <syscall>

    return state.eax;
400007bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
400007bf:	83 c4 34             	add    $0x34,%esp
400007c2:	5e                   	pop    %esi
400007c3:	5d                   	pop    %ebp
400007c4:	c3                   	ret    
400007c5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
400007cc:	00 00 00 00 

400007d0 <fopenpmhandle>:

static HANDLE getstdout() { return getpmhandle(PMID_STDOUT); };
static HANDLE getstdin() { return getpmhandle(PMID_STDIN); };
static HANDLE getstderr() { return getpmhandle(PMID_STDERR); };

int fopenpmhandle (uint32_t pmid, char* path) {
400007d0:	55                   	push   %ebp
400007d1:	89 e5                	mov    %esp,%ebp
400007d3:	83 ec 28             	sub    $0x28,%esp
400007d6:	8b 45 0c             	mov    0xc(%ebp),%eax
400007d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
400007dc:	8d 55 e0             	lea    -0x20(%ebp),%edx
400007df:	89 4d fc             	mov    %ecx,-0x4(%ebp)
400007e2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct regstate state = {
400007e5:	c7 45 e0 15 00 00 00 	movl   $0x15,-0x20(%ebp)
400007ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
400007ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400007f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
400007f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
400007f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400007ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000806:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
4000080d:	89 14 24             	mov    %edx,(%esp)
40000810:	e8 0b 19 00 00       	call   40002120 <syscall>

    return (HANDLE)state.eax;
40000815:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000818:	83 c4 28             	add    $0x28,%esp
4000081b:	5d                   	pop    %ebp
4000081c:	c3                   	ret    
4000081d:	0f 1f 00             	nopl   (%eax)

40000820 <setstdout>:
}

int setstdout(char* path) { return fopenpmhandle(PMID_STDOUT, path); };
40000820:	55                   	push   %ebp
40000821:	89 e5                	mov    %esp,%ebp
40000823:	83 ec 18             	sub    $0x18,%esp
40000826:	8b 45 08             	mov    0x8(%ebp),%eax
40000829:	b9 00 00 00 00       	mov    $0x0,%ecx
4000082e:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000831:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000834:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
4000083b:	89 44 24 04          	mov    %eax,0x4(%esp)
4000083f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000842:	e8 89 ff ff ff       	call   400007d0 <fopenpmhandle>
40000847:	83 c4 18             	add    $0x18,%esp
4000084a:	5d                   	pop    %ebp
4000084b:	c3                   	ret    
4000084c:	0f 1f 40 00          	nopl   0x0(%eax)

40000850 <setstdin>:
int setstdin (char* path) { return fopenpmhandle(PMID_STDIN , path); };
40000850:	55                   	push   %ebp
40000851:	89 e5                	mov    %esp,%ebp
40000853:	83 ec 18             	sub    $0x18,%esp
40000856:	8b 45 08             	mov    0x8(%ebp),%eax
40000859:	b9 01 00 00 00       	mov    $0x1,%ecx
4000085e:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000861:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000864:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
4000086b:	89 44 24 04          	mov    %eax,0x4(%esp)
4000086f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000872:	e8 59 ff ff ff       	call   400007d0 <fopenpmhandle>
40000877:	83 c4 18             	add    $0x18,%esp
4000087a:	5d                   	pop    %ebp
4000087b:	c3                   	ret    
4000087c:	0f 1f 40 00          	nopl   0x0(%eax)

40000880 <setstderr>:
int setstderr(char* path) { return fopenpmhandle(PMID_STDERR, path); };
40000880:	55                   	push   %ebp
40000881:	89 e5                	mov    %esp,%ebp
40000883:	83 ec 18             	sub    $0x18,%esp
40000886:	8b 45 08             	mov    0x8(%ebp),%eax
40000889:	b9 02 00 00 00       	mov    $0x2,%ecx
4000088e:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000891:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000894:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
4000089b:	89 44 24 04          	mov    %eax,0x4(%esp)
4000089f:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400008a2:	e8 29 ff ff ff       	call   400007d0 <fopenpmhandle>
400008a7:	83 c4 18             	add    $0x18,%esp
400008aa:	5d                   	pop    %ebp
400008ab:	c3                   	ret    
400008ac:	0f 1f 40 00          	nopl   0x0(%eax)

400008b0 <fopen>:

HANDLE fopen(char* path, uint32_t mode) {
400008b0:	55                   	push   %ebp
400008b1:	89 e5                	mov    %esp,%ebp
400008b3:	83 ec 28             	sub    $0x28,%esp
400008b6:	8b 45 0c             	mov    0xc(%ebp),%eax
400008b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
400008bc:	8d 55 e0             	lea    -0x20(%ebp),%edx
400008bf:	89 4d fc             	mov    %ecx,-0x4(%ebp)
400008c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct regstate state = {
400008c5:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
400008cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
400008cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400008d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
400008d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
400008d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400008df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400008e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
400008ed:	89 14 24             	mov    %edx,(%esp)
400008f0:	e8 2b 18 00 00       	call   40002120 <syscall>

    return (HANDLE)state.eax;
400008f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
400008f8:	83 c4 28             	add    $0x28,%esp
400008fb:	5d                   	pop    %ebp
400008fc:	c3                   	ret    
400008fd:	0f 1f 00             	nopl   (%eax)

40000900 <fclose>:
}

int fclose(uint32_t handle) {
40000900:	55                   	push   %ebp
40000901:	89 e5                	mov    %esp,%ebp
40000903:	83 ec 28             	sub    $0x28,%esp
40000906:	8b 45 08             	mov    0x8(%ebp),%eax
40000909:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000090c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
4000090f:	c7 45 e0 0b 00 00 00 	movl   $0xb,-0x20(%ebp)
40000916:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000919:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000091c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000923:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000092a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000931:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000938:	89 0c 24             	mov    %ecx,(%esp)
4000093b:	e8 e0 17 00 00       	call   40002120 <syscall>

    return (int)state.eax;
40000940:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000943:	83 c4 28             	add    $0x28,%esp
40000946:	5d                   	pop    %ebp
40000947:	c3                   	ret    
40000948:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
4000094f:	00 

40000950 <fwrite>:
    syscall(&state);

    return (int)state.eax;
}

uint32_t fwrite(uint32_t handle, const void* src, uint32_t length) {
40000950:	55                   	push   %ebp
40000951:	89 e5                	mov    %esp,%ebp
40000953:	83 ec 28             	sub    $0x28,%esp
40000956:	8b 45 10             	mov    0x10(%ebp),%eax
40000959:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000095c:	8b 55 08             	mov    0x8(%ebp),%edx
4000095f:	89 55 fc             	mov    %edx,-0x4(%ebp)
40000962:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000965:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t res = frwrite(handle, src, length);
40000968:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000096b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
4000096e:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000971:	89 04 24             	mov    %eax,(%esp)
40000974:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000978:	89 54 24 08          	mov    %edx,0x8(%esp)
4000097c:	e8 5f 00 00 00       	call   400009e0 <frwrite>
40000981:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(res == RW_BLOCK) {
40000984:	81 7d f0 01 00 00 00 	cmpl   $0x1,-0x10(%ebp)
4000098b:	0f 85 26 00 00 00    	jne    400009b7 <fwrite+0x67>
        yield();
40000991:	e8 4a fa ff ff       	call   400003e0 <yield>
        res = frwrite(handle, src, length);
40000996:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000999:	8b 4d f8             	mov    -0x8(%ebp),%ecx
4000099c:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000099f:	89 04 24             	mov    %eax,(%esp)
400009a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400009a6:	89 54 24 08          	mov    %edx,0x8(%esp)
400009aa:	e8 31 00 00 00       	call   400009e0 <frwrite>
400009af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
400009b2:	e9 cd ff ff ff       	jmp    40000984 <fwrite+0x34>

    printrwerror(handle, res);
400009b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
400009ba:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400009bd:	89 04 24             	mov    %eax,(%esp)
400009c0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400009c4:	e8 77 00 00 00       	call   40000a40 <printrwerror>

    return res;
400009c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
400009cc:	83 c4 28             	add    $0x28,%esp
400009cf:	5d                   	pop    %ebp
400009d0:	c3                   	ret    
400009d1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
400009d8:	0f 1f 84 00 00 00 00 
400009df:	00 

400009e0 <frwrite>:
    if(res == RW_NOFM_WRITE) {
        printf("HANDLE[0x%x] FILEMODE doesn't allow write\n", handle);
    }
}

static uint32_t frwrite(uint32_t handle, const void* src, uint32_t length) {
400009e0:	55                   	push   %ebp
400009e1:	89 e5                	mov    %esp,%ebp
400009e3:	56                   	push   %esi
400009e4:	83 ec 34             	sub    $0x34,%esp
400009e7:	8b 45 10             	mov    0x10(%ebp),%eax
400009ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400009ed:	8b 55 08             	mov    0x8(%ebp),%edx
400009f0:	8d 75 d8             	lea    -0x28(%ebp),%esi
400009f3:	89 55 f8             	mov    %edx,-0x8(%ebp)
400009f6:	89 4d f4             	mov    %ecx,-0xc(%ebp)
400009f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct regstate state = {
400009fc:	c7 45 d8 0c 00 00 00 	movl   $0xc,-0x28(%ebp)
40000a03:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000a06:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000a09:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000a0c:	89 45 e0             	mov    %eax,-0x20(%ebp)
40000a0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000a12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000a15:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000a1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
      .edx = length,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000a23:	89 34 24             	mov    %esi,(%esp)
40000a26:	e8 f5 16 00 00       	call   40002120 <syscall>

    return (int)state.eax;
40000a2b:	8b 45 d8             	mov    -0x28(%ebp),%eax
40000a2e:	83 c4 34             	add    $0x34,%esp
40000a31:	5e                   	pop    %esi
40000a32:	5d                   	pop    %ebp
40000a33:	c3                   	ret    
40000a34:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000a3b:	00 00 00 00 00 

40000a40 <printrwerror>:
    syscall(&state);

    return (int)state.eax;
}

static void printrwerror(HANDLE handle, uint32_t res) {
40000a40:	55                   	push   %ebp
40000a41:	89 e5                	mov    %esp,%ebp
40000a43:	83 ec 28             	sub    $0x28,%esp
40000a46:	8b 45 0c             	mov    0xc(%ebp),%eax
40000a49:	8b 4d 08             	mov    0x8(%ebp),%ecx
40000a4c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40000a4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(res == RW_ERR_VFS) {
40000a52:	81 7d f8 02 00 00 00 	cmpl   $0x2,-0x8(%ebp)
40000a59:	0f 85 18 00 00 00    	jne    40000a77 <printrwerror+0x37>
40000a5f:	8d 05 00 33 00 40    	lea    0x40003300,%eax
        printf("HANDLE[0x%x] VFS_ERROR\n", handle);
40000a65:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000a68:	89 04 24             	mov    %eax,(%esp)
40000a6b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000a6f:	e8 5c 06 00 00       	call   400010d0 <printf>
40000a74:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if(res == RW_ERR_DRIVER) {
40000a77:	81 7d f8 03 00 00 00 	cmpl   $0x3,-0x8(%ebp)
40000a7e:	0f 85 18 00 00 00    	jne    40000a9c <printrwerror+0x5c>
40000a84:	8d 05 18 33 00 40    	lea    0x40003318,%eax
        printf("HANDLE[0x%x] DRIVER_ERROR\n", handle);
40000a8a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000a8d:	89 04 24             	mov    %eax,(%esp)
40000a90:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000a94:	e8 37 06 00 00       	call   400010d0 <printf>
40000a99:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    if(res == RW_NOFM_READ) {
40000a9c:	81 7d f8 04 00 00 00 	cmpl   $0x4,-0x8(%ebp)
40000aa3:	0f 85 18 00 00 00    	jne    40000ac1 <printrwerror+0x81>
40000aa9:	8d 05 33 33 00 40    	lea    0x40003333,%eax
        printf("HANDLE[0x%x] FILEMODE doesn't allow read\n", handle);
40000aaf:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000ab2:	89 04 24             	mov    %eax,(%esp)
40000ab5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000ab9:	e8 12 06 00 00       	call   400010d0 <printf>
40000abe:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }

    if(res == RW_NOFM_WRITE) {
40000ac1:	81 7d f8 05 00 00 00 	cmpl   $0x5,-0x8(%ebp)
40000ac8:	0f 85 18 00 00 00    	jne    40000ae6 <printrwerror+0xa6>
40000ace:	8d 05 5d 33 00 40    	lea    0x4000335d,%eax
        printf("HANDLE[0x%x] FILEMODE doesn't allow write\n", handle);
40000ad4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000ad7:	89 04 24             	mov    %eax,(%esp)
40000ada:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000ade:	e8 ed 05 00 00       	call   400010d0 <printf>
40000ae3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }
}
40000ae6:	83 c4 28             	add    $0x28,%esp
40000ae9:	5d                   	pop    %ebp
40000aea:	c3                   	ret    
40000aeb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40000af0 <fread>:
    syscall(&state);

    return (int)state.eax;
}

uint32_t fread(uint32_t handle, void* dest, uint32_t length) {
40000af0:	55                   	push   %ebp
40000af1:	89 e5                	mov    %esp,%ebp
40000af3:	83 ec 28             	sub    $0x28,%esp
40000af6:	8b 45 10             	mov    0x10(%ebp),%eax
40000af9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000afc:	8b 55 08             	mov    0x8(%ebp),%edx
40000aff:	89 55 fc             	mov    %edx,-0x4(%ebp)
40000b02:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000b05:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t res = frread(handle, dest, length);
40000b08:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000b0b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000b0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000b11:	89 04 24             	mov    %eax,(%esp)
40000b14:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b18:	89 54 24 08          	mov    %edx,0x8(%esp)
40000b1c:	e8 5f 00 00 00       	call   40000b80 <frread>
40000b21:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(res == RW_BLOCK) {
40000b24:	81 7d f0 01 00 00 00 	cmpl   $0x1,-0x10(%ebp)
40000b2b:	0f 85 26 00 00 00    	jne    40000b57 <fread+0x67>
        yield();
40000b31:	e8 aa f8 ff ff       	call   400003e0 <yield>
        res = frread(handle, dest, length);
40000b36:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000b39:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000b3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000b3f:	89 04 24             	mov    %eax,(%esp)
40000b42:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b46:	89 54 24 08          	mov    %edx,0x8(%esp)
40000b4a:	e8 31 00 00 00       	call   40000b80 <frread>
40000b4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40000b52:	e9 cd ff ff ff       	jmp    40000b24 <fread+0x34>

    printrwerror(handle, res);
40000b57:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000b5a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40000b5d:	89 04 24             	mov    %eax,(%esp)
40000b60:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40000b64:	e8 d7 fe ff ff       	call   40000a40 <printrwerror>

    return res;
40000b69:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000b6c:	83 c4 28             	add    $0x28,%esp
40000b6f:	5d                   	pop    %ebp
40000b70:	c3                   	ret    
40000b71:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000b78:	0f 1f 84 00 00 00 00 
40000b7f:	00 

40000b80 <frread>:
    printrwerror(handle, res);

    return res;
}

static uint32_t frread(uint32_t handle, void* dest, uint32_t length) {
40000b80:	55                   	push   %ebp
40000b81:	89 e5                	mov    %esp,%ebp
40000b83:	56                   	push   %esi
40000b84:	83 ec 34             	sub    $0x34,%esp
40000b87:	8b 45 10             	mov    0x10(%ebp),%eax
40000b8a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000b8d:	8b 55 08             	mov    0x8(%ebp),%edx
40000b90:	8d 75 d8             	lea    -0x28(%ebp),%esi
40000b93:	89 55 f8             	mov    %edx,-0x8(%ebp)
40000b96:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000b99:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct regstate state = {
40000b9c:	c7 45 d8 0d 00 00 00 	movl   $0xd,-0x28(%ebp)
40000ba3:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000ba6:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000bac:	89 45 e0             	mov    %eax,-0x20(%ebp)
40000baf:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000bb2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000bb5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000bbc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
      .edx = length,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000bc3:	89 34 24             	mov    %esi,(%esp)
40000bc6:	e8 55 15 00 00       	call   40002120 <syscall>

    return (int)state.eax;
40000bcb:	8b 45 d8             	mov    -0x28(%ebp),%eax
40000bce:	83 c4 34             	add    $0x34,%esp
40000bd1:	5e                   	pop    %esi
40000bd2:	5d                   	pop    %ebp
40000bd3:	c3                   	ret    
40000bd4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000bdb:	00 00 00 00 00 

40000be0 <fmkfifo>:
    printrwerror(handle, res);

    return res;
}

HANDLE fmkfifo(char* path) {
40000be0:	55                   	push   %ebp
40000be1:	89 e5                	mov    %esp,%ebp
40000be3:	83 ec 28             	sub    $0x28,%esp
40000be6:	8b 45 08             	mov    0x8(%ebp),%eax
40000be9:	8d 4d e0             	lea    -0x20(%ebp),%ecx
40000bec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
40000bef:	c7 45 e0 0e 00 00 00 	movl   $0xe,-0x20(%ebp)
40000bf6:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000bf9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000bfc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000c03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000c0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000c11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40000c18:	89 0c 24             	mov    %ecx,(%esp)
40000c1b:	e8 00 15 00 00       	call   40002120 <syscall>

    return (HANDLE)state.eax;
40000c20:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c23:	83 c4 28             	add    $0x28,%esp
40000c26:	5d                   	pop    %ebp
40000c27:	c3                   	ret    
40000c28:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
40000c2f:	00 

40000c30 <fgetc>:
        hdl = getpmhandle(hdl);
    }
    return hdl;
}

char fgetc(HANDLE hdl) {
40000c30:	55                   	push   %ebp
40000c31:	89 e5                	mov    %esp,%ebp
40000c33:	83 ec 28             	sub    $0x28,%esp
40000c36:	8b 45 08             	mov    0x8(%ebp),%eax
40000c39:	89 45 fc             	mov    %eax,-0x4(%ebp)
    hdl = resolveHandle(hdl);
40000c3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000c3f:	89 04 24             	mov    %eax,(%esp)
40000c42:	e8 49 00 00 00       	call   40000c90 <resolveHandle>
40000c47:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char in = 0;
40000c4a:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
    if(hdl != 0) {
40000c4e:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
40000c55:	0f 84 25 00 00 00    	je     40000c80 <fgetc+0x50>
40000c5b:	8d 45 fb             	lea    -0x5(%ebp),%eax
40000c5e:	b9 01 00 00 00       	mov    $0x1,%ecx
        fread(hdl, &in, sizeof(char));
40000c63:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000c66:	89 14 24             	mov    %edx,(%esp)
40000c69:	89 44 24 04          	mov    %eax,0x4(%esp)
40000c6d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
40000c74:	00 
40000c75:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000c78:	e8 73 fe ff ff       	call   40000af0 <fread>
40000c7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    return in;
40000c80:	0f be 45 fb          	movsbl -0x5(%ebp),%eax
40000c84:	83 c4 28             	add    $0x28,%esp
40000c87:	5d                   	pop    %ebp
40000c88:	c3                   	ret    
40000c89:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40000c90 <resolveHandle>:
    syscall(&state);

    return (HANDLE)state.eax;
}

static HANDLE resolveHandle(HANDLE hdl) {
40000c90:	55                   	push   %ebp
40000c91:	89 e5                	mov    %esp,%ebp
40000c93:	83 ec 08             	sub    $0x8,%esp
40000c96:	8b 45 08             	mov    0x8(%ebp),%eax
40000c99:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(hdl < 0xFFF) {
40000c9c:	81 7d fc ff 0f 00 00 	cmpl   $0xfff,-0x4(%ebp)
40000ca3:	0f 83 0e 00 00 00    	jae    40000cb7 <resolveHandle+0x27>
        hdl = getpmhandle(hdl);
40000ca9:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000cac:	89 04 24             	mov    %eax,(%esp)
40000caf:	e8 3c 07 00 00       	call   400013f0 <getpmhandle>
40000cb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    return hdl;
40000cb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000cba:	83 c4 08             	add    $0x8,%esp
40000cbd:	5d                   	pop    %ebp
40000cbe:	c3                   	ret    
40000cbf:	90                   	nop

40000cc0 <fgets>:
        fread(hdl, &in, sizeof(char));
    }
    return in;
}

char* fgets(char* str, int num, HANDLE hdl) {
40000cc0:	55                   	push   %ebp
40000cc1:	89 e5                	mov    %esp,%ebp
40000cc3:	83 ec 18             	sub    $0x18,%esp
40000cc6:	8b 45 10             	mov    0x10(%ebp),%eax
40000cc9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40000ccc:	8b 55 08             	mov    0x8(%ebp),%edx
40000ccf:	89 55 f8             	mov    %edx,-0x8(%ebp)
40000cd2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40000cd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int n = 0; n < (num - 1); n++) {
40000cd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000cdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000ce2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40000ce5:	81 e9 01 00 00 00    	sub    $0x1,%ecx
40000ceb:	39 c8                	cmp    %ecx,%eax
40000ced:	0f 8d 5f 00 00 00    	jge    40000d52 <fgets+0x92>
        str[n] = fgetc(hdl);
40000cf3:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000cf6:	89 04 24             	mov    %eax,(%esp)
40000cf9:	e8 32 ff ff ff       	call   40000c30 <fgetc>
40000cfe:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40000d01:	8b 55 f8             	mov    -0x8(%ebp),%edx
40000d04:	88 04 0a             	mov    %al,(%edx,%ecx,1)
        if(str[n] == 0 || str[n] == '\0') {
40000d07:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40000d0a:	8b 55 f8             	mov    -0x8(%ebp),%edx
40000d0d:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
40000d11:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
40000d17:	0f 84 15 00 00 00    	je     40000d32 <fgets+0x72>
40000d1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000d20:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000d23:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
40000d27:	3d 00 00 00 00       	cmp    $0x0,%eax
40000d2c:	0f 85 0b 00 00 00    	jne    40000d3d <fgets+0x7d>
            return str;
40000d32:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000d35:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000d38:	e9 25 00 00 00       	jmp    40000d62 <fgets+0xa2>
        }
    }
40000d3d:	e9 00 00 00 00       	jmp    40000d42 <fgets+0x82>
    }
    return in;
}

char* fgets(char* str, int num, HANDLE hdl) {
    for(int n = 0; n < (num - 1); n++) {
40000d42:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000d45:	05 01 00 00 00       	add    $0x1,%eax
40000d4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000d4d:	e9 8d ff ff ff       	jmp    40000cdf <fgets+0x1f>
        if(str[n] == 0 || str[n] == '\0') {
            return str;
        }
    }

    str[num] = '\0';
40000d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000d55:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000d58:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    return str;
40000d5c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000d5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40000d62:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000d65:	83 c4 18             	add    $0x18,%esp
40000d68:	5d                   	pop    %ebp
40000d69:	c3                   	ret    
40000d6a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

40000d70 <getc>:

char getc(HANDLE hdl) {
40000d70:	55                   	push   %ebp
40000d71:	89 e5                	mov    %esp,%ebp
40000d73:	83 ec 08             	sub    $0x8,%esp
40000d76:	8b 45 08             	mov    0x8(%ebp),%eax
40000d79:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return fgetc(hdl);
40000d7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000d7f:	89 04 24             	mov    %eax,(%esp)
40000d82:	e8 a9 fe ff ff       	call   40000c30 <fgetc>
40000d87:	0f be c0             	movsbl %al,%eax
40000d8a:	83 c4 08             	add    $0x8,%esp
40000d8d:	5d                   	pop    %ebp
40000d8e:	c3                   	ret    
40000d8f:	90                   	nop

40000d90 <getchar>:
}

char getchar() {
40000d90:	55                   	push   %ebp
40000d91:	89 e5                	mov    %esp,%ebp
40000d93:	83 ec 08             	sub    $0x8,%esp
40000d96:	b8 01 00 00 00       	mov    $0x1,%eax
    return fgetc(PMID_STDIN);
40000d9b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
40000da2:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000da5:	e8 86 fe ff ff       	call   40000c30 <fgetc>
40000daa:	0f be c0             	movsbl %al,%eax
40000dad:	83 c4 08             	add    $0x8,%esp
40000db0:	5d                   	pop    %ebp
40000db1:	c3                   	ret    
40000db2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40000db9:	1f 84 00 00 00 00 00 

40000dc0 <getln>:
}

char* getln(char* str) {
40000dc0:	55                   	push   %ebp
40000dc1:	89 e5                	mov    %esp,%ebp
40000dc3:	83 ec 28             	sub    $0x28,%esp
40000dc6:	8b 45 08             	mov    0x8(%ebp),%eax
40000dc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t index = 0;
40000dcc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    char lastChar = 0;
40000dd3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
40000dd7:	b8 01 00 00 00       	mov    $0x1,%eax

    while((lastChar = fgetc(PMID_STDIN))) {
40000ddc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
40000de3:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000de6:	e8 45 fe ff ff       	call   40000c30 <fgetc>
40000deb:	88 45 f7             	mov    %al,-0x9(%ebp)
40000dee:	3c 00                	cmp    $0x0,%al
40000df0:	0f 84 a5 00 00 00    	je     40000e9b <getln+0xdb>
        if(lastChar == '\n') {
40000df6:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
40000dfa:	3d 0a 00 00 00       	cmp    $0xa,%eax
40000dff:	0f 85 1c 00 00 00    	jne    40000e21 <getln+0x61>
40000e05:	b8 0a 00 00 00       	mov    $0xa,%eax
            putchar('\n');
40000e0a:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
40000e11:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000e14:	e8 97 00 00 00       	call   40000eb0 <putchar>
            break;
40000e19:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000e1c:	e9 7a 00 00 00       	jmp    40000e9b <getln+0xdb>
        }

        if(lastChar == 8) {
40000e21:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
40000e25:	3d 08 00 00 00       	cmp    $0x8,%eax
40000e2a:	0f 85 3f 00 00 00    	jne    40000e6f <getln+0xaf>
            if(index != 0) {
40000e30:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
40000e37:	0f 84 23 00 00 00    	je     40000e60 <getln+0xa0>
40000e3d:	b8 08 00 00 00       	mov    $0x8,%eax
                index--;
40000e42:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000e45:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
40000e4b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
                putchar(8);
40000e4e:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
40000e55:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000e58:	e8 53 00 00 00       	call   40000eb0 <putchar>
40000e5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
            }
            str[index] = 0;
40000e60:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000e63:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000e66:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
            continue;
40000e6a:	e9 68 ff ff ff       	jmp    40000dd7 <getln+0x17>
        }

        str[index] = lastChar;
40000e6f:	8a 45 f7             	mov    -0x9(%ebp),%al
40000e72:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000e75:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000e78:	88 04 0a             	mov    %al,(%edx,%ecx,1)
        putchar(lastChar);
40000e7b:	0f be 4d f7          	movsbl -0x9(%ebp),%ecx
40000e7f:	89 0c 24             	mov    %ecx,(%esp)
40000e82:	e8 29 00 00 00       	call   40000eb0 <putchar>

        index++;
40000e87:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40000e8a:	81 c1 01 00 00 00    	add    $0x1,%ecx
40000e90:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    }
40000e93:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000e96:	e9 3c ff ff ff       	jmp    40000dd7 <getln+0x17>

    str[index] = 0;
40000e9b:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000e9e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40000ea1:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)

    return str;
40000ea5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000ea8:	83 c4 28             	add    $0x28,%esp
40000eab:	5d                   	pop    %ebp
40000eac:	c3                   	ret    
40000ead:	0f 1f 00             	nopl   (%eax)

40000eb0 <putchar>:
  syscall(&state);
  
  return state.eax;
}

int putchar(char c) {
40000eb0:	55                   	push   %ebp
40000eb1:	89 e5                	mov    %esp,%ebp
40000eb3:	83 ec 18             	sub    $0x18,%esp
40000eb6:	8a 45 08             	mov    0x8(%ebp),%al
40000eb9:	b9 00 00 00 00       	mov    $0x0,%ecx
40000ebe:	88 45 ff             	mov    %al,-0x1(%ebp)
    return fputc(c, PMID_STDOUT);
40000ec1:	0f be 55 ff          	movsbl -0x1(%ebp),%edx
40000ec5:	89 14 24             	mov    %edx,(%esp)
40000ec8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000ecf:	00 
40000ed0:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000ed3:	e8 08 00 00 00       	call   40000ee0 <fputc>
40000ed8:	83 c4 18             	add    $0x18,%esp
40000edb:	5d                   	pop    %ebp
40000edc:	c3                   	ret    
40000edd:	0f 1f 00             	nopl   (%eax)

40000ee0 <fputc>:

int putc(char c, HANDLE hdl) {
    return fputc(c, hdl);
}

int fputc(char c, HANDLE hdl) {
40000ee0:	55                   	push   %ebp
40000ee1:	89 e5                	mov    %esp,%ebp
40000ee3:	83 ec 28             	sub    $0x28,%esp
40000ee6:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ee9:	8a 4d 08             	mov    0x8(%ebp),%cl
40000eec:	88 4d fb             	mov    %cl,-0x5(%ebp)
40000eef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    hdl = resolveHandle(hdl);
40000ef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000ef5:	89 04 24             	mov    %eax,(%esp)
40000ef8:	e8 93 fd ff ff       	call   40000c90 <resolveHandle>
40000efd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(hdl != 0) {
40000f00:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40000f07:	0f 84 2a 00 00 00    	je     40000f37 <fputc+0x57>
40000f0d:	8d 45 fb             	lea    -0x5(%ebp),%eax
40000f10:	b9 01 00 00 00       	mov    $0x1,%ecx
        return fwrite(hdl, &c, sizeof(char));
40000f15:	8b 55 f4             	mov    -0xc(%ebp),%edx
40000f18:	89 14 24             	mov    %edx,(%esp)
40000f1b:	89 44 24 04          	mov    %eax,0x4(%esp)
40000f1f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
40000f26:	00 
40000f27:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40000f2a:	e8 21 fa ff ff       	call   40000950 <fwrite>
40000f2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000f32:	e9 0f 00 00 00       	jmp    40000f46 <fputc+0x66>
    }
    return kputc(c);
40000f37:	0f be 45 fb          	movsbl -0x5(%ebp),%eax
40000f3b:	89 04 24             	mov    %eax,(%esp)
40000f3e:	e8 3d 00 00 00       	call   40000f80 <kputc>
40000f43:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40000f46:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000f49:	83 c4 28             	add    $0x28,%esp
40000f4c:	5d                   	pop    %ebp
40000f4d:	c3                   	ret    
40000f4e:	66 90                	xchg   %ax,%ax

40000f50 <putc>:

int putchar(char c) {
    return fputc(c, PMID_STDOUT);
}

int putc(char c, HANDLE hdl) {
40000f50:	55                   	push   %ebp
40000f51:	89 e5                	mov    %esp,%ebp
40000f53:	83 ec 18             	sub    $0x18,%esp
40000f56:	8b 45 0c             	mov    0xc(%ebp),%eax
40000f59:	8a 4d 08             	mov    0x8(%ebp),%cl
40000f5c:	88 4d ff             	mov    %cl,-0x1(%ebp)
40000f5f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return fputc(c, hdl);
40000f62:	8a 4d ff             	mov    -0x1(%ebp),%cl
40000f65:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000f68:	0f be d1             	movsbl %cl,%edx
40000f6b:	89 14 24             	mov    %edx,(%esp)
40000f6e:	89 44 24 04          	mov    %eax,0x4(%esp)
40000f72:	e8 69 ff ff ff       	call   40000ee0 <fputc>
40000f77:	83 c4 18             	add    $0x18,%esp
40000f7a:	5d                   	pop    %ebp
40000f7b:	c3                   	ret    
40000f7c:	0f 1f 40 00          	nopl   0x0(%eax)

40000f80 <kputc>:
    str[index] = 0;

    return str;
}

static int kputc(char c) {
40000f80:	55                   	push   %ebp
40000f81:	89 e5                	mov    %esp,%ebp
40000f83:	83 ec 28             	sub    $0x28,%esp
40000f86:	8a 45 08             	mov    0x8(%ebp),%al
40000f89:	8d 4d e0             	lea    -0x20(%ebp),%ecx
40000f8c:	88 45 ff             	mov    %al,-0x1(%ebp)
  struct regstate state = {
40000f8f:	c7 45 e0 c9 00 00 00 	movl   $0xc9,-0x20(%ebp)
40000f96:	0f be 55 ff          	movsbl -0x1(%ebp),%edx
40000f9a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40000f9d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40000fa4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000fab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000fb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);
40000fb9:	89 0c 24             	mov    %ecx,(%esp)
40000fbc:	e8 5f 11 00 00       	call   40002120 <syscall>
  
  return state.eax;
40000fc1:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000fc4:	83 c4 28             	add    $0x28,%esp
40000fc7:	5d                   	pop    %ebp
40000fc8:	c3                   	ret    
40000fc9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40000fd0 <puts>:
  syscall(&state);
  
  return state.eax;
}

int puts(const char* c) {
40000fd0:	55                   	push   %ebp
40000fd1:	89 e5                	mov    %esp,%ebp
40000fd3:	83 ec 18             	sub    $0x18,%esp
40000fd6:	8b 45 08             	mov    0x8(%ebp),%eax
40000fd9:	b9 00 00 00 00       	mov    $0x0,%ecx
40000fde:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return fputs(c, PMID_STDOUT);
40000fe1:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000fe4:	89 04 24             	mov    %eax,(%esp)
40000fe7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40000fee:	00 
40000fef:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40000ff2:	e8 09 00 00 00       	call   40001000 <fputs>
40000ff7:	83 c4 18             	add    $0x18,%esp
40000ffa:	5d                   	pop    %ebp
40000ffb:	c3                   	ret    
40000ffc:	0f 1f 40 00          	nopl   0x0(%eax)

40001000 <fputs>:
}

int fputs(const char* c, HANDLE hdl) {
40001000:	55                   	push   %ebp
40001001:	89 e5                	mov    %esp,%ebp
40001003:	56                   	push   %esi
40001004:	83 ec 24             	sub    $0x24,%esp
40001007:	8b 45 0c             	mov    0xc(%ebp),%eax
4000100a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000100d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40001010:	89 45 f0             	mov    %eax,-0x10(%ebp)
    hdl = resolveHandle(hdl);
40001013:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001016:	89 04 24             	mov    %eax,(%esp)
40001019:	e8 72 fc ff ff       	call   40000c90 <resolveHandle>
4000101e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(hdl != 0) {
40001021:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001028:	0f 84 36 00 00 00    	je     40001064 <fputs+0x64>
        return fwrite(hdl, c, strlen(c));
4000102e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001031:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001034:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001037:	89 e6                	mov    %esp,%esi
40001039:	89 16                	mov    %edx,(%esi)
4000103b:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000103e:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40001041:	e8 4a 06 00 00       	call   40001690 <strlen>
40001046:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40001049:	89 0c 24             	mov    %ecx,(%esp)
4000104c:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000104f:	89 54 24 04          	mov    %edx,0x4(%esp)
40001053:	89 44 24 08          	mov    %eax,0x8(%esp)
40001057:	e8 f4 f8 ff ff       	call   40000950 <fwrite>
4000105c:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000105f:	e9 0e 00 00 00       	jmp    40001072 <fputs+0x72>
    }
    return kputs(c);
40001064:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001067:	89 04 24             	mov    %eax,(%esp)
4000106a:	e8 11 00 00 00       	call   40001080 <kputs>
4000106f:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
40001072:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001075:	83 c4 24             	add    $0x24,%esp
40001078:	5e                   	pop    %esi
40001079:	5d                   	pop    %ebp
4000107a:	c3                   	ret    
4000107b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40001080 <kputs>:
        return fwrite(hdl, &c, sizeof(char));
    }
    return kputc(c);
}

static int kputs(const char* cp) {
40001080:	55                   	push   %ebp
40001081:	89 e5                	mov    %esp,%ebp
40001083:	83 ec 28             	sub    $0x28,%esp
40001086:	8b 45 08             	mov    0x8(%ebp),%eax
40001089:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000108c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct regstate state = {
4000108f:	c7 45 e0 ca 00 00 00 	movl   $0xca,-0x20(%ebp)
40001096:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001099:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000109c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400010a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400010aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400010b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);
400010b8:	89 0c 24             	mov    %ecx,(%esp)
400010bb:	e8 60 10 00 00       	call   40002120 <syscall>
  
  return state.eax;
400010c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400010c3:	83 c4 28             	add    $0x28,%esp
400010c6:	5d                   	pop    %ebp
400010c7:	c3                   	ret    
400010c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
400010cf:	00 

400010d0 <printf>:
  
  return wrt;
}

int printf(const char* fmt, ...)
{
400010d0:	55                   	push   %ebp
400010d1:	89 e5                	mov    %esp,%ebp
400010d3:	83 ec 58             	sub    $0x58,%esp
400010d6:	8b 45 08             	mov    0x8(%ebp),%eax
400010d9:	8d 4d f8             	lea    -0x8(%ebp),%ecx
400010dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  va_list ap;
  const char* s;
  unsigned long n;
	char c;
	int wrt = 0;
400010df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400010e6:	8d 45 0c             	lea    0xc(%ebp),%eax

  va_start(ap, fmt);
400010e9:	89 01                	mov    %eax,(%ecx)
  while (*fmt) {
400010eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
400010ee:	80 38 00             	cmpb   $0x0,(%eax)
400010f1:	0f 84 1d 02 00 00    	je     40001314 <printf+0x244>
    if (*fmt == '%') {
400010f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
400010fa:	0f be 00             	movsbl (%eax),%eax
400010fd:	3d 25 00 00 00       	cmp    $0x25,%eax
40001102:	0f 85 e6 01 00 00    	jne    400012ee <printf+0x21e>
      fmt++;
40001108:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000110b:	89 c1                	mov    %eax,%ecx
4000110d:	41                   	inc    %ecx
4000110e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
      switch (*fmt) {
40001111:	0f be 40 01          	movsbl 0x1(%eax),%eax
40001115:	89 c1                	mov    %eax,%ecx
40001117:	83 e9 24             	sub    $0x24,%ecx
4000111a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000111d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
40001120:	0f 8f 15 00 00 00    	jg     4000113b <printf+0x6b>
40001126:	e9 00 00 00 00       	jmp    4000112b <printf+0x5b>
4000112b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000112e:	85 c0                	test   %eax,%eax
40001130:	0f 84 7c 01 00 00    	je     400012b2 <printf+0x1e2>
40001136:	e9 7c 01 00 00       	jmp    400012b7 <printf+0x1e7>
4000113b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000113e:	83 e8 62             	sub    $0x62,%eax
40001141:	89 45 dc             	mov    %eax,-0x24(%ebp)
40001144:	0f 8f 19 00 00 00    	jg     40001163 <printf+0x93>
4000114a:	e9 00 00 00 00       	jmp    4000114f <printf+0x7f>
4000114f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001152:	83 e8 25             	sub    $0x25,%eax
40001155:	89 45 d8             	mov    %eax,-0x28(%ebp)
40001158:	0f 84 33 01 00 00    	je     40001291 <printf+0x1c1>
4000115e:	e9 54 01 00 00       	jmp    400012b7 <printf+0x1e7>
40001163:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001166:	83 e8 6f             	sub    $0x6f,%eax
40001169:	89 45 d4             	mov    %eax,-0x2c(%ebp)
4000116c:	0f 8f 2d 00 00 00    	jg     4000119f <printf+0xcf>
40001172:	e9 00 00 00 00       	jmp    40001177 <printf+0xa7>
40001177:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000117a:	83 e8 63             	sub    $0x63,%eax
4000117d:	89 45 d0             	mov    %eax,-0x30(%ebp)
40001180:	0f 84 dd 00 00 00    	je     40001263 <printf+0x193>
40001186:	e9 00 00 00 00       	jmp    4000118b <printf+0xbb>
4000118b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000118e:	83 e8 64             	sub    $0x64,%eax
40001191:	89 45 cc             	mov    %eax,-0x34(%ebp)
40001194:	0f 84 53 00 00 00    	je     400011ed <printf+0x11d>
4000119a:	e9 18 01 00 00       	jmp    400012b7 <printf+0x1e7>
4000119f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400011a2:	83 c0 90             	add    $0xffffff90,%eax
400011a5:	89 c1                	mov    %eax,%ecx
400011a7:	83 e9 08             	sub    $0x8,%ecx
400011aa:	89 45 c8             	mov    %eax,-0x38(%ebp)
400011ad:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
400011b0:	0f 87 01 01 00 00    	ja     400012b7 <printf+0x1e7>
400011b6:	8b 45 c8             	mov    -0x38(%ebp),%eax
400011b9:	8b 0c 85 6c 30 00 40 	mov    0x4000306c(,%eax,4),%ecx
400011c0:	ff e1                	jmp    *%ecx
        case 's':
          s = va_arg(ap, char*);
400011c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
400011c5:	89 c1                	mov    %eax,%ecx
400011c7:	81 c1 04 00 00 00    	add    $0x4,%ecx
400011cd:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400011d0:	8b 00                	mov    (%eax),%eax
400011d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
          wrt += puts(s);
400011d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
400011d8:	89 04 24             	mov    %eax,(%esp)
400011db:	e8 f0 fd ff ff       	call   40000fd0 <puts>
400011e0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400011e3:	01 c1                	add    %eax,%ecx
400011e5:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
400011e8:	e9 fc 00 00 00       	jmp    400012e9 <printf+0x219>
400011ed:	b8 0a 00 00 00       	mov    $0xa,%eax
        case 'd':
        case 'u':
          n = va_arg(ap, unsigned long int);
400011f2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400011f5:	89 ca                	mov    %ecx,%edx
400011f7:	81 c2 04 00 00 00    	add    $0x4,%edx
400011fd:	89 55 f8             	mov    %edx,-0x8(%ebp)
40001200:	8b 09                	mov    (%ecx),%ecx
40001202:	89 4d f0             	mov    %ecx,-0x10(%ebp)
          wrt += putn(n, 10);
40001205:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001208:	89 0c 24             	mov    %ecx,(%esp)
4000120b:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
40001212:	00 
40001213:	89 45 c0             	mov    %eax,-0x40(%ebp)
40001216:	e8 15 01 00 00       	call   40001330 <putn>
4000121b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000121e:	01 c1                	add    %eax,%ecx
40001220:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
40001223:	e9 c1 00 00 00       	jmp    400012e9 <printf+0x219>
40001228:	b8 10 00 00 00       	mov    $0x10,%eax
        case 'x':
        case 'p':
          n = va_arg(ap, unsigned long int);
4000122d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001230:	89 ca                	mov    %ecx,%edx
40001232:	81 c2 04 00 00 00    	add    $0x4,%edx
40001238:	89 55 f8             	mov    %edx,-0x8(%ebp)
4000123b:	8b 09                	mov    (%ecx),%ecx
4000123d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
          wrt += putn(n, 16);
40001240:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001243:	89 0c 24             	mov    %ecx,(%esp)
40001246:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
4000124d:	00 
4000124e:	89 45 bc             	mov    %eax,-0x44(%ebp)
40001251:	e8 da 00 00 00       	call   40001330 <putn>
40001256:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40001259:	01 c1                	add    %eax,%ecx
4000125b:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
4000125e:	e9 86 00 00 00       	jmp    400012e9 <printf+0x219>
        case 'c':
          c = va_arg(ap, int);
40001263:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001266:	89 c1                	mov    %eax,%ecx
40001268:	81 c1 04 00 00 00    	add    $0x4,%ecx
4000126e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001271:	8b 00                	mov    (%eax),%eax
40001273:	88 c2                	mov    %al,%dl
40001275:	88 55 ef             	mov    %dl,-0x11(%ebp)
          wrt += putchar(c);
40001278:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
4000127c:	89 04 24             	mov    %eax,(%esp)
4000127f:	e8 2c fc ff ff       	call   40000eb0 <putchar>
40001284:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40001287:	01 c1                	add    %eax,%ecx
40001289:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
4000128c:	e9 58 00 00 00       	jmp    400012e9 <printf+0x219>
40001291:	b8 25 00 00 00       	mov    $0x25,%eax
        case '%':
          wrt += putchar('%');
40001296:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
4000129d:	89 45 b8             	mov    %eax,-0x48(%ebp)
400012a0:	e8 0b fc ff ff       	call   40000eb0 <putchar>
400012a5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400012a8:	01 c1                	add    %eax,%ecx
400012aa:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
400012ad:	e9 37 00 00 00       	jmp    400012e9 <printf+0x219>
        case '\0':
          goto out;
400012b2:	e9 62 00 00 00       	jmp    40001319 <printf+0x249>
400012b7:	b8 25 00 00 00       	mov    $0x25,%eax
        default:
          wrt += putchar('%');
400012bc:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
400012c3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
400012c6:	e8 e5 fb ff ff       	call   40000eb0 <putchar>
400012cb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400012ce:	01 c1                	add    %eax,%ecx
400012d0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          wrt += putchar(*fmt);
400012d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
400012d6:	0f be 00             	movsbl (%eax),%eax
400012d9:	89 04 24             	mov    %eax,(%esp)
400012dc:	e8 cf fb ff ff       	call   40000eb0 <putchar>
400012e1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400012e4:	01 c1                	add    %eax,%ecx
400012e6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
          break;
      }
    } else {
400012e9:	e9 16 00 00 00       	jmp    40001304 <printf+0x234>
      wrt += putchar(*fmt);
400012ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
400012f1:	0f be 00             	movsbl (%eax),%eax
400012f4:	89 04 24             	mov    %eax,(%esp)
400012f7:	e8 b4 fb ff ff       	call   40000eb0 <putchar>
400012fc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400012ff:	01 c1                	add    %eax,%ecx
40001301:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    }

    fmt++;
40001304:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001307:	05 01 00 00 00       	add    $0x1,%eax
4000130c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  }
4000130f:	e9 d7 fd ff ff       	jmp    400010eb <printf+0x1b>
40001314:	e9 00 00 00 00       	jmp    40001319 <printf+0x249>

out:
  va_end(ap);

  return wrt;
40001319:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000131c:	83 c4 58             	add    $0x58,%esp
4000131f:	5d                   	pop    %ebp
40001320:	c3                   	ret    
40001321:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001328:	0f 1f 84 00 00 00 00 
4000132f:	00 

40001330 <putn>:
    }
    return kputs(c);
}

static int putn(unsigned long x, int base)
{
40001330:	55                   	push   %ebp
40001331:	89 e5                	mov    %esp,%ebp
40001333:	56                   	push   %esi
40001334:	83 ec 74             	sub    $0x74,%esp
40001337:	8b 45 0c             	mov    0xc(%ebp),%eax
4000133a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000133d:	8d 15 db 32 00 40    	lea    0x400032db,%edx
40001343:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40001346:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char buf[65];
  const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
40001349:	89 55 a8             	mov    %edx,-0x58(%ebp)
  char* p;
  int wrt = 0;
4000134c:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)

  if (base > 36) {
40001353:	81 7d f0 24 00 00 00 	cmpl   $0x24,-0x10(%ebp)
4000135a:	0f 8e 0c 00 00 00    	jle    4000136c <putn+0x3c>
    return 0;
40001360:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40001367:	e9 71 00 00 00       	jmp    400013dd <putn+0xad>
4000136c:	8d 45 af             	lea    -0x51(%ebp),%eax
  }

  p = buf + 64;
4000136f:	05 40 00 00 00       	add    $0x40,%eax
40001374:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  *p = '\0';
40001377:	8b 45 a4             	mov    -0x5c(%ebp),%eax
4000137a:	c6 00 00             	movb   $0x0,(%eax)
  do {
    wrt++;
4000137d:	8b 45 a0             	mov    -0x60(%ebp),%eax
40001380:	05 01 00 00 00       	add    $0x1,%eax
40001385:	89 45 a0             	mov    %eax,-0x60(%ebp)
    *--p = digits[x % base];
40001388:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000138b:	31 d2                	xor    %edx,%edx
4000138d:	f7 75 f0             	divl   -0x10(%ebp)
40001390:	8b 45 a8             	mov    -0x58(%ebp),%eax
40001393:	8a 0c 10             	mov    (%eax,%edx,1),%cl
40001396:	8b 45 a4             	mov    -0x5c(%ebp),%eax
40001399:	89 c2                	mov    %eax,%edx
4000139b:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
400013a1:	89 55 a4             	mov    %edx,-0x5c(%ebp)
400013a4:	88 48 ff             	mov    %cl,-0x1(%eax)
    x /= base;
400013a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400013aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
400013ad:	89 45 9c             	mov    %eax,-0x64(%ebp)
400013b0:	89 d0                	mov    %edx,%eax
400013b2:	31 d2                	xor    %edx,%edx
400013b4:	8b 75 9c             	mov    -0x64(%ebp),%esi
400013b7:	f7 f6                	div    %esi
400013b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  } while (x);
400013bc:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
400013c3:	0f 85 b4 ff ff ff    	jne    4000137d <putn+0x4d>
  puts(p);
400013c9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
400013cc:	89 04 24             	mov    %eax,(%esp)
400013cf:	e8 fc fb ff ff       	call   40000fd0 <puts>
  
  return wrt;
400013d4:	8b 4d a0             	mov    -0x60(%ebp),%ecx
400013d7:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400013da:	89 45 98             	mov    %eax,-0x68(%ebp)
}
400013dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
400013e0:	83 c4 74             	add    $0x74,%esp
400013e3:	5e                   	pop    %esi
400013e4:	5d                   	pop    %ebp
400013e5:	c3                   	ret    
400013e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
400013ed:	00 00 00 

400013f0 <getpmhandle>:
    syscall(&state);

    return state.eax;
}

static HANDLE getpmhandle   (uint32_t pmid) {
400013f0:	55                   	push   %ebp
400013f1:	89 e5                	mov    %esp,%ebp
400013f3:	83 ec 28             	sub    $0x28,%esp
400013f6:	8b 45 08             	mov    0x8(%ebp),%eax
400013f9:	8d 4d e0             	lea    -0x20(%ebp),%ecx
400013fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct regstate state = {
400013ff:	c7 45 e0 14 00 00 00 	movl   $0x14,-0x20(%ebp)
40001406:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001409:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000140c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001413:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000141a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001421:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      .edx = 0,
      .esi = 0,
      .edi = 0
    };

    syscall(&state);
40001428:	89 0c 24             	mov    %ecx,(%esp)
4000142b:	e8 f0 0c 00 00       	call   40002120 <syscall>

    return (HANDLE)state.eax;
40001430:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001433:	83 c4 28             	add    $0x28,%esp
40001436:	5d                   	pop    %ebp
40001437:	c3                   	ret    
40001438:	66 90                	xchg   %ax,%ax
4000143a:	66 90                	xchg   %ax,%ax
4000143c:	66 90                	xchg   %ax,%ax
4000143e:	66 90                	xchg   %ax,%ax

40001440 <memset>:
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
40001440:	55                   	push   %ebp
40001441:	89 e5                	mov    %esp,%ebp
40001443:	83 ec 10             	sub    $0x10,%esp
40001446:	8b 45 10             	mov    0x10(%ebp),%eax
40001449:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000144c:	8b 55 08             	mov    0x8(%ebp),%edx
4000144f:	89 55 fc             	mov    %edx,-0x4(%ebp)
40001452:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001455:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char* p = buf;
40001458:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000145b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	while (n--) {
4000145e:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001461:	89 c1                	mov    %eax,%ecx
40001463:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
40001469:	89 4d f4             	mov    %ecx,-0xc(%ebp)
4000146c:	3d 00 00 00 00       	cmp    $0x0,%eax
40001471:	0f 84 1a 00 00 00    	je     40001491 <memset+0x51>
		*p++ = c;
40001477:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000147a:	88 c1                	mov    %al,%cl
4000147c:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000147f:	89 c2                	mov    %eax,%edx
40001481:	81 c2 01 00 00 00    	add    $0x1,%edx
40001487:	89 55 f0             	mov    %edx,-0x10(%ebp)
4000148a:	88 08                	mov    %cl,(%eax)
	}
4000148c:	e9 cd ff ff ff       	jmp    4000145e <memset+0x1e>

	return buf;
40001491:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001494:	83 c4 10             	add    $0x10,%esp
40001497:	5d                   	pop    %ebp
40001498:	c3                   	ret    
40001499:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

400014a0 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
400014a0:	55                   	push   %ebp
400014a1:	89 e5                	mov    %esp,%ebp
400014a3:	83 ec 18             	sub    $0x18,%esp
400014a6:	8b 45 10             	mov    0x10(%ebp),%eax
400014a9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400014ac:	8b 55 08             	mov    0x8(%ebp),%edx
400014af:	89 55 f8             	mov    %edx,-0x8(%ebp)
400014b2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
400014b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char* d = dest;
400014b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
400014bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const unsigned char* s = src;
400014be:	8b 45 f4             	mov    -0xc(%ebp),%eax
400014c1:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(n == 0) return 0;
400014c4:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
400014cb:	0f 85 0c 00 00 00    	jne    400014dd <memcpy+0x3d>
400014d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400014d8:	e9 49 00 00 00       	jmp    40001526 <memcpy+0x86>

	while (n--) {
400014dd:	e9 00 00 00 00       	jmp    400014e2 <memcpy+0x42>
400014e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
400014e5:	89 c1                	mov    %eax,%ecx
400014e7:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
400014ed:	89 4d f0             	mov    %ecx,-0x10(%ebp)
400014f0:	3d 00 00 00 00       	cmp    $0x0,%eax
400014f5:	0f 84 25 00 00 00    	je     40001520 <memcpy+0x80>
		*d++ = *s++;
400014fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
400014fe:	89 c1                	mov    %eax,%ecx
40001500:	81 c1 01 00 00 00    	add    $0x1,%ecx
40001506:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40001509:	8a 10                	mov    (%eax),%dl
4000150b:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000150e:	89 c1                	mov    %eax,%ecx
40001510:	81 c1 01 00 00 00    	add    $0x1,%ecx
40001516:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40001519:	88 10                	mov    %dl,(%eax)
	}
4000151b:	e9 c2 ff ff ff       	jmp    400014e2 <memcpy+0x42>

	return dest;
40001520:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001523:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40001526:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001529:	83 c4 18             	add    $0x18,%esp
4000152c:	5d                   	pop    %ebp
4000152d:	c3                   	ret    
4000152e:	66 90                	xchg   %ax,%ax

40001530 <memcmp>:

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
40001530:	55                   	push   %ebp
40001531:	89 e5                	mov    %esp,%ebp
40001533:	83 ec 1c             	sub    $0x1c,%esp
40001536:	8b 45 10             	mov    0x10(%ebp),%eax
40001539:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000153c:	8b 55 08             	mov    0x8(%ebp),%edx
4000153f:	89 55 f8             	mov    %edx,-0x8(%ebp)
40001542:	89 4d f4             	mov    %ecx,-0xc(%ebp)
40001545:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
40001548:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
4000154f:	0f 85 0c 00 00 00    	jne    40001561 <memcmp+0x31>
        return -1;
40001555:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
4000155c:	e9 a7 00 00 00       	jmp    40001608 <memcmp+0xd8>
    if (ptr2 == 0)
40001561:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001568:	0f 85 0c 00 00 00    	jne    4000157a <memcmp+0x4a>
        return 1;
4000156e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
40001575:	e9 8e 00 00 00       	jmp    40001608 <memcmp+0xd8>
    if (num == 0)
4000157a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001581:	0f 85 0c 00 00 00    	jne    40001593 <memcmp+0x63>
        return 0;
40001587:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000158e:	e9 75 00 00 00       	jmp    40001608 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
40001593:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001596:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
40001599:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000159c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
4000159f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
400015a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400015a9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
400015ac:	0f 83 4f 00 00 00    	jae    40001601 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
400015b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400015b5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400015b8:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
400015bc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400015bf:	8b 55 e8             	mov    -0x18(%ebp),%edx
400015c2:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
400015c6:	39 c8                	cmp    %ecx,%eax
400015c8:	0f 84 1e 00 00 00    	je     400015ec <memcmp+0xbc>
            return pa[i] - pb[i];
400015ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400015d1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400015d4:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
400015d8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400015db:	8b 55 e8             	mov    -0x18(%ebp),%edx
400015de:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
400015e2:	29 c8                	sub    %ecx,%eax
400015e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
400015e7:	e9 1c 00 00 00       	jmp    40001608 <memcmp+0xd8>
        }
    }
400015ec:	e9 00 00 00 00       	jmp    400015f1 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
400015f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400015f4:	05 01 00 00 00       	add    $0x1,%eax
400015f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400015fc:	e9 a5 ff ff ff       	jmp    400015a6 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
40001601:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
40001608:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000160b:	83 c4 1c             	add    $0x1c,%esp
4000160e:	5d                   	pop    %ebp
4000160f:	c3                   	ret    

40001610 <strcmp>:

int strcmp(const char* str1, const char* str2) {
40001610:	55                   	push   %ebp
40001611:	89 e5                	mov    %esp,%ebp
40001613:	56                   	push   %esi
40001614:	83 ec 24             	sub    $0x24,%esp
40001617:	8b 45 0c             	mov    0xc(%ebp),%eax
4000161a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000161d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001620:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
40001623:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001626:	89 e1                	mov    %esp,%ecx
40001628:	89 01                	mov    %eax,(%ecx)
4000162a:	e8 61 00 00 00       	call   40001690 <strlen>
4000162f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
40001632:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001635:	89 e1                	mov    %esp,%ecx
40001637:	89 01                	mov    %eax,(%ecx)
40001639:	e8 52 00 00 00       	call   40001690 <strlen>
4000163e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
40001641:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001644:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40001647:	0f 8d 0b 00 00 00    	jge    40001658 <strcmp+0x48>
4000164d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001650:	89 45 e8             	mov    %eax,-0x18(%ebp)
40001653:	e9 06 00 00 00       	jmp    4000165e <strcmp+0x4e>
40001658:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000165b:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000165e:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001661:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
40001664:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001667:	8b 4d f4             	mov    -0xc(%ebp),%ecx
4000166a:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000166d:	81 c2 01 00 00 00    	add    $0x1,%edx
40001673:	c1 e2 00             	shl    $0x0,%edx
40001676:	89 e6                	mov    %esp,%esi
40001678:	89 56 08             	mov    %edx,0x8(%esi)
4000167b:	89 4e 04             	mov    %ecx,0x4(%esi)
4000167e:	89 06                	mov    %eax,(%esi)
40001680:	e8 ab fe ff ff       	call   40001530 <memcmp>
40001685:	83 c4 24             	add    $0x24,%esp
40001688:	5e                   	pop    %esi
40001689:	5d                   	pop    %ebp
4000168a:	c3                   	ret    
4000168b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40001690 <strlen>:
}

unsigned int strlen(const char* str) {
40001690:	55                   	push   %ebp
40001691:	89 e5                	mov    %esp,%ebp
40001693:	83 ec 0c             	sub    $0xc,%esp
40001696:	8b 45 08             	mov    0x8(%ebp),%eax
40001699:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
4000169c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
400016a3:	0f 85 0c 00 00 00    	jne    400016b5 <strlen+0x25>
        return 0;
400016a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400016b0:	e9 37 00 00 00       	jmp    400016ec <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
400016b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
400016bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
400016bf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400016c2:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
400016c6:	3d 00 00 00 00       	cmp    $0x0,%eax
400016cb:	0f 84 15 00 00 00    	je     400016e6 <strlen+0x56>
400016d1:	e9 00 00 00 00       	jmp    400016d6 <strlen+0x46>
400016d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
400016d9:	05 01 00 00 00       	add    $0x1,%eax
400016de:	89 45 f4             	mov    %eax,-0xc(%ebp)
400016e1:	e9 d6 ff ff ff       	jmp    400016bc <strlen+0x2c>
        ;
    return i;
400016e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
400016e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
400016ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
400016ef:	83 c4 0c             	add    $0xc,%esp
400016f2:	5d                   	pop    %ebp
400016f3:	c3                   	ret    
400016f4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
400016fb:	00 00 00 00 00 

40001700 <strcpy>:

char* strcpy(char* dest, const char* src) {
40001700:	55                   	push   %ebp
40001701:	89 e5                	mov    %esp,%ebp
40001703:	56                   	push   %esi
40001704:	83 ec 24             	sub    $0x24,%esp
40001707:	8b 45 0c             	mov    0xc(%ebp),%eax
4000170a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000170d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001710:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
40001713:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001716:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001719:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000171c:	89 e6                	mov    %esp,%esi
4000171e:	89 16                	mov    %edx,(%esi)
40001720:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001723:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40001726:	e8 65 ff ff ff       	call   40001690 <strlen>
4000172b:	c1 e0 00             	shl    $0x0,%eax
4000172e:	05 01 00 00 00       	add    $0x1,%eax
40001733:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001736:	89 0c 24             	mov    %ecx,(%esp)
40001739:	8b 55 ec             	mov    -0x14(%ebp),%edx
4000173c:	89 54 24 04          	mov    %edx,0x4(%esp)
40001740:	89 44 24 08          	mov    %eax,0x8(%esp)
40001744:	e8 57 fd ff ff       	call   400014a0 <memcpy>
    return dest;
40001749:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000174c:	83 c4 24             	add    $0x24,%esp
4000174f:	5e                   	pop    %esi
40001750:	5d                   	pop    %ebp
40001751:	c3                   	ret    
40001752:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001759:	1f 84 00 00 00 00 00 

40001760 <strclone>:
}

char* strclone(char* str) {
40001760:	55                   	push   %ebp
40001761:	89 e5                	mov    %esp,%ebp
40001763:	83 ec 18             	sub    $0x18,%esp
40001766:	8b 45 08             	mov    0x8(%ebp),%eax
40001769:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
4000176c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000176f:	89 e1                	mov    %esp,%ecx
40001771:	89 01                	mov    %eax,(%ecx)
40001773:	e8 18 ff ff ff       	call   40001690 <strlen>
40001778:	c1 e0 00             	shl    $0x0,%eax
4000177b:	05 01 00 00 00       	add    $0x1,%eax
40001780:	89 04 24             	mov    %eax,(%esp)
40001783:	e8 58 02 00 00       	call   400019e0 <malloc>
40001788:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
4000178b:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000178e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001791:	89 e2                	mov    %esp,%edx
40001793:	89 4a 04             	mov    %ecx,0x4(%edx)
40001796:	89 02                	mov    %eax,(%edx)
40001798:	e8 63 ff ff ff       	call   40001700 <strcpy>

    return ret;
4000179d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
400017a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
400017a3:	89 c8                	mov    %ecx,%eax
400017a5:	83 c4 18             	add    $0x18,%esp
400017a8:	5d                   	pop    %ebp
400017a9:	c3                   	ret    
400017aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

400017b0 <strtok>:
}

char* sp = NULL; /* the start position of the string */

char* strtok(char* str, const char* delimiters) {
400017b0:	55                   	push   %ebp
400017b1:	89 e5                	mov    %esp,%ebp
400017b3:	83 ec 18             	sub    $0x18,%esp
400017b6:	8b 45 0c             	mov    0xc(%ebp),%eax
400017b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
400017bc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
400017bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) {
400017c2:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
400017c9:	0f 84 22 00 00 00    	je     400017f1 <strtok+0x41>
        return strtoknc(strclone(str), delimiters);
400017cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
400017d2:	89 04 24             	mov    %eax,(%esp)
400017d5:	e8 86 ff ff ff       	call   40001760 <strclone>
400017da:	8b 4d f4             	mov    -0xc(%ebp),%ecx
400017dd:	89 04 24             	mov    %eax,(%esp)
400017e0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400017e4:	e8 37 00 00 00       	call   40001820 <strtoknc>
400017e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
400017ec:	e9 1e 00 00 00       	jmp    4000180f <strtok+0x5f>
400017f1:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
400017f6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
400017f9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
40001800:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001804:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001807:	e8 14 00 00 00       	call   40001820 <strtoknc>
4000180c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
4000180f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001812:	83 c4 18             	add    $0x18,%esp
40001815:	5d                   	pop    %ebp
40001816:	c3                   	ret    
40001817:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
4000181e:	00 00 

40001820 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
40001820:	55                   	push   %ebp
40001821:	89 e5                	mov    %esp,%ebp
40001823:	83 ec 28             	sub    $0x28,%esp
40001826:	8b 45 0c             	mov    0xc(%ebp),%eax
40001829:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000182c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
4000182f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
40001832:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
40001839:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000183c:	89 e1                	mov    %esp,%ecx
4000183e:	89 01                	mov    %eax,(%ecx)
40001840:	e8 4b fe ff ff       	call   40001690 <strlen>
40001845:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
40001848:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
4000184f:	0f 85 0c 00 00 00    	jne    40001861 <strtoknc+0x41>
        return 0;
40001855:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000185c:	e9 70 01 00 00       	jmp    400019d1 <strtoknc+0x1b1>

    /* if the original string has nothing left */
    if (!str && !sp)
40001861:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
40001868:	0f 85 1c 00 00 00    	jne    4000188a <strtoknc+0x6a>
4000186e:	81 3d 00 40 00 40 00 	cmpl   $0x0,0x40004000
40001875:	00 00 00 
40001878:	0f 85 0c 00 00 00    	jne    4000188a <strtoknc+0x6a>
        return 0;
4000187e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001885:	e9 47 01 00 00       	jmp    400019d1 <strtoknc+0x1b1>

    /* initialize the sp during the first call */
    if (str)
4000188a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
40001891:	0f 84 08 00 00 00    	je     4000189f <strtoknc+0x7f>
        sp = str;
40001897:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000189a:	a3 00 40 00 40       	mov    %eax,0x40004000

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
4000189f:	a1 00 40 00 40       	mov    0x40004000,%eax
400018a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
400018a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400018ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
400018b1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
400018b4:	0f 8d 3d 00 00 00    	jge    400018f7 <strtoknc+0xd7>
            if (*p_start == delimiters[i]) {
400018ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
400018bd:	0f be 00             	movsbl (%eax),%eax
400018c0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400018c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
400018c6:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
400018ca:	39 c8                	cmp    %ecx,%eax
400018cc:	0f 85 10 00 00 00    	jne    400018e2 <strtoknc+0xc2>
                p_start++;
400018d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
400018d5:	05 01 00 00 00       	add    $0x1,%eax
400018da:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
400018dd:	e9 15 00 00 00       	jmp    400018f7 <strtoknc+0xd7>
            }
        }
400018e2:	e9 00 00 00 00       	jmp    400018e7 <strtoknc+0xc7>
        sp = str;

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
400018e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400018ea:	05 01 00 00 00       	add    $0x1,%eax
400018ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
400018f2:	e9 b7 ff ff ff       	jmp    400018ae <strtoknc+0x8e>
                p_start++;
                break;
            }
        }

        if (i == len) {
400018f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400018fa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
400018fd:	0f 85 0d 00 00 00    	jne    40001910 <strtoknc+0xf0>
            sp = p_start;
40001903:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001906:	a3 00 40 00 40       	mov    %eax,0x40004000
            break;
4000190b:	e9 05 00 00 00       	jmp    40001915 <strtoknc+0xf5>
        }
    }
40001910:	e9 92 ff ff ff       	jmp    400018a7 <strtoknc+0x87>

    /* return NULL if nothing left */
    if (*sp == '\0') {
40001915:	a1 00 40 00 40       	mov    0x40004000,%eax
4000191a:	0f be 00             	movsbl (%eax),%eax
4000191d:	3d 00 00 00 00       	cmp    $0x0,%eax
40001922:	0f 85 17 00 00 00    	jne    4000193f <strtoknc+0x11f>
        sp = NULL;
40001928:	c7 05 00 40 00 40 00 	movl   $0x0,0x40004000
4000192f:	00 00 00 
        return sp;
40001932:	a1 00 40 00 40       	mov    0x40004000,%eax
40001937:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000193a:	e9 92 00 00 00       	jmp    400019d1 <strtoknc+0x1b1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
4000193f:	e9 00 00 00 00       	jmp    40001944 <strtoknc+0x124>
40001944:	a1 00 40 00 40       	mov    0x40004000,%eax
40001949:	0f be 00             	movsbl (%eax),%eax
4000194c:	3d 00 00 00 00       	cmp    $0x0,%eax
40001951:	0f 84 74 00 00 00    	je     400019cb <strtoknc+0x1ab>
        for (i = 0; i < len; i++) {
40001957:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000195e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001961:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40001964:	0f 8d 3c 00 00 00    	jge    400019a6 <strtoknc+0x186>
            if (*sp == delimiters[i]) {
4000196a:	a1 00 40 00 40       	mov    0x40004000,%eax
4000196f:	0f be 00             	movsbl (%eax),%eax
40001972:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001975:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001978:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
4000197c:	39 c8                	cmp    %ecx,%eax
4000197e:	0f 85 0d 00 00 00    	jne    40001991 <strtoknc+0x171>
                *sp = '\0';
40001984:	a1 00 40 00 40       	mov    0x40004000,%eax
40001989:	c6 00 00             	movb   $0x0,(%eax)
                break;
4000198c:	e9 15 00 00 00       	jmp    400019a6 <strtoknc+0x186>
            }
        }
40001991:	e9 00 00 00 00       	jmp    40001996 <strtoknc+0x176>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
40001996:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001999:	05 01 00 00 00       	add    $0x1,%eax
4000199e:	89 45 f0             	mov    %eax,-0x10(%ebp)
400019a1:	e9 b8 ff ff ff       	jmp    4000195e <strtoknc+0x13e>
                *sp = '\0';
                break;
            }
        }

        sp++;
400019a6:	a1 00 40 00 40       	mov    0x40004000,%eax
400019ab:	05 01 00 00 00       	add    $0x1,%eax
400019b0:	a3 00 40 00 40       	mov    %eax,0x40004000
        if (i < len)
400019b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400019b8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
400019bb:	0f 8d 05 00 00 00    	jge    400019c6 <strtoknc+0x1a6>
            break;
400019c1:	e9 05 00 00 00       	jmp    400019cb <strtoknc+0x1ab>
    }
400019c6:	e9 79 ff ff ff       	jmp    40001944 <strtoknc+0x124>

    return p_start;
400019cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
400019ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
400019d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
400019d4:	83 c4 28             	add    $0x28,%esp
400019d7:	5d                   	pop    %ebp
400019d8:	c3                   	ret    
400019d9:	66 90                	xchg   %ax,%ax
400019db:	66 90                	xchg   %ax,%ax
400019dd:	66 90                	xchg   %ax,%ax
400019df:	90                   	nop

400019e0 <malloc>:
    }

    append_to_list(&first_free, tf);
}

void* malloc(size_t size) {
400019e0:	55                   	push   %ebp
400019e1:	89 e5                	mov    %esp,%ebp
400019e3:	83 ec 38             	sub    $0x38,%esp
400019e6:	8b 45 08             	mov    0x8(%ebp),%eax
400019e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
400019ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
400019f3:	a1 0c 40 00 40       	mov    0x4000400c,%eax
400019f8:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
400019fb:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001a02:	0f 84 27 00 00 00    	je     40001a2f <malloc+0x4f>
        if (cur->size >= size) {
40001a08:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a0b:	8b 00                	mov    (%eax),%eax
40001a0d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40001a10:	0f 82 05 00 00 00    	jb     40001a1b <malloc+0x3b>
            break;
40001a16:	e9 14 00 00 00       	jmp    40001a2f <malloc+0x4f>
        }
        last = cur;
40001a1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
40001a21:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001a24:	8b 40 08             	mov    0x8(%eax),%eax
40001a27:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001a2a:	e9 cc ff ff ff       	jmp    400019fb <malloc+0x1b>

    if (cur == 0) {
40001a2f:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001a36:	0f 85 bc 00 00 00    	jne    40001af8 <malloc+0x118>
        uint32_t pgs = size / PAGESIZE;
40001a3c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001a3f:	c1 e8 0c             	shr    $0xc,%eax
40001a42:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
40001a45:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001a48:	25 ff 0f 00 00       	and    $0xfff,%eax
40001a4d:	3d 00 00 00 00       	cmp    $0x0,%eax
40001a52:	0f 84 0b 00 00 00    	je     40001a63 <malloc+0x83>
            pgs++;
40001a58:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001a5b:	05 01 00 00 00       	add    $0x1,%eax
40001a60:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
40001a63:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001a66:	89 04 24             	mov    %eax,(%esp)
40001a69:	e8 c2 05 00 00       	call   40002030 <vmm_alloc_cont>
40001a6e:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
40001a71:	e8 7a 04 00 00       	call   40001ef0 <pop_unused_node>
40001a76:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
40001a79:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001a7c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40001a7f:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
40001a82:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001a85:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40001a88:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
40001a8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001a8d:	c1 e0 0c             	shl    $0xc,%eax
40001a90:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40001a93:	0f 86 3c 00 00 00    	jbe    40001ad5 <malloc+0xf5>
            struct memory_node* free = pop_unused_node();
40001a99:	e8 52 04 00 00       	call   40001ef0 <pop_unused_node>
40001a9e:	8d 0d 0c 40 00 40    	lea    0x4000400c,%ecx
40001aa4:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
40001aa7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001aaa:	8b 40 04             	mov    0x4(%eax),%eax
40001aad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40001ab0:	03 02                	add    (%edx),%eax
40001ab2:	8b 55 e0             	mov    -0x20(%ebp),%edx
40001ab5:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
40001ab8:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001abb:	c1 e0 0c             	shl    $0xc,%eax
40001abe:	2b 45 f8             	sub    -0x8(%ebp),%eax
40001ac1:	8b 55 e0             	mov    -0x20(%ebp),%edx
40001ac4:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
40001ac6:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001ac9:	89 0c 24             	mov    %ecx,(%esp)
40001acc:	89 44 24 04          	mov    %eax,0x4(%esp)
40001ad0:	e8 bb 00 00 00       	call   40001b90 <append_to_list>
40001ad5:	8d 05 08 40 00 40    	lea    0x40004008,%eax
        }

        append_to_list(&first_used, fill);
40001adb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40001ade:	89 04 24             	mov    %eax,(%esp)
40001ae1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001ae5:	e8 a6 00 00 00       	call   40001b90 <append_to_list>

        return (void*) fill->address;
40001aea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001aed:	8b 40 04             	mov    0x4(%eax),%eax
40001af0:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001af3:	e9 89 00 00 00       	jmp    40001b81 <malloc+0x1a1>
40001af8:	8d 05 0c 40 00 40    	lea    0x4000400c,%eax
    } else {
        uint32_t freesize = cur->size - size;
40001afe:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001b01:	8b 09                	mov    (%ecx),%ecx
40001b03:	2b 4d f8             	sub    -0x8(%ebp),%ecx
40001b06:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
40001b09:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001b0c:	8b 55 f0             	mov    -0x10(%ebp),%edx
40001b0f:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
40001b11:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001b14:	89 04 24             	mov    %eax,(%esp)
40001b17:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001b1b:	e8 a0 00 00 00       	call   40001bc0 <remove_from_list>
40001b20:	8d 05 08 40 00 40    	lea    0x40004008,%eax
        append_to_list(&first_used, cur);
40001b26:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001b29:	89 04 24             	mov    %eax,(%esp)
40001b2c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001b30:	e8 5b 00 00 00       	call   40001b90 <append_to_list>

        if (freesize > 0) {
40001b35:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
40001b3c:	0f 86 36 00 00 00    	jbe    40001b78 <malloc+0x198>
            struct memory_node* free = pop_unused_node();
40001b42:	e8 a9 03 00 00       	call   40001ef0 <pop_unused_node>
40001b47:	8d 0d 0c 40 00 40    	lea    0x4000400c,%ecx
40001b4d:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
40001b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001b53:	8b 40 04             	mov    0x4(%eax),%eax
40001b56:	8b 55 f0             	mov    -0x10(%ebp),%edx
40001b59:	03 02                	add    (%edx),%eax
40001b5b:	8b 55 d8             	mov    -0x28(%ebp),%edx
40001b5e:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
40001b61:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001b64:	8b 55 d8             	mov    -0x28(%ebp),%edx
40001b67:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
40001b69:	8b 45 d8             	mov    -0x28(%ebp),%eax
40001b6c:	89 0c 24             	mov    %ecx,(%esp)
40001b6f:	89 44 24 04          	mov    %eax,0x4(%esp)
40001b73:	e8 18 00 00 00       	call   40001b90 <append_to_list>
        }

        return (void*) cur->address;
40001b78:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001b7b:	8b 40 04             	mov    0x4(%eax),%eax
40001b7e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
40001b81:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001b84:	83 c4 38             	add    $0x38,%esp
40001b87:	5d                   	pop    %ebp
40001b88:	c3                   	ret    
40001b89:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

40001b90 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
40001b90:	55                   	push   %ebp
40001b91:	89 e5                	mov    %esp,%ebp
40001b93:	83 ec 08             	sub    $0x8,%esp
40001b96:	8b 45 0c             	mov    0xc(%ebp),%eax
40001b99:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001b9c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40001b9f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
40001ba2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001ba5:	8b 00                	mov    (%eax),%eax
40001ba7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001baa:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
40001bad:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001bb0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001bb3:	89 01                	mov    %eax,(%ecx)
}
40001bb5:	83 c4 08             	add    $0x8,%esp
40001bb8:	5d                   	pop    %ebp
40001bb9:	c3                   	ret    
40001bba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

40001bc0 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
40001bc0:	55                   	push   %ebp
40001bc1:	89 e5                	mov    %esp,%ebp
40001bc3:	83 ec 10             	sub    $0x10,%esp
40001bc6:	8b 45 0c             	mov    0xc(%ebp),%eax
40001bc9:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001bcc:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40001bcf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
40001bd2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
40001bd9:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001bdc:	8b 00                	mov    (%eax),%eax
40001bde:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
40001be1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001be8:	0f 84 4e 00 00 00    	je     40001c3c <remove_from_list+0x7c>
        if (cur == element) {
40001bee:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001bf1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40001bf4:	0f 85 2e 00 00 00    	jne    40001c28 <remove_from_list+0x68>
            if (last == 0) {
40001bfa:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001c01:	0f 85 10 00 00 00    	jne    40001c17 <remove_from_list+0x57>
                *root = cur->next;
40001c07:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c0a:	8b 40 08             	mov    0x8(%eax),%eax
40001c0d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001c10:	89 01                	mov    %eax,(%ecx)
                return;
40001c12:	e9 25 00 00 00       	jmp    40001c3c <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
40001c17:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c1a:	8b 40 08             	mov    0x8(%eax),%eax
40001c1d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001c20:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
40001c23:	e9 14 00 00 00       	jmp    40001c3c <remove_from_list+0x7c>
            }
        }
        last = cur;
40001c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
40001c2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001c31:	8b 40 08             	mov    0x8(%eax),%eax
40001c34:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001c37:	e9 a5 ff ff ff       	jmp    40001be1 <remove_from_list+0x21>
}
40001c3c:	83 c4 10             	add    $0x10,%esp
40001c3f:	5d                   	pop    %ebp
40001c40:	c3                   	ret    
40001c41:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001c48:	0f 1f 84 00 00 00 00 
40001c4f:	00 

40001c50 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
40001c50:	55                   	push   %ebp
40001c51:	89 e5                	mov    %esp,%ebp
40001c53:	83 ec 28             	sub    $0x28,%esp
40001c56:	8b 45 0c             	mov    0xc(%ebp),%eax
40001c59:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001c5c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40001c5f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
40001c62:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001c65:	0f af 45 f8          	imul   -0x8(%ebp),%eax
40001c69:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
40001c6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001c6f:	89 04 24             	mov    %eax,(%esp)
40001c72:	e8 69 fd ff ff       	call   400019e0 <malloc>
40001c77:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
40001c7a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001c81:	0f 84 22 00 00 00    	je     40001ca9 <calloc+0x59>
40001c87:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
40001c8c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001c8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001c92:	89 0c 24             	mov    %ecx,(%esp)
40001c95:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40001c9c:	00 
40001c9d:	89 54 24 08          	mov    %edx,0x8(%esp)
40001ca1:	89 45 ec             	mov    %eax,-0x14(%ebp)
40001ca4:	e8 97 f7 ff ff       	call   40001440 <memset>
    }

    return p;
40001ca9:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001cac:	83 c4 28             	add    $0x28,%esp
40001caf:	5d                   	pop    %ebp
40001cb0:	c3                   	ret    
40001cb1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001cb8:	0f 1f 84 00 00 00 00 
40001cbf:	00 

40001cc0 <realloc>:
}

void* realloc(void* ptr, size_t size) {
40001cc0:	55                   	push   %ebp
40001cc1:	89 e5                	mov    %esp,%ebp
40001cc3:	83 ec 28             	sub    $0x28,%esp
40001cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
40001cc9:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001ccc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
40001ccf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
40001cd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
40001cd9:	a1 08 40 00 40       	mov    0x40004008,%eax
40001cde:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
40001ce1:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
40001ce8:	0f 84 8e 00 00 00    	je     40001d7c <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
40001cee:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001cf1:	8b 40 04             	mov    0x4(%eax),%eax
40001cf4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001cf7:	39 c8                	cmp    %ecx,%eax
40001cf9:	0f 85 69 00 00 00    	jne    40001d68 <realloc+0xa8>
            if (size == 0) {
40001cff:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001d06:	0f 85 17 00 00 00    	jne    40001d23 <realloc+0x63>
                free(ptr);
40001d0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001d0f:	89 04 24             	mov    %eax,(%esp)
40001d12:	e8 79 00 00 00       	call   40001d90 <free>
                return 0;
40001d17:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001d1e:	e9 60 00 00 00       	jmp    40001d83 <realloc+0xc3>
            } else {
                void* new = malloc(size);
40001d23:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001d26:	89 04 24             	mov    %eax,(%esp)
40001d29:	e8 b2 fc ff ff       	call   400019e0 <malloc>
40001d2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
40001d31:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001d34:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40001d37:	8b 49 04             	mov    0x4(%ecx),%ecx
40001d3a:	8b 55 ec             	mov    -0x14(%ebp),%edx
40001d3d:	8b 12                	mov    (%edx),%edx
40001d3f:	89 04 24             	mov    %eax,(%esp)
40001d42:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001d46:	89 54 24 08          	mov    %edx,0x8(%esp)
40001d4a:	e8 51 f7 ff ff       	call   400014a0 <memcpy>
                free((void*) cur->address);
40001d4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001d52:	8b 40 04             	mov    0x4(%eax),%eax
40001d55:	89 04 24             	mov    %eax,(%esp)
40001d58:	e8 33 00 00 00       	call   40001d90 <free>

                return new;
40001d5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001d60:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001d63:	e9 1b 00 00 00       	jmp    40001d83 <realloc+0xc3>
            }
        }
        last = cur;
40001d68:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001d6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
40001d6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001d71:	8b 40 08             	mov    0x8(%eax),%eax
40001d74:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
40001d77:	e9 65 ff ff ff       	jmp    40001ce1 <realloc+0x21>
    return 0;
40001d7c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
40001d83:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001d86:	83 c4 28             	add    $0x28,%esp
40001d89:	5d                   	pop    %ebp
40001d8a:	c3                   	ret    
40001d8b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40001d90 <free>:

void free(void* ptr) {
40001d90:	55                   	push   %ebp
40001d91:	89 e5                	mov    %esp,%ebp
40001d93:	83 ec 18             	sub    $0x18,%esp
40001d96:	8b 45 08             	mov    0x8(%ebp),%eax
40001d99:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
40001d9c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
40001da3:	a1 08 40 00 40       	mov    0x40004008,%eax
40001da8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
40001dab:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
40001db2:	0f 84 35 00 00 00    	je     40001ded <free+0x5d>
        if (cur->address == (uint32_t) ptr) {
40001db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001dbb:	8b 40 04             	mov    0x4(%eax),%eax
40001dbe:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001dc1:	39 c8                	cmp    %ecx,%eax
40001dc3:	0f 85 10 00 00 00    	jne    40001dd9 <free+0x49>
            merge_into_frees(cur);
40001dc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001dcc:	89 04 24             	mov    %eax,(%esp)
40001dcf:	e8 2c 00 00 00       	call   40001e00 <merge_into_frees>
            break;
40001dd4:	e9 14 00 00 00       	jmp    40001ded <free+0x5d>
        }
        last = cur;
40001dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001ddc:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
40001ddf:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001de2:	8b 40 08             	mov    0x8(%eax),%eax
40001de5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
40001de8:	e9 be ff ff ff       	jmp    40001dab <free+0x1b>
}
40001ded:	83 c4 18             	add    $0x18,%esp
40001df0:	5d                   	pop    %ebp
40001df1:	c3                   	ret    
40001df2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
40001df9:	1f 84 00 00 00 00 00 

40001e00 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
40001e00:	55                   	push   %ebp
40001e01:	89 e5                	mov    %esp,%ebp
40001e03:	56                   	push   %esi
40001e04:	83 ec 14             	sub    $0x14,%esp
40001e07:	8b 45 08             	mov    0x8(%ebp),%eax
40001e0a:	8d 0d 08 40 00 40    	lea    0x40004008,%ecx
40001e10:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
40001e13:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001e16:	89 0c 24             	mov    %ecx,(%esp)
40001e19:	89 44 24 04          	mov    %eax,0x4(%esp)
40001e1d:	e8 9e fd ff ff       	call   40001bc0 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
40001e22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
40001e29:	a1 0c 40 00 40       	mov    0x4000400c,%eax
40001e2e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
40001e31:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
40001e38:	0f 84 92 00 00 00    	je     40001ed0 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
40001e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001e41:	8b 40 04             	mov    0x4(%eax),%eax
40001e44:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001e47:	03 01                	add    (%ecx),%eax
40001e49:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001e4c:	3b 41 04             	cmp    0x4(%ecx),%eax
40001e4f:	0f 85 26 00 00 00    	jne    40001e7b <merge_into_frees+0x7b>
40001e55:	8d 05 0c 40 00 40    	lea    0x4000400c,%eax
            tf->address = cur->address;
40001e5b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001e5e:	8b 49 04             	mov    0x4(%ecx),%ecx
40001e61:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001e64:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
40001e67:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001e6a:	89 04 24             	mov    %eax,(%esp)
40001e6d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001e71:	e8 4a fd ff ff       	call   40001bc0 <remove_from_list>
            goto editedList;
40001e76:	e9 a7 ff ff ff       	jmp    40001e22 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
40001e7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001e7e:	8b 40 04             	mov    0x4(%eax),%eax
40001e81:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001e84:	8b 49 04             	mov    0x4(%ecx),%ecx
40001e87:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001e8a:	03 0a                	add    (%edx),%ecx
40001e8c:	39 c8                	cmp    %ecx,%eax
40001e8e:	0f 85 28 00 00 00    	jne    40001ebc <merge_into_frees+0xbc>
40001e94:	8d 05 0c 40 00 40    	lea    0x4000400c,%eax
            tf->size += cur->size;
40001e9a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001e9d:	8b 09                	mov    (%ecx),%ecx
40001e9f:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001ea2:	8b 32                	mov    (%edx),%esi
40001ea4:	01 ce                	add    %ecx,%esi
40001ea6:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
40001ea8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40001eab:	89 04 24             	mov    %eax,(%esp)
40001eae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001eb2:	e8 09 fd ff ff       	call   40001bc0 <remove_from_list>
            goto editedList;
40001eb7:	e9 66 ff ff ff       	jmp    40001e22 <merge_into_frees+0x22>
        }

        last = cur;
40001ebc:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001ebf:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
40001ec2:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001ec5:	8b 40 08             	mov    0x8(%eax),%eax
40001ec8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001ecb:	e9 61 ff ff ff       	jmp    40001e31 <merge_into_frees+0x31>
40001ed0:	8d 05 0c 40 00 40    	lea    0x4000400c,%eax

    append_to_list(&first_free, tf);
40001ed6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001ed9:	89 04 24             	mov    %eax,(%esp)
40001edc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001ee0:	e8 ab fc ff ff       	call   40001b90 <append_to_list>
}
40001ee5:	83 c4 14             	add    $0x14,%esp
40001ee8:	5e                   	pop    %esi
40001ee9:	5d                   	pop    %ebp
40001eea:	c3                   	ret    
40001eeb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

40001ef0 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
40001ef0:	55                   	push   %ebp
40001ef1:	89 e5                	mov    %esp,%ebp
40001ef3:	83 ec 08             	sub    $0x8,%esp
40001ef6:	8d 05 04 40 00 40    	lea    0x40004004,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
40001efc:	89 04 24             	mov    %eax,(%esp)
40001eff:	e8 3c 00 00 00       	call   40001f40 <pop_from_list>
40001f04:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
40001f07:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
40001f0e:	0f 85 1b 00 00 00    	jne    40001f2f <pop_unused_node+0x3f>
        allocate_unused_nodes();
40001f14:	e8 77 00 00 00       	call   40001f90 <allocate_unused_nodes>
40001f19:	8d 05 04 40 00 40    	lea    0x40004004,%eax
        ret = pop_from_list(&first_unused);
40001f1f:	89 04 24             	mov    %eax,(%esp)
40001f22:	e8 19 00 00 00       	call   40001f40 <pop_from_list>
40001f27:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
40001f2a:	e9 d8 ff ff ff       	jmp    40001f07 <pop_unused_node+0x17>

    return ret;
40001f2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001f32:	83 c4 08             	add    $0x8,%esp
40001f35:	5d                   	pop    %ebp
40001f36:	c3                   	ret    
40001f37:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
40001f3e:	00 00 

40001f40 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
40001f40:	55                   	push   %ebp
40001f41:	89 e5                	mov    %esp,%ebp
40001f43:	83 ec 18             	sub    $0x18,%esp
40001f46:	8b 45 08             	mov    0x8(%ebp),%eax
40001f49:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
40001f4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001f4f:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
40001f55:	0f 85 0c 00 00 00    	jne    40001f67 <pop_from_list+0x27>
        return 0;
40001f5b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001f62:	e9 20 00 00 00       	jmp    40001f87 <pop_from_list+0x47>
    struct memory_node* pop = *root;
40001f67:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001f6a:	8b 00                	mov    (%eax),%eax
40001f6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
40001f6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001f72:	8b 4d f4             	mov    -0xc(%ebp),%ecx
40001f75:	89 04 24             	mov    %eax,(%esp)
40001f78:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40001f7c:	e8 3f fc ff ff       	call   40001bc0 <remove_from_list>
    return pop;
40001f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001f84:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
40001f87:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001f8a:	83 c4 18             	add    $0x18,%esp
40001f8d:	5d                   	pop    %ebp
40001f8e:	c3                   	ret    
40001f8f:	90                   	nop

40001f90 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
40001f90:	55                   	push   %ebp
40001f91:	89 e5                	mov    %esp,%ebp
40001f93:	83 ec 28             	sub    $0x28,%esp
40001f96:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
40001f9b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
40001fa2:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001fa5:	e8 86 00 00 00       	call   40002030 <vmm_alloc_cont>
40001faa:	b9 00 00 00 00       	mov    $0x0,%ecx
40001faf:	ba 00 10 00 00       	mov    $0x1000,%edx
40001fb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
40001fb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001fba:	89 04 24             	mov    %eax,(%esp)
40001fbd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
40001fc4:	00 
40001fc5:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
40001fcc:	00 
40001fcd:	89 55 f0             	mov    %edx,-0x10(%ebp)
40001fd0:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40001fd3:	e8 68 f4 ff ff       	call   40001440 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
40001fd8:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
40001fdf:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
40001fe6:	0f 83 30 00 00 00    	jae    4000201c <allocate_unused_nodes+0x8c>
40001fec:	8d 05 04 40 00 40    	lea    0x40004004,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
40001ff2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40001ff5:	8b 55 fc             	mov    -0x4(%ebp),%edx
40001ff8:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
40001ffe:	01 ca                	add    %ecx,%edx
40002000:	89 04 24             	mov    %eax,(%esp)
40002003:	89 54 24 04          	mov    %edx,0x4(%esp)
40002007:	e8 84 fb ff ff       	call   40001b90 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
4000200c:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000200f:	05 01 00 00 00       	add    $0x1,%eax
40002014:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002017:	e9 c3 ff ff ff       	jmp    40001fdf <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
4000201c:	83 c4 28             	add    $0x28,%esp
4000201f:	5d                   	pop    %ebp
40002020:	c3                   	ret    
40002021:	66 90                	xchg   %ax,%ax
40002023:	66 90                	xchg   %ax,%ax
40002025:	66 90                	xchg   %ax,%ax
40002027:	66 90                	xchg   %ax,%ax
40002029:	66 90                	xchg   %ax,%ax
4000202b:	66 90                	xchg   %ax,%ax
4000202d:	66 90                	xchg   %ax,%ax
4000202f:	90                   	nop

40002030 <vmm_alloc_cont>:
#include "vmmcall.h"

void* vmm_alloc_cont (uint32_t cont) {
40002030:	55                   	push   %ebp
40002031:	89 e5                	mov    %esp,%ebp
40002033:	83 ec 28             	sub    $0x28,%esp
40002036:	8b 45 08             	mov    0x8(%ebp),%eax
40002039:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000203c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct regstate state = {
4000203f:	c7 45 e0 cb 00 00 00 	movl   $0xcb,-0x20(%ebp)
40002046:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002049:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000204c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40002053:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000205a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40002061:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);  
40002068:	89 0c 24             	mov    %ecx,(%esp)
4000206b:	e8 b0 00 00 00       	call   40002120 <syscall>
  
  return (void*)state.eax;
40002070:	8b 45 e0             	mov    -0x20(%ebp),%eax
40002073:	83 c4 28             	add    $0x28,%esp
40002076:	5d                   	pop    %ebp
40002077:	c3                   	ret    
40002078:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
4000207f:	00 

40002080 <vmm_free>:
}

void vmm_free (void* vaddr) {
40002080:	55                   	push   %ebp
40002081:	89 e5                	mov    %esp,%ebp
40002083:	83 ec 28             	sub    $0x28,%esp
40002086:	8b 45 08             	mov    0x8(%ebp),%eax
40002089:	8d 4d e0             	lea    -0x20(%ebp),%ecx
4000208c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  struct regstate state = {
4000208f:	c7 45 e0 cc 00 00 00 	movl   $0xcc,-0x20(%ebp)
40002096:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002099:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000209c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400020a3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400020aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400020b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);  
400020b8:	89 0c 24             	mov    %ecx,(%esp)
400020bb:	e8 60 00 00 00       	call   40002120 <syscall>
}
400020c0:	83 c4 28             	add    $0x28,%esp
400020c3:	5d                   	pop    %ebp
400020c4:	c3                   	ret    
400020c5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
400020cc:	00 00 00 00 

400020d0 <print_memstat>:

void print_memstat() {
400020d0:	55                   	push   %ebp
400020d1:	89 e5                	mov    %esp,%ebp
400020d3:	56                   	push   %esi
400020d4:	83 ec 34             	sub    $0x34,%esp
400020d7:	8d 45 e0             	lea    -0x20(%ebp),%eax
400020da:	8d 0d a8 30 00 40    	lea    0x400030a8,%ecx
400020e0:	ba 18 00 00 00       	mov    $0x18,%edx
  struct regstate state = {
400020e5:	89 c6                	mov    %eax,%esi
400020e7:	89 34 24             	mov    %esi,(%esp)
400020ea:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400020ee:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
400020f5:	00 
400020f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
400020f9:	89 55 d8             	mov    %edx,-0x28(%ebp)
400020fc:	e8 9f f3 ff ff       	call   400014a0 <memcpy>
    .edx = 0,
    .esi = 0,
    .edi = 0
  };
  
  syscall(&state);  
40002101:	8b 45 dc             	mov    -0x24(%ebp),%eax
40002104:	89 04 24             	mov    %eax,(%esp)
40002107:	e8 14 00 00 00       	call   40002120 <syscall>
}
4000210c:	83 c4 34             	add    $0x34,%esp
4000210f:	5e                   	pop    %esi
40002110:	5d                   	pop    %ebp
40002111:	c3                   	ret    
40002112:	66 90                	xchg   %ax,%ax
40002114:	66 90                	xchg   %ax,%ax
40002116:	66 90                	xchg   %ax,%ax
40002118:	66 90                	xchg   %ax,%ax
4000211a:	66 90                	xchg   %ax,%ax
4000211c:	66 90                	xchg   %ax,%ax
4000211e:	66 90                	xchg   %ax,%ax

40002120 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
40002120:	55                   	push   %ebp
40002121:	89 e5                	mov    %esp,%ebp
40002123:	53                   	push   %ebx
40002124:	57                   	push   %edi
40002125:	56                   	push   %esi
40002126:	83 ec 3c             	sub    $0x3c,%esp
40002129:	8b 45 08             	mov    0x8(%ebp),%eax
4000212c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	asm("int $0x30"
4000212f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002132:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40002135:	8b 55 f0             	mov    -0x10(%ebp),%edx
40002138:	8b 75 f0             	mov    -0x10(%ebp),%esi
4000213b:	8b 7d f0             	mov    -0x10(%ebp),%edi
4000213e:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40002141:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002144:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002147:	8b 00                	mov    (%eax),%eax
40002149:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000214c:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000214f:	8b 40 04             	mov    0x4(%eax),%eax
40002152:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40002155:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002158:	8b 40 08             	mov    0x8(%eax),%eax
4000215b:	89 45 e0             	mov    %eax,-0x20(%ebp)
4000215e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002161:	8b 40 0c             	mov    0xc(%eax),%eax
40002164:	89 45 dc             	mov    %eax,-0x24(%ebp)
40002167:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000216a:	8b 40 10             	mov    0x10(%eax),%eax
4000216d:	89 45 d8             	mov    %eax,-0x28(%ebp)
40002170:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002173:	8b 40 14             	mov    0x14(%eax),%eax
40002176:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40002179:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000217c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
4000217f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40002182:	89 5d cc             	mov    %ebx,-0x34(%ebp)
40002185:	89 cb                	mov    %ecx,%ebx
40002187:	8b 4d e0             	mov    -0x20(%ebp),%ecx
4000218a:	89 55 c8             	mov    %edx,-0x38(%ebp)
4000218d:	8b 55 dc             	mov    -0x24(%ebp),%edx
40002190:	89 75 c4             	mov    %esi,-0x3c(%ebp)
40002193:	8b 75 d8             	mov    -0x28(%ebp),%esi
40002196:	89 7d c0             	mov    %edi,-0x40(%ebp)
40002199:	8b 7d d4             	mov    -0x2c(%ebp),%edi
4000219c:	cd 30                	int    $0x30
4000219e:	89 45 bc             	mov    %eax,-0x44(%ebp)
400021a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400021a4:	89 4d b8             	mov    %ecx,-0x48(%ebp)
400021a7:	8b 4d bc             	mov    -0x44(%ebp),%ecx
400021aa:	89 08                	mov    %ecx,(%eax)
400021ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
400021af:	89 58 04             	mov    %ebx,0x4(%eax)
400021b2:	8b 5d c8             	mov    -0x38(%ebp),%ebx
400021b5:	8b 45 b8             	mov    -0x48(%ebp),%eax
400021b8:	89 43 08             	mov    %eax,0x8(%ebx)
400021bb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
400021be:	89 50 0c             	mov    %edx,0xc(%eax)
400021c1:	8b 55 c0             	mov    -0x40(%ebp),%edx
400021c4:	89 72 10             	mov    %esi,0x10(%edx)
400021c7:	8b 75 cc             	mov    -0x34(%ebp),%esi
400021ca:	89 7e 14             	mov    %edi,0x14(%esi)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
400021cd:	83 c4 3c             	add    $0x3c,%esp
400021d0:	5e                   	pop    %esi
400021d1:	5f                   	pop    %edi
400021d2:	5b                   	pop    %ebx
400021d3:	5d                   	pop    %ebp
400021d4:	c3                   	ret    
